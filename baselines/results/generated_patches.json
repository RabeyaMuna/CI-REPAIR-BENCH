[
    {
        "id": 324,
        "sha_fail": "647a2972a332e48cf4d97487d7dccb5abbaf1abc",
        "diff": "diff --git a/pwndbg/gdblib/ptmalloc2_tracking.py b/pwndbg/gdblib/ptmalloc2_tracking.py\nindex 2799490..3e69b9a 100644\n--- a/pwndbg/gdblib/ptmalloc2_tracking.py\n+++ b/pwndbg/gdblib/ptmalloc2_tracking.py\n@@ -229,9 +229,9 @@ class Tracker:\n \n         # We don't support re-entry.\n         if thread in self.memory_management_calls:\n-            assert not self.memory_management_calls[\n-                thread\n-            ], f\"in {name}(): re-entrant calls are not supported\"\n+            assert not self.memory_management_calls[thread], (\n+                f\"in {name}(): re-entrant calls are not supported\"\n+            )\n \n         self.memory_management_calls[thread] = True\n \n@@ -240,9 +240,9 @@ class Tracker:\n \n         # Make sure we're not doing anything wrong.\n         if thread in self.memory_management_calls:\n-            assert self.memory_management_calls[\n-                thread\n-            ], \"exit_memory_management_calls assert failed\"\n+            assert self.memory_management_calls[thread], (\n+                \"exit_memory_management_calls assert failed\"\n+            )\n \n         self.memory_management_calls[thread] = False\n \n@@ -250,7 +250,7 @@ class Tracker:\n         \"\"\"\n         Returns colored string of the provided pointer/address\n         \"\"\"\n-        if colored_ptr := self.colorized_heap_ptrs.get(ptr)\n+        if colored_ptr := self.colorized_heap_ptrs.get(ptr):\n             return colored_ptr\n \n         idx = len(self.colorized_heap_ptrs) % len(PTRS_COLORS)\n@@ -285,9 +285,9 @@ class Tracker:\n \n                 lo_heap = pwndbg.aglib.heap.ptmalloc.Heap(lo_addr)\n                 hi_heap = pwndbg.aglib.heap.ptmalloc.Heap(hi_addr - 1)\n-                assert (\n-                    lo_heap.arena is not None and hi_heap.arena is not None\n-                ), \"malloc assert failed\"\n+                assert lo_heap.arena is not None and hi_heap.arena is not None, (\n+                    \"malloc assert failed\"\n+                )\n \n                 # TODO: Can this ever actually fail in real world use?\n                 #\n@@ -307,9 +307,9 @@ class Tracker:\n                 # than to let it become a bug.\n                 #\n                 # [0]: https://sourceware.org/glibc/wiki/MallocInternals\n-                assert (\n-                    lo_heap.start == hi_heap.start and lo_heap.end == hi_heap.end\n-                ), \"malloc assert start failed\"\n+                assert lo_heap.start == hi_heap.start and lo_heap.end == hi_heap.end, (\n+                    \"malloc assert start failed\"\n+                )\n \n                 # Remove all of our old handlers.\n                 for i in reversed(range(lo_i, hi_i)):\n@@ -323,9 +323,9 @@ class Tracker:\n                 # the heap in the range of affected chunks, and add the ones that\n                 # are free.\n                 allocator = pwndbg.aglib.heap.current\n-                assert isinstance(\n-                    allocator, pwndbg.aglib.heap.ptmalloc.GlibcMemoryAllocator\n-                ), \"malloc allocator assert failed\"\n+                assert isinstance(allocator, pwndbg.aglib.heap.ptmalloc.GlibcMemoryAllocator), (\n+                    \"malloc allocator assert failed\"\n+                )\n                 bins_list = [\n                     allocator.fastbins(lo_heap.arena.address),\n                     allocator.smallbins(lo_heap.arena.address),\n"
    },
    {
        "id": 327,
        "sha_fail": "6066f06de3275801b19af5f23ccb5e3940991e60",
        "diff": "diff --git a/Lib/code.py b/Lib/code.py\nindex f7e275d8..6c56320f 100644\n--- a/Lib/code.py\n+++ b/Lib/code.py\n@@ -1,17 +1,19 @@\n-\"\"\"Utilities needed to emulate Python's interactive interpreter.\n-\n-\"\"\"\n+\"\"\"Utilities needed to emulate Python's interactive interpreter.\"\"\"\n \n # Inspired by similar code by Jeff Epler and Fredrik Lundh.\n \n-\n import builtins\n import sys\n import traceback\n from codeop import CommandCompiler, compile_command\n \n-__all__ = [\"InteractiveInterpreter\", \"InteractiveConsole\", \"interact\",\n-           \"compile_command\"]\n+__all__ = [\n+    \"InteractiveInterpreter\",\n+    \"InteractiveConsole\",\n+    \"interact\",\n+    \"compile_command\",\n+]\n+\n \n class InteractiveInterpreter:\n     \"\"\"Base class for InteractiveConsole.\n@@ -110,7 +112,7 @@ def showsyntaxerror(self, filename=None, **kwargs):\n             typ, value, tb = sys.exc_info()\n             if filename and issubclass(typ, SyntaxError):\n                 value.filename = filename\n-            source = kwargs.pop('source', \"\")\n+            source = kwargs.pop(\"source\", \"\")\n             self._showtraceback(typ, value, None, source)\n         finally:\n             typ = value = tb = None\n@@ -135,9 +137,13 @@ def _showtraceback(self, typ, value, tb, source):\n         value = value.with_traceback(tb)\n         # Set the line of text that the exception refers to\n         lines = source.splitlines()\n-        if (source and typ is SyntaxError\n-                and not value.text and value.lineno is not None\n-                and len(lines) >= value.lineno):\n+        if (\n+            source\n+            and typ is SyntaxError\n+            and not value.text\n+            and value.lineno is not None\n+            and len(lines) >= value.lineno\n+        ):\n             value.text = lines[value.lineno - 1]\n         sys.last_exc = sys.last_value = value\n         if sys.excepthook is sys.__excepthook__:\n@@ -152,17 +158,17 @@ def _showtraceback(self, typ, value, tb, source):\n             except BaseException as e:\n                 e.__context__ = None\n                 e = e.with_traceback(e.__traceback__.tb_next)\n-                print('Error in sys.excepthook:', file=sys.stderr)\n+                print(\"Error in sys.excepthook:\", file=sys.stderr)\n                 sys.__excepthook__(type(e), e, e.__traceback__)\n                 print(file=sys.stderr)\n-                print('Original exception was:', file=sys.stderr)\n+                print(\"Original exception was:\", file=sys.stderr)\n                 sys.__excepthook__(typ, value, tb)\n \n     def _excepthook(self, typ, value, tb):\n         # This method is being overwritten in\n         # _pyrepl.console.InteractiveColoredConsole\n         lines = traceback.format_exception(typ, value, tb)\n-        self.write(''.join(lines))\n+        self.write(\"\".join(lines))\n \n     def write(self, data):\n         \"\"\"Write a string.\n@@ -232,9 +238,10 @@ def interact(self, banner=None, exitmsg=None):\n \n         cprt = 'Type \"help\", \"copyright\", \"credits\" or \"license\" for more information.'\n         if banner is None:\n-            self.write(\"Python %s on %s\\n%s\\n(%s)\\n\" %\n-                       (sys.version, sys.platform, cprt,\n-                        self.__class__.__name__))\n+            self.write(\n+                \"Python %s on %s\\n%s\\n(%s)\\n\"\n+                % (sys.version, sys.platform, cprt, self.__class__.__name__)\n+            )\n         elif banner:\n             self.write(\"%s\\n\" % str(banner))\n         more = 0\n@@ -299,9 +306,9 @@ def interact(self, banner=None, exitmsg=None):\n                 del sys.ps2\n \n             if exitmsg is None:\n-                self.write('now exiting %s...\\n' % self.__class__.__name__)\n-            elif exitmsg != '':\n-                self.write('%s\\n' % exitmsg)\n+                self.write(\"now exiting %s...\\n\" % self.__class__.__name__)\n+            elif exitmsg != \"\":\n+                self.write(\"%s\\n\" % exitmsg)\n \n     def push(self, line, filename=None, _symbol=\"single\"):\n         \"\"\"Push a line to the interpreter.\n@@ -344,18 +351,20 @@ class Quitter:\n     def __init__(self, name):\n         self.name = name\n         if sys.platform == \"win32\":\n-            self.eof = 'Ctrl-Z plus Return'\n+            self.eof = \"Ctrl-Z plus Return\"\n         else:\n-            self.eof = 'Ctrl-D (i.e. EOF)'\n+            self.eof = \"Ctrl-D (i.e. EOF)\"\n \n     def __repr__(self):\n-        return f'Use {self.name} or {self.eof} to exit'\n+        return f\"Use {self.name} or {self.eof} to exit\"\n \n     def __call__(self, code=None):\n         raise SystemExit(code)\n \n \n-def interact(banner=None, readfunc=None, local=None, exitmsg=None, local_exit=False):\n+def interact(\n+    banner=None, readfunc=None, local=None, exitmsg=None, local_exit=False\n+):\n     \"\"\"Closely emulate the interactive Python interpreter.\n \n     This is a backwards compatible interface to the InteractiveConsole\n@@ -386,11 +395,14 @@ def interact(banner=None, readfunc=None, local=None, exitmsg=None, local_exit=Fa\n     import argparse\n \n     parser = argparse.ArgumentParser(color=True)\n-    parser.add_argument('-q', action='store_true',\n-                       help=\"don't print version and copyright messages\")\n+    parser.add_argument(\n+        \"-q\",\n+        action=\"store_true\",\n+        help=\"don't print version and copyright messages\",\n+    )\n     args = parser.parse_args()\n     if args.q or sys.flags.quiet:\n-        banner = ''\n+        banner = \"\"\n     else:\n         banner = None\n     interact(banner)\ndiff --git a/Lib/idlelib/rpc.py b/Lib/idlelib/rpc.py\nindex 3f0b2230..64577d5f 100644\n--- a/Lib/idlelib/rpc.py\n+++ b/Lib/idlelib/rpc.py\n@@ -26,6 +26,7 @@\n accomplished in Idle.\n \n \"\"\"\n+\n import builtins\n import copyreg\n import io\n@@ -42,18 +43,21 @@\n import traceback\n import types\n \n+\n def unpickle_code(ms):\n     \"Return code object from marshal string ms.\"\n     co = marshal.loads(ms)\n     assert isinstance(co, types.CodeType)\n     return co\n \n+\n def pickle_code(co):\n     \"Return unpickle function and tuple with marshalled co code object.\"\n     assert isinstance(co, types.CodeType)\n     ms = marshal.dumps(co)\n     return unpickle_code, (ms,)\n \n+\n def dumps(obj, protocol=None):\n     \"Return pickled (or marshalled) string for obj.\"\n     # IDLE passes 'None' to select pickle.DEFAULT_PROTOCOL.\n@@ -67,11 +71,11 @@ class CodePickler(pickle.Pickler):\n     dispatch_table = {types.CodeType: pickle_code, **copyreg.dispatch_table}\n \n \n-BUFSIZE = 8*1024\n-LOCALHOST = '127.0.0.1'\n+BUFSIZE = 8 * 1024\n+LOCALHOST = \"127.0.0.1\"\n \n-class RPCServer(socketserver.TCPServer):\n \n+class RPCServer(socketserver.TCPServer):\n     def __init__(self, addr, handlerclass=None):\n         if handlerclass is None:\n             handlerclass = RPCHandler\n@@ -108,17 +112,18 @@ def handle_error(self, request, client_address):\n             raise\n         except:\n             erf = sys.__stderr__\n-            print('\\n' + '-'*40, file=erf)\n-            print('Unhandled server exception!', file=erf)\n-            print('Thread: %s' % threading.current_thread().name, file=erf)\n-            print('Client Address: ', client_address, file=erf)\n-            print('Request: ', repr(request), file=erf)\n+            print(\"\\n\" + \"-\" * 40, file=erf)\n+            print(\"Unhandled server exception!\", file=erf)\n+            print(\"Thread: %s\" % threading.current_thread().name, file=erf)\n+            print(\"Client Address: \", client_address, file=erf)\n+            print(\"Request: \", repr(request), file=erf)\n             traceback.print_exc(file=erf)\n-            print('\\n*** Unrecoverable, server exiting!', file=erf)\n-            print('-'*40, file=erf)\n+            print(\"\\n*** Unrecoverable, server exiting!\", file=erf)\n+            print(\"-\" * 40, file=erf)\n             os._exit(0)\n \n-#----------------- end class RPCServer --------------------\n+\n+# ----------------- end class RPCServer --------------------\n \n objecttable = {}\n request_queue = queue.Queue(0)\n@@ -126,7 +131,6 @@ def handle_error(self, request, client_address):\n \n \n class SocketIO:\n-\n     nextseq = 0\n \n     def __init__(self, sock, objtable=None, debugging=None):\n@@ -188,14 +192,14 @@ def localcall(self, seq, request):\n             return (\"ERROR\", f\"Unsupported method name: {methodname!r}\")\n         method = getattr(obj, methodname)\n         try:\n-            if how == 'CALL':\n+            if how == \"CALL\":\n                 ret = method(*args, **kwargs)\n                 if isinstance(ret, RemoteObject):\n                     ret = remoteref(ret)\n                 return (\"OK\", ret)\n-            elif how == 'QUEUE':\n+            elif how == \"QUEUE\":\n                 request_queue.put((seq, (method, args, kwargs)))\n-                return(\"QUEUED\", None)\n+                return (\"QUEUED\", None)\n             else:\n                 return (\"ERROR\", \"Unsupported message type: %s\" % how)\n         except SystemExit:\n@@ -207,8 +211,10 @@ def localcall(self, seq, request):\n         except Exception as ex:\n             return (\"CALLEXC\", ex)\n         except:\n-            msg = \"*** Internal Error: rpc.py:SocketIO.localcall()\\n\\n\"\\\n-                  \" Object: %s \\n Method: %s \\n Args: %s\\n\"\n+            msg = (\n+                \"*** Internal Error: rpc.py:SocketIO.localcall()\\n\\n\"\n+                \" Object: %s \\n Method: %s \\n Args: %s\\n\"\n+            )\n             print(msg % (oid, method, args), file=sys.__stderr__)\n             traceback.print_exc(file=sys.__stderr__)\n             return (\"EXCEPTION\", None)\n@@ -318,8 +324,10 @@ def _getresponse(self, myseq, wait):\n             while myseq not in self.responses:\n                 cvar.wait()\n             response = self.responses[myseq]\n-            self.debug(\"_getresponse:%s: thread woke up: response: %s\" %\n-                       (myseq, response))\n+            self.debug(\n+                \"_getresponse:%s: thread woke up: response: %s\"\n+                % (myseq, response)\n+            )\n             del self.responses[myseq]\n             del self.cvars[myseq]\n             cvar.release()\n@@ -345,9 +353,9 @@ def putmessage(self, message):\n                 raise OSError(\"socket no longer exists\")\n             s = s[n:]\n \n-    buff = b''\n+    buff = b\"\"\n     bufneed = 4\n-    bufstate = 0 # meaning: 0 => reading count; 1 => reading data\n+    bufstate = 0  # meaning: 0 => reading count; 1 => reading data\n \n     def pollpacket(self, wait):\n         self._stage0()\n@@ -374,8 +382,8 @@ def _stage0(self):\n \n     def _stage1(self):\n         if self.bufstate == 1 and len(self.buff) >= self.bufneed:\n-            packet = self.buff[:self.bufneed]\n-            self.buff = self.buff[self.bufneed:]\n+            packet = self.buff[: self.bufneed]\n+            self.buff = self.buff[self.bufneed :]\n             self.bufneed = 4\n             self.bufstate = 0\n             return packet\n@@ -425,7 +433,7 @@ def pollresponse(self, myseq, wait):\n                 pass\n             else:\n                 seq, response = qmsg\n-                message = (seq, ('OK', response))\n+                message = (seq, (\"OK\", response))\n                 self.putmessage(message)\n             # poll for message on link\n             try:\n@@ -444,8 +452,9 @@ def pollresponse(self, myseq, wait):\n             if how in (\"CALL\", \"QUEUE\"):\n                 self.debug(\"pollresponse:%d:localcall:call:\" % seq)\n                 response = self.localcall(seq, resq)\n-                self.debug(\"pollresponse:%d:localcall:response:%s\"\n-                           % (seq, response))\n+                self.debug(\n+                    \"pollresponse:%d:localcall:response:%s\" % (seq, response)\n+                )\n                 if how == \"CALL\":\n                     self.putmessage((seq, response))\n                 elif how == \"QUEUE\":\n@@ -474,7 +483,7 @@ def handle_EOF(self):\n         for key in self.cvars:\n             cv = self.cvars[key]\n             cv.acquire()\n-            self.responses[key] = ('EOF', None)\n+            self.responses[key] = (\"EOF\", None)\n             cv.notify()\n             cv.release()\n         # call our (possibly overridden) exit function\n@@ -484,7 +493,9 @@ def EOFhook(self):\n         \"Classes using rpc client/server can override to augment EOF action\"\n         pass\n \n-#----------------- end class SocketIO --------------------\n+\n+# ----------------- end class SocketIO --------------------\n+\n \n class RemoteObject:\n     # Token mix-in class\n@@ -498,18 +509,16 @@ def remoteref(obj):\n \n \n class RemoteProxy:\n-\n     def __init__(self, oid):\n         self.oid = oid\n \n \n class RPCHandler(socketserver.BaseRequestHandler, SocketIO):\n-\n     debugging = False\n     location = \"#S\"  # Server\n \n     def __init__(self, sock, addr, svr):\n-        svr.current_handler = self ## cgt xxx\n+        svr.current_handler = self  ## cgt xxx\n         SocketIO.__init__(self, sock)\n         socketserver.BaseRequestHandler.__init__(self, sock, addr, svr)\n \n@@ -522,13 +531,14 @@ def get_remote_proxy(self, oid):\n \n \n class RPCClient(SocketIO):\n-\n     debugging = False\n     location = \"#C\"  # Client\n \n-    nextseq = 1 # Requests coming from the client are odd numbered\n+    nextseq = 1  # Requests coming from the client are odd numbered\n \n-    def __init__(self, address, family=socket.AF_INET, type=socket.SOCK_STREAM):\n+    def __init__(\n+        self, address, family=socket.AF_INET, type=socket.SOCK_STREAM\n+    ):\n         self.listening_sock = socket.socket(family, type)\n         self.listening_sock.bind(address)\n         self.listening_sock.listen(1)\n@@ -536,7 +546,9 @@ def __init__(self, address, family=socket.AF_INET, type=socket.SOCK_STREAM):\n     def accept(self):\n         working_sock, address = self.listening_sock.accept()\n         if self.debugging:\n-            print(\"****** Connection request from \", address, file=sys.__stderr__)\n+            print(\n+                \"****** Connection request from \", address, file=sys.__stderr__\n+            )\n         if address[0] == LOCALHOST:\n             SocketIO.__init__(self, working_sock)\n         else:\n@@ -548,7 +560,6 @@ def get_remote_proxy(self, oid):\n \n \n class RPCProxy:\n-\n     __methods = None\n     __attributes = None\n \n@@ -564,19 +575,23 @@ def __getattr__(self, name):\n         if self.__attributes is None:\n             self.__getattributes()\n         if name in self.__attributes:\n-            value = self.sockio.remotecall(self.oid, '__getattribute__',\n-                                           (name,), {})\n+            value = self.sockio.remotecall(\n+                self.oid, \"__getattribute__\", (name,), {}\n+            )\n             return value\n         else:\n             raise AttributeError(name)\n \n     def __getattributes(self):\n-        self.__attributes = self.sockio.remotecall(self.oid,\n-                                                \"__attributes__\", (), {})\n+        self.__attributes = self.sockio.remotecall(\n+            self.oid, \"__attributes__\", (), {}\n+        )\n \n     def __getmethods(self):\n-        self.__methods = self.sockio.remotecall(self.oid,\n-                                                \"__methods__\", (), {})\n+        self.__methods = self.sockio.remotecall(\n+            self.oid, \"__methods__\", (), {}\n+        )\n+\n \n def _getmethods(obj, methods):\n     # Helper to get a list of methods from an object\n@@ -589,6 +604,7 @@ def _getmethods(obj, methods):\n         for super in obj.__bases__:\n             _getmethods(super, methods)\n \n+\n def _getattributes(obj, attributes):\n     for name in dir(obj):\n         attr = getattr(obj, name)\n@@ -597,7 +613,6 @@ def _getattributes(obj, attributes):\n \n \n class MethodProxy:\n-\n     def __init__(self, sockio, oid, name):\n         self.sockio = sockio\n         self.oid = oid\n@@ -611,6 +626,7 @@ def __call__(self, /, *args, **kwargs):\n # XXX KBK 09Sep03  We need a proper unit test for this module.  Previously\n #                  existing test code was removed at Rev 1.27 (r34098).\n \n+\n def displayhook(value):\n     \"\"\"Override standard display hook to use non-locale encoding\"\"\"\n     if value is None:\n@@ -622,14 +638,18 @@ def displayhook(value):\n         sys.stdout.write(text)\n     except UnicodeEncodeError:\n         # let's use ascii while utf8-bmp codec doesn't present\n-        encoding = 'ascii'\n-        bytes = text.encode(encoding, 'backslashreplace')\n-        text = bytes.decode(encoding, 'strict')\n+        encoding = \"ascii\"\n+        bytes = text.encode(encoding, \"backslashreplace\")\n+        text = bytes.decode(encoding, \"strict\")\n         sys.stdout.write(text)\n     sys.stdout.write(\"\\n\")\n     builtins._ = value\n \n \n-if __name__ == '__main__':\n+if __name__ == \"__main__\":\n     from unittest import main\n-    main('idlelib.idle_test.test_rpc', verbosity=2,)\n+\n+    main(\n+        \"idlelib.idle_test.test_rpc\",\n+        verbosity=2,\n+    )\ndiff --git a/Lib/test/bisect_cmd.py b/Lib/test/bisect_cmd.py\nindex aee2e8ac..f79a5c88 100755\n--- a/Lib/test/bisect_cmd.py\n+++ b/Lib/test/bisect_cmd.py\n@@ -44,29 +44,29 @@ def write_output(filename, tests):\n \n \n def format_shell_args(args):\n-    return ' '.join(args)\n+    return \" \".join(args)\n \n \n def python_cmd():\n     cmd = [sys.executable]\n     cmd.extend(subprocess._args_from_interpreter_flags())\n     cmd.extend(subprocess._optim_args_from_interpreter_flags())\n-    cmd.extend(('-X', 'faulthandler'))\n+    cmd.extend((\"-X\", \"faulthandler\"))\n     return cmd\n \n \n def list_cases(args):\n     cmd = python_cmd()\n-    cmd.extend(['-m', 'test', '--list-cases'])\n+    cmd.extend([\"-m\", \"test\", \"--list-cases\"])\n     cmd.extend(args.test_args)\n-    proc = subprocess.run(cmd,\n-                          stdout=subprocess.PIPE,\n-                          universal_newlines=True)\n+    proc = subprocess.run(cmd, stdout=subprocess.PIPE, universal_newlines=True)\n     exitcode = proc.returncode\n     if exitcode:\n         cmd = format_shell_args(cmd)\n-        print(\"Failed to list tests: %s failed with exit code %s\"\n-              % (cmd, exitcode))\n+        print(\n+            \"Failed to list tests: %s failed with exit code %s\"\n+            % (cmd, exitcode)\n+        )\n         sys.exit(exitcode)\n     tests = proc.stdout.splitlines()\n     return tests\n@@ -78,7 +78,7 @@ def run_tests(args, tests, huntrleaks=None):\n         write_tests(tmp, tests)\n \n         cmd = python_cmd()\n-        cmd.extend(['-u', '-m', 'test', '--matchfile', tmp])\n+        cmd.extend([\"-u\", \"-m\", \"test\", \"--matchfile\", tmp])\n         cmd.extend(args.test_args)\n         print(\"+ %s\" % format_shell_args(cmd))\n \n@@ -94,17 +94,27 @@ def run_tests(args, tests, huntrleaks=None):\n \n def parse_args():\n     parser = argparse.ArgumentParser()\n-    parser.add_argument('-i', '--input',\n-                        help='Test names produced by --list-tests written '\n-                             'into a file. If not set, run --list-tests')\n-    parser.add_argument('-o', '--output',\n-                        help='Result of the bisection')\n-    parser.add_argument('-n', '--max-tests', type=int, default=1,\n-                        help='Maximum number of tests to stop the bisection '\n-                             '(default: 1)')\n-    parser.add_argument('-N', '--max-iter', type=int, default=100,\n-                        help='Maximum number of bisection iterations '\n-                             '(default: 100)')\n+    parser.add_argument(\n+        \"-i\",\n+        \"--input\",\n+        help=\"Test names produced by --list-tests written \"\n+        \"into a file. If not set, run --list-tests\",\n+    )\n+    parser.add_argument(\"-o\", \"--output\", help=\"Result of the bisection\")\n+    parser.add_argument(\n+        \"-n\",\n+        \"--max-tests\",\n+        type=int,\n+        default=1,\n+        help=\"Maximum number of tests to stop the bisection (default: 1)\",\n+    )\n+    parser.add_argument(\n+        \"-N\",\n+        \"--max-iter\",\n+        type=int,\n+        default=100,\n+        help=\"Maximum number of bisection iterations (default: 100)\",\n+    )\n     # FIXME: document that following arguments are test arguments\n \n     args, test_args = parser.parse_known_args()\n@@ -114,7 +124,7 @@ def parse_args():\n \n def main():\n     args = parse_args()\n-    for opt in ('-w', '--rerun', '--verbose2'):\n+    for opt in (\"-w\", \"--rerun\", \"--verbose2\"):\n         if opt in args.test_args:\n             print(f\"WARNING: {opt} option should not be used to bisect!\")\n             print()\n@@ -127,10 +137,11 @@ def main():\n \n     print(\"Start bisection with %s tests\" % len(tests))\n     print(\"Test arguments: %s\" % format_shell_args(args.test_args))\n-    print(\"Bisection will stop when getting %s or less tests \"\n-          \"(-n/--max-tests option), or after %s iterations \"\n-          \"(-N/--max-iter option)\"\n-          % (args.max_tests, args.max_iter))\n+    print(\n+        \"Bisection will stop when getting %s or less tests \"\n+        \"(-n/--max-tests option), or after %s iterations \"\n+        \"(-N/--max-iter option)\" % (args.max_tests, args.max_iter)\n+    )\n     output = write_output(args.output, tests)\n     print()\n \n@@ -142,8 +153,10 @@ def main():\n             ntest = max(ntest // 2, 1)\n             subtests = random.sample(tests, ntest)\n \n-            print(f\"[+] Iteration {iteration}/{args.max_iter}: \"\n-                  f\"run {len(subtests)} tests/{len(tests)}\")\n+            print(\n+                f\"[+] Iteration {iteration}/{args.max_iter}: \"\n+                f\"run {len(subtests)} tests/{len(tests)}\"\n+            )\n             print()\n \n             exitcode = run_tests(args, subtests)\n@@ -155,7 +168,9 @@ def main():\n                 tests = subtests\n                 output = write_output(args.output, tests)\n             else:\n-                print(\"Tests succeeded: skipping this subtest, trying a new subset\")\n+                print(\n+                    \"Tests succeeded: skipping this subtest, trying a new subset\"\n+                )\n             print()\n             iteration += 1\n     except KeyboardInterrupt:\n@@ -173,11 +188,15 @@ def main():\n \n     dt = math.ceil(time.monotonic() - start_time)\n     if len(tests) <= args.max_tests:\n-        print(\"Bisection completed in %s iterations and %s\"\n-              % (iteration, datetime.timedelta(seconds=dt)))\n+        print(\n+            \"Bisection completed in %s iterations and %s\"\n+            % (iteration, datetime.timedelta(seconds=dt))\n+        )\n     else:\n-        print(\"Bisection failed after %s iterations and %s\"\n-              % (iteration, datetime.timedelta(seconds=dt)))\n+        print(\n+            \"Bisection failed after %s iterations and %s\"\n+            % (iteration, datetime.timedelta(seconds=dt))\n+        )\n         sys.exit(1)\n \n \ndiff --git a/Lib/test/test_argparse.py b/Lib/test/test_argparse.py\nindex fc73174d..f76b230b 100644\n--- a/Lib/test/test_argparse.py\n+++ b/Lib/test/test_argparse.py\n@@ -26,7 +26,10 @@\n from test.support import import_helper\n from test.support import os_helper\n from test.support import script_helper\n-from test.support.i18n_helper import TestTranslationsBase, update_translation_snapshots\n+from test.support.i18n_helper import (\n+    TestTranslationsBase,\n+    update_translation_snapshots,\n+)\n from unittest import mock\n \n \n@@ -34,39 +37,41 @@\n \n \n class StdIOBuffer(io.TextIOWrapper):\n-    '''Replacement for writable io.StringIO that behaves more like real file\n+    \"\"\"Replacement for writable io.StringIO that behaves more like real file\n \n     Unlike StringIO, provides a buffer attribute that holds the underlying\n     binary data, allowing it to replace sys.stdout/sys.stderr in more\n     contexts.\n-    '''\n+    \"\"\"\n \n-    def __init__(self, initial_value='', newline='\\n'):\n-        initial_value = initial_value.encode('utf-8')\n-        super().__init__(io.BufferedWriter(io.BytesIO(initial_value)),\n-                         'utf-8', newline=newline)\n+    def __init__(self, initial_value=\"\", newline=\"\\n\"):\n+        initial_value = initial_value.encode(\"utf-8\")\n+        super().__init__(\n+            io.BufferedWriter(io.BytesIO(initial_value)),\n+            \"utf-8\",\n+            newline=newline,\n+        )\n \n     def getvalue(self):\n         self.flush()\n-        return self.buffer.raw.getvalue().decode('utf-8')\n+        return self.buffer.raw.getvalue().decode(\"utf-8\")\n \n \n class StdStreamTest(unittest.TestCase):\n-\n     def test_skip_invalid_stderr(self):\n         parser = argparse.ArgumentParser()\n         with (\n             contextlib.redirect_stderr(None),\n-            mock.patch('argparse._sys.exit')\n+            mock.patch(\"argparse._sys.exit\"),\n         ):\n-            parser.exit(status=0, message='foo')\n+            parser.exit(status=0, message=\"foo\")\n \n     def test_skip_invalid_stdout(self):\n         parser = argparse.ArgumentParser()\n         for func in (\n             parser.print_usage,\n             parser.print_help,\n-            functools.partial(parser.parse_args, ['-h'])\n+            functools.partial(parser.parse_args, [\"-h\"]),\n         ):\n             with (\n                 self.subTest(func=func),\n@@ -74,25 +79,23 @@ def test_skip_invalid_stdout(self):\n                 # argparse uses stderr as a fallback\n                 StdIOBuffer() as mocked_stderr,\n                 contextlib.redirect_stderr(mocked_stderr),\n-                mock.patch('argparse._sys.exit'),\n+                mock.patch(\"argparse._sys.exit\"),\n             ):\n                 func()\n-                self.assertRegex(mocked_stderr.getvalue(), r'usage:')\n+                self.assertRegex(mocked_stderr.getvalue(), r\"usage:\")\n \n \n class TestCase(unittest.TestCase):\n-\n     def setUp(self):\n         # The tests assume that line wrapping occurs at 80 columns, but this\n         # behaviour can be overridden by setting the COLUMNS environment\n         # variable.  To ensure that this width is used, set COLUMNS to 80.\n         env = self.enterContext(os_helper.EnvironmentVarGuard())\n-        env['COLUMNS'] = '80'\n+        env[\"COLUMNS\"] = \"80\"\n \n \n @os_helper.skip_unless_working_chmod\n class TempDirMixin(object):\n-\n     def setUp(self):\n         self.temp_dir = tempfile.mkdtemp()\n         self.old_dir = os.getcwd()\n@@ -107,36 +110,34 @@ def tearDown(self):\n \n     def create_writable_file(self, filename):\n         file_path = os.path.join(self.temp_dir, filename)\n-        with open(file_path, 'w', encoding=\"utf-8\") as file:\n+        with open(file_path, \"w\", encoding=\"utf-8\") as file:\n             file.write(filename)\n         return file_path\n \n     def create_readonly_file(self, filename):\n         os.chmod(self.create_writable_file(filename), stat.S_IREAD)\n \n-class Sig(object):\n \n+class Sig(object):\n     def __init__(self, *args, **kwargs):\n         self.args = args\n         self.kwargs = kwargs\n \n \n class NS(object):\n-\n     def __init__(self, **kwargs):\n         self.__dict__.update(kwargs)\n \n     def __repr__(self):\n         sorted_items = sorted(self.__dict__.items())\n-        kwarg_str = ', '.join(['%s=%r' % tup for tup in sorted_items])\n-        return '%s(%s)' % (type(self).__name__, kwarg_str)\n+        kwarg_str = \", \".join([\"%s=%r\" % tup for tup in sorted_items])\n+        return \"%s(%s)\" % (type(self).__name__, kwarg_str)\n \n     def __eq__(self, other):\n         return vars(self) == vars(other)\n \n \n class ArgumentParserError(Exception):\n-\n     def __init__(self, message, stdout=None, stderr=None, error_code=None):\n         Exception.__init__(self, message, stdout, stderr)\n         self.message = message\n@@ -149,7 +150,9 @@ def stderr_to_parser_error(parse_args, *args, **kwargs):\n     # if this is being called recursively and stderr or stdout is already being\n     # redirected, simply call the function and let the enclosing function\n     # catch the exception\n-    if isinstance(sys.stderr, StdIOBuffer) or isinstance(sys.stdout, StdIOBuffer):\n+    if isinstance(sys.stderr, StdIOBuffer) or isinstance(\n+        sys.stdout, StdIOBuffer\n+    ):\n         return parse_args(*args, **kwargs)\n \n     # if this is not being called recursively, redirect stderr and\n@@ -166,25 +169,33 @@ def stderr_to_parser_error(parse_args, *args, **kwargs):\n                 if attr is sys.stdout:\n                     setattr(result, key, old_stdout)\n                 elif attr is sys.stdout.buffer:\n-                    setattr(result, key, getattr(old_stdout, 'buffer', BIN_STDOUT_SENTINEL))\n+                    setattr(\n+                        result,\n+                        key,\n+                        getattr(old_stdout, \"buffer\", BIN_STDOUT_SENTINEL),\n+                    )\n                 elif attr is sys.stderr:\n                     setattr(result, key, old_stderr)\n                 elif attr is sys.stderr.buffer:\n-                    setattr(result, key, getattr(old_stderr, 'buffer', BIN_STDERR_SENTINEL))\n+                    setattr(\n+                        result,\n+                        key,\n+                        getattr(old_stderr, \"buffer\", BIN_STDERR_SENTINEL),\n+                    )\n             return result\n         except SystemExit as e:\n             code = e.code\n             stdout = sys.stdout.getvalue()\n             stderr = sys.stderr.getvalue()\n             raise ArgumentParserError(\n-                \"SystemExit\", stdout, stderr, code) from None\n+                \"SystemExit\", stdout, stderr, code\n+            ) from None\n     finally:\n         sys.stdout = old_stdout\n         sys.stderr = old_stderr\n \n \n class ErrorRaisingArgumentParser(argparse.ArgumentParser):\n-\n     def parse_args(self, *args, **kwargs):\n         parse_args = super(ErrorRaisingArgumentParser, self).parse_args\n         return stderr_to_parser_error(parse_args, *args, **kwargs)\n@@ -215,13 +226,13 @@ class ParserTesterMetaclass(type):\n     \"\"\"\n \n     def __init__(cls, name, bases, bodydict):\n-        if name == 'ParserTestCase':\n+        if name == \"ParserTestCase\":\n             return\n \n         # default parser signature is empty\n-        if not hasattr(cls, 'parser_signature'):\n+        if not hasattr(cls, \"parser_signature\"):\n             cls.parser_signature = Sig()\n-        if not hasattr(cls, 'parser_class'):\n+        if not hasattr(cls, \"parser_class\"):\n             cls.parser_class = ErrorRaisingArgumentParser\n \n         # ---------------------------------------\n@@ -234,14 +245,14 @@ def no_groups(parser, argument_signatures):\n \n         def one_group(parser, argument_signatures):\n             \"\"\"Add all arguments under a single group in the parser\"\"\"\n-            group = parser.add_argument_group('foo')\n+            group = parser.add_argument_group(\"foo\")\n             for sig in argument_signatures:\n                 group.add_argument(*sig.args, **sig.kwargs)\n \n         def many_groups(parser, argument_signatures):\n             \"\"\"Add each argument in its own group to the parser\"\"\"\n             for i, sig in enumerate(argument_signatures):\n-                group = parser.add_argument_group('foo:%i' % i)\n+                group = parser.add_argument_group(\"foo:%i\" % i)\n                 group.add_argument(*sig.args, **sig.kwargs)\n \n         # --------------------------\n@@ -263,7 +274,6 @@ def sysargs(parser, args):\n         # class that holds the combination of one optional argument\n         # addition method and one arg parsing method\n         class AddTests(object):\n-\n             def __init__(self, tester_cls, add_arguments, parse_args):\n                 self._add_arguments = add_arguments\n                 self._parse_args = parse_args\n@@ -273,10 +283,11 @@ def __init__(self, tester_cls, add_arguments, parse_args):\n                 for test_func in [self.test_failures, self.test_successes]:\n                     func_name = test_func.__name__\n                     names = func_name, add_arguments_name, parse_args_name\n-                    test_name = '_'.join(names)\n+                    test_name = \"_\".join(names)\n \n                     def wrapper(self, test_func=test_func):\n                         test_func(self)\n+\n                     try:\n                         wrapper.__name__ = test_name\n                     except TypeError:\n@@ -295,7 +306,9 @@ def test_failures(self, tester):\n                 for args_str in tester.failures:\n                     args = args_str.split()\n                     with tester.subTest(args=args):\n-                        with tester.assertRaises(ArgumentParserError, msg=args):\n+                        with tester.assertRaises(\n+                            ArgumentParserError, msg=args\n+                        ):\n                             parser.parse_args(args)\n \n             def test_successes(self, tester):\n@@ -313,24 +326,26 @@ def test_successes(self, tester):\n             for parse_args in [listargs, sysargs]:\n                 AddTests(cls, add_arguments, parse_args)\n \n-bases = TestCase,\n-ParserTestCase = ParserTesterMetaclass('ParserTestCase', bases, {})\n+\n+bases = (TestCase,)\n+ParserTestCase = ParserTesterMetaclass(\"ParserTestCase\", bases, {})\n \n # ===============\n # Optionals tests\n # ===============\n \n+\n class TestOptionalsSingleDash(ParserTestCase):\n     \"\"\"Test an Optional with a single-dash option string\"\"\"\n \n-    argument_signatures = [Sig('-x')]\n-    failures = ['-x', 'a', '--foo', '-x --foo', '-x -y']\n+    argument_signatures = [Sig(\"-x\")]\n+    failures = [\"-x\", \"a\", \"--foo\", \"-x --foo\", \"-x -y\"]\n     successes = [\n-        ('', NS(x=None)),\n-        ('-x a', NS(x='a')),\n-        ('-xa', NS(x='a')),\n-        ('-x -1', NS(x='-1')),\n-        ('-x-1', NS(x='-1')),\n+        (\"\", NS(x=None)),\n+        (\"-x a\", NS(x=\"a\")),\n+        (\"-xa\", NS(x=\"a\")),\n+        (\"-x -1\", NS(x=\"-1\")),\n+        (\"-x-1\", NS(x=\"-1\")),\n     ]\n \n \n@@ -338,105 +353,126 @@ class TestOptionalsSingleDashCombined(ParserTestCase):\n     \"\"\"Test an Optional with a single-dash option string\"\"\"\n \n     argument_signatures = [\n-        Sig('-x', action='store_true'),\n-        Sig('-yyy', action='store_const', const=42),\n-        Sig('-z'),\n+        Sig(\"-x\", action=\"store_true\"),\n+        Sig(\"-yyy\", action=\"store_const\", const=42),\n+        Sig(\"-z\"),\n+    ]\n+    failures = [\n+        \"a\",\n+        \"--foo\",\n+        \"-xa\",\n+        \"-x --foo\",\n+        \"-x -z\",\n+        \"-z -x\",\n+        \"-yx\",\n+        \"-yz a\",\n+        \"-yyyx\",\n+        \"-yyyza\",\n+        \"-xyza\",\n+        \"-x=\",\n     ]\n-    failures = ['a', '--foo', '-xa', '-x --foo', '-x -z', '-z -x',\n-                '-yx', '-yz a', '-yyyx', '-yyyza', '-xyza', '-x=']\n     successes = [\n-        ('', NS(x=False, yyy=None, z=None)),\n-        ('-x', NS(x=True, yyy=None, z=None)),\n-        ('-za', NS(x=False, yyy=None, z='a')),\n-        ('-z a', NS(x=False, yyy=None, z='a')),\n-        ('-xza', NS(x=True, yyy=None, z='a')),\n-        ('-xz a', NS(x=True, yyy=None, z='a')),\n-        ('-x -za', NS(x=True, yyy=None, z='a')),\n-        ('-x -z a', NS(x=True, yyy=None, z='a')),\n-        ('-y', NS(x=False, yyy=42, z=None)),\n-        ('-yyy', NS(x=False, yyy=42, z=None)),\n-        ('-x -yyy -za', NS(x=True, yyy=42, z='a')),\n-        ('-x -yyy -z a', NS(x=True, yyy=42, z='a')),\n+        (\"\", NS(x=False, yyy=None, z=None)),\n+        (\"-x\", NS(x=True, yyy=None, z=None)),\n+        (\"-za\", NS(x=False, yyy=None, z=\"a\")),\n+        (\"-z a\", NS(x=False, yyy=None, z=\"a\")),\n+        (\"-xza\", NS(x=True, yyy=None, z=\"a\")),\n+        (\"-xz a\", NS(x=True, yyy=None, z=\"a\")),\n+        (\"-x -za\", NS(x=True, yyy=None, z=\"a\")),\n+        (\"-x -z a\", NS(x=True, yyy=None, z=\"a\")),\n+        (\"-y\", NS(x=False, yyy=42, z=None)),\n+        (\"-yyy\", NS(x=False, yyy=42, z=None)),\n+        (\"-x -yyy -za\", NS(x=True, yyy=42, z=\"a\")),\n+        (\"-x -yyy -z a\", NS(x=True, yyy=42, z=\"a\")),\n     ]\n \n \n class TestOptionalsSingleDashLong(ParserTestCase):\n     \"\"\"Test an Optional with a multi-character single-dash option string\"\"\"\n \n-    argument_signatures = [Sig('-foo')]\n-    failures = ['-foo', 'a', '--foo', '-foo --foo', '-foo -y', '-fooa']\n+    argument_signatures = [Sig(\"-foo\")]\n+    failures = [\"-foo\", \"a\", \"--foo\", \"-foo --foo\", \"-foo -y\", \"-fooa\"]\n     successes = [\n-        ('', NS(foo=None)),\n-        ('-foo a', NS(foo='a')),\n-        ('-foo -1', NS(foo='-1')),\n-        ('-fo a', NS(foo='a')),\n-        ('-f a', NS(foo='a')),\n+        (\"\", NS(foo=None)),\n+        (\"-foo a\", NS(foo=\"a\")),\n+        (\"-foo -1\", NS(foo=\"-1\")),\n+        (\"-fo a\", NS(foo=\"a\")),\n+        (\"-f a\", NS(foo=\"a\")),\n     ]\n \n \n class TestOptionalsSingleDashSubsetAmbiguous(ParserTestCase):\n     \"\"\"Test Optionals where option strings are subsets of each other\"\"\"\n \n-    argument_signatures = [Sig('-f'), Sig('-foobar'), Sig('-foorab')]\n-    failures = ['-f', '-foo', '-fo', '-foo b', '-foob', '-fooba', '-foora']\n+    argument_signatures = [Sig(\"-f\"), Sig(\"-foobar\"), Sig(\"-foorab\")]\n+    failures = [\"-f\", \"-foo\", \"-fo\", \"-foo b\", \"-foob\", \"-fooba\", \"-foora\"]\n     successes = [\n-        ('', NS(f=None, foobar=None, foorab=None)),\n-        ('-f a', NS(f='a', foobar=None, foorab=None)),\n-        ('-fa', NS(f='a', foobar=None, foorab=None)),\n-        ('-foa', NS(f='oa', foobar=None, foorab=None)),\n-        ('-fooa', NS(f='ooa', foobar=None, foorab=None)),\n-        ('-foobar a', NS(f=None, foobar='a', foorab=None)),\n-        ('-foorab a', NS(f=None, foobar=None, foorab='a')),\n+        (\"\", NS(f=None, foobar=None, foorab=None)),\n+        (\"-f a\", NS(f=\"a\", foobar=None, foorab=None)),\n+        (\"-fa\", NS(f=\"a\", foobar=None, foorab=None)),\n+        (\"-foa\", NS(f=\"oa\", foobar=None, foorab=None)),\n+        (\"-fooa\", NS(f=\"ooa\", foobar=None, foorab=None)),\n+        (\"-foobar a\", NS(f=None, foobar=\"a\", foorab=None)),\n+        (\"-foorab a\", NS(f=None, foobar=None, foorab=\"a\")),\n     ]\n \n \n class TestOptionalsSingleDashAmbiguous(ParserTestCase):\n     \"\"\"Test Optionals that partially match but are not subsets\"\"\"\n \n-    argument_signatures = [Sig('-foobar'), Sig('-foorab')]\n-    failures = ['-f', '-f a', '-fa', '-foa', '-foo', '-fo', '-foo b',\n-                '-f=a', '-foo=b']\n+    argument_signatures = [Sig(\"-foobar\"), Sig(\"-foorab\")]\n+    failures = [\n+        \"-f\",\n+        \"-f a\",\n+        \"-fa\",\n+        \"-foa\",\n+        \"-foo\",\n+        \"-fo\",\n+        \"-foo b\",\n+        \"-f=a\",\n+        \"-foo=b\",\n+    ]\n     successes = [\n-        ('', NS(foobar=None, foorab=None)),\n-        ('-foob a', NS(foobar='a', foorab=None)),\n-        ('-foob=a', NS(foobar='a', foorab=None)),\n-        ('-foor a', NS(foobar=None, foorab='a')),\n-        ('-foor=a', NS(foobar=None, foorab='a')),\n-        ('-fooba a', NS(foobar='a', foorab=None)),\n-        ('-fooba=a', NS(foobar='a', foorab=None)),\n-        ('-foora a', NS(foobar=None, foorab='a')),\n-        ('-foora=a', NS(foobar=None, foorab='a')),\n-        ('-foobar a', NS(foobar='a', foorab=None)),\n-        ('-foobar=a', NS(foobar='a', foorab=None)),\n-        ('-foorab a', NS(foobar=None, foorab='a')),\n-        ('-foorab=a', NS(foobar=None, foorab='a')),\n+        (\"\", NS(foobar=None, foorab=None)),\n+        (\"-foob a\", NS(foobar=\"a\", foorab=None)),\n+        (\"-foob=a\", NS(foobar=\"a\", foorab=None)),\n+        (\"-foor a\", NS(foobar=None, foorab=\"a\")),\n+        (\"-foor=a\", NS(foobar=None, foorab=\"a\")),\n+        (\"-fooba a\", NS(foobar=\"a\", foorab=None)),\n+        (\"-fooba=a\", NS(foobar=\"a\", foorab=None)),\n+        (\"-foora a\", NS(foobar=None, foorab=\"a\")),\n+        (\"-foora=a\", NS(foobar=None, foorab=\"a\")),\n+        (\"-foobar a\", NS(foobar=\"a\", foorab=None)),\n+        (\"-foobar=a\", NS(foobar=\"a\", foorab=None)),\n+        (\"-foorab a\", NS(foobar=None, foorab=\"a\")),\n+        (\"-foorab=a\", NS(foobar=None, foorab=\"a\")),\n     ]\n \n \n class TestOptionalsNumeric(ParserTestCase):\n     \"\"\"Test an Optional with a short opt string\"\"\"\n \n-    argument_signatures = [Sig('-1', dest='one')]\n-    failures = ['-1', 'a', '-1 --foo', '-1 -y', '-1 -1', '-1 -2']\n+    argument_signatures = [Sig(\"-1\", dest=\"one\")]\n+    failures = [\"-1\", \"a\", \"-1 --foo\", \"-1 -y\", \"-1 -1\", \"-1 -2\"]\n     successes = [\n-        ('', NS(one=None)),\n-        ('-1 a', NS(one='a')),\n-        ('-1a', NS(one='a')),\n-        ('-1-2', NS(one='-2')),\n+        (\"\", NS(one=None)),\n+        (\"-1 a\", NS(one=\"a\")),\n+        (\"-1a\", NS(one=\"a\")),\n+        (\"-1-2\", NS(one=\"-2\")),\n     ]\n \n \n class TestOptionalsDoubleDash(ParserTestCase):\n     \"\"\"Test an Optional with a double-dash option string\"\"\"\n \n-    argument_signatures = [Sig('--foo')]\n-    failures = ['--foo', '-f', '-f a', 'a', '--foo -x', '--foo --bar']\n+    argument_signatures = [Sig(\"--foo\")]\n+    failures = [\"--foo\", \"-f\", \"-f a\", \"a\", \"--foo -x\", \"--foo --bar\"]\n     successes = [\n-        ('', NS(foo=None)),\n-        ('--foo a', NS(foo='a')),\n-        ('--foo=a', NS(foo='a')),\n-        ('--foo -2.5', NS(foo='-2.5')),\n-        ('--foo=-2.5', NS(foo='-2.5')),\n+        (\"\", NS(foo=None)),\n+        (\"--foo a\", NS(foo=\"a\")),\n+        (\"--foo=a\", NS(foo=\"a\")),\n+        (\"--foo -2.5\", NS(foo=\"-2.5\")),\n+        (\"--foo=-2.5\", NS(foo=\"-2.5\")),\n     ]\n \n \n@@ -444,17 +480,17 @@ class TestOptionalsDoubleDashPartialMatch(ParserTestCase):\n     \"\"\"Tests partial matching with a double-dash option string\"\"\"\n \n     argument_signatures = [\n-        Sig('--badger', action='store_true'),\n-        Sig('--bat'),\n+        Sig(\"--badger\", action=\"store_true\"),\n+        Sig(\"--bat\"),\n     ]\n-    failures = ['--bar', '--b', '--ba', '--b=2', '--ba=4', '--badge 5']\n+    failures = [\"--bar\", \"--b\", \"--ba\", \"--b=2\", \"--ba=4\", \"--badge 5\"]\n     successes = [\n-        ('', NS(badger=False, bat=None)),\n-        ('--bat X', NS(badger=False, bat='X')),\n-        ('--bad', NS(badger=True, bat=None)),\n-        ('--badg', NS(badger=True, bat=None)),\n-        ('--badge', NS(badger=True, bat=None)),\n-        ('--badger', NS(badger=True, bat=None)),\n+        (\"\", NS(badger=False, bat=None)),\n+        (\"--bat X\", NS(badger=False, bat=\"X\")),\n+        (\"--bad\", NS(badger=True, bat=None)),\n+        (\"--badg\", NS(badger=True, bat=None)),\n+        (\"--badge\", NS(badger=True, bat=None)),\n+        (\"--badger\", NS(badger=True, bat=None)),\n     ]\n \n \n@@ -462,18 +498,18 @@ class TestOptionalsDoubleDashPrefixMatch(ParserTestCase):\n     \"\"\"Tests when one double-dash option string is a prefix of another\"\"\"\n \n     argument_signatures = [\n-        Sig('--badger', action='store_true'),\n-        Sig('--ba'),\n+        Sig(\"--badger\", action=\"store_true\"),\n+        Sig(\"--ba\"),\n     ]\n-    failures = ['--bar', '--b', '--ba', '--b=2', '--badge 5']\n+    failures = [\"--bar\", \"--b\", \"--ba\", \"--b=2\", \"--badge 5\"]\n     successes = [\n-        ('', NS(badger=False, ba=None)),\n-        ('--ba X', NS(badger=False, ba='X')),\n-        ('--ba=X', NS(badger=False, ba='X')),\n-        ('--bad', NS(badger=True, ba=None)),\n-        ('--badg', NS(badger=True, ba=None)),\n-        ('--badge', NS(badger=True, ba=None)),\n-        ('--badger', NS(badger=True, ba=None)),\n+        (\"\", NS(badger=False, ba=None)),\n+        (\"--ba X\", NS(badger=False, ba=\"X\")),\n+        (\"--ba=X\", NS(badger=False, ba=\"X\")),\n+        (\"--bad\", NS(badger=True, ba=None)),\n+        (\"--badg\", NS(badger=True, ba=None)),\n+        (\"--badge\", NS(badger=True, ba=None)),\n+        (\"--badger\", NS(badger=True, ba=None)),\n     ]\n \n \n@@ -481,83 +517,97 @@ class TestOptionalsSingleDoubleDash(ParserTestCase):\n     \"\"\"Test an Optional with single- and double-dash option strings\"\"\"\n \n     argument_signatures = [\n-        Sig('-f', action='store_true'),\n-        Sig('--bar'),\n-        Sig('-baz', action='store_const', const=42),\n+        Sig(\"-f\", action=\"store_true\"),\n+        Sig(\"--bar\"),\n+        Sig(\"-baz\", action=\"store_const\", const=42),\n     ]\n-    failures = ['--bar', '-fbar', '-fbaz', '-bazf', '-b B', 'B']\n+    failures = [\"--bar\", \"-fbar\", \"-fbaz\", \"-bazf\", \"-b B\", \"B\"]\n     successes = [\n-        ('', NS(f=False, bar=None, baz=None)),\n-        ('-f', NS(f=True, bar=None, baz=None)),\n-        ('--ba B', NS(f=False, bar='B', baz=None)),\n-        ('-f --bar B', NS(f=True, bar='B', baz=None)),\n-        ('-f -b', NS(f=True, bar=None, baz=42)),\n-        ('-ba -f', NS(f=True, bar=None, baz=42)),\n+        (\"\", NS(f=False, bar=None, baz=None)),\n+        (\"-f\", NS(f=True, bar=None, baz=None)),\n+        (\"--ba B\", NS(f=False, bar=\"B\", baz=None)),\n+        (\"-f --bar B\", NS(f=True, bar=\"B\", baz=None)),\n+        (\"-f -b\", NS(f=True, bar=None, baz=42)),\n+        (\"-ba -f\", NS(f=True, bar=None, baz=42)),\n     ]\n \n \n class TestOptionalsAlternatePrefixChars(ParserTestCase):\n     \"\"\"Test an Optional with option strings with custom prefixes\"\"\"\n \n-    parser_signature = Sig(prefix_chars='+:/', add_help=False)\n+    parser_signature = Sig(prefix_chars=\"+:/\", add_help=False)\n     argument_signatures = [\n-        Sig('+f', action='store_true'),\n-        Sig('::bar'),\n-        Sig('/baz', action='store_const', const=42),\n+        Sig(\"+f\", action=\"store_true\"),\n+        Sig(\"::bar\"),\n+        Sig(\"/baz\", action=\"store_const\", const=42),\n+    ]\n+    failures = [\n+        \"--bar\",\n+        \"-fbar\",\n+        \"-b B\",\n+        \"B\",\n+        \"-f\",\n+        \"--bar B\",\n+        \"-baz\",\n+        \"-h\",\n+        \"--help\",\n+        \"+h\",\n+        \"::help\",\n+        \"/help\",\n     ]\n-    failures = ['--bar', '-fbar', '-b B', 'B', '-f', '--bar B', '-baz', '-h', '--help', '+h', '::help', '/help']\n     successes = [\n-        ('', NS(f=False, bar=None, baz=None)),\n-        ('+f', NS(f=True, bar=None, baz=None)),\n-        ('::ba B', NS(f=False, bar='B', baz=None)),\n-        ('+f ::bar B', NS(f=True, bar='B', baz=None)),\n-        ('+f /b', NS(f=True, bar=None, baz=42)),\n-        ('/ba +f', NS(f=True, bar=None, baz=42)),\n+        (\"\", NS(f=False, bar=None, baz=None)),\n+        (\"+f\", NS(f=True, bar=None, baz=None)),\n+        (\"::ba B\", NS(f=False, bar=\"B\", baz=None)),\n+        (\"+f ::bar B\", NS(f=True, bar=\"B\", baz=None)),\n+        (\"+f /b\", NS(f=True, bar=None, baz=42)),\n+        (\"/ba +f\", NS(f=True, bar=None, baz=42)),\n     ]\n \n \n class TestOptionalsAlternatePrefixCharsAddedHelp(ParserTestCase):\n     \"\"\"When ``-`` not in prefix_chars, default operators created for help\n-       should use the prefix_chars in use rather than - or --\n-       http://bugs.python.org/issue9444\"\"\"\n+    should use the prefix_chars in use rather than - or --\n+    http://bugs.python.org/issue9444\"\"\"\n \n-    parser_signature = Sig(prefix_chars='+:/', add_help=True)\n+    parser_signature = Sig(prefix_chars=\"+:/\", add_help=True)\n     argument_signatures = [\n-        Sig('+f', action='store_true'),\n-        Sig('::bar'),\n-        Sig('/baz', action='store_const', const=42),\n+        Sig(\"+f\", action=\"store_true\"),\n+        Sig(\"::bar\"),\n+        Sig(\"/baz\", action=\"store_const\", const=42),\n     ]\n-    failures = ['--bar', '-fbar', '-b B', 'B', '-f', '--bar B', '-baz']\n+    failures = [\"--bar\", \"-fbar\", \"-b B\", \"B\", \"-f\", \"--bar B\", \"-baz\"]\n     successes = [\n-        ('', NS(f=False, bar=None, baz=None)),\n-        ('+f', NS(f=True, bar=None, baz=None)),\n-        ('::ba B', NS(f=False, bar='B', baz=None)),\n-        ('+f ::bar B', NS(f=True, bar='B', baz=None)),\n-        ('+f /b', NS(f=True, bar=None, baz=42)),\n-        ('/ba +f', NS(f=True, bar=None, baz=42))\n+        (\"\", NS(f=False, bar=None, baz=None)),\n+        (\"+f\", NS(f=True, bar=None, baz=None)),\n+        (\"::ba B\", NS(f=False, bar=\"B\", baz=None)),\n+        (\"+f ::bar B\", NS(f=True, bar=\"B\", baz=None)),\n+        (\"+f /b\", NS(f=True, bar=None, baz=42)),\n+        (\"/ba +f\", NS(f=True, bar=None, baz=42)),\n     ]\n \n \n class TestOptionalsAlternatePrefixCharsMultipleShortArgs(ParserTestCase):\n     \"\"\"Verify that Optionals must be called with their defined prefixes\"\"\"\n \n-    parser_signature = Sig(prefix_chars='+-', add_help=False)\n+    parser_signature = Sig(prefix_chars=\"+-\", add_help=False)\n     argument_signatures = [\n-        Sig('-x', action='store_true'),\n-        Sig('+y', action='store_true'),\n-        Sig('+z', action='store_true'),\n+        Sig(\"-x\", action=\"store_true\"),\n+        Sig(\"+y\", action=\"store_true\"),\n+        Sig(\"+z\", action=\"store_true\"),\n     ]\n-    failures = ['-w',\n-                '-xyz',\n-                '+x',\n-                '-y',\n-                '+xyz',\n+    failures = [\n+        \"-w\",\n+        \"-xyz\",\n+        \"+x\",\n+        \"-y\",\n+        \"+xyz\",\n     ]\n     successes = [\n-        ('', NS(x=False, y=False, z=False)),\n-        ('-x', NS(x=True, y=False, z=False)),\n-        ('+y -x', NS(x=True, y=True, z=False)),\n-        ('+yz -x', NS(x=True, y=True, z=True)),\n+        (\"\", NS(x=False, y=False, z=False)),\n+        (\"-x\", NS(x=True, y=False, z=False)),\n+        (\"+y -x\", NS(x=True, y=True, z=False)),\n+        (\"+yz -x\", NS(x=True, y=True, z=True)),\n     ]\n \n \n@@ -565,73 +615,73 @@ class TestOptionalsShortLong(ParserTestCase):\n     \"\"\"Test a combination of single- and double-dash option strings\"\"\"\n \n     argument_signatures = [\n-        Sig('-v', '--verbose', '-n', '--noisy', action='store_true'),\n+        Sig(\"-v\", \"--verbose\", \"-n\", \"--noisy\", action=\"store_true\"),\n     ]\n-    failures = ['--x --verbose', '-N', 'a', '-v x']\n+    failures = [\"--x --verbose\", \"-N\", \"a\", \"-v x\"]\n     successes = [\n-        ('', NS(verbose=False)),\n-        ('-v', NS(verbose=True)),\n-        ('--verbose', NS(verbose=True)),\n-        ('-n', NS(verbose=True)),\n-        ('--noisy', NS(verbose=True)),\n+        (\"\", NS(verbose=False)),\n+        (\"-v\", NS(verbose=True)),\n+        (\"--verbose\", NS(verbose=True)),\n+        (\"-n\", NS(verbose=True)),\n+        (\"--noisy\", NS(verbose=True)),\n     ]\n \n \n class TestOptionalsDest(ParserTestCase):\n     \"\"\"Tests various means of setting destination\"\"\"\n \n-    argument_signatures = [Sig('--foo-bar'), Sig('--baz', dest='zabbaz')]\n-    failures = ['a']\n+    argument_signatures = [Sig(\"--foo-bar\"), Sig(\"--baz\", dest=\"zabbaz\")]\n+    failures = [\"a\"]\n     successes = [\n-        ('--foo-bar f', NS(foo_bar='f', zabbaz=None)),\n-        ('--baz g', NS(foo_bar=None, zabbaz='g')),\n-        ('--foo-bar h --baz i', NS(foo_bar='h', zabbaz='i')),\n-        ('--baz j --foo-bar k', NS(foo_bar='k', zabbaz='j')),\n+        (\"--foo-bar f\", NS(foo_bar=\"f\", zabbaz=None)),\n+        (\"--baz g\", NS(foo_bar=None, zabbaz=\"g\")),\n+        (\"--foo-bar h --baz i\", NS(foo_bar=\"h\", zabbaz=\"i\")),\n+        (\"--baz j --foo-bar k\", NS(foo_bar=\"k\", zabbaz=\"j\")),\n     ]\n \n \n class TestOptionalsDefault(ParserTestCase):\n     \"\"\"Tests specifying a default for an Optional\"\"\"\n \n-    argument_signatures = [Sig('-x'), Sig('-y', default=42)]\n-    failures = ['a']\n+    argument_signatures = [Sig(\"-x\"), Sig(\"-y\", default=42)]\n+    failures = [\"a\"]\n     successes = [\n-        ('', NS(x=None, y=42)),\n-        ('-xx', NS(x='x', y=42)),\n-        ('-yy', NS(x=None, y='y')),\n+        (\"\", NS(x=None, y=42)),\n+        (\"-xx\", NS(x=\"x\", y=42)),\n+        (\"-yy\", NS(x=None, y=\"y\")),\n     ]\n \n \n class TestOptionalsNargsDefault(ParserTestCase):\n     \"\"\"Tests not specifying the number of args for an Optional\"\"\"\n \n-    argument_signatures = [Sig('-x')]\n-    failures = ['a', '-x']\n+    argument_signatures = [Sig(\"-x\")]\n+    failures = [\"a\", \"-x\"]\n     successes = [\n-        ('', NS(x=None)),\n-        ('-x a', NS(x='a')),\n+        (\"\", NS(x=None)),\n+        (\"-x a\", NS(x=\"a\")),\n     ]\n \n \n class TestOptionalsNargs1(ParserTestCase):\n     \"\"\"Tests specifying 1 arg for an Optional\"\"\"\n \n-    argument_signatures = [Sig('-x', nargs=1)]\n-    failures = ['a', '-x']\n+    argument_signatures = [Sig(\"-x\", nargs=1)]\n+    failures = [\"a\", \"-x\"]\n     successes = [\n-        ('', NS(x=None)),\n-        ('-x a', NS(x=['a'])),\n+        (\"\", NS(x=None)),\n+        (\"-x a\", NS(x=[\"a\"])),\n     ]\n \n \n class TestOptionalsNargs3(ParserTestCase):\n     \"\"\"Tests specifying 3 args for an Optional\"\"\"\n \n-    argument_signatures = [Sig('-x', nargs=3)]\n-    failures = ['a', '-x', '-x a', '-x a b', 'a -x', 'a -x b']\n+    argument_signatures = [Sig(\"-x\", nargs=3)]\n+    failures = [\"a\", \"-x\", \"-x a\", \"-x a b\", \"a -x\", \"a -x b\"]\n     successes = [\n-        ('', NS(x=None)),\n-        ('-x a b c', NS(x=['a', 'b', 'c'])),\n+        (\"\", NS(x=None)),\n+        (\"-x a b c\", NS(x=[\"a\", \"b\", \"c\"])),\n     ]\n \n \n@@ -639,22 +689,24 @@ class TestOptionalsNargsOptional(ParserTestCase):\n     \"\"\"Tests specifying an Optional arg for an Optional\"\"\"\n \n     argument_signatures = [\n-        Sig('-w', nargs='?'),\n-        Sig('-x', nargs='?', const=42),\n-        Sig('-y', nargs='?', default='spam'),\n-        Sig('-z', nargs='?', type=int, const='42', default='84', choices=[1, 2]),\n-    ]\n-    failures = ['2', '-z a', '-z 42', '-z 84']\n+        Sig(\"-w\", nargs=\"?\"),\n+        Sig(\"-x\", nargs=\"?\", const=42),\n+        Sig(\"-y\", nargs=\"?\", default=\"spam\"),\n+        Sig(\n+            \"-z\", nargs=\"?\", type=int, const=\"42\", default=\"84\", choices=[1, 2]\n+        ),\n+    ]\n+    failures = [\"2\", \"-z a\", \"-z 42\", \"-z 84\"]\n     successes = [\n-        ('', NS(w=None, x=None, y='spam', z=84)),\n-        ('-w', NS(w=None, x=None, y='spam', z=84)),\n-        ('-w 2', NS(w='2', x=None, y='spam', z=84)),\n-        ('-x', NS(w=None, x=42, y='spam', z=84)),\n-        ('-x 2', NS(w=None, x='2', y='spam', z=84)),\n-        ('-y', NS(w=None, x=None, y=None, z=84)),\n-        ('-y 2', NS(w=None, x=None, y='2', z=84)),\n-        ('-z', NS(w=None, x=None, y='spam', z=42)),\n-        ('-z 2', NS(w=None, x=None, y='spam', z=2)),\n+        (\"\", NS(w=None, x=None, y=\"spam\", z=84)),\n+        (\"-w\", NS(w=None, x=None, y=\"spam\", z=84)),\n+        (\"-w 2\", NS(w=\"2\", x=None, y=\"spam\", z=84)),\n+        (\"-x\", NS(w=None, x=42, y=\"spam\", z=84)),\n+        (\"-x 2\", NS(w=None, x=\"2\", y=\"spam\", z=84)),\n+        (\"-y\", NS(w=None, x=None, y=None, z=84)),\n+        (\"-y 2\", NS(w=None, x=None, y=\"2\", z=84)),\n+        (\"-z\", NS(w=None, x=None, y=\"spam\", z=42)),\n+        (\"-z 2\", NS(w=None, x=None, y=\"spam\", z=2)),\n     ]\n \n \n@@ -662,18 +714,18 @@ class TestOptionalsNargsZeroOrMore(ParserTestCase):\n     \"\"\"Tests specifying args for an Optional that accepts zero or more\"\"\"\n \n     argument_signatures = [\n-        Sig('-x', nargs='*'),\n-        Sig('-y', nargs='*', default='spam'),\n+        Sig(\"-x\", nargs=\"*\"),\n+        Sig(\"-y\", nargs=\"*\", default=\"spam\"),\n     ]\n-    failures = ['a']\n+    failures = [\"a\"]\n     successes = [\n-        ('', NS(x=None, y='spam')),\n-        ('-x', NS(x=[], y='spam')),\n-        ('-x a', NS(x=['a'], y='spam')),\n-        ('-x a b', NS(x=['a', 'b'], y='spam')),\n-        ('-y', NS(x=None, y=[])),\n-        ('-y a', NS(x=None, y=['a'])),\n-        ('-y a b', NS(x=None, y=['a', 'b'])),\n+        (\"\", NS(x=None, y=\"spam\")),\n+        (\"-x\", NS(x=[], y=\"spam\")),\n+        (\"-x a\", NS(x=[\"a\"], y=\"spam\")),\n+        (\"-x a b\", NS(x=[\"a\", \"b\"], y=\"spam\")),\n+        (\"-y\", NS(x=None, y=[])),\n+        (\"-y a\", NS(x=None, y=[\"a\"])),\n+        (\"-y a b\", NS(x=None, y=[\"a\", \"b\"])),\n     ]\n \n \n@@ -681,16 +733,16 @@ class TestOptionalsNargsOneOrMore(ParserTestCase):\n     \"\"\"Tests specifying args for an Optional that accepts one or more\"\"\"\n \n     argument_signatures = [\n-        Sig('-x', nargs='+'),\n-        Sig('-y', nargs='+', default='spam'),\n+        Sig(\"-x\", nargs=\"+\"),\n+        Sig(\"-y\", nargs=\"+\", default=\"spam\"),\n     ]\n-    failures = ['a', '-x', '-y', 'a -x', 'a -y b']\n+    failures = [\"a\", \"-x\", \"-y\", \"a -x\", \"a -y b\"]\n     successes = [\n-        ('', NS(x=None, y='spam')),\n-        ('-x a', NS(x=['a'], y='spam')),\n-        ('-x a b', NS(x=['a', 'b'], y='spam')),\n-        ('-y a', NS(x=None, y=['a'])),\n-        ('-y a b', NS(x=None, y=['a', 'b'])),\n+        (\"\", NS(x=None, y=\"spam\")),\n+        (\"-x a\", NS(x=[\"a\"], y=\"spam\")),\n+        (\"-x a b\", NS(x=[\"a\", \"b\"], y=\"spam\")),\n+        (\"-y a\", NS(x=None, y=[\"a\"])),\n+        (\"-y a b\", NS(x=None, y=[\"a\", \"b\"])),\n     ]\n \n \n@@ -698,16 +750,17 @@ class TestOptionalsChoices(ParserTestCase):\n     \"\"\"Tests specifying the choices for an Optional\"\"\"\n \n     argument_signatures = [\n-        Sig('-f', choices='abc'),\n-        Sig('-g', type=int, choices=range(5))]\n-    failures = ['a', '-f d', '-f ab', '-fad', '-ga', '-g 6']\n+        Sig(\"-f\", choices=\"abc\"),\n+        Sig(\"-g\", type=int, choices=range(5)),\n+    ]\n+    failures = [\"a\", \"-f d\", \"-f ab\", \"-fad\", \"-ga\", \"-g 6\"]\n     successes = [\n-        ('', NS(f=None, g=None)),\n-        ('-f a', NS(f='a', g=None)),\n-        ('-f c', NS(f='c', g=None)),\n-        ('-g 0', NS(f=None, g=0)),\n-        ('-g 03', NS(f=None, g=3)),\n-        ('-fb -g4', NS(f='b', g=4)),\n+        (\"\", NS(f=None, g=None)),\n+        (\"-f a\", NS(f=\"a\", g=None)),\n+        (\"-f c\", NS(f=\"c\", g=None)),\n+        (\"-g 0\", NS(f=None, g=0)),\n+        (\"-g 03\", NS(f=None, g=3)),\n+        (\"-fb -g4\", NS(f=\"b\", g=4)),\n     ]\n \n \n@@ -715,119 +768,130 @@ class TestOptionalsRequired(ParserTestCase):\n     \"\"\"Tests an optional action that is required\"\"\"\n \n     argument_signatures = [\n-        Sig('-x', type=int, required=True),\n+        Sig(\"-x\", type=int, required=True),\n     ]\n-    failures = ['a', '']\n+    failures = [\"a\", \"\"]\n     successes = [\n-        ('-x 1', NS(x=1)),\n-        ('-x42', NS(x=42)),\n+        (\"-x 1\", NS(x=1)),\n+        (\"-x42\", NS(x=42)),\n     ]\n \n \n class TestOptionalsActionStore(ParserTestCase):\n     \"\"\"Tests the store action for an Optional\"\"\"\n \n-    argument_signatures = [Sig('-x', action='store')]\n-    failures = ['a', 'a -x']\n+    argument_signatures = [Sig(\"-x\", action=\"store\")]\n+    failures = [\"a\", \"a -x\"]\n     successes = [\n-        ('', NS(x=None)),\n-        ('-xfoo', NS(x='foo')),\n+        (\"\", NS(x=None)),\n+        (\"-xfoo\", NS(x=\"foo\")),\n     ]\n \n \n class TestOptionalsActionStoreConst(ParserTestCase):\n     \"\"\"Tests the store_const action for an Optional\"\"\"\n \n-    argument_signatures = [Sig('-y', action='store_const', const=object)]\n-    failures = ['a']\n+    argument_signatures = [Sig(\"-y\", action=\"store_const\", const=object)]\n+    failures = [\"a\"]\n     successes = [\n-        ('', NS(y=None)),\n-        ('-y', NS(y=object)),\n+        (\"\", NS(y=None)),\n+        (\"-y\", NS(y=object)),\n     ]\n \n \n class TestOptionalsActionStoreFalse(ParserTestCase):\n     \"\"\"Tests the store_false action for an Optional\"\"\"\n \n-    argument_signatures = [Sig('-z', action='store_false')]\n-    failures = ['a', '-za', '-z a']\n+    argument_signatures = [Sig(\"-z\", action=\"store_false\")]\n+    failures = [\"a\", \"-za\", \"-z a\"]\n     successes = [\n-        ('', NS(z=True)),\n-        ('-z', NS(z=False)),\n+        (\"\", NS(z=True)),\n+        (\"-z\", NS(z=False)),\n     ]\n \n \n class TestOptionalsActionStoreTrue(ParserTestCase):\n     \"\"\"Tests the store_true action for an Optional\"\"\"\n \n-    argument_signatures = [Sig('--apple', action='store_true')]\n-    failures = ['a', '--apple=b', '--apple b']\n+    argument_signatures = [Sig(\"--apple\", action=\"store_true\")]\n+    failures = [\"a\", \"--apple=b\", \"--apple b\"]\n     successes = [\n-        ('', NS(apple=False)),\n-        ('--apple', NS(apple=True)),\n+        (\"\", NS(apple=False)),\n+        (\"--apple\", NS(apple=True)),\n     ]\n \n+\n class TestBooleanOptionalAction(ParserTestCase):\n     \"\"\"Tests BooleanOptionalAction\"\"\"\n \n-    argument_signatures = [Sig('--foo', action=argparse.BooleanOptionalAction)]\n-    failures = ['--foo bar', '--foo=bar']\n+    argument_signatures = [Sig(\"--foo\", action=argparse.BooleanOptionalAction)]\n+    failures = [\"--foo bar\", \"--foo=bar\"]\n     successes = [\n-        ('', NS(foo=None)),\n-        ('--foo', NS(foo=True)),\n-        ('--no-foo', NS(foo=False)),\n-        ('--foo --no-foo', NS(foo=False)),  # useful for aliases\n-        ('--no-foo --foo', NS(foo=True)),\n+        (\"\", NS(foo=None)),\n+        (\"--foo\", NS(foo=True)),\n+        (\"--no-foo\", NS(foo=False)),\n+        (\"--foo --no-foo\", NS(foo=False)),  # useful for aliases\n+        (\"--no-foo --foo\", NS(foo=True)),\n     ]\n \n     def test_const(self):\n         # See bpo-40862\n         parser = argparse.ArgumentParser()\n         with self.assertRaises(TypeError) as cm:\n-            parser.add_argument('--foo', const=True, action=argparse.BooleanOptionalAction)\n+            parser.add_argument(\n+                \"--foo\", const=True, action=argparse.BooleanOptionalAction\n+            )\n \n-        self.assertIn(\"got an unexpected keyword argument 'const'\", str(cm.exception))\n+        self.assertIn(\n+            \"got an unexpected keyword argument 'const'\", str(cm.exception)\n+        )\n \n     def test_invalid_name(self):\n         parser = argparse.ArgumentParser()\n         with self.assertRaises(ValueError) as cm:\n-            parser.add_argument('--no-foo', action=argparse.BooleanOptionalAction)\n-        self.assertEqual(str(cm.exception),\n-                         \"invalid option name '--no-foo' for BooleanOptionalAction\")\n+            parser.add_argument(\n+                \"--no-foo\", action=argparse.BooleanOptionalAction\n+            )\n+        self.assertEqual(\n+            str(cm.exception),\n+            \"invalid option name '--no-foo' for BooleanOptionalAction\",\n+        )\n+\n \n class TestBooleanOptionalActionRequired(ParserTestCase):\n     \"\"\"Tests BooleanOptionalAction required\"\"\"\n \n     argument_signatures = [\n-        Sig('--foo', required=True, action=argparse.BooleanOptionalAction)\n+        Sig(\"--foo\", required=True, action=argparse.BooleanOptionalAction)\n     ]\n-    failures = ['']\n+    failures = [\"\"]\n     successes = [\n-        ('--foo', NS(foo=True)),\n-        ('--no-foo', NS(foo=False)),\n+        (\"--foo\", NS(foo=True)),\n+        (\"--no-foo\", NS(foo=False)),\n     ]\n \n+\n class TestOptionalsActionAppend(ParserTestCase):\n     \"\"\"Tests the append action for an Optional\"\"\"\n \n-    argument_signatures = [Sig('--baz', action='append')]\n-    failures = ['a', '--baz', 'a --baz', '--baz a b']\n+    argument_signatures = [Sig(\"--baz\", action=\"append\")]\n+    failures = [\"a\", \"--baz\", \"a --baz\", \"--baz a b\"]\n     successes = [\n-        ('', NS(baz=None)),\n-        ('--baz a', NS(baz=['a'])),\n-        ('--baz a --baz b', NS(baz=['a', 'b'])),\n+        (\"\", NS(baz=None)),\n+        (\"--baz a\", NS(baz=[\"a\"])),\n+        (\"--baz a --baz b\", NS(baz=[\"a\", \"b\"])),\n     ]\n \n \n class TestOptionalsActionAppendWithDefault(ParserTestCase):\n     \"\"\"Tests the append action for an Optional\"\"\"\n \n-    argument_signatures = [Sig('--baz', action='append', default=['X'])]\n-    failures = ['a', '--baz', 'a --baz', '--baz a b']\n+    argument_signatures = [Sig(\"--baz\", action=\"append\", default=[\"X\"])]\n+    failures = [\"a\", \"--baz\", \"a --baz\", \"--baz a b\"]\n     successes = [\n-        ('', NS(baz=['X'])),\n-        ('--baz a', NS(baz=['X', 'a'])),\n-        ('--baz a --baz b', NS(baz=['X', 'a', 'b'])),\n+        (\"\", NS(baz=[\"X\"])),\n+        (\"--baz a\", NS(baz=[\"X\", \"a\"])),\n+        (\"--baz a --baz b\", NS(baz=[\"X\", \"a\", \"b\"])),\n     ]\n \n \n@@ -835,18 +899,18 @@ class TestConstActionsMissingConstKwarg(ParserTestCase):\n     \"\"\"Tests that const gets default value of None when not provided\"\"\"\n \n     argument_signatures = [\n-        Sig('-f', action='append_const'),\n-        Sig('--foo', action='append_const'),\n-        Sig('-b', action='store_const'),\n-        Sig('--bar', action='store_const')\n+        Sig(\"-f\", action=\"append_const\"),\n+        Sig(\"--foo\", action=\"append_const\"),\n+        Sig(\"-b\", action=\"store_const\"),\n+        Sig(\"--bar\", action=\"store_const\"),\n     ]\n-    failures = ['-f v', '--foo=bar', '--foo bar']\n+    failures = [\"-f v\", \"--foo=bar\", \"--foo bar\"]\n     successes = [\n-        ('', NS(f=None, foo=None, b=None, bar=None)),\n-        ('-f', NS(f=[None], foo=None, b=None, bar=None)),\n-        ('--foo', NS(f=None, foo=[None], b=None, bar=None)),\n-        ('-b', NS(f=None, foo=None, b=None, bar=None)),\n-        ('--bar', NS(f=None, foo=None, b=None, bar=None)),\n+        (\"\", NS(f=None, foo=None, b=None, bar=None)),\n+        (\"-f\", NS(f=[None], foo=None, b=None, bar=None)),\n+        (\"--foo\", NS(f=None, foo=[None], b=None, bar=None)),\n+        (\"-b\", NS(f=None, foo=None, b=None, bar=None)),\n+        (\"--bar\", NS(f=None, foo=None, b=None, bar=None)),\n     ]\n \n \n@@ -854,14 +918,14 @@ class TestOptionalsActionAppendConst(ParserTestCase):\n     \"\"\"Tests the append_const action for an Optional\"\"\"\n \n     argument_signatures = [\n-        Sig('-b', action='append_const', const=Exception),\n-        Sig('-c', action='append', dest='b'),\n+        Sig(\"-b\", action=\"append_const\", const=Exception),\n+        Sig(\"-c\", action=\"append\", dest=\"b\"),\n     ]\n-    failures = ['a', '-c', 'a -c', '-bx', '-b x']\n+    failures = [\"a\", \"-c\", \"a -c\", \"-bx\", \"-b x\"]\n     successes = [\n-        ('', NS(b=None)),\n-        ('-b', NS(b=[Exception])),\n-        ('-b -cx -b -cyz', NS(b=[Exception, 'x', Exception, 'yz'])),\n+        (\"\", NS(b=None)),\n+        (\"-b\", NS(b=[Exception])),\n+        (\"-b -cx -b -cyz\", NS(b=[Exception, \"x\", Exception, \"yz\"])),\n     ]\n \n \n@@ -869,25 +933,25 @@ class TestOptionalsActionAppendConstWithDefault(ParserTestCase):\n     \"\"\"Tests the append_const action for an Optional\"\"\"\n \n     argument_signatures = [\n-        Sig('-b', action='append_const', const=Exception, default=['X']),\n-        Sig('-c', action='append', dest='b'),\n+        Sig(\"-b\", action=\"append_const\", const=Exception, default=[\"X\"]),\n+        Sig(\"-c\", action=\"append\", dest=\"b\"),\n     ]\n-    failures = ['a', '-c', 'a -c', '-bx', '-b x']\n+    failures = [\"a\", \"-c\", \"a -c\", \"-bx\", \"-b x\"]\n     successes = [\n-        ('', NS(b=['X'])),\n-        ('-b', NS(b=['X', Exception])),\n-        ('-b -cx -b -cyz', NS(b=['X', Exception, 'x', Exception, 'yz'])),\n+        (\"\", NS(b=[\"X\"])),\n+        (\"-b\", NS(b=[\"X\", Exception])),\n+        (\"-b -cx -b -cyz\", NS(b=[\"X\", Exception, \"x\", Exception, \"yz\"])),\n     ]\n \n \n class TestOptionalsActionCount(ParserTestCase):\n     \"\"\"Tests the count action for an Optional\"\"\"\n \n-    argument_signatures = [Sig('-x', action='count')]\n-    failures = ['a', '-x a', '-x b', '-x a -x b']\n+    argument_signatures = [Sig(\"-x\", action=\"count\")]\n+    failures = [\"a\", \"-x a\", \"-x b\", \"-x a -x b\"]\n     successes = [\n-        ('', NS(x=None)),\n-        ('-x', NS(x=1)),\n+        (\"\", NS(x=None)),\n+        (\"-x\", NS(x=1)),\n     ]\n \n \n@@ -895,18 +959,18 @@ class TestOptionalsAllowLongAbbreviation(ParserTestCase):\n     \"\"\"Allow long options to be abbreviated unambiguously\"\"\"\n \n     argument_signatures = [\n-        Sig('--foo'),\n-        Sig('--foobaz'),\n-        Sig('--fooble', action='store_true'),\n+        Sig(\"--foo\"),\n+        Sig(\"--foobaz\"),\n+        Sig(\"--fooble\", action=\"store_true\"),\n     ]\n-    failures = ['--foob 5', '--foob']\n+    failures = [\"--foob 5\", \"--foob\"]\n     successes = [\n-        ('', NS(foo=None, foobaz=None, fooble=False)),\n-        ('--foo 7', NS(foo='7', foobaz=None, fooble=False)),\n-        ('--foo=7', NS(foo='7', foobaz=None, fooble=False)),\n-        ('--fooba a', NS(foo=None, foobaz='a', fooble=False)),\n-        ('--fooba=a', NS(foo=None, foobaz='a', fooble=False)),\n-        ('--foobl --foo g', NS(foo='g', foobaz=None, fooble=True)),\n+        (\"\", NS(foo=None, foobaz=None, fooble=False)),\n+        (\"--foo 7\", NS(foo=\"7\", foobaz=None, fooble=False)),\n+        (\"--foo=7\", NS(foo=\"7\", foobaz=None, fooble=False)),\n+        (\"--fooba a\", NS(foo=None, foobaz=\"a\", fooble=False)),\n+        (\"--fooba=a\", NS(foo=None, foobaz=\"a\", fooble=False)),\n+        (\"--foobl --foo g\", NS(foo=\"g\", foobaz=None, fooble=True)),\n     ]\n \n \n@@ -915,32 +979,32 @@ class TestOptionalsDisallowLongAbbreviation(ParserTestCase):\n \n     parser_signature = Sig(allow_abbrev=False)\n     argument_signatures = [\n-        Sig('--foo'),\n-        Sig('--foodle', action='store_true'),\n-        Sig('--foonly'),\n+        Sig(\"--foo\"),\n+        Sig(\"--foodle\", action=\"store_true\"),\n+        Sig(\"--foonly\"),\n     ]\n-    failures = ['-foon 3', '--foon 3', '--food', '--food --foo 2']\n+    failures = [\"-foon 3\", \"--foon 3\", \"--food\", \"--food --foo 2\"]\n     successes = [\n-        ('', NS(foo=None, foodle=False, foonly=None)),\n-        ('--foo 3', NS(foo='3', foodle=False, foonly=None)),\n-        ('--foonly 7 --foodle --foo 2', NS(foo='2', foodle=True, foonly='7')),\n+        (\"\", NS(foo=None, foodle=False, foonly=None)),\n+        (\"--foo 3\", NS(foo=\"3\", foodle=False, foonly=None)),\n+        (\"--foonly 7 --foodle --foo 2\", NS(foo=\"2\", foodle=True, foonly=\"7\")),\n     ]\n \n \n class TestOptionalsDisallowLongAbbreviationPrefixChars(ParserTestCase):\n     \"\"\"Disallowing abbreviations works with alternative prefix characters\"\"\"\n \n-    parser_signature = Sig(prefix_chars='+', allow_abbrev=False)\n+    parser_signature = Sig(prefix_chars=\"+\", allow_abbrev=False)\n     argument_signatures = [\n-        Sig('++foo'),\n-        Sig('++foodle', action='store_true'),\n-        Sig('++foonly'),\n+        Sig(\"++foo\"),\n+        Sig(\"++foodle\", action=\"store_true\"),\n+        Sig(\"++foonly\"),\n     ]\n-    failures = ['+foon 3', '++foon 3', '++food', '++food ++foo 2']\n+    failures = [\"+foon 3\", \"++foon 3\", \"++food\", \"++food ++foo 2\"]\n     successes = [\n-        ('', NS(foo=None, foodle=False, foonly=None)),\n-        ('++foo 3', NS(foo='3', foodle=False, foonly=None)),\n-        ('++foonly 7 ++foodle ++foo 2', NS(foo='2', foodle=True, foonly='7')),\n+        (\"\", NS(foo=None, foodle=False, foonly=None)),\n+        (\"++foo 3\", NS(foo=\"3\", foodle=False, foonly=None)),\n+        (\"++foonly 7 ++foodle ++foo 2\", NS(foo=\"2\", foodle=True, foonly=\"7\")),\n     ]\n \n \n@@ -949,15 +1013,15 @@ class TestOptionalsDisallowSingleDashLongAbbreviation(ParserTestCase):\n \n     parser_signature = Sig(allow_abbrev=False)\n     argument_signatures = [\n-        Sig('-foo'),\n-        Sig('-foodle', action='store_true'),\n-        Sig('-foonly'),\n+        Sig(\"-foo\"),\n+        Sig(\"-foodle\", action=\"store_true\"),\n+        Sig(\"-foonly\"),\n     ]\n-    failures = ['-foon 3', '-food', '-food -foo 2']\n+    failures = [\"-foon 3\", \"-food\", \"-food -foo 2\"]\n     successes = [\n-        ('', NS(foo=None, foodle=False, foonly=None)),\n-        ('-foo 3', NS(foo='3', foodle=False, foonly=None)),\n-        ('-foonly 7 -foodle -foo 2', NS(foo='2', foodle=True, foonly='7')),\n+        (\"\", NS(foo=None, foodle=False, foonly=None)),\n+        (\"-foo 3\", NS(foo=\"3\", foodle=False, foonly=None)),\n+        (\"-foonly 7 -foodle -foo 2\", NS(foo=\"2\", foodle=True, foonly=\"7\")),\n     ]\n \n \n@@ -966,36 +1030,36 @@ class TestDisallowLongAbbreviationAllowsShortGrouping(ParserTestCase):\n \n     parser_signature = Sig(allow_abbrev=False)\n     argument_signatures = [\n-        Sig('-r'),\n-        Sig('-c', action='count'),\n+        Sig(\"-r\"),\n+        Sig(\"-c\", action=\"count\"),\n     ]\n-    failures = ['-r', '-c -r']\n+    failures = [\"-r\", \"-c -r\"]\n     successes = [\n-        ('', NS(r=None, c=None)),\n-        ('-ra', NS(r='a', c=None)),\n-        ('-rcc', NS(r='cc', c=None)),\n-        ('-cc', NS(r=None, c=2)),\n-        ('-cc -ra', NS(r='a', c=2)),\n-        ('-ccrcc', NS(r='cc', c=2)),\n+        (\"\", NS(r=None, c=None)),\n+        (\"-ra\", NS(r=\"a\", c=None)),\n+        (\"-rcc\", NS(r=\"cc\", c=None)),\n+        (\"-cc\", NS(r=None, c=2)),\n+        (\"-cc -ra\", NS(r=\"a\", c=2)),\n+        (\"-ccrcc\", NS(r=\"cc\", c=2)),\n     ]\n \n \n class TestDisallowLongAbbreviationAllowsShortGroupingPrefix(ParserTestCase):\n     \"\"\"Short option grouping works with custom prefix and allow_abbrev=False\"\"\"\n \n-    parser_signature = Sig(prefix_chars='+', allow_abbrev=False)\n+    parser_signature = Sig(prefix_chars=\"+\", allow_abbrev=False)\n     argument_signatures = [\n-        Sig('+r'),\n-        Sig('+c', action='count'),\n+        Sig(\"+r\"),\n+        Sig(\"+c\", action=\"count\"),\n     ]\n-    failures = ['+r', '+c +r']\n+    failures = [\"+r\", \"+c +r\"]\n     successes = [\n-        ('', NS(r=None, c=None)),\n-        ('+ra', NS(r='a', c=None)),\n-        ('+rcc', NS(r='cc', c=None)),\n-        ('+cc', NS(r=None, c=2)),\n-        ('+cc +ra', NS(r='a', c=2)),\n-        ('+ccrcc', NS(r='cc', c=2)),\n+        (\"\", NS(r=None, c=None)),\n+        (\"+ra\", NS(r=\"a\", c=None)),\n+        (\"+rcc\", NS(r=\"cc\", c=None)),\n+        (\"+cc\", NS(r=None, c=2)),\n+        (\"+cc +ra\", NS(r=\"a\", c=2)),\n+        (\"+ccrcc\", NS(r=\"cc\", c=2)),\n     ]\n \n \n@@ -1007,115 +1071,123 @@ class Color(StrEnum):\n \n     def test_parse_enum_value(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('--color', choices=self.Color)\n-        args = parser.parse_args(['--color', 'red'])\n+        parser.add_argument(\"--color\", choices=self.Color)\n+        args = parser.parse_args([\"--color\", \"red\"])\n         self.assertEqual(args.color, self.Color.RED)\n \n     @force_not_colorized\n     def test_help_message_contains_enum_choices(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('--color', choices=self.Color, help='Choose a color')\n-        self.assertIn('[--color {red,green,blue}]', parser.format_usage())\n-        self.assertIn('  --color {red,green,blue}', parser.format_help())\n+        parser.add_argument(\n+            \"--color\", choices=self.Color, help=\"Choose a color\"\n+        )\n+        self.assertIn(\"[--color {red,green,blue}]\", parser.format_usage())\n+        self.assertIn(\"  --color {red,green,blue}\", parser.format_help())\n \n     def test_invalid_enum_value_raises_error(self):\n         parser = argparse.ArgumentParser(exit_on_error=False)\n-        parser.add_argument('--color', choices=self.Color)\n+        parser.add_argument(\"--color\", choices=self.Color)\n         self.assertRaisesRegex(\n             argparse.ArgumentError,\n             r\"invalid choice: 'yellow' \\(choose from red, green, blue\\)\",\n             parser.parse_args,\n-            ['--color', 'yellow'],\n+            [\"--color\", \"yellow\"],\n         )\n \n+\n # ================\n # Positional tests\n # ================\n \n+\n class TestPositionalsNargsNone(ParserTestCase):\n     \"\"\"Test a Positional that doesn't specify nargs\"\"\"\n \n-    argument_signatures = [Sig('foo')]\n-    failures = ['', '-x', 'a b']\n+    argument_signatures = [Sig(\"foo\")]\n+    failures = [\"\", \"-x\", \"a b\"]\n     successes = [\n-        ('a', NS(foo='a')),\n+        (\"a\", NS(foo=\"a\")),\n     ]\n \n \n class TestPositionalsNargs1(ParserTestCase):\n     \"\"\"Test a Positional that specifies an nargs of 1\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs=1)]\n-    failures = ['', '-x', 'a b']\n+    argument_signatures = [Sig(\"foo\", nargs=1)]\n+    failures = [\"\", \"-x\", \"a b\"]\n     successes = [\n-        ('a', NS(foo=['a'])),\n+        (\"a\", NS(foo=[\"a\"])),\n     ]\n \n \n class TestPositionalsNargs2(ParserTestCase):\n     \"\"\"Test a Positional that specifies an nargs of 2\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs=2)]\n-    failures = ['', 'a', '-x', 'a b c']\n+    argument_signatures = [Sig(\"foo\", nargs=2)]\n+    failures = [\"\", \"a\", \"-x\", \"a b c\"]\n     successes = [\n-        ('a b', NS(foo=['a', 'b'])),\n+        (\"a b\", NS(foo=[\"a\", \"b\"])),\n     ]\n \n \n class TestPositionalsNargsZeroOrMore(ParserTestCase):\n     \"\"\"Test a Positional that specifies unlimited nargs\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs='*')]\n-    failures = ['-x']\n+    argument_signatures = [Sig(\"foo\", nargs=\"*\")]\n+    failures = [\"-x\"]\n     successes = [\n-        ('', NS(foo=[])),\n-        ('a', NS(foo=['a'])),\n-        ('a b', NS(foo=['a', 'b'])),\n+        (\"\", NS(foo=[])),\n+        (\"a\", NS(foo=[\"a\"])),\n+        (\"a b\", NS(foo=[\"a\", \"b\"])),\n     ]\n \n \n class TestPositionalsNargsZeroOrMoreDefault(ParserTestCase):\n     \"\"\"Test a Positional that specifies unlimited nargs and a default\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs='*', default='bar', choices=['a', 'b'])]\n-    failures = ['-x', 'bar', 'a c']\n+    argument_signatures = [\n+        Sig(\"foo\", nargs=\"*\", default=\"bar\", choices=[\"a\", \"b\"])\n+    ]\n+    failures = [\"-x\", \"bar\", \"a c\"]\n     successes = [\n-        ('', NS(foo='bar')),\n-        ('a', NS(foo=['a'])),\n-        ('a b', NS(foo=['a', 'b'])),\n+        (\"\", NS(foo=\"bar\")),\n+        (\"a\", NS(foo=[\"a\"])),\n+        (\"a b\", NS(foo=[\"a\", \"b\"])),\n     ]\n \n \n class TestPositionalsNargsOneOrMore(ParserTestCase):\n     \"\"\"Test a Positional that specifies one or more nargs\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs='+')]\n-    failures = ['', '-x']\n+    argument_signatures = [Sig(\"foo\", nargs=\"+\")]\n+    failures = [\"\", \"-x\"]\n     successes = [\n-        ('a', NS(foo=['a'])),\n-        ('a b', NS(foo=['a', 'b'])),\n+        (\"a\", NS(foo=[\"a\"])),\n+        (\"a b\", NS(foo=[\"a\", \"b\"])),\n     ]\n \n \n class TestPositionalsNargsOptional(ParserTestCase):\n     \"\"\"Tests an Optional Positional\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs='?')]\n-    failures = ['-x', 'a b']\n+    argument_signatures = [Sig(\"foo\", nargs=\"?\")]\n+    failures = [\"-x\", \"a b\"]\n     successes = [\n-        ('', NS(foo=None)),\n-        ('a', NS(foo='a')),\n+        (\"\", NS(foo=None)),\n+        (\"a\", NS(foo=\"a\")),\n     ]\n \n \n class TestPositionalsNargsOptionalDefault(ParserTestCase):\n     \"\"\"Tests an Optional Positional with a default value\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs='?', default=42, choices=['a', 'b'])]\n-    failures = ['-x', 'a b', '42']\n+    argument_signatures = [\n+        Sig(\"foo\", nargs=\"?\", default=42, choices=[\"a\", \"b\"])\n+    ]\n+    failures = [\"-x\", \"a b\", \"42\"]\n     successes = [\n-        ('', NS(foo=42)),\n-        ('a', NS(foo='a')),\n+        (\"\", NS(foo=42)),\n+        (\"a\", NS(foo=\"a\")),\n     ]\n \n \n@@ -1125,206 +1197,209 @@ class TestPositionalsNargsOptionalConvertedDefault(ParserTestCase):\n     \"\"\"\n \n     argument_signatures = [\n-        Sig('foo', nargs='?', type=int, default='42', choices=[1, 2]),\n+        Sig(\"foo\", nargs=\"?\", type=int, default=\"42\", choices=[1, 2]),\n     ]\n-    failures = ['-x', 'a b', '1 2', '42']\n+    failures = [\"-x\", \"a b\", \"1 2\", \"42\"]\n     successes = [\n-        ('', NS(foo=42)),\n-        ('1', NS(foo=1)),\n+        (\"\", NS(foo=42)),\n+        (\"1\", NS(foo=1)),\n     ]\n \n \n class TestPositionalsNargsNoneNone(ParserTestCase):\n     \"\"\"Test two Positionals that don't specify nargs\"\"\"\n \n-    argument_signatures = [Sig('foo'), Sig('bar')]\n-    failures = ['', '-x', 'a', 'a b c']\n+    argument_signatures = [Sig(\"foo\"), Sig(\"bar\")]\n+    failures = [\"\", \"-x\", \"a\", \"a b c\"]\n     successes = [\n-        ('a b', NS(foo='a', bar='b')),\n+        (\"a b\", NS(foo=\"a\", bar=\"b\")),\n     ]\n \n \n class TestPositionalsNargsNone1(ParserTestCase):\n     \"\"\"Test a Positional with no nargs followed by one with 1\"\"\"\n \n-    argument_signatures = [Sig('foo'), Sig('bar', nargs=1)]\n-    failures = ['', '--foo', 'a', 'a b c']\n+    argument_signatures = [Sig(\"foo\"), Sig(\"bar\", nargs=1)]\n+    failures = [\"\", \"--foo\", \"a\", \"a b c\"]\n     successes = [\n-        ('a b', NS(foo='a', bar=['b'])),\n+        (\"a b\", NS(foo=\"a\", bar=[\"b\"])),\n     ]\n \n \n class TestPositionalsNargs2None(ParserTestCase):\n     \"\"\"Test a Positional with 2 nargs followed by one with none\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs=2), Sig('bar')]\n-    failures = ['', '--foo', 'a', 'a b', 'a b c d']\n+    argument_signatures = [Sig(\"foo\", nargs=2), Sig(\"bar\")]\n+    failures = [\"\", \"--foo\", \"a\", \"a b\", \"a b c d\"]\n     successes = [\n-        ('a b c', NS(foo=['a', 'b'], bar='c')),\n+        (\"a b c\", NS(foo=[\"a\", \"b\"], bar=\"c\")),\n     ]\n \n \n class TestPositionalsNargsNoneZeroOrMore(ParserTestCase):\n     \"\"\"Test a Positional with no nargs followed by one with unlimited\"\"\"\n \n-    argument_signatures = [Sig('-x'), Sig('foo'), Sig('bar', nargs='*')]\n-    failures = ['', '--foo', 'a b -x X c']\n+    argument_signatures = [Sig(\"-x\"), Sig(\"foo\"), Sig(\"bar\", nargs=\"*\")]\n+    failures = [\"\", \"--foo\", \"a b -x X c\"]\n     successes = [\n-        ('a', NS(x=None, foo='a', bar=[])),\n-        ('a b', NS(x=None, foo='a', bar=['b'])),\n-        ('a b c', NS(x=None, foo='a', bar=['b', 'c'])),\n-        ('-x X a', NS(x='X', foo='a', bar=[])),\n-        ('a -x X', NS(x='X', foo='a', bar=[])),\n-        ('-x X a b', NS(x='X', foo='a', bar=['b'])),\n-        ('a -x X b', NS(x='X', foo='a', bar=['b'])),\n-        ('a b -x X', NS(x='X', foo='a', bar=['b'])),\n-        ('-x X a b c', NS(x='X', foo='a', bar=['b', 'c'])),\n-        ('a -x X b c', NS(x='X', foo='a', bar=['b', 'c'])),\n-        ('a b c -x X', NS(x='X', foo='a', bar=['b', 'c'])),\n+        (\"a\", NS(x=None, foo=\"a\", bar=[])),\n+        (\"a b\", NS(x=None, foo=\"a\", bar=[\"b\"])),\n+        (\"a b c\", NS(x=None, foo=\"a\", bar=[\"b\", \"c\"])),\n+        (\"-x X a\", NS(x=\"X\", foo=\"a\", bar=[])),\n+        (\"a -x X\", NS(x=\"X\", foo=\"a\", bar=[])),\n+        (\"-x X a b\", NS(x=\"X\", foo=\"a\", bar=[\"b\"])),\n+        (\"a -x X b\", NS(x=\"X\", foo=\"a\", bar=[\"b\"])),\n+        (\"a b -x X\", NS(x=\"X\", foo=\"a\", bar=[\"b\"])),\n+        (\"-x X a b c\", NS(x=\"X\", foo=\"a\", bar=[\"b\", \"c\"])),\n+        (\"a -x X b c\", NS(x=\"X\", foo=\"a\", bar=[\"b\", \"c\"])),\n+        (\"a b c -x X\", NS(x=\"X\", foo=\"a\", bar=[\"b\", \"c\"])),\n     ]\n \n \n class TestPositionalsNargsNoneOneOrMore(ParserTestCase):\n     \"\"\"Test a Positional with no nargs followed by one with one or more\"\"\"\n \n-    argument_signatures = [Sig('-x'), Sig('foo'), Sig('bar', nargs='+')]\n-    failures = ['', '--foo', 'a', 'a b -x X c']\n+    argument_signatures = [Sig(\"-x\"), Sig(\"foo\"), Sig(\"bar\", nargs=\"+\")]\n+    failures = [\"\", \"--foo\", \"a\", \"a b -x X c\"]\n     successes = [\n-        ('a b', NS(x=None, foo='a', bar=['b'])),\n-        ('a b c', NS(x=None, foo='a', bar=['b', 'c'])),\n-        ('-x X a b', NS(x='X', foo='a', bar=['b'])),\n-        ('a -x X b', NS(x='X', foo='a', bar=['b'])),\n-        ('a b -x X', NS(x='X', foo='a', bar=['b'])),\n-        ('-x X a b c', NS(x='X', foo='a', bar=['b', 'c'])),\n-        ('a -x X b c', NS(x='X', foo='a', bar=['b', 'c'])),\n-        ('a b c -x X', NS(x='X', foo='a', bar=['b', 'c'])),\n+        (\"a b\", NS(x=None, foo=\"a\", bar=[\"b\"])),\n+        (\"a b c\", NS(x=None, foo=\"a\", bar=[\"b\", \"c\"])),\n+        (\"-x X a b\", NS(x=\"X\", foo=\"a\", bar=[\"b\"])),\n+        (\"a -x X b\", NS(x=\"X\", foo=\"a\", bar=[\"b\"])),\n+        (\"a b -x X\", NS(x=\"X\", foo=\"a\", bar=[\"b\"])),\n+        (\"-x X a b c\", NS(x=\"X\", foo=\"a\", bar=[\"b\", \"c\"])),\n+        (\"a -x X b c\", NS(x=\"X\", foo=\"a\", bar=[\"b\", \"c\"])),\n+        (\"a b c -x X\", NS(x=\"X\", foo=\"a\", bar=[\"b\", \"c\"])),\n     ]\n \n \n class TestPositionalsNargsNoneOptional(ParserTestCase):\n     \"\"\"Test a Positional with no nargs followed by one with an Optional\"\"\"\n \n-    argument_signatures = [Sig('-x'), Sig('foo'), Sig('bar', nargs='?')]\n-    failures = ['', '--foo', 'a b c']\n+    argument_signatures = [Sig(\"-x\"), Sig(\"foo\"), Sig(\"bar\", nargs=\"?\")]\n+    failures = [\"\", \"--foo\", \"a b c\"]\n     successes = [\n-        ('a', NS(x=None, foo='a', bar=None)),\n-        ('a b', NS(x=None, foo='a', bar='b')),\n-        ('-x X a', NS(x='X', foo='a', bar=None)),\n-        ('a -x X', NS(x='X', foo='a', bar=None)),\n-        ('-x X a b', NS(x='X', foo='a', bar='b')),\n-        ('a -x X b', NS(x='X', foo='a', bar='b')),\n-        ('a b -x X', NS(x='X', foo='a', bar='b')),\n+        (\"a\", NS(x=None, foo=\"a\", bar=None)),\n+        (\"a b\", NS(x=None, foo=\"a\", bar=\"b\")),\n+        (\"-x X a\", NS(x=\"X\", foo=\"a\", bar=None)),\n+        (\"a -x X\", NS(x=\"X\", foo=\"a\", bar=None)),\n+        (\"-x X a b\", NS(x=\"X\", foo=\"a\", bar=\"b\")),\n+        (\"a -x X b\", NS(x=\"X\", foo=\"a\", bar=\"b\")),\n+        (\"a b -x X\", NS(x=\"X\", foo=\"a\", bar=\"b\")),\n     ]\n \n \n class TestPositionalsNargsZeroOrMoreNone(ParserTestCase):\n     \"\"\"Test a Positional with unlimited nargs followed by one with none\"\"\"\n \n-    argument_signatures = [Sig('-x'), Sig('foo', nargs='*'), Sig('bar')]\n-    failures = ['', '--foo', 'a -x X b', 'a -x X b c', 'a b -x X c']\n+    argument_signatures = [Sig(\"-x\"), Sig(\"foo\", nargs=\"*\"), Sig(\"bar\")]\n+    failures = [\"\", \"--foo\", \"a -x X b\", \"a -x X b c\", \"a b -x X c\"]\n     successes = [\n-        ('a', NS(x=None, foo=[], bar='a')),\n-        ('a b', NS(x=None, foo=['a'], bar='b')),\n-        ('a b c', NS(x=None, foo=['a', 'b'], bar='c')),\n-        ('-x X a', NS(x='X', foo=[], bar='a')),\n-        ('a -x X', NS(x='X', foo=[], bar='a')),\n-        ('-x X a b', NS(x='X', foo=['a'], bar='b')),\n-        ('a b -x X', NS(x='X', foo=['a'], bar='b')),\n-        ('-x X a b c', NS(x='X', foo=['a', 'b'], bar='c')),\n-        ('a b c -x X', NS(x='X', foo=['a', 'b'], bar='c')),\n+        (\"a\", NS(x=None, foo=[], bar=\"a\")),\n+        (\"a b\", NS(x=None, foo=[\"a\"], bar=\"b\")),\n+        (\"a b c\", NS(x=None, foo=[\"a\", \"b\"], bar=\"c\")),\n+        (\"-x X a\", NS(x=\"X\", foo=[], bar=\"a\")),\n+        (\"a -x X\", NS(x=\"X\", foo=[], bar=\"a\")),\n+        (\"-x X a b\", NS(x=\"X\", foo=[\"a\"], bar=\"b\")),\n+        (\"a b -x X\", NS(x=\"X\", foo=[\"a\"], bar=\"b\")),\n+        (\"-x X a b c\", NS(x=\"X\", foo=[\"a\", \"b\"], bar=\"c\")),\n+        (\"a b c -x X\", NS(x=\"X\", foo=[\"a\", \"b\"], bar=\"c\")),\n     ]\n \n \n class TestPositionalsNargsOneOrMoreNone(ParserTestCase):\n     \"\"\"Test a Positional with one or more nargs followed by one with none\"\"\"\n \n-    argument_signatures = [Sig('-x'), Sig('foo', nargs='+'), Sig('bar')]\n-    failures = ['', '--foo', 'a', 'a -x X b c', 'a b -x X c']\n+    argument_signatures = [Sig(\"-x\"), Sig(\"foo\", nargs=\"+\"), Sig(\"bar\")]\n+    failures = [\"\", \"--foo\", \"a\", \"a -x X b c\", \"a b -x X c\"]\n     successes = [\n-        ('a b', NS(x=None, foo=['a'], bar='b')),\n-        ('a b c', NS(x=None, foo=['a', 'b'], bar='c')),\n-        ('-x X a b', NS(x='X', foo=['a'], bar='b')),\n-        ('a -x X b', NS(x='X', foo=['a'], bar='b')),\n-        ('a b -x X', NS(x='X', foo=['a'], bar='b')),\n-        ('-x X a b c', NS(x='X', foo=['a', 'b'], bar='c')),\n-        ('a b c -x X', NS(x='X', foo=['a', 'b'], bar='c')),\n+        (\"a b\", NS(x=None, foo=[\"a\"], bar=\"b\")),\n+        (\"a b c\", NS(x=None, foo=[\"a\", \"b\"], bar=\"c\")),\n+        (\"-x X a b\", NS(x=\"X\", foo=[\"a\"], bar=\"b\")),\n+        (\"a -x X b\", NS(x=\"X\", foo=[\"a\"], bar=\"b\")),\n+        (\"a b -x X\", NS(x=\"X\", foo=[\"a\"], bar=\"b\")),\n+        (\"-x X a b c\", NS(x=\"X\", foo=[\"a\", \"b\"], bar=\"c\")),\n+        (\"a b c -x X\", NS(x=\"X\", foo=[\"a\", \"b\"], bar=\"c\")),\n     ]\n \n \n class TestPositionalsNargsOptionalNone(ParserTestCase):\n     \"\"\"Test a Positional with an Optional nargs followed by one with none\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs='?', default=42), Sig('bar')]\n-    failures = ['', '--foo', 'a b c']\n+    argument_signatures = [Sig(\"foo\", nargs=\"?\", default=42), Sig(\"bar\")]\n+    failures = [\"\", \"--foo\", \"a b c\"]\n     successes = [\n-        ('a', NS(foo=42, bar='a')),\n-        ('a b', NS(foo='a', bar='b')),\n+        (\"a\", NS(foo=42, bar=\"a\")),\n+        (\"a b\", NS(foo=\"a\", bar=\"b\")),\n     ]\n \n \n class TestPositionalsNargs2ZeroOrMore(ParserTestCase):\n     \"\"\"Test a Positional with 2 nargs followed by one with unlimited\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs=2), Sig('bar', nargs='*')]\n-    failures = ['', '--foo', 'a']\n+    argument_signatures = [Sig(\"foo\", nargs=2), Sig(\"bar\", nargs=\"*\")]\n+    failures = [\"\", \"--foo\", \"a\"]\n     successes = [\n-        ('a b', NS(foo=['a', 'b'], bar=[])),\n-        ('a b c', NS(foo=['a', 'b'], bar=['c'])),\n+        (\"a b\", NS(foo=[\"a\", \"b\"], bar=[])),\n+        (\"a b c\", NS(foo=[\"a\", \"b\"], bar=[\"c\"])),\n     ]\n \n \n class TestPositionalsNargs2OneOrMore(ParserTestCase):\n     \"\"\"Test a Positional with 2 nargs followed by one with one or more\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs=2), Sig('bar', nargs='+')]\n-    failures = ['', '--foo', 'a', 'a b']\n+    argument_signatures = [Sig(\"foo\", nargs=2), Sig(\"bar\", nargs=\"+\")]\n+    failures = [\"\", \"--foo\", \"a\", \"a b\"]\n     successes = [\n-        ('a b c', NS(foo=['a', 'b'], bar=['c'])),\n+        (\"a b c\", NS(foo=[\"a\", \"b\"], bar=[\"c\"])),\n     ]\n \n \n class TestPositionalsNargs2Optional(ParserTestCase):\n     \"\"\"Test a Positional with 2 nargs followed by one optional\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs=2), Sig('bar', nargs='?')]\n-    failures = ['', '--foo', 'a', 'a b c d']\n+    argument_signatures = [Sig(\"foo\", nargs=2), Sig(\"bar\", nargs=\"?\")]\n+    failures = [\"\", \"--foo\", \"a\", \"a b c d\"]\n     successes = [\n-        ('a b', NS(foo=['a', 'b'], bar=None)),\n-        ('a b c', NS(foo=['a', 'b'], bar='c')),\n+        (\"a b\", NS(foo=[\"a\", \"b\"], bar=None)),\n+        (\"a b c\", NS(foo=[\"a\", \"b\"], bar=\"c\")),\n     ]\n \n \n class TestPositionalsNargsZeroOrMore1(ParserTestCase):\n     \"\"\"Test a Positional with unlimited nargs followed by one with 1\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs='*'), Sig('bar', nargs=1)]\n-    failures = ['', '--foo', ]\n+    argument_signatures = [Sig(\"foo\", nargs=\"*\"), Sig(\"bar\", nargs=1)]\n+    failures = [\n+        \"\",\n+        \"--foo\",\n+    ]\n     successes = [\n-        ('a', NS(foo=[], bar=['a'])),\n-        ('a b', NS(foo=['a'], bar=['b'])),\n-        ('a b c', NS(foo=['a', 'b'], bar=['c'])),\n+        (\"a\", NS(foo=[], bar=[\"a\"])),\n+        (\"a b\", NS(foo=[\"a\"], bar=[\"b\"])),\n+        (\"a b c\", NS(foo=[\"a\", \"b\"], bar=[\"c\"])),\n     ]\n \n \n class TestPositionalsNargsOneOrMore1(ParserTestCase):\n     \"\"\"Test a Positional with one or more nargs followed by one with 1\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs='+'), Sig('bar', nargs=1)]\n-    failures = ['', '--foo', 'a']\n+    argument_signatures = [Sig(\"foo\", nargs=\"+\"), Sig(\"bar\", nargs=1)]\n+    failures = [\"\", \"--foo\", \"a\"]\n     successes = [\n-        ('a b', NS(foo=['a'], bar=['b'])),\n-        ('a b c', NS(foo=['a', 'b'], bar=['c'])),\n+        (\"a b\", NS(foo=[\"a\"], bar=[\"b\"])),\n+        (\"a b c\", NS(foo=[\"a\", \"b\"], bar=[\"c\"])),\n     ]\n \n \n class TestPositionalsNargsOptional1(ParserTestCase):\n     \"\"\"Test a Positional with an Optional nargs followed by one with 1\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs='?'), Sig('bar', nargs=1)]\n-    failures = ['', '--foo', 'a b c']\n+    argument_signatures = [Sig(\"foo\", nargs=\"?\"), Sig(\"bar\", nargs=1)]\n+    failures = [\"\", \"--foo\", \"a b c\"]\n     successes = [\n-        ('a', NS(foo=None, bar=['a'])),\n-        ('a b', NS(foo='a', bar=['b'])),\n+        (\"a\", NS(foo=None, bar=[\"a\"])),\n+        (\"a b\", NS(foo=\"a\", bar=[\"b\"])),\n     ]\n \n \n@@ -1332,21 +1407,21 @@ class TestPositionalsNargsNoneZeroOrMore1(ParserTestCase):\n     \"\"\"Test three Positionals: no nargs, unlimited nargs and 1 nargs\"\"\"\n \n     argument_signatures = [\n-        Sig('-x'),\n-        Sig('foo'),\n-        Sig('bar', nargs='*'),\n-        Sig('baz', nargs=1),\n+        Sig(\"-x\"),\n+        Sig(\"foo\"),\n+        Sig(\"bar\", nargs=\"*\"),\n+        Sig(\"baz\", nargs=1),\n     ]\n-    failures = ['', '--foo', 'a', 'a b -x X c']\n+    failures = [\"\", \"--foo\", \"a\", \"a b -x X c\"]\n     successes = [\n-        ('a b', NS(x=None, foo='a', bar=[], baz=['b'])),\n-        ('a b c', NS(x=None, foo='a', bar=['b'], baz=['c'])),\n-        ('-x X a b', NS(x='X', foo='a', bar=[], baz=['b'])),\n-        ('a -x X b', NS(x='X', foo='a', bar=[], baz=['b'])),\n-        ('a b -x X', NS(x='X', foo='a', bar=[], baz=['b'])),\n-        ('-x X a b c', NS(x='X', foo='a', bar=['b'], baz=['c'])),\n-        ('a -x X b c', NS(x='X', foo='a', bar=['b'], baz=['c'])),\n-        ('a b c -x X', NS(x='X', foo='a', bar=['b'], baz=['c'])),\n+        (\"a b\", NS(x=None, foo=\"a\", bar=[], baz=[\"b\"])),\n+        (\"a b c\", NS(x=None, foo=\"a\", bar=[\"b\"], baz=[\"c\"])),\n+        (\"-x X a b\", NS(x=\"X\", foo=\"a\", bar=[], baz=[\"b\"])),\n+        (\"a -x X b\", NS(x=\"X\", foo=\"a\", bar=[], baz=[\"b\"])),\n+        (\"a b -x X\", NS(x=\"X\", foo=\"a\", bar=[], baz=[\"b\"])),\n+        (\"-x X a b c\", NS(x=\"X\", foo=\"a\", bar=[\"b\"], baz=[\"c\"])),\n+        (\"a -x X b c\", NS(x=\"X\", foo=\"a\", bar=[\"b\"], baz=[\"c\"])),\n+        (\"a b c -x X\", NS(x=\"X\", foo=\"a\", bar=[\"b\"], baz=[\"c\"])),\n     ]\n \n \n@@ -1354,22 +1429,22 @@ class TestPositionalsNargsNoneOneOrMore1(ParserTestCase):\n     \"\"\"Test three Positionals: no nargs, one or more nargs and 1 nargs\"\"\"\n \n     argument_signatures = [\n-        Sig('-x'),\n-        Sig('foo'),\n-        Sig('bar', nargs='+'),\n-        Sig('baz', nargs=1),\n+        Sig(\"-x\"),\n+        Sig(\"foo\"),\n+        Sig(\"bar\", nargs=\"+\"),\n+        Sig(\"baz\", nargs=1),\n     ]\n-    failures = ['', '--foo', 'a', 'b', 'a b -x X c d', 'a b c -x X d']\n+    failures = [\"\", \"--foo\", \"a\", \"b\", \"a b -x X c d\", \"a b c -x X d\"]\n     successes = [\n-        ('a b c', NS(x=None, foo='a', bar=['b'], baz=['c'])),\n-        ('a b c d', NS(x=None, foo='a', bar=['b', 'c'], baz=['d'])),\n-        ('-x X a b c', NS(x='X', foo='a', bar=['b'], baz=['c'])),\n-        ('a -x X b c', NS(x='X', foo='a', bar=['b'], baz=['c'])),\n-        ('a b -x X c', NS(x='X', foo='a', bar=['b'], baz=['c'])),\n-        ('a b c -x X', NS(x='X', foo='a', bar=['b'], baz=['c'])),\n-        ('-x X a b c d', NS(x='X', foo='a', bar=['b', 'c'], baz=['d'])),\n-        ('a -x X b c d', NS(x='X', foo='a', bar=['b', 'c'], baz=['d'])),\n-        ('a b c d -x X', NS(x='X', foo='a', bar=['b', 'c'], baz=['d'])),\n+        (\"a b c\", NS(x=None, foo=\"a\", bar=[\"b\"], baz=[\"c\"])),\n+        (\"a b c d\", NS(x=None, foo=\"a\", bar=[\"b\", \"c\"], baz=[\"d\"])),\n+        (\"-x X a b c\", NS(x=\"X\", foo=\"a\", bar=[\"b\"], baz=[\"c\"])),\n+        (\"a -x X b c\", NS(x=\"X\", foo=\"a\", bar=[\"b\"], baz=[\"c\"])),\n+        (\"a b -x X c\", NS(x=\"X\", foo=\"a\", bar=[\"b\"], baz=[\"c\"])),\n+        (\"a b c -x X\", NS(x=\"X\", foo=\"a\", bar=[\"b\"], baz=[\"c\"])),\n+        (\"-x X a b c d\", NS(x=\"X\", foo=\"a\", bar=[\"b\", \"c\"], baz=[\"d\"])),\n+        (\"a -x X b c d\", NS(x=\"X\", foo=\"a\", bar=[\"b\", \"c\"], baz=[\"d\"])),\n+        (\"a b c d -x X\", NS(x=\"X\", foo=\"a\", bar=[\"b\", \"c\"], baz=[\"d\"])),\n     ]\n \n \n@@ -1377,21 +1452,21 @@ class TestPositionalsNargsNoneOptional1(ParserTestCase):\n     \"\"\"Test three Positionals: no nargs, optional narg and 1 nargs\"\"\"\n \n     argument_signatures = [\n-        Sig('-x'),\n-        Sig('foo'),\n-        Sig('bar', nargs='?', default=0.625),\n-        Sig('baz', nargs=1),\n+        Sig(\"-x\"),\n+        Sig(\"foo\"),\n+        Sig(\"bar\", nargs=\"?\", default=0.625),\n+        Sig(\"baz\", nargs=1),\n     ]\n-    failures = ['', '--foo', 'a', 'a b -x X c']\n+    failures = [\"\", \"--foo\", \"a\", \"a b -x X c\"]\n     successes = [\n-        ('a b', NS(x=None, foo='a', bar=0.625, baz=['b'])),\n-        ('a b c', NS(x=None, foo='a', bar='b', baz=['c'])),\n-        ('-x X a b', NS(x='X', foo='a', bar=0.625, baz=['b'])),\n-        ('a -x X b', NS(x='X', foo='a', bar=0.625, baz=['b'])),\n-        ('a b -x X', NS(x='X', foo='a', bar=0.625, baz=['b'])),\n-        ('-x X a b c', NS(x='X', foo='a', bar='b', baz=['c'])),\n-        ('a -x X b c', NS(x='X', foo='a', bar='b', baz=['c'])),\n-        ('a b c -x X', NS(x='X', foo='a', bar='b', baz=['c'])),\n+        (\"a b\", NS(x=None, foo=\"a\", bar=0.625, baz=[\"b\"])),\n+        (\"a b c\", NS(x=None, foo=\"a\", bar=\"b\", baz=[\"c\"])),\n+        (\"-x X a b\", NS(x=\"X\", foo=\"a\", bar=0.625, baz=[\"b\"])),\n+        (\"a -x X b\", NS(x=\"X\", foo=\"a\", bar=0.625, baz=[\"b\"])),\n+        (\"a b -x X\", NS(x=\"X\", foo=\"a\", bar=0.625, baz=[\"b\"])),\n+        (\"-x X a b c\", NS(x=\"X\", foo=\"a\", bar=\"b\", baz=[\"c\"])),\n+        (\"a -x X b c\", NS(x=\"X\", foo=\"a\", bar=\"b\", baz=[\"c\"])),\n+        (\"a b c -x X\", NS(x=\"X\", foo=\"a\", bar=\"b\", baz=[\"c\"])),\n     ]\n \n \n@@ -1399,61 +1474,61 @@ class TestPositionalsNargsOptionalOptional(ParserTestCase):\n     \"\"\"Test two optional nargs\"\"\"\n \n     argument_signatures = [\n-        Sig('foo', nargs='?'),\n-        Sig('bar', nargs='?', default=42),\n+        Sig(\"foo\", nargs=\"?\"),\n+        Sig(\"bar\", nargs=\"?\", default=42),\n     ]\n-    failures = ['--foo', 'a b c']\n+    failures = [\"--foo\", \"a b c\"]\n     successes = [\n-        ('', NS(foo=None, bar=42)),\n-        ('a', NS(foo='a', bar=42)),\n-        ('a b', NS(foo='a', bar='b')),\n+        (\"\", NS(foo=None, bar=42)),\n+        (\"a\", NS(foo=\"a\", bar=42)),\n+        (\"a b\", NS(foo=\"a\", bar=\"b\")),\n     ]\n \n \n class TestPositionalsNargsOptionalZeroOrMore(ParserTestCase):\n     \"\"\"Test an Optional narg followed by unlimited nargs\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs='?'), Sig('bar', nargs='*')]\n-    failures = ['--foo']\n+    argument_signatures = [Sig(\"foo\", nargs=\"?\"), Sig(\"bar\", nargs=\"*\")]\n+    failures = [\"--foo\"]\n     successes = [\n-        ('', NS(foo=None, bar=[])),\n-        ('a', NS(foo='a', bar=[])),\n-        ('a b', NS(foo='a', bar=['b'])),\n-        ('a b c', NS(foo='a', bar=['b', 'c'])),\n+        (\"\", NS(foo=None, bar=[])),\n+        (\"a\", NS(foo=\"a\", bar=[])),\n+        (\"a b\", NS(foo=\"a\", bar=[\"b\"])),\n+        (\"a b c\", NS(foo=\"a\", bar=[\"b\", \"c\"])),\n     ]\n \n \n class TestPositionalsNargsOptionalOneOrMore(ParserTestCase):\n     \"\"\"Test an Optional narg followed by one or more nargs\"\"\"\n \n-    argument_signatures = [Sig('foo', nargs='?'), Sig('bar', nargs='+')]\n-    failures = ['', '--foo']\n+    argument_signatures = [Sig(\"foo\", nargs=\"?\"), Sig(\"bar\", nargs=\"+\")]\n+    failures = [\"\", \"--foo\"]\n     successes = [\n-        ('a', NS(foo=None, bar=['a'])),\n-        ('a b', NS(foo='a', bar=['b'])),\n-        ('a b c', NS(foo='a', bar=['b', 'c'])),\n+        (\"a\", NS(foo=None, bar=[\"a\"])),\n+        (\"a b\", NS(foo=\"a\", bar=[\"b\"])),\n+        (\"a b c\", NS(foo=\"a\", bar=[\"b\", \"c\"])),\n     ]\n \n \n class TestPositionalsChoicesString(ParserTestCase):\n     \"\"\"Test a set of single-character choices\"\"\"\n \n-    argument_signatures = [Sig('spam', choices=set('abcdefg'))]\n-    failures = ['', '--foo', 'h', '42', 'ef']\n+    argument_signatures = [Sig(\"spam\", choices=set(\"abcdefg\"))]\n+    failures = [\"\", \"--foo\", \"h\", \"42\", \"ef\"]\n     successes = [\n-        ('a', NS(spam='a')),\n-        ('g', NS(spam='g')),\n+        (\"a\", NS(spam=\"a\")),\n+        (\"g\", NS(spam=\"g\")),\n     ]\n \n \n class TestPositionalsChoicesInt(ParserTestCase):\n     \"\"\"Test a set of integer choices\"\"\"\n \n-    argument_signatures = [Sig('spam', type=int, choices=range(20))]\n-    failures = ['', '--foo', 'h', '42', 'ef']\n+    argument_signatures = [Sig(\"spam\", type=int, choices=range(20))]\n+    failures = [\"\", \"--foo\", \"h\", \"42\", \"ef\"]\n     successes = [\n-        ('4', NS(spam=4)),\n-        ('15', NS(spam=15)),\n+        (\"4\", NS(spam=4)),\n+        (\"15\", NS(spam=15)),\n     ]\n \n \n@@ -1461,12 +1536,12 @@ class TestPositionalsActionAppend(ParserTestCase):\n     \"\"\"Test the 'append' action\"\"\"\n \n     argument_signatures = [\n-        Sig('spam', action='append'),\n-        Sig('spam', action='append', nargs=2),\n+        Sig(\"spam\", action=\"append\"),\n+        Sig(\"spam\", action=\"append\", nargs=2),\n     ]\n-    failures = ['', '--foo', 'a', 'a b', 'a b c d']\n+    failures = [\"\", \"--foo\", \"a\", \"a b\", \"a b c d\"]\n     successes = [\n-        ('a b c', NS(spam=['a', ['b', 'c']])),\n+        (\"a b c\", NS(spam=[\"a\", [\"b\", \"c\"]])),\n     ]\n \n \n@@ -1474,31 +1549,33 @@ class TestPositionalsActionExtend(ParserTestCase):\n     \"\"\"Test the 'extend' action\"\"\"\n \n     argument_signatures = [\n-        Sig('spam', action='extend'),\n-        Sig('spam', action='extend', nargs=2),\n+        Sig(\"spam\", action=\"extend\"),\n+        Sig(\"spam\", action=\"extend\", nargs=2),\n     ]\n-    failures = ['', '--foo', 'a', 'a b', 'a b c d']\n+    failures = [\"\", \"--foo\", \"a\", \"a b\", \"a b c d\"]\n     successes = [\n-        ('a b c', NS(spam=['a', 'b', 'c'])),\n+        (\"a b c\", NS(spam=[\"a\", \"b\", \"c\"])),\n     ]\n \n+\n # ========================================\n # Combined optionals and positionals tests\n # ========================================\n \n+\n class TestOptionalsNumericAndPositionals(ParserTestCase):\n     \"\"\"Tests negative number args when numeric options are present\"\"\"\n \n     argument_signatures = [\n-        Sig('x', nargs='?'),\n-        Sig('-4', dest='y', action='store_true'),\n+        Sig(\"x\", nargs=\"?\"),\n+        Sig(\"-4\", dest=\"y\", action=\"store_true\"),\n     ]\n-    failures = ['-2', '-315']\n+    failures = [\"-2\", \"-315\"]\n     successes = [\n-        ('', NS(x=None, y=False)),\n-        ('a', NS(x='a', y=False)),\n-        ('-4', NS(x=None, y=True)),\n-        ('-4 a', NS(x='a', y=True)),\n+        (\"\", NS(x=None, y=False)),\n+        (\"a\", NS(x=\"a\", y=False)),\n+        (\"-4\", NS(x=None, y=True)),\n+        (\"-4 a\", NS(x=\"a\", y=True)),\n     ]\n \n \n@@ -1506,112 +1583,110 @@ class TestOptionalsAlmostNumericAndPositionals(ParserTestCase):\n     \"\"\"Tests negative number args when almost numeric options are present\"\"\"\n \n     argument_signatures = [\n-        Sig('x', nargs='?'),\n-        Sig('-k4', dest='y', action='store_true'),\n+        Sig(\"x\", nargs=\"?\"),\n+        Sig(\"-k4\", dest=\"y\", action=\"store_true\"),\n     ]\n-    failures = ['-k3']\n+    failures = [\"-k3\"]\n     successes = [\n-        ('', NS(x=None, y=False)),\n-        ('-2', NS(x='-2', y=False)),\n-        ('a', NS(x='a', y=False)),\n-        ('-k4', NS(x=None, y=True)),\n-        ('-k4 a', NS(x='a', y=True)),\n+        (\"\", NS(x=None, y=False)),\n+        (\"-2\", NS(x=\"-2\", y=False)),\n+        (\"a\", NS(x=\"a\", y=False)),\n+        (\"-k4\", NS(x=None, y=True)),\n+        (\"-k4 a\", NS(x=\"a\", y=True)),\n     ]\n \n \n class TestOptionalsAndPositionalsAppend(ParserTestCase):\n     argument_signatures = [\n-        Sig('foo', nargs='*', action='append'),\n-        Sig('--bar'),\n+        Sig(\"foo\", nargs=\"*\", action=\"append\"),\n+        Sig(\"--bar\"),\n     ]\n-    failures = ['-foo']\n+    failures = [\"-foo\"]\n     successes = [\n-        ('a b', NS(foo=[['a', 'b']], bar=None)),\n-        ('--bar a b', NS(foo=[['b']], bar='a')),\n-        ('a b --bar c', NS(foo=[['a', 'b']], bar='c')),\n+        (\"a b\", NS(foo=[[\"a\", \"b\"]], bar=None)),\n+        (\"--bar a b\", NS(foo=[[\"b\"]], bar=\"a\")),\n+        (\"a b --bar c\", NS(foo=[[\"a\", \"b\"]], bar=\"c\")),\n     ]\n \n \n class TestOptionalsAndPositionalsExtend(ParserTestCase):\n     argument_signatures = [\n-        Sig('foo', nargs='*', action='extend'),\n-        Sig('--bar'),\n+        Sig(\"foo\", nargs=\"*\", action=\"extend\"),\n+        Sig(\"--bar\"),\n     ]\n-    failures = ['-foo']\n+    failures = [\"-foo\"]\n     successes = [\n-        ('a b', NS(foo=['a', 'b'], bar=None)),\n-        ('--bar a b', NS(foo=['b'], bar='a')),\n-        ('a b --bar c', NS(foo=['a', 'b'], bar='c')),\n+        (\"a b\", NS(foo=[\"a\", \"b\"], bar=None)),\n+        (\"--bar a b\", NS(foo=[\"b\"], bar=\"a\")),\n+        (\"a b --bar c\", NS(foo=[\"a\", \"b\"], bar=\"c\")),\n     ]\n \n \n class TestEmptyAndSpaceContainingArguments(ParserTestCase):\n-\n     argument_signatures = [\n-        Sig('x', nargs='?'),\n-        Sig('-y', '--yyy', dest='y'),\n+        Sig(\"x\", nargs=\"?\"),\n+        Sig(\"-y\", \"--yyy\", dest=\"y\"),\n     ]\n-    failures = ['-y']\n+    failures = [\"-y\"]\n     successes = [\n-        ([''], NS(x='', y=None)),\n-        (['a badger'], NS(x='a badger', y=None)),\n-        (['-a badger'], NS(x='-a badger', y=None)),\n-        (['-y', ''], NS(x=None, y='')),\n-        (['-y', 'a badger'], NS(x=None, y='a badger')),\n-        (['-y', '-a badger'], NS(x=None, y='-a badger')),\n-        (['--yyy=a badger'], NS(x=None, y='a badger')),\n-        (['--yyy=-a badger'], NS(x=None, y='-a badger')),\n+        ([\"\"], NS(x=\"\", y=None)),\n+        ([\"a badger\"], NS(x=\"a badger\", y=None)),\n+        ([\"-a badger\"], NS(x=\"-a badger\", y=None)),\n+        ([\"-y\", \"\"], NS(x=None, y=\"\")),\n+        ([\"-y\", \"a badger\"], NS(x=None, y=\"a badger\")),\n+        ([\"-y\", \"-a badger\"], NS(x=None, y=\"-a badger\")),\n+        ([\"--yyy=a badger\"], NS(x=None, y=\"a badger\")),\n+        ([\"--yyy=-a badger\"], NS(x=None, y=\"-a badger\")),\n     ]\n \n \n class TestPrefixCharacterOnlyArguments(ParserTestCase):\n-\n-    parser_signature = Sig(prefix_chars='-+')\n+    parser_signature = Sig(prefix_chars=\"-+\")\n     argument_signatures = [\n-        Sig('-', dest='x', nargs='?', const='badger'),\n-        Sig('+', dest='y', type=int, default=42),\n-        Sig('-+-', dest='z', action='store_true'),\n+        Sig(\"-\", dest=\"x\", nargs=\"?\", const=\"badger\"),\n+        Sig(\"+\", dest=\"y\", type=int, default=42),\n+        Sig(\"-+-\", dest=\"z\", action=\"store_true\"),\n     ]\n-    failures = ['-y', '+ -']\n+    failures = [\"-y\", \"+ -\"]\n     successes = [\n-        ('', NS(x=None, y=42, z=False)),\n-        ('-', NS(x='badger', y=42, z=False)),\n-        ('- X', NS(x='X', y=42, z=False)),\n-        ('+ -3', NS(x=None, y=-3, z=False)),\n-        ('-+-', NS(x=None, y=42, z=True)),\n-        ('- ===', NS(x='===', y=42, z=False)),\n+        (\"\", NS(x=None, y=42, z=False)),\n+        (\"-\", NS(x=\"badger\", y=42, z=False)),\n+        (\"- X\", NS(x=\"X\", y=42, z=False)),\n+        (\"+ -3\", NS(x=None, y=-3, z=False)),\n+        (\"-+-\", NS(x=None, y=42, z=True)),\n+        (\"- ===\", NS(x=\"===\", y=42, z=False)),\n     ]\n \n \n class TestNargsZeroOrMore(ParserTestCase):\n     \"\"\"Tests specifying args for an Optional that accepts zero or more\"\"\"\n \n-    argument_signatures = [Sig('-x', nargs='*'), Sig('y', nargs='*')]\n+    argument_signatures = [Sig(\"-x\", nargs=\"*\"), Sig(\"y\", nargs=\"*\")]\n     failures = []\n     successes = [\n-        ('', NS(x=None, y=[])),\n-        ('-x', NS(x=[], y=[])),\n-        ('-x a', NS(x=['a'], y=[])),\n-        ('-x a -- b', NS(x=['a'], y=['b'])),\n-        ('a', NS(x=None, y=['a'])),\n-        ('a -x', NS(x=[], y=['a'])),\n-        ('a -x b', NS(x=['b'], y=['a'])),\n+        (\"\", NS(x=None, y=[])),\n+        (\"-x\", NS(x=[], y=[])),\n+        (\"-x a\", NS(x=[\"a\"], y=[])),\n+        (\"-x a -- b\", NS(x=[\"a\"], y=[\"b\"])),\n+        (\"a\", NS(x=None, y=[\"a\"])),\n+        (\"a -x\", NS(x=[], y=[\"a\"])),\n+        (\"a -x b\", NS(x=[\"b\"], y=[\"a\"])),\n     ]\n \n \n class TestNargsRemainder(ParserTestCase):\n     \"\"\"Tests specifying a positional with nargs=REMAINDER\"\"\"\n \n-    argument_signatures = [Sig('x'), Sig('y', nargs='...'), Sig('-z')]\n-    failures = ['', '-z', '-z Z']\n+    argument_signatures = [Sig(\"x\"), Sig(\"y\", nargs=\"...\"), Sig(\"-z\")]\n+    failures = [\"\", \"-z\", \"-z Z\"]\n     successes = [\n-        ('X', NS(x='X', y=[], z=None)),\n-        ('-z Z X', NS(x='X', y=[], z='Z')),\n-        ('-z Z X A B', NS(x='X', y=['A', 'B'], z='Z')),\n-        ('X -z Z A B', NS(x='X', y=['-z', 'Z', 'A', 'B'], z=None)),\n-        ('X A -z Z B', NS(x='X', y=['A', '-z', 'Z', 'B'], z=None)),\n-        ('X A B -z Z', NS(x='X', y=['A', 'B', '-z', 'Z'], z=None)),\n-        ('X Y --foo', NS(x='X', y=['Y', '--foo'], z=None)),\n+        (\"X\", NS(x=\"X\", y=[], z=None)),\n+        (\"-z Z X\", NS(x=\"X\", y=[], z=\"Z\")),\n+        (\"-z Z X A B\", NS(x=\"X\", y=[\"A\", \"B\"], z=\"Z\")),\n+        (\"X -z Z A B\", NS(x=\"X\", y=[\"-z\", \"Z\", \"A\", \"B\"], z=None)),\n+        (\"X A -z Z B\", NS(x=\"X\", y=[\"A\", \"-z\", \"Z\", \"B\"], z=None)),\n+        (\"X A B -z Z\", NS(x=\"X\", y=[\"A\", \"B\", \"-z\", \"Z\"], z=None)),\n+        (\"X Y --foo\", NS(x=\"X\", y=[\"Y\", \"--foo\"], z=None)),\n     ]\n \n \n@@ -1619,26 +1694,37 @@ class TestOptionLike(ParserTestCase):\n     \"\"\"Tests options that may or may not be arguments\"\"\"\n \n     argument_signatures = [\n-        Sig('-x', type=float),\n-        Sig('-3', type=float, dest='y'),\n-        Sig('z', nargs='*'),\n-    ]\n-    failures = ['-x', '-y2.5', '-xa', '-x -a',\n-                '-x -3', '-x -3.5', '-3 -3.5',\n-                '-x -2.5', '-x -2.5 a', '-3 -.5',\n-                'a x -1', '-x -1 a', '-3 -1 a']\n+        Sig(\"-x\", type=float),\n+        Sig(\"-3\", type=float, dest=\"y\"),\n+        Sig(\"z\", nargs=\"*\"),\n+    ]\n+    failures = [\n+        \"-x\",\n+        \"-y2.5\",\n+        \"-xa\",\n+        \"-x -a\",\n+        \"-x -3\",\n+        \"-x -3.5\",\n+        \"-3 -3.5\",\n+        \"-x -2.5\",\n+        \"-x -2.5 a\",\n+        \"-3 -.5\",\n+        \"a x -1\",\n+        \"-x -1 a\",\n+        \"-3 -1 a\",\n+    ]\n     successes = [\n-        ('', NS(x=None, y=None, z=[])),\n-        ('-x 2.5', NS(x=2.5, y=None, z=[])),\n-        ('-x 2.5 a', NS(x=2.5, y=None, z=['a'])),\n-        ('-3.5', NS(x=None, y=0.5, z=[])),\n-        ('-3-.5', NS(x=None, y=-0.5, z=[])),\n-        ('-3 .5', NS(x=None, y=0.5, z=[])),\n-        ('a -3.5', NS(x=None, y=0.5, z=['a'])),\n-        ('a', NS(x=None, y=None, z=['a'])),\n-        ('a -x 1', NS(x=1.0, y=None, z=['a'])),\n-        ('-x 1 a', NS(x=1.0, y=None, z=['a'])),\n-        ('-3 1 a', NS(x=None, y=1.0, z=['a'])),\n+        (\"\", NS(x=None, y=None, z=[])),\n+        (\"-x 2.5\", NS(x=2.5, y=None, z=[])),\n+        (\"-x 2.5 a\", NS(x=2.5, y=None, z=[\"a\"])),\n+        (\"-3.5\", NS(x=None, y=0.5, z=[])),\n+        (\"-3-.5\", NS(x=None, y=-0.5, z=[])),\n+        (\"-3 .5\", NS(x=None, y=0.5, z=[])),\n+        (\"a -3.5\", NS(x=None, y=0.5, z=[\"a\"])),\n+        (\"a\", NS(x=None, y=None, z=[\"a\"])),\n+        (\"a -x 1\", NS(x=1.0, y=None, z=[\"a\"])),\n+        (\"-x 1 a\", NS(x=1.0, y=None, z=[\"a\"])),\n+        (\"-3 1 a\", NS(x=None, y=1.0, z=[\"a\"])),\n     ]\n \n \n@@ -1646,24 +1732,24 @@ class TestDefaultSuppress(ParserTestCase):\n     \"\"\"Test actions with suppressed defaults\"\"\"\n \n     argument_signatures = [\n-        Sig('foo', nargs='?', type=int, default=argparse.SUPPRESS),\n-        Sig('bar', nargs='*', type=int, default=argparse.SUPPRESS),\n-        Sig('--baz', action='store_true', default=argparse.SUPPRESS),\n-        Sig('--qux', nargs='?', type=int, default=argparse.SUPPRESS),\n-        Sig('--quux', nargs='*', type=int, default=argparse.SUPPRESS),\n+        Sig(\"foo\", nargs=\"?\", type=int, default=argparse.SUPPRESS),\n+        Sig(\"bar\", nargs=\"*\", type=int, default=argparse.SUPPRESS),\n+        Sig(\"--baz\", action=\"store_true\", default=argparse.SUPPRESS),\n+        Sig(\"--qux\", nargs=\"?\", type=int, default=argparse.SUPPRESS),\n+        Sig(\"--quux\", nargs=\"*\", type=int, default=argparse.SUPPRESS),\n     ]\n-    failures = ['-x', 'a', '1 a']\n+    failures = [\"-x\", \"a\", \"1 a\"]\n     successes = [\n-        ('', NS()),\n-        ('1', NS(foo=1)),\n-        ('1 2', NS(foo=1, bar=[2])),\n-        ('--baz', NS(baz=True)),\n-        ('1 --baz', NS(foo=1, baz=True)),\n-        ('--baz 1 2', NS(foo=1, bar=[2], baz=True)),\n-        ('--qux', NS(qux=None)),\n-        ('--qux 1', NS(qux=1)),\n-        ('--quux', NS(quux=[])),\n-        ('--quux 1 2', NS(quux=[1, 2])),\n+        (\"\", NS()),\n+        (\"1\", NS(foo=1)),\n+        (\"1 2\", NS(foo=1, bar=[2])),\n+        (\"--baz\", NS(baz=True)),\n+        (\"1 --baz\", NS(foo=1, baz=True)),\n+        (\"--baz 1 2\", NS(foo=1, bar=[2], baz=True)),\n+        (\"--qux\", NS(qux=None)),\n+        (\"--qux 1\", NS(qux=1)),\n+        (\"--quux\", NS(quux=[])),\n+        (\"--quux 1 2\", NS(quux=[1, 2])),\n     ]\n \n \n@@ -1672,18 +1758,18 @@ class TestParserDefaultSuppress(ParserTestCase):\n \n     parser_signature = Sig(argument_default=argparse.SUPPRESS)\n     argument_signatures = [\n-        Sig('foo', nargs='?'),\n-        Sig('bar', nargs='*'),\n-        Sig('--baz', action='store_true'),\n+        Sig(\"foo\", nargs=\"?\"),\n+        Sig(\"bar\", nargs=\"*\"),\n+        Sig(\"--baz\", action=\"store_true\"),\n     ]\n-    failures = ['-x']\n+    failures = [\"-x\"]\n     successes = [\n-        ('', NS()),\n-        ('a', NS(foo='a')),\n-        ('a b', NS(foo='a', bar=['b'])),\n-        ('--baz', NS(baz=True)),\n-        ('a --baz', NS(foo='a', baz=True)),\n-        ('--baz a b', NS(foo='a', bar=['b'], baz=True)),\n+        (\"\", NS()),\n+        (\"a\", NS(foo=\"a\")),\n+        (\"a b\", NS(foo=\"a\", bar=[\"b\"])),\n+        (\"--baz\", NS(baz=True)),\n+        (\"a --baz\", NS(foo=\"a\", baz=True)),\n+        (\"--baz a b\", NS(foo=\"a\", bar=[\"b\"], baz=True)),\n     ]\n \n \n@@ -1692,19 +1778,19 @@ class TestParserDefault42(ParserTestCase):\n \n     parser_signature = Sig(argument_default=42)\n     argument_signatures = [\n-        Sig('--version', action='version', version='1.0'),\n-        Sig('foo', nargs='?'),\n-        Sig('bar', nargs='*'),\n-        Sig('--baz', action='store_true'),\n+        Sig(\"--version\", action=\"version\", version=\"1.0\"),\n+        Sig(\"foo\", nargs=\"?\"),\n+        Sig(\"bar\", nargs=\"*\"),\n+        Sig(\"--baz\", action=\"store_true\"),\n     ]\n-    failures = ['-x']\n+    failures = [\"-x\"]\n     successes = [\n-        ('', NS(foo=42, bar=42, baz=42, version=42)),\n-        ('a', NS(foo='a', bar=42, baz=42, version=42)),\n-        ('a b', NS(foo='a', bar=['b'], baz=42, version=42)),\n-        ('--baz', NS(foo=42, bar=42, baz=True, version=42)),\n-        ('a --baz', NS(foo='a', bar=42, baz=True, version=42)),\n-        ('--baz a b', NS(foo='a', bar=['b'], baz=True, version=42)),\n+        (\"\", NS(foo=42, bar=42, baz=42, version=42)),\n+        (\"a\", NS(foo=\"a\", bar=42, baz=42, version=42)),\n+        (\"a b\", NS(foo=\"a\", bar=[\"b\"], baz=42, version=42)),\n+        (\"--baz\", NS(foo=42, bar=42, baz=True, version=42)),\n+        (\"a --baz\", NS(foo=\"a\", bar=42, baz=True, version=42)),\n+        (\"--baz a b\", NS(foo=\"a\", bar=[\"b\"], baz=True, version=42)),\n     ]\n \n \n@@ -1714,43 +1800,41 @@ class TestArgumentsFromFile(TempDirMixin, ParserTestCase):\n     def setUp(self):\n         super(TestArgumentsFromFile, self).setUp()\n         file_texts = [\n-            ('hello', os.fsencode(self.hello) + b'\\n'),\n-            ('recursive', b'-a\\n'\n-                          b'A\\n'\n-                          b'@hello'),\n-            ('invalid', b'@no-such-path\\n'),\n-            ('undecodable', self.undecodable + b'\\n'),\n+            (\"hello\", os.fsencode(self.hello) + b\"\\n\"),\n+            (\"recursive\", b\"-a\\nA\\n@hello\"),\n+            (\"invalid\", b\"@no-such-path\\n\"),\n+            (\"undecodable\", self.undecodable + b\"\\n\"),\n         ]\n         for path, text in file_texts:\n-            with open(path, 'wb') as file:\n+            with open(path, \"wb\") as file:\n                 file.write(text)\n \n-    parser_signature = Sig(fromfile_prefix_chars='@')\n+    parser_signature = Sig(fromfile_prefix_chars=\"@\")\n     argument_signatures = [\n-        Sig('-a'),\n-        Sig('x'),\n-        Sig('y', nargs='+'),\n+        Sig(\"-a\"),\n+        Sig(\"x\"),\n+        Sig(\"y\", nargs=\"+\"),\n     ]\n-    failures = ['', '-b', 'X', '@invalid', '@missing']\n-    hello = 'hello world!' + os_helper.FS_NONASCII\n+    failures = [\"\", \"-b\", \"X\", \"@invalid\", \"@missing\"]\n+    hello = \"hello world!\" + os_helper.FS_NONASCII\n     successes = [\n-        ('X Y', NS(a=None, x='X', y=['Y'])),\n-        ('X -a A Y Z', NS(a='A', x='X', y=['Y', 'Z'])),\n-        ('@hello X', NS(a=None, x=hello, y=['X'])),\n-        ('X @hello', NS(a=None, x='X', y=[hello])),\n-        ('-a B @recursive Y Z', NS(a='A', x=hello, y=['Y', 'Z'])),\n-        ('X @recursive Z -a B', NS(a='B', x='X', y=[hello, 'Z'])),\n-        ([\"-a\", \"\", \"X\", \"Y\"], NS(a='', x='X', y=['Y'])),\n+        (\"X Y\", NS(a=None, x=\"X\", y=[\"Y\"])),\n+        (\"X -a A Y Z\", NS(a=\"A\", x=\"X\", y=[\"Y\", \"Z\"])),\n+        (\"@hello X\", NS(a=None, x=hello, y=[\"X\"])),\n+        (\"X @hello\", NS(a=None, x=\"X\", y=[hello])),\n+        (\"-a B @recursive Y Z\", NS(a=\"A\", x=hello, y=[\"Y\", \"Z\"])),\n+        (\"X @recursive Z -a B\", NS(a=\"B\", x=\"X\", y=[hello, \"Z\"])),\n+        ([\"-a\", \"\", \"X\", \"Y\"], NS(a=\"\", x=\"X\", y=[\"Y\"])),\n     ]\n     if os_helper.TESTFN_UNDECODABLE:\n-        undecodable = os_helper.TESTFN_UNDECODABLE.lstrip(b'@')\n+        undecodable = os_helper.TESTFN_UNDECODABLE.lstrip(b\"@\")\n         decoded_undecodable = os.fsdecode(undecodable)\n         successes += [\n-            ('@undecodable X', NS(a=None, x=decoded_undecodable, y=['X'])),\n-            ('X @undecodable', NS(a=None, x='X', y=[decoded_undecodable])),\n+            (\"@undecodable X\", NS(a=None, x=decoded_undecodable, y=[\"X\"])),\n+            (\"X @undecodable\", NS(a=None, x=\"X\", y=[decoded_undecodable])),\n         ]\n     else:\n-        undecodable = b''\n+        undecodable = b\"\"\n \n \n class TestArgumentsFromFileConverter(TempDirMixin, ParserTestCase):\n@@ -1759,27 +1843,27 @@ class TestArgumentsFromFileConverter(TempDirMixin, ParserTestCase):\n     def setUp(self):\n         super(TestArgumentsFromFileConverter, self).setUp()\n         file_texts = [\n-            ('hello', b'hello world!\\n'),\n+            (\"hello\", b\"hello world!\\n\"),\n         ]\n         for path, text in file_texts:\n-            with open(path, 'wb') as file:\n+            with open(path, \"wb\") as file:\n                 file.write(text)\n \n     class FromFileConverterArgumentParser(ErrorRaisingArgumentParser):\n-\n         def convert_arg_line_to_args(self, arg_line):\n             for arg in arg_line.split():\n                 if not arg.strip():\n                     continue\n                 yield arg\n+\n     parser_class = FromFileConverterArgumentParser\n-    parser_signature = Sig(fromfile_prefix_chars='@')\n+    parser_signature = Sig(fromfile_prefix_chars=\"@\")\n     argument_signatures = [\n-        Sig('y', nargs='+'),\n+        Sig(\"y\", nargs=\"+\"),\n     ]\n     failures = []\n     successes = [\n-        ('@hello X', NS(y=['hello', 'world!', 'X'])),\n+        (\"@hello X\", NS(y=[\"hello\", \"world!\", \"X\"])),\n     ]\n \n \n@@ -1787,43 +1871,47 @@ def convert_arg_line_to_args(self, arg_line):\n # Type conversion tests\n # =====================\n \n+\n def FileType(*args, **kwargs):\n     with warnings.catch_warnings():\n-        warnings.filterwarnings('ignore', 'FileType is deprecated',\n-                                PendingDeprecationWarning, __name__)\n+        warnings.filterwarnings(\n+            \"ignore\",\n+            \"FileType is deprecated\",\n+            PendingDeprecationWarning,\n+            __name__,\n+        )\n         return argparse.FileType(*args, **kwargs)\n \n \n class TestFileTypeDeprecation(TestCase):\n-\n     def test(self):\n         with self.assertWarns(PendingDeprecationWarning) as cm:\n             argparse.FileType()\n-        self.assertIn('FileType is deprecated', str(cm.warning))\n+        self.assertIn(\"FileType is deprecated\", str(cm.warning))\n         self.assertEqual(cm.filename, __file__)\n \n \n class TestFileTypeRepr(TestCase):\n-\n     def test_r(self):\n-        type = FileType('r')\n+        type = FileType(\"r\")\n         self.assertEqual(\"FileType('r')\", repr(type))\n \n     def test_wb_1(self):\n-        type = FileType('wb', 1)\n+        type = FileType(\"wb\", 1)\n         self.assertEqual(\"FileType('wb', 1)\", repr(type))\n \n     def test_r_latin(self):\n-        type = FileType('r', encoding='latin_1')\n+        type = FileType(\"r\", encoding=\"latin_1\")\n         self.assertEqual(\"FileType('r', encoding='latin_1')\", repr(type))\n \n     def test_w_big5_ignore(self):\n-        type = FileType('w', encoding='big5', errors='ignore')\n-        self.assertEqual(\"FileType('w', encoding='big5', errors='ignore')\",\n-                         repr(type))\n+        type = FileType(\"w\", encoding=\"big5\", errors=\"ignore\")\n+        self.assertEqual(\n+            \"FileType('w', encoding='big5', errors='ignore')\", repr(type)\n+        )\n \n     def test_r_1_replace(self):\n-        type = FileType('r', 1, errors='replace')\n+        type = FileType(\"r\", 1, errors=\"replace\")\n         self.assertEqual(\"FileType('r', 1, errors='replace')\", repr(type))\n \n \n@@ -1839,12 +1927,12 @@ def __init__(self, attr):\n         # so we use a sentinel simply to show that the tests do the right thing\n         # for any buffer supporting object\n         self.getattr = operator.attrgetter(attr)\n-        if attr == 'stdout.buffer':\n+        if attr == \"stdout.buffer\":\n             self.backupattr = BIN_STDOUT_SENTINEL\n-        elif attr == 'stderr.buffer':\n+        elif attr == \"stderr.buffer\":\n             self.backupattr = BIN_STDERR_SENTINEL\n         else:\n-            self.backupattr = object() # Not equal to anything\n+            self.backupattr = object()  # Not equal to anything\n \n     def __eq__(self, other):\n         try:\n@@ -1853,12 +1941,12 @@ def __eq__(self, other):\n             return other == self.backupattr\n \n \n-eq_stdin = StdStreamComparer('stdin')\n-eq_stdout = StdStreamComparer('stdout')\n-eq_stderr = StdStreamComparer('stderr')\n-eq_bstdin = StdStreamComparer('stdin.buffer')\n-eq_bstdout = StdStreamComparer('stdout.buffer')\n-eq_bstderr = StdStreamComparer('stderr.buffer')\n+eq_stdin = StdStreamComparer(\"stdin\")\n+eq_stdout = StdStreamComparer(\"stdout\")\n+eq_stderr = StdStreamComparer(\"stderr\")\n+eq_bstdin = StdStreamComparer(\"stdin.buffer\")\n+eq_bstdout = StdStreamComparer(\"stdout.buffer\")\n+eq_bstderr = StdStreamComparer(\"stderr.buffer\")\n \n \n class RFile(object):\n@@ -1874,48 +1962,52 @@ def __eq__(self, other):\n             text = self.seen[other] = other.read()\n             other.close()\n         if not isinstance(text, str):\n-            text = text.decode('ascii')\n+            text = text.decode(\"ascii\")\n         return self.name == other.name == text\n \n+\n class TestFileTypeR(TempDirMixin, ParserTestCase):\n     \"\"\"Test the FileType option/argument type for reading files\"\"\"\n \n     def setUp(self):\n         super(TestFileTypeR, self).setUp()\n-        for file_name in ['foo', 'bar']:\n-            with open(os.path.join(self.temp_dir, file_name),\n-                      'w', encoding=\"utf-8\") as file:\n+        for file_name in [\"foo\", \"bar\"]:\n+            with open(\n+                os.path.join(self.temp_dir, file_name), \"w\", encoding=\"utf-8\"\n+            ) as file:\n                 file.write(file_name)\n-        self.create_readonly_file('readonly')\n+        self.create_readonly_file(\"readonly\")\n \n     argument_signatures = [\n-        Sig('-x', type=FileType()),\n-        Sig('spam', type=FileType('r')),\n+        Sig(\"-x\", type=FileType()),\n+        Sig(\"spam\", type=FileType(\"r\")),\n     ]\n-    failures = ['-x', '', 'non-existent-file.txt']\n+    failures = [\"-x\", \"\", \"non-existent-file.txt\"]\n     successes = [\n-        ('foo', NS(x=None, spam=RFile('foo'))),\n-        ('-x foo bar', NS(x=RFile('foo'), spam=RFile('bar'))),\n-        ('bar -x foo', NS(x=RFile('foo'), spam=RFile('bar'))),\n-        ('-x - -', NS(x=eq_stdin, spam=eq_stdin)),\n-        ('readonly', NS(x=None, spam=RFile('readonly'))),\n+        (\"foo\", NS(x=None, spam=RFile(\"foo\"))),\n+        (\"-x foo bar\", NS(x=RFile(\"foo\"), spam=RFile(\"bar\"))),\n+        (\"bar -x foo\", NS(x=RFile(\"foo\"), spam=RFile(\"bar\"))),\n+        (\"-x - -\", NS(x=eq_stdin, spam=eq_stdin)),\n+        (\"readonly\", NS(x=None, spam=RFile(\"readonly\"))),\n     ]\n \n+\n class TestFileTypeDefaults(TempDirMixin, ParserTestCase):\n     \"\"\"Test that a file is not created unless the default is needed\"\"\"\n+\n     def setUp(self):\n         super(TestFileTypeDefaults, self).setUp()\n-        file = open(os.path.join(self.temp_dir, 'good'), 'w', encoding=\"utf-8\")\n-        file.write('good')\n+        file = open(os.path.join(self.temp_dir, \"good\"), \"w\", encoding=\"utf-8\")\n+        file.write(\"good\")\n         file.close()\n \n     argument_signatures = [\n-        Sig('-c', type=FileType('r'), default='no-file.txt'),\n+        Sig(\"-c\", type=FileType(\"r\"), default=\"no-file.txt\"),\n     ]\n     # should provoke no such file error\n-    failures = ['']\n+    failures = [\"\"]\n     # should not provoke error because default file is created\n-    successes = [('-c good', NS(c=RFile('good')))]\n+    successes = [(\"-c good\", NS(c=RFile(\"good\")))]\n \n \n class TestFileTypeRB(TempDirMixin, ParserTestCase):\n@@ -1923,21 +2015,22 @@ class TestFileTypeRB(TempDirMixin, ParserTestCase):\n \n     def setUp(self):\n         super(TestFileTypeRB, self).setUp()\n-        for file_name in ['foo', 'bar']:\n-            with open(os.path.join(self.temp_dir, file_name),\n-                      'w', encoding=\"utf-8\") as file:\n+        for file_name in [\"foo\", \"bar\"]:\n+            with open(\n+                os.path.join(self.temp_dir, file_name), \"w\", encoding=\"utf-8\"\n+            ) as file:\n                 file.write(file_name)\n \n     argument_signatures = [\n-        Sig('-x', type=FileType('rb')),\n-        Sig('spam', type=FileType('rb')),\n+        Sig(\"-x\", type=FileType(\"rb\")),\n+        Sig(\"spam\", type=FileType(\"rb\")),\n     ]\n-    failures = ['-x', '']\n+    failures = [\"-x\", \"\"]\n     successes = [\n-        ('foo', NS(x=None, spam=RFile('foo'))),\n-        ('-x foo bar', NS(x=RFile('foo'), spam=RFile('bar'))),\n-        ('bar -x foo', NS(x=RFile('foo'), spam=RFile('bar'))),\n-        ('-x - -', NS(x=eq_bstdin, spam=eq_bstdin)),\n+        (\"foo\", NS(x=None, spam=RFile(\"foo\"))),\n+        (\"-x foo bar\", NS(x=RFile(\"foo\"), spam=RFile(\"bar\"))),\n+        (\"bar -x foo\", NS(x=RFile(\"foo\"), spam=RFile(\"bar\"))),\n+        (\"-x - -\", NS(x=eq_bstdin, spam=eq_bstdin)),\n     ]\n \n \n@@ -1949,9 +2042,9 @@ def __init__(self, name):\n \n     def __eq__(self, other):\n         if other not in self.seen:\n-            text = 'Check that file is writable.'\n-            if 'b' in other.mode:\n-                text = text.encode('ascii')\n+            text = \"Check that file is writable.\"\n+            if \"b\" in other.mode:\n+                text = text.encode(\"ascii\")\n             other.write(text)\n             other.close()\n             self.seen.add(other)\n@@ -1964,20 +2057,20 @@ class TestFileTypeW(TempDirMixin, ParserTestCase):\n \n     def setUp(self):\n         super().setUp()\n-        self.create_readonly_file('readonly')\n-        self.create_writable_file('writable')\n+        self.create_readonly_file(\"readonly\")\n+        self.create_writable_file(\"writable\")\n \n     argument_signatures = [\n-        Sig('-x', type=FileType('w')),\n-        Sig('spam', type=FileType('w')),\n+        Sig(\"-x\", type=FileType(\"w\")),\n+        Sig(\"spam\", type=FileType(\"w\")),\n     ]\n-    failures = ['-x', '', 'readonly']\n+    failures = [\"-x\", \"\", \"readonly\"]\n     successes = [\n-        ('foo', NS(x=None, spam=WFile('foo'))),\n-        ('writable', NS(x=None, spam=WFile('writable'))),\n-        ('-x foo bar', NS(x=WFile('foo'), spam=WFile('bar'))),\n-        ('bar -x foo', NS(x=WFile('foo'), spam=WFile('bar'))),\n-        ('-x - -', NS(x=eq_stdout, spam=eq_stdout)),\n+        (\"foo\", NS(x=None, spam=WFile(\"foo\"))),\n+        (\"writable\", NS(x=None, spam=WFile(\"writable\"))),\n+        (\"-x foo bar\", NS(x=WFile(\"foo\"), spam=WFile(\"bar\"))),\n+        (\"bar -x foo\", NS(x=WFile(\"foo\"), spam=WFile(\"bar\"))),\n+        (\"-x - -\", NS(x=eq_stdout, spam=eq_stdout)),\n     ]\n \n \n@@ -1987,17 +2080,17 @@ class TestFileTypeX(TempDirMixin, ParserTestCase):\n \n     def setUp(self):\n         super().setUp()\n-        self.create_readonly_file('readonly')\n-        self.create_writable_file('writable')\n+        self.create_readonly_file(\"readonly\")\n+        self.create_writable_file(\"writable\")\n \n     argument_signatures = [\n-        Sig('-x', type=FileType('x')),\n-        Sig('spam', type=FileType('x')),\n+        Sig(\"-x\", type=FileType(\"x\")),\n+        Sig(\"spam\", type=FileType(\"x\")),\n     ]\n-    failures = ['-x', '', 'readonly', 'writable']\n+    failures = [\"-x\", \"\", \"readonly\", \"writable\"]\n     successes = [\n-        ('-x foo bar', NS(x=WFile('foo'), spam=WFile('bar'))),\n-        ('-x - -', NS(x=eq_stdout, spam=eq_stdout)),\n+        (\"-x foo bar\", NS(x=WFile(\"foo\"), spam=WFile(\"bar\"))),\n+        (\"-x - -\", NS(x=eq_stdout, spam=eq_stdout)),\n     ]\n \n \n@@ -2006,15 +2099,15 @@ class TestFileTypeWB(TempDirMixin, ParserTestCase):\n     \"\"\"Test the FileType option/argument type for writing binary files\"\"\"\n \n     argument_signatures = [\n-        Sig('-x', type=FileType('wb')),\n-        Sig('spam', type=FileType('wb')),\n+        Sig(\"-x\", type=FileType(\"wb\")),\n+        Sig(\"spam\", type=FileType(\"wb\")),\n     ]\n-    failures = ['-x', '']\n+    failures = [\"-x\", \"\"]\n     successes = [\n-        ('foo', NS(x=None, spam=WFile('foo'))),\n-        ('-x foo bar', NS(x=WFile('foo'), spam=WFile('bar'))),\n-        ('bar -x foo', NS(x=WFile('foo'), spam=WFile('bar'))),\n-        ('-x - -', NS(x=eq_bstdout, spam=eq_bstdout)),\n+        (\"foo\", NS(x=None, spam=WFile(\"foo\"))),\n+        (\"-x foo bar\", NS(x=WFile(\"foo\"), spam=WFile(\"bar\"))),\n+        (\"bar -x foo\", NS(x=WFile(\"foo\"), spam=WFile(\"bar\"))),\n+        (\"-x - -\", NS(x=eq_bstdout, spam=eq_bstdout)),\n     ]\n \n \n@@ -2023,12 +2116,12 @@ class TestFileTypeXB(TestFileTypeX):\n     \"Test the FileType option/argument type for writing new binary files only\"\n \n     argument_signatures = [\n-        Sig('-x', type=FileType('xb')),\n-        Sig('spam', type=FileType('xb')),\n+        Sig(\"-x\", type=FileType(\"xb\")),\n+        Sig(\"spam\", type=FileType(\"xb\")),\n     ]\n     successes = [\n-        ('-x foo bar', NS(x=WFile('foo'), spam=WFile('bar'))),\n-        ('-x - -', NS(x=eq_bstdout, spam=eq_bstdout)),\n+        (\"-x foo bar\", NS(x=WFile(\"foo\"), spam=WFile(\"bar\"))),\n+        (\"-x - -\", NS(x=eq_bstdout, spam=eq_bstdout)),\n     ]\n \n \n@@ -2038,20 +2131,20 @@ class TestFileTypeOpenArgs(TestCase):\n     def test_open_args(self):\n         FT = FileType\n         cases = [\n-            (FT('rb'), ('rb', -1, None, None)),\n-            (FT('w', 1), ('w', 1, None, None)),\n-            (FT('w', errors='replace'), ('w', -1, None, 'replace')),\n-            (FT('wb', encoding='big5'), ('wb', -1, 'big5', None)),\n-            (FT('w', 0, 'l1', 'strict'), ('w', 0, 'l1', 'strict')),\n+            (FT(\"rb\"), (\"rb\", -1, None, None)),\n+            (FT(\"w\", 1), (\"w\", 1, None, None)),\n+            (FT(\"w\", errors=\"replace\"), (\"w\", -1, None, \"replace\")),\n+            (FT(\"wb\", encoding=\"big5\"), (\"wb\", -1, \"big5\", None)),\n+            (FT(\"w\", 0, \"l1\", \"strict\"), (\"w\", 0, \"l1\", \"strict\")),\n         ]\n-        with mock.patch('builtins.open') as m:\n+        with mock.patch(\"builtins.open\") as m:\n             for type, args in cases:\n-                type('foo')\n-                m.assert_called_with('foo', *args)\n+                type(\"foo\")\n+                m.assert_called_with(\"foo\", *args)\n \n     def test_invalid_file_type(self):\n         with self.assertRaises(ValueError):\n-            FileType('b')('-test')\n+            FileType(\"b\")(\"-test\")\n \n \n class TestFileTypeMissingInitialization(TestCase):\n@@ -2063,12 +2156,12 @@ class TestFileTypeMissingInitialization(TestCase):\n     def test(self):\n         parser = argparse.ArgumentParser()\n         with self.assertRaises(TypeError) as cm:\n-            parser.add_argument('-x', type=argparse.FileType)\n+            parser.add_argument(\"-x\", type=argparse.FileType)\n \n         self.assertEqual(\n-            '%r is a FileType class object, instance of it must be passed'\n+            \"%r is a FileType class object, instance of it must be passed\"\n             % (argparse.FileType,),\n-            str(cm.exception)\n+            str(cm.exception),\n         )\n \n \n@@ -2076,14 +2169,14 @@ class TestTypeCallable(ParserTestCase):\n     \"\"\"Test some callables as option/argument types\"\"\"\n \n     argument_signatures = [\n-        Sig('--eggs', type=complex),\n-        Sig('spam', type=float),\n+        Sig(\"--eggs\", type=complex),\n+        Sig(\"spam\", type=float),\n     ]\n-    failures = ['a', '42j', '--eggs a', '--eggs 2i']\n+    failures = [\"a\", \"42j\", \"--eggs a\", \"--eggs 2i\"]\n     successes = [\n-        ('--eggs=42 42', NS(eggs=42, spam=42.0)),\n-        ('--eggs 2j -- -1.5', NS(eggs=2j, spam=-1.5)),\n-        ('1024.675', NS(eggs=None, spam=1024.675)),\n+        (\"--eggs=42 42\", NS(eggs=42, spam=42.0)),\n+        (\"--eggs 2j -- -1.5\", NS(eggs=2j, spam=-1.5)),\n+        (\"1024.675\", NS(eggs=None, spam=1024.675)),\n     ]\n \n \n@@ -2091,7 +2184,6 @@ class TestTypeUserDefined(ParserTestCase):\n     \"\"\"Test a user-defined option/argument type\"\"\"\n \n     class MyType(TestCase):\n-\n         def __init__(self, value):\n             self.value = value\n \n@@ -2099,13 +2191,13 @@ def __eq__(self, other):\n             return (type(self), self.value) == (type(other), other.value)\n \n     argument_signatures = [\n-        Sig('-x', type=MyType),\n-        Sig('spam', type=MyType),\n+        Sig(\"-x\", type=MyType),\n+        Sig(\"spam\", type=MyType),\n     ]\n     failures = []\n     successes = [\n-        ('a -x b', NS(x=MyType('b'), spam=MyType('a'))),\n-        ('-xf g', NS(x=MyType('f'), spam=MyType('g'))),\n+        (\"a -x b\", NS(x=MyType(\"b\"), spam=MyType(\"a\"))),\n+        (\"-xf g\", NS(x=MyType(\"f\"), spam=MyType(\"g\"))),\n     ]\n \n \n@@ -2113,7 +2205,6 @@ class TestTypeClassicClass(ParserTestCase):\n     \"\"\"Test a classic class type\"\"\"\n \n     class C:\n-\n         def __init__(self, value):\n             self.value = value\n \n@@ -2121,13 +2212,13 @@ def __eq__(self, other):\n             return (type(self), self.value) == (type(other), other.value)\n \n     argument_signatures = [\n-        Sig('-x', type=C),\n-        Sig('spam', type=C),\n+        Sig(\"-x\", type=C),\n+        Sig(\"spam\", type=C),\n     ]\n     failures = []\n     successes = [\n-        ('a -x b', NS(x=C('b'), spam=C('a'))),\n-        ('-xf g', NS(x=C('f'), spam=C('g'))),\n+        (\"a -x b\", NS(x=C(\"b\"), spam=C(\"a\"))),\n+        (\"-xf g\", NS(x=C(\"f\"), spam=C(\"g\"))),\n     ]\n \n \n@@ -2135,35 +2226,37 @@ class TestTypeRegistration(TestCase):\n     \"\"\"Test a user-defined type by registering it\"\"\"\n \n     def test(self):\n-\n         def get_my_type(string):\n-            return 'my_type{%s}' % string\n+            return \"my_type{%s}\" % string\n \n         parser = argparse.ArgumentParser()\n-        parser.register('type', 'my_type', get_my_type)\n-        parser.add_argument('-x', type='my_type')\n-        parser.add_argument('y', type='my_type')\n+        parser.register(\"type\", \"my_type\", get_my_type)\n+        parser.add_argument(\"-x\", type=\"my_type\")\n+        parser.add_argument(\"y\", type=\"my_type\")\n \n-        self.assertEqual(parser.parse_args('1'.split()),\n-                         NS(x=None, y='my_type{1}'))\n-        self.assertEqual(parser.parse_args('-x 1 42'.split()),\n-                         NS(x='my_type{1}', y='my_type{42}'))\n+        self.assertEqual(\n+            parser.parse_args(\"1\".split()), NS(x=None, y=\"my_type{1}\")\n+        )\n+        self.assertEqual(\n+            parser.parse_args(\"-x 1 42\".split()),\n+            NS(x=\"my_type{1}\", y=\"my_type{42}\"),\n+        )\n \n \n # ============\n # Action tests\n # ============\n \n+\n class TestActionUserDefined(ParserTestCase):\n     \"\"\"Test a user-defined option/argument action\"\"\"\n \n     class OptionalAction(argparse.Action):\n-\n         def __call__(self, parser, namespace, value, option_string=None):\n             try:\n                 # check destination and option string\n-                assert self.dest == 'spam', 'dest: %s' % self.dest\n-                assert option_string == '-s', 'flag: %s' % option_string\n+                assert self.dest == \"spam\", \"dest: %s\" % self.dest\n+                assert option_string == \"-s\", \"flag: %s\" % option_string\n                 # when option is before argument, badger=2, and when\n                 # option is after argument, badger=<whatever was set>\n                 expected_ns = NS(spam=0.25)\n@@ -2172,21 +2265,23 @@ def __call__(self, parser, namespace, value, option_string=None):\n                 elif value in [2.0]:\n                     expected_ns.badger = 84\n                 else:\n-                    raise AssertionError('value: %s' % value)\n-                assert expected_ns == namespace, ('expected %s, got %s' %\n-                                                  (expected_ns, namespace))\n+                    raise AssertionError(\"value: %s\" % value)\n+                assert expected_ns == namespace, \"expected %s, got %s\" % (\n+                    expected_ns,\n+                    namespace,\n+                )\n             except AssertionError as e:\n-                raise ArgumentParserError('opt_action failed: %s' % e)\n-            setattr(namespace, 'spam', value)\n+                raise ArgumentParserError(\"opt_action failed: %s\" % e)\n+            setattr(namespace, \"spam\", value)\n \n     class PositionalAction(argparse.Action):\n-\n         def __call__(self, parser, namespace, value, option_string=None):\n             try:\n-                assert option_string is None, ('option_string: %s' %\n-                                               option_string)\n+                assert option_string is None, (\n+                    \"option_string: %s\" % option_string\n+                )\n                 # check destination\n-                assert self.dest == 'badger', 'dest: %s' % self.dest\n+                assert self.dest == \"badger\", \"dest: %s\" % self.dest\n                 # when argument is before option, spam=0.25, and when\n                 # option is after argument, spam=<whatever was set>\n                 expected_ns = NS(badger=2)\n@@ -2197,25 +2292,27 @@ def __call__(self, parser, namespace, value, option_string=None):\n                 elif value in [2]:\n                     expected_ns.spam = 0.125\n                 else:\n-                    raise AssertionError('value: %s' % value)\n-                assert expected_ns == namespace, ('expected %s, got %s' %\n-                                                  (expected_ns, namespace))\n+                    raise AssertionError(\"value: %s\" % value)\n+                assert expected_ns == namespace, \"expected %s, got %s\" % (\n+                    expected_ns,\n+                    namespace,\n+                )\n             except AssertionError as e:\n-                raise ArgumentParserError('arg_action failed: %s' % e)\n-            setattr(namespace, 'badger', value)\n+                raise ArgumentParserError(\"arg_action failed: %s\" % e)\n+            setattr(namespace, \"badger\", value)\n \n     argument_signatures = [\n-        Sig('-s', dest='spam', action=OptionalAction,\n-            type=float, default=0.25),\n-        Sig('badger', action=PositionalAction,\n-            type=int, nargs='?', default=2),\n+        Sig(\n+            \"-s\", dest=\"spam\", action=OptionalAction, type=float, default=0.25\n+        ),\n+        Sig(\"badger\", action=PositionalAction, type=int, nargs=\"?\", default=2),\n     ]\n     failures = []\n     successes = [\n-        ('-s0.125', NS(spam=0.125, badger=2)),\n-        ('42', NS(spam=0.25, badger=42)),\n-        ('-s 0.625 1', NS(spam=0.625, badger=1)),\n-        ('84 -s2', NS(spam=2.0, badger=84)),\n+        (\"-s0.125\", NS(spam=0.125, badger=2)),\n+        (\"42\", NS(spam=0.25, badger=42)),\n+        (\"-s 0.625 1\", NS(spam=0.625, badger=1)),\n+        (\"84 -s2\", NS(spam=2.0, badger=84)),\n     ]\n \n \n@@ -2223,27 +2320,25 @@ class TestActionRegistration(TestCase):\n     \"\"\"Test a user-defined action supplied by registering it\"\"\"\n \n     class MyAction(argparse.Action):\n-\n         def __call__(self, parser, namespace, values, option_string=None):\n-            setattr(namespace, self.dest, 'foo[%s]' % values)\n+            setattr(namespace, self.dest, \"foo[%s]\" % values)\n \n     def test(self):\n-\n         parser = argparse.ArgumentParser()\n-        parser.register('action', 'my_action', self.MyAction)\n-        parser.add_argument('badger', action='my_action')\n+        parser.register(\"action\", \"my_action\", self.MyAction)\n+        parser.add_argument(\"badger\", action=\"my_action\")\n \n-        self.assertEqual(parser.parse_args(['1']), NS(badger='foo[1]'))\n-        self.assertEqual(parser.parse_args(['42']), NS(badger='foo[42]'))\n+        self.assertEqual(parser.parse_args([\"1\"]), NS(badger=\"foo[1]\"))\n+        self.assertEqual(parser.parse_args([\"42\"]), NS(badger=\"foo[42]\"))\n \n \n class TestActionExtend(ParserTestCase):\n     argument_signatures = [\n-        Sig('--foo', action=\"extend\", nargs=\"+\", type=str),\n+        Sig(\"--foo\", action=\"extend\", nargs=\"+\", type=str),\n     ]\n     failures = ()\n     successes = [\n-        ('--foo f1 --foo f2 f3 f4', NS(foo=['f1', 'f2', 'f3', 'f4'])),\n+        (\"--foo f1 --foo f2 f3 f4\", NS(foo=[\"f1\", \"f2\", \"f3\", \"f4\"])),\n     ]\n \n \n@@ -2251,55 +2346,68 @@ class TestNegativeNumber(ParserTestCase):\n     \"\"\"Test parsing negative numbers\"\"\"\n \n     argument_signatures = [\n-        Sig('--int', type=int),\n-        Sig('--float', type=float),\n-        Sig('--complex', type=complex),\n+        Sig(\"--int\", type=int),\n+        Sig(\"--float\", type=float),\n+        Sig(\"--complex\", type=complex),\n     ]\n     failures = [\n-        '--float -_.45',\n-        '--float -1__000.0',\n-        '--float -1.0.0',\n-        '--int -1__000',\n-        '--int -1.0',\n-        '--complex -1__000.0j',\n-        '--complex -1.0jj',\n-        '--complex -_.45j',\n+        \"--float -_.45\",\n+        \"--float -1__000.0\",\n+        \"--float -1.0.0\",\n+        \"--int -1__000\",\n+        \"--int -1.0\",\n+        \"--complex -1__000.0j\",\n+        \"--complex -1.0jj\",\n+        \"--complex -_.45j\",\n     ]\n     successes = [\n-        ('--int -1000 --float -1000.0', NS(int=-1000, float=-1000.0, complex=None)),\n-        ('--int -1_000 --float -1_000.0', NS(int=-1000, float=-1000.0, complex=None)),\n-        ('--int -1_000_000 --float -1_000_000.0', NS(int=-1000000, float=-1000000.0, complex=None)),\n-        ('--float -1_000.0', NS(int=None, float=-1000.0, complex=None)),\n-        ('--float -1_000_000.0_0', NS(int=None, float=-1000000.0, complex=None)),\n-        ('--float -.5', NS(int=None, float=-0.5, complex=None)),\n-        ('--float -.5_000', NS(int=None, float=-0.5, complex=None)),\n-        ('--float -1e3', NS(int=None, float=-1000, complex=None)),\n-        ('--float -1e-3', NS(int=None, float=-0.001, complex=None)),\n-        ('--complex -1j', NS(int=None, float=None, complex=-1j)),\n-        ('--complex -1_000j', NS(int=None, float=None, complex=-1000j)),\n-        ('--complex -1_000.0j', NS(int=None, float=None, complex=-1000.0j)),\n-        ('--complex -1e3j', NS(int=None, float=None, complex=-1000j)),\n-        ('--complex -1e-3j', NS(int=None, float=None, complex=-0.001j)),\n+        (\n+            \"--int -1000 --float -1000.0\",\n+            NS(int=-1000, float=-1000.0, complex=None),\n+        ),\n+        (\n+            \"--int -1_000 --float -1_000.0\",\n+            NS(int=-1000, float=-1000.0, complex=None),\n+        ),\n+        (\n+            \"--int -1_000_000 --float -1_000_000.0\",\n+            NS(int=-1000000, float=-1000000.0, complex=None),\n+        ),\n+        (\"--float -1_000.0\", NS(int=None, float=-1000.0, complex=None)),\n+        (\n+            \"--float -1_000_000.0_0\",\n+            NS(int=None, float=-1000000.0, complex=None),\n+        ),\n+        (\"--float -.5\", NS(int=None, float=-0.5, complex=None)),\n+        (\"--float -.5_000\", NS(int=None, float=-0.5, complex=None)),\n+        (\"--float -1e3\", NS(int=None, float=-1000, complex=None)),\n+        (\"--float -1e-3\", NS(int=None, float=-0.001, complex=None)),\n+        (\"--complex -1j\", NS(int=None, float=None, complex=-1j)),\n+        (\"--complex -1_000j\", NS(int=None, float=None, complex=-1000j)),\n+        (\"--complex -1_000.0j\", NS(int=None, float=None, complex=-1000.0j)),\n+        (\"--complex -1e3j\", NS(int=None, float=None, complex=-1000j)),\n+        (\"--complex -1e-3j\", NS(int=None, float=None, complex=-0.001j)),\n     ]\n \n+\n class TestArgumentAndSubparserSuggestions(TestCase):\n     \"\"\"Test error handling and suggestion when a user makes a typo\"\"\"\n \n     def test_wrong_argument_error_with_suggestions(self):\n         parser = ErrorRaisingArgumentParser(suggest_on_error=True)\n-        parser.add_argument('foo', choices=['bar', 'baz'])\n+        parser.add_argument(\"foo\", choices=[\"bar\", \"baz\"])\n         with self.assertRaises(ArgumentParserError) as excinfo:\n-            parser.parse_args(('bazz',))\n+            parser.parse_args((\"bazz\",))\n         self.assertIn(\n             \"error: argument foo: invalid choice: 'bazz', maybe you meant 'baz'? (choose from bar, baz)\",\n-            excinfo.exception.stderr\n+            excinfo.exception.stderr,\n         )\n \n     def test_wrong_argument_error_no_suggestions(self):\n         parser = ErrorRaisingArgumentParser(suggest_on_error=False)\n-        parser.add_argument('foo', choices=['bar', 'baz'])\n+        parser.add_argument(\"foo\", choices=[\"bar\", \"baz\"])\n         with self.assertRaises(ArgumentParserError) as excinfo:\n-            parser.parse_args(('bazz',))\n+            parser.parse_args((\"bazz\",))\n         self.assertIn(\n             \"error: argument foo: invalid choice: 'bazz' (choose from bar, baz)\",\n             excinfo.exception.stderr,\n@@ -2308,23 +2416,23 @@ def test_wrong_argument_error_no_suggestions(self):\n     def test_wrong_argument_subparsers_with_suggestions(self):\n         parser = ErrorRaisingArgumentParser(suggest_on_error=True)\n         subparsers = parser.add_subparsers(required=True)\n-        subparsers.add_parser('foo')\n-        subparsers.add_parser('bar')\n+        subparsers.add_parser(\"foo\")\n+        subparsers.add_parser(\"bar\")\n         with self.assertRaises(ArgumentParserError) as excinfo:\n-            parser.parse_args(('baz',))\n+            parser.parse_args((\"baz\",))\n         self.assertIn(\n             \"error: argument {foo,bar}: invalid choice: 'baz', maybe you meant\"\n-             \" 'bar'? (choose from foo, bar)\",\n+            \" 'bar'? (choose from foo, bar)\",\n             excinfo.exception.stderr,\n         )\n \n     def test_wrong_argument_subparsers_no_suggestions(self):\n         parser = ErrorRaisingArgumentParser(suggest_on_error=False)\n         subparsers = parser.add_subparsers(required=True)\n-        subparsers.add_parser('foo')\n-        subparsers.add_parser('bar')\n+        subparsers.add_parser(\"foo\")\n+        subparsers.add_parser(\"bar\")\n         with self.assertRaises(ArgumentParserError) as excinfo:\n-            parser.parse_args(('baz',))\n+            parser.parse_args((\"baz\",))\n         self.assertIn(\n             \"error: argument {foo,bar}: invalid choice: 'baz' (choose from foo, bar)\",\n             excinfo.exception.stderr,\n@@ -2332,9 +2440,9 @@ def test_wrong_argument_subparsers_no_suggestions(self):\n \n     def test_wrong_argument_no_suggestion_implicit(self):\n         parser = ErrorRaisingArgumentParser()\n-        parser.add_argument('foo', choices=['bar', 'baz'])\n+        parser.add_argument(\"foo\", choices=[\"bar\", \"baz\"])\n         with self.assertRaises(ArgumentParserError) as excinfo:\n-            parser.parse_args(('bazz',))\n+            parser.parse_args((\"bazz\",))\n         self.assertIn(\n             \"error: argument foo: invalid choice: 'bazz' (choose from bar, baz)\",\n             excinfo.exception.stderr,\n@@ -2342,9 +2450,9 @@ def test_wrong_argument_no_suggestion_implicit(self):\n \n     def test_suggestions_choices_empty(self):\n         parser = ErrorRaisingArgumentParser(suggest_on_error=True)\n-        parser.add_argument('foo', choices=[])\n+        parser.add_argument(\"foo\", choices=[])\n         with self.assertRaises(ArgumentParserError) as excinfo:\n-            parser.parse_args(('bazz',))\n+            parser.parse_args((\"bazz\",))\n         self.assertIn(\n             \"error: argument foo: invalid choice: 'bazz' (choose from )\",\n             excinfo.exception.stderr,\n@@ -2352,9 +2460,9 @@ def test_suggestions_choices_empty(self):\n \n     def test_suggestions_choices_int(self):\n         parser = ErrorRaisingArgumentParser(suggest_on_error=True)\n-        parser.add_argument('foo', choices=[1, 2])\n+        parser.add_argument(\"foo\", choices=[1, 2])\n         with self.assertRaises(ArgumentParserError) as excinfo:\n-            parser.parse_args(('3',))\n+            parser.parse_args((\"3\",))\n         self.assertIn(\n             \"error: argument foo: invalid choice: '3' (choose from 1, 2)\",\n             excinfo.exception.stderr,\n@@ -2362,9 +2470,9 @@ def test_suggestions_choices_int(self):\n \n     def test_suggestions_choices_mixed_types(self):\n         parser = ErrorRaisingArgumentParser(suggest_on_error=True)\n-        parser.add_argument('foo', choices=[1, '2'])\n+        parser.add_argument(\"foo\", choices=[1, \"2\"])\n         with self.assertRaises(ArgumentParserError) as excinfo:\n-            parser.parse_args(('3',))\n+            parser.parse_args((\"3\",))\n         self.assertIn(\n             \"error: argument foo: invalid choice: '3' (choose from 1, 2)\",\n             excinfo.exception.stderr,\n@@ -2380,34 +2488,45 @@ class ActionWithoutCall(argparse.Action):\n     def test_invalid_type(self):\n         parser = argparse.ArgumentParser()\n \n-        parser.add_argument('--foo', action=self.ActionWithoutCall)\n-        self.assertRaises(NotImplementedError, parser.parse_args, ['--foo', 'bar'])\n+        parser.add_argument(\"--foo\", action=self.ActionWithoutCall)\n+        self.assertRaises(\n+            NotImplementedError, parser.parse_args, [\"--foo\", \"bar\"]\n+        )\n \n     def test_modified_invalid_action(self):\n         parser = argparse.ArgumentParser(exit_on_error=False)\n-        action = parser.add_argument('--foo')\n+        action = parser.add_argument(\"--foo\")\n         # Someone got crazy and did this\n         action.type = 1\n-        self.assertRaisesRegex(TypeError, '1 is not callable',\n-                               parser.parse_args, ['--foo', 'bar'])\n+        self.assertRaisesRegex(\n+            TypeError, \"1 is not callable\", parser.parse_args, [\"--foo\", \"bar\"]\n+        )\n         action.type = ()\n-        self.assertRaisesRegex(TypeError, r'\\(\\) is not callable',\n-                               parser.parse_args, ['--foo', 'bar'])\n+        self.assertRaisesRegex(\n+            TypeError,\n+            r\"\\(\\) is not callable\",\n+            parser.parse_args,\n+            [\"--foo\", \"bar\"],\n+        )\n         # It is impossible to distinguish a TypeError raised due to a mismatch\n         # of the required function arguments from a TypeError raised for an incorrect\n         # argument value, and using the heavy inspection machinery is not worthwhile\n         # as it does not reliably work in all cases.\n         # Therefore, a generic ArgumentError is raised to handle this logical error.\n         action.type = pow\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               \"argument --foo: invalid pow value: 'bar'\",\n-                               parser.parse_args, ['--foo', 'bar'])\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"argument --foo: invalid pow value: 'bar'\",\n+            parser.parse_args,\n+            [\"--foo\", \"bar\"],\n+        )\n \n \n # ================\n # Subparsers tests\n # ================\n \n+\n @force_not_colorized_test_class\n class TestAddSubparsers(TestCase):\n     \"\"\"Test the add_subparsers method\"\"\"\n@@ -2415,61 +2534,74 @@ class TestAddSubparsers(TestCase):\n     def assertArgumentParserError(self, *args, **kwargs):\n         self.assertRaises(ArgumentParserError, *args, **kwargs)\n \n-    def _get_parser(self, subparser_help=False, prefix_chars=None,\n-                    aliases=False, usage=None):\n+    def _get_parser(\n+        self,\n+        subparser_help=False,\n+        prefix_chars=None,\n+        aliases=False,\n+        usage=None,\n+    ):\n         # create a parser with a subparsers argument\n         if prefix_chars:\n             parser = ErrorRaisingArgumentParser(\n-                prog='PROG', description='main description', usage=usage,\n-                prefix_chars=prefix_chars)\n+                prog=\"PROG\",\n+                description=\"main description\",\n+                usage=usage,\n+                prefix_chars=prefix_chars,\n+            )\n             parser.add_argument(\n-                prefix_chars[0] * 2 + 'foo', action='store_true', help='foo help')\n+                prefix_chars[0] * 2 + \"foo\",\n+                action=\"store_true\",\n+                help=\"foo help\",\n+            )\n         else:\n             parser = ErrorRaisingArgumentParser(\n-                prog='PROG', description='main description', usage=usage)\n-            parser.add_argument(\n-                '--foo', action='store_true', help='foo help')\n-        parser.add_argument(\n-            'bar', type=float, help='bar help')\n+                prog=\"PROG\", description=\"main description\", usage=usage\n+            )\n+            parser.add_argument(\"--foo\", action=\"store_true\", help=\"foo help\")\n+        parser.add_argument(\"bar\", type=float, help=\"bar help\")\n \n         # check that only one subparsers argument can be added\n-        subparsers_kwargs = {'required': False}\n+        subparsers_kwargs = {\"required\": False}\n         if aliases:\n-            subparsers_kwargs['metavar'] = 'COMMAND'\n-            subparsers_kwargs['title'] = 'commands'\n+            subparsers_kwargs[\"metavar\"] = \"COMMAND\"\n+            subparsers_kwargs[\"title\"] = \"commands\"\n         else:\n-            subparsers_kwargs['help'] = 'command help'\n+            subparsers_kwargs[\"help\"] = \"command help\"\n         subparsers = parser.add_subparsers(**subparsers_kwargs)\n-        self.assertRaisesRegex(ValueError,\n-                               'cannot have multiple subparser arguments',\n-                               parser.add_subparsers)\n+        self.assertRaisesRegex(\n+            ValueError,\n+            \"cannot have multiple subparser arguments\",\n+            parser.add_subparsers,\n+        )\n \n         # add first sub-parser\n-        parser1_kwargs = dict(description='1 description')\n+        parser1_kwargs = dict(description=\"1 description\")\n         if subparser_help:\n-            parser1_kwargs['help'] = '1 help'\n+            parser1_kwargs[\"help\"] = \"1 help\"\n         if aliases:\n-            parser1_kwargs['aliases'] = ['1alias1', '1alias2']\n-        parser1 = subparsers.add_parser('1', **parser1_kwargs)\n-        parser1.add_argument('-w', type=int, help='w help')\n-        parser1.add_argument('x', choices=['a', 'b', 'c'], help='x help')\n+            parser1_kwargs[\"aliases\"] = [\"1alias1\", \"1alias2\"]\n+        parser1 = subparsers.add_parser(\"1\", **parser1_kwargs)\n+        parser1.add_argument(\"-w\", type=int, help=\"w help\")\n+        parser1.add_argument(\"x\", choices=[\"a\", \"b\", \"c\"], help=\"x help\")\n \n         # add second sub-parser\n-        parser2_kwargs = dict(description='2 description')\n+        parser2_kwargs = dict(description=\"2 description\")\n         if subparser_help:\n-            parser2_kwargs['help'] = '2 help'\n-        parser2 = subparsers.add_parser('2', **parser2_kwargs)\n-        parser2.add_argument('-y', choices=['1', '2', '3'], help='y help')\n-        parser2.add_argument('z', type=complex, nargs='*', help='z help')\n+            parser2_kwargs[\"help\"] = \"2 help\"\n+        parser2 = subparsers.add_parser(\"2\", **parser2_kwargs)\n+        parser2.add_argument(\"-y\", choices=[\"1\", \"2\", \"3\"], help=\"y help\")\n+        parser2.add_argument(\"z\", type=complex, nargs=\"*\", help=\"z help\")\n \n         # add third sub-parser\n-        parser3_kwargs = dict(description='3 description',\n-                              usage='PROG --foo bar 3 t ...')\n+        parser3_kwargs = dict(\n+            description=\"3 description\", usage=\"PROG --foo bar 3 t ...\"\n+        )\n         if subparser_help:\n-            parser3_kwargs['help'] = '3 help'\n-        parser3 = subparsers.add_parser('3', **parser3_kwargs)\n-        parser3.add_argument('t', type=int, help='t help')\n-        parser3.add_argument('u', nargs='...', help='u help')\n+            parser3_kwargs[\"help\"] = \"3 help\"\n+        parser3 = subparsers.add_parser(\"3\", **parser3_kwargs)\n+        parser3.add_argument(\"t\", type=int, help=\"t help\")\n+        parser3.add_argument(\"u\", nargs=\"...\", help=\"u help\")\n \n         # return the main parser\n         return parser\n@@ -2481,189 +2613,243 @@ def setUp(self):\n \n     def test_parse_args_failures(self):\n         # check some failure cases:\n-        for args_str in ['', 'a', 'a a', '0.5 a', '0.5 1',\n-                         '0.5 1 -y', '0.5 2 -w']:\n+        for args_str in [\n+            \"\",\n+            \"a\",\n+            \"a a\",\n+            \"0.5 a\",\n+            \"0.5 1\",\n+            \"0.5 1 -y\",\n+            \"0.5 2 -w\",\n+        ]:\n             args = args_str.split()\n             self.assertArgumentParserError(self.parser.parse_args, args)\n \n     def test_parse_args_failures_details(self):\n         for args_str, usage_str, error_str in [\n-            ('',\n-             'usage: PROG [-h] [--foo] bar {1,2,3} ...',\n-             'PROG: error: the following arguments are required: bar'),\n-            ('0.5 1 -y',\n-             'usage: PROG bar 1 [-h] [-w W] {a,b,c}',\n-             'PROG bar 1: error: the following arguments are required: x'),\n-            ('0.5 3',\n-             'usage: PROG --foo bar 3 t ...',\n-             'PROG bar 3: error: the following arguments are required: t'),\n+            (\n+                \"\",\n+                \"usage: PROG [-h] [--foo] bar {1,2,3} ...\",\n+                \"PROG: error: the following arguments are required: bar\",\n+            ),\n+            (\n+                \"0.5 1 -y\",\n+                \"usage: PROG bar 1 [-h] [-w W] {a,b,c}\",\n+                \"PROG bar 1: error: the following arguments are required: x\",\n+            ),\n+            (\n+                \"0.5 3\",\n+                \"usage: PROG --foo bar 3 t ...\",\n+                \"PROG bar 3: error: the following arguments are required: t\",\n+            ),\n         ]:\n             with self.subTest(args_str):\n                 args = args_str.split()\n                 with self.assertRaises(ArgumentParserError) as cm:\n                     self.parser.parse_args(args)\n-                self.assertEqual(cm.exception.args[0], 'SystemExit')\n-                self.assertEqual(cm.exception.args[2], f'{usage_str}\\n{error_str}\\n')\n+                self.assertEqual(cm.exception.args[0], \"SystemExit\")\n+                self.assertEqual(\n+                    cm.exception.args[2], f\"{usage_str}\\n{error_str}\\n\"\n+                )\n \n     def test_parse_args_failures_details_custom_usage(self):\n-        parser = self._get_parser(usage='PROG [--foo] bar 1 [-w W] {a,b,c}\\n'\n-                                 '       PROG --foo bar 3 t ...')\n+        parser = self._get_parser(\n+            usage=\"PROG [--foo] bar 1 [-w W] {a,b,c}\\n\"\n+            \"       PROG --foo bar 3 t ...\"\n+        )\n         for args_str, usage_str, error_str in [\n-            ('',\n-             'usage: PROG [--foo] bar 1 [-w W] {a,b,c}\\n'\n-             '       PROG --foo bar 3 t ...',\n-             'PROG: error: the following arguments are required: bar'),\n-            ('0.5 1 -y',\n-             'usage: PROG bar 1 [-h] [-w W] {a,b,c}',\n-             'PROG bar 1: error: the following arguments are required: x'),\n-            ('0.5 3',\n-             'usage: PROG --foo bar 3 t ...',\n-             'PROG bar 3: error: the following arguments are required: t'),\n+            (\n+                \"\",\n+                \"usage: PROG [--foo] bar 1 [-w W] {a,b,c}\\n\"\n+                \"       PROG --foo bar 3 t ...\",\n+                \"PROG: error: the following arguments are required: bar\",\n+            ),\n+            (\n+                \"0.5 1 -y\",\n+                \"usage: PROG bar 1 [-h] [-w W] {a,b,c}\",\n+                \"PROG bar 1: error: the following arguments are required: x\",\n+            ),\n+            (\n+                \"0.5 3\",\n+                \"usage: PROG --foo bar 3 t ...\",\n+                \"PROG bar 3: error: the following arguments are required: t\",\n+            ),\n         ]:\n             with self.subTest(args_str):\n                 args = args_str.split()\n                 with self.assertRaises(ArgumentParserError) as cm:\n                     parser.parse_args(args)\n-                self.assertEqual(cm.exception.args[0], 'SystemExit')\n-                self.assertEqual(cm.exception.args[2], f'{usage_str}\\n{error_str}\\n')\n+                self.assertEqual(cm.exception.args[0], \"SystemExit\")\n+                self.assertEqual(\n+                    cm.exception.args[2], f\"{usage_str}\\n{error_str}\\n\"\n+                )\n \n     def test_parse_args(self):\n         # check some non-failure cases:\n         self.assertEqual(\n-            self.parser.parse_args('0.5 1 b -w 7'.split()),\n-            NS(foo=False, bar=0.5, w=7, x='b'),\n+            self.parser.parse_args(\"0.5 1 b -w 7\".split()),\n+            NS(foo=False, bar=0.5, w=7, x=\"b\"),\n         )\n         self.assertEqual(\n-            self.parser.parse_args('0.25 --foo 2 -y 2 3j -- -1j'.split()),\n-            NS(foo=True, bar=0.25, y='2', z=[3j, -1j]),\n+            self.parser.parse_args(\"0.25 --foo 2 -y 2 3j -- -1j\".split()),\n+            NS(foo=True, bar=0.25, y=\"2\", z=[3j, -1j]),\n         )\n         self.assertEqual(\n-            self.parser.parse_args('--foo 0.125 1 c'.split()),\n-            NS(foo=True, bar=0.125, w=None, x='c'),\n+            self.parser.parse_args(\"--foo 0.125 1 c\".split()),\n+            NS(foo=True, bar=0.125, w=None, x=\"c\"),\n         )\n         self.assertEqual(\n-            self.parser.parse_args('-1.5 3 11 -- a --foo 7 -- b'.split()),\n-            NS(foo=False, bar=-1.5, t=11, u=['a', '--foo', '7', '--', 'b']),\n+            self.parser.parse_args(\"-1.5 3 11 -- a --foo 7 -- b\".split()),\n+            NS(foo=False, bar=-1.5, t=11, u=[\"a\", \"--foo\", \"7\", \"--\", \"b\"]),\n         )\n \n     def test_parse_known_args(self):\n         self.assertEqual(\n-            self.parser.parse_known_args('0.5 1 b -w 7'.split()),\n-            (NS(foo=False, bar=0.5, w=7, x='b'), []),\n+            self.parser.parse_known_args(\"0.5 1 b -w 7\".split()),\n+            (NS(foo=False, bar=0.5, w=7, x=\"b\"), []),\n         )\n         self.assertEqual(\n-            self.parser.parse_known_args('0.5 -p 1 b -w 7'.split()),\n-            (NS(foo=False, bar=0.5, w=7, x='b'), ['-p']),\n+            self.parser.parse_known_args(\"0.5 -p 1 b -w 7\".split()),\n+            (NS(foo=False, bar=0.5, w=7, x=\"b\"), [\"-p\"]),\n         )\n         self.assertEqual(\n-            self.parser.parse_known_args('0.5 1 b -w 7 -p'.split()),\n-            (NS(foo=False, bar=0.5, w=7, x='b'), ['-p']),\n+            self.parser.parse_known_args(\"0.5 1 b -w 7 -p\".split()),\n+            (NS(foo=False, bar=0.5, w=7, x=\"b\"), [\"-p\"]),\n         )\n         self.assertEqual(\n-            self.parser.parse_known_args('0.5 1 b -q -rs -w 7'.split()),\n-            (NS(foo=False, bar=0.5, w=7, x='b'), ['-q', '-rs']),\n+            self.parser.parse_known_args(\"0.5 1 b -q -rs -w 7\".split()),\n+            (NS(foo=False, bar=0.5, w=7, x=\"b\"), [\"-q\", \"-rs\"]),\n         )\n         self.assertEqual(\n-            self.parser.parse_known_args('0.5 -W 1 b -X Y -w 7 Z'.split()),\n-            (NS(foo=False, bar=0.5, w=7, x='b'), ['-W', '-X', 'Y', 'Z']),\n+            self.parser.parse_known_args(\"0.5 -W 1 b -X Y -w 7 Z\".split()),\n+            (NS(foo=False, bar=0.5, w=7, x=\"b\"), [\"-W\", \"-X\", \"Y\", \"Z\"]),\n         )\n \n     def test_parse_known_args_to_class_namespace(self):\n         class C:\n             pass\n+\n         self.assertEqual(\n-            self.parser.parse_known_args('0.5 1 b -w 7 -p'.split(), namespace=C),\n-            (C, ['-p']),\n+            self.parser.parse_known_args(\n+                \"0.5 1 b -w 7 -p\".split(), namespace=C\n+            ),\n+            (C, [\"-p\"]),\n         )\n         self.assertIs(C.foo, False)\n         self.assertEqual(C.bar, 0.5)\n         self.assertEqual(C.w, 7)\n-        self.assertEqual(C.x, 'b')\n+        self.assertEqual(C.x, \"b\")\n \n     def test_abbreviation(self):\n         parser = ErrorRaisingArgumentParser()\n-        parser.add_argument('--foodle')\n-        parser.add_argument('--foonly')\n+        parser.add_argument(\"--foodle\")\n+        parser.add_argument(\"--foonly\")\n         subparsers = parser.add_subparsers()\n-        parser1 = subparsers.add_parser('bar')\n-        parser1.add_argument('--fo')\n-        parser1.add_argument('--foonew')\n-\n-        self.assertEqual(parser.parse_args(['--food', 'baz', 'bar']),\n-                         NS(foodle='baz', foonly=None, fo=None, foonew=None))\n-        self.assertEqual(parser.parse_args(['--foon', 'baz', 'bar']),\n-                         NS(foodle=None, foonly='baz', fo=None, foonew=None))\n-        self.assertArgumentParserError(parser.parse_args, ['--fo', 'baz', 'bar'])\n-        self.assertEqual(parser.parse_args(['bar', '--fo', 'baz']),\n-                         NS(foodle=None, foonly=None, fo='baz', foonew=None))\n-        self.assertEqual(parser.parse_args(['bar', '--foo', 'baz']),\n-                         NS(foodle=None, foonly=None, fo=None, foonew='baz'))\n-        self.assertEqual(parser.parse_args(['bar', '--foon', 'baz']),\n-                         NS(foodle=None, foonly=None, fo=None, foonew='baz'))\n-        self.assertArgumentParserError(parser.parse_args, ['bar', '--food', 'baz'])\n+        parser1 = subparsers.add_parser(\"bar\")\n+        parser1.add_argument(\"--fo\")\n+        parser1.add_argument(\"--foonew\")\n+\n+        self.assertEqual(\n+            parser.parse_args([\"--food\", \"baz\", \"bar\"]),\n+            NS(foodle=\"baz\", foonly=None, fo=None, foonew=None),\n+        )\n+        self.assertEqual(\n+            parser.parse_args([\"--foon\", \"baz\", \"bar\"]),\n+            NS(foodle=None, foonly=\"baz\", fo=None, foonew=None),\n+        )\n+        self.assertArgumentParserError(\n+            parser.parse_args, [\"--fo\", \"baz\", \"bar\"]\n+        )\n+        self.assertEqual(\n+            parser.parse_args([\"bar\", \"--fo\", \"baz\"]),\n+            NS(foodle=None, foonly=None, fo=\"baz\", foonew=None),\n+        )\n+        self.assertEqual(\n+            parser.parse_args([\"bar\", \"--foo\", \"baz\"]),\n+            NS(foodle=None, foonly=None, fo=None, foonew=\"baz\"),\n+        )\n+        self.assertEqual(\n+            parser.parse_args([\"bar\", \"--foon\", \"baz\"]),\n+            NS(foodle=None, foonly=None, fo=None, foonew=\"baz\"),\n+        )\n+        self.assertArgumentParserError(\n+            parser.parse_args, [\"bar\", \"--food\", \"baz\"]\n+        )\n \n     def test_parse_known_args_with_single_dash_option(self):\n         parser = ErrorRaisingArgumentParser()\n-        parser.add_argument('-k', '--known', action='count', default=0)\n-        parser.add_argument('-n', '--new', action='count', default=0)\n-        self.assertEqual(parser.parse_known_args(['-k', '-u']),\n-                         (NS(known=1, new=0), ['-u']))\n-        self.assertEqual(parser.parse_known_args(['-u', '-k']),\n-                         (NS(known=1, new=0), ['-u']))\n-        self.assertEqual(parser.parse_known_args(['-ku']),\n-                         (NS(known=1, new=0), ['-u']))\n-        self.assertArgumentParserError(parser.parse_known_args, ['-k=u'])\n-        self.assertEqual(parser.parse_known_args(['-uk']),\n-                         (NS(known=0, new=0), ['-uk']))\n-        self.assertEqual(parser.parse_known_args(['-u=k']),\n-                         (NS(known=0, new=0), ['-u=k']))\n-        self.assertEqual(parser.parse_known_args(['-kunknown']),\n-                         (NS(known=1, new=0), ['-unknown']))\n-        self.assertArgumentParserError(parser.parse_known_args, ['-k=unknown'])\n-        self.assertEqual(parser.parse_known_args(['-ku=nknown']),\n-                         (NS(known=1, new=0), ['-u=nknown']))\n-        self.assertEqual(parser.parse_known_args(['-knew']),\n-                         (NS(known=1, new=1), ['-ew']))\n-        self.assertArgumentParserError(parser.parse_known_args, ['-kn=ew'])\n-        self.assertArgumentParserError(parser.parse_known_args, ['-k-new'])\n-        self.assertArgumentParserError(parser.parse_known_args, ['-kn-ew'])\n-        self.assertEqual(parser.parse_known_args(['-kne-w']),\n-                         (NS(known=1, new=1), ['-e-w']))\n+        parser.add_argument(\"-k\", \"--known\", action=\"count\", default=0)\n+        parser.add_argument(\"-n\", \"--new\", action=\"count\", default=0)\n+        self.assertEqual(\n+            parser.parse_known_args([\"-k\", \"-u\"]), (NS(known=1, new=0), [\"-u\"])\n+        )\n+        self.assertEqual(\n+            parser.parse_known_args([\"-u\", \"-k\"]), (NS(known=1, new=0), [\"-u\"])\n+        )\n+        self.assertEqual(\n+            parser.parse_known_args([\"-ku\"]), (NS(known=1, new=0), [\"-u\"])\n+        )\n+        self.assertArgumentParserError(parser.parse_known_args, [\"-k=u\"])\n+        self.assertEqual(\n+            parser.parse_known_args([\"-uk\"]), (NS(known=0, new=0), [\"-uk\"])\n+        )\n+        self.assertEqual(\n+            parser.parse_known_args([\"-u=k\"]), (NS(known=0, new=0), [\"-u=k\"])\n+        )\n+        self.assertEqual(\n+            parser.parse_known_args([\"-kunknown\"]),\n+            (NS(known=1, new=0), [\"-unknown\"]),\n+        )\n+        self.assertArgumentParserError(parser.parse_known_args, [\"-k=unknown\"])\n+        self.assertEqual(\n+            parser.parse_known_args([\"-ku=nknown\"]),\n+            (NS(known=1, new=0), [\"-u=nknown\"]),\n+        )\n+        self.assertEqual(\n+            parser.parse_known_args([\"-knew\"]), (NS(known=1, new=1), [\"-ew\"])\n+        )\n+        self.assertArgumentParserError(parser.parse_known_args, [\"-kn=ew\"])\n+        self.assertArgumentParserError(parser.parse_known_args, [\"-k-new\"])\n+        self.assertArgumentParserError(parser.parse_known_args, [\"-kn-ew\"])\n+        self.assertEqual(\n+            parser.parse_known_args([\"-kne-w\"]), (NS(known=1, new=1), [\"-e-w\"])\n+        )\n \n     def test_dest(self):\n         parser = ErrorRaisingArgumentParser()\n-        parser.add_argument('--foo', action='store_true')\n-        subparsers = parser.add_subparsers(dest='bar')\n-        parser1 = subparsers.add_parser('1')\n-        parser1.add_argument('baz')\n-        self.assertEqual(NS(foo=False, bar='1', baz='2'),\n-                         parser.parse_args('1 2'.split()))\n+        parser.add_argument(\"--foo\", action=\"store_true\")\n+        subparsers = parser.add_subparsers(dest=\"bar\")\n+        parser1 = subparsers.add_parser(\"1\")\n+        parser1.add_argument(\"baz\")\n+        self.assertEqual(\n+            NS(foo=False, bar=\"1\", baz=\"2\"), parser.parse_args(\"1 2\".split())\n+        )\n \n     def _test_required_subparsers(self, parser):\n         # Should parse the sub command\n-        ret = parser.parse_args(['run'])\n-        self.assertEqual(ret.command, 'run')\n+        ret = parser.parse_args([\"run\"])\n+        self.assertEqual(ret.command, \"run\")\n \n         # Error when the command is missing\n         self.assertArgumentParserError(parser.parse_args, ())\n \n     def test_required_subparsers_via_attribute(self):\n         parser = ErrorRaisingArgumentParser()\n-        subparsers = parser.add_subparsers(dest='command')\n+        subparsers = parser.add_subparsers(dest=\"command\")\n         subparsers.required = True\n-        subparsers.add_parser('run')\n+        subparsers.add_parser(\"run\")\n         self._test_required_subparsers(parser)\n \n     def test_required_subparsers_via_kwarg(self):\n         parser = ErrorRaisingArgumentParser()\n-        subparsers = parser.add_subparsers(dest='command', required=True)\n-        subparsers.add_parser('run')\n+        subparsers = parser.add_subparsers(dest=\"command\", required=True)\n+        subparsers.add_parser(\"run\")\n         self._test_required_subparsers(parser)\n \n     def test_required_subparsers_default(self):\n         parser = ErrorRaisingArgumentParser()\n-        subparsers = parser.add_subparsers(dest='command')\n-        subparsers.add_parser('run')\n+        subparsers = parser.add_subparsers(dest=\"command\")\n+        subparsers.add_parser(\"run\")\n         # No error here\n         ret = parser.parse_args(())\n         self.assertIsNone(ret.command)\n@@ -2671,27 +2857,31 @@ def test_required_subparsers_default(self):\n     def test_required_subparsers_no_destination_error(self):\n         parser = ErrorRaisingArgumentParser()\n         subparsers = parser.add_subparsers(required=True)\n-        subparsers.add_parser('foo')\n-        subparsers.add_parser('bar')\n+        subparsers.add_parser(\"foo\")\n+        subparsers.add_parser(\"bar\")\n         with self.assertRaises(ArgumentParserError) as excinfo:\n             parser.parse_args(())\n         self.assertRegex(\n             excinfo.exception.stderr,\n-            'error: the following arguments are required: {foo,bar}\\n$'\n+            \"error: the following arguments are required: {foo,bar}\\n$\",\n         )\n \n     def test_optional_subparsers(self):\n         parser = ErrorRaisingArgumentParser()\n-        subparsers = parser.add_subparsers(dest='command', required=False)\n-        subparsers.add_parser('run')\n+        subparsers = parser.add_subparsers(dest=\"command\", required=False)\n+        subparsers.add_parser(\"run\")\n         # No error here\n         ret = parser.parse_args(())\n         self.assertIsNone(ret.command)\n \n     def test_help(self):\n-        self.assertEqual(self.parser.format_usage(),\n-                         'usage: PROG [-h] [--foo] bar {1,2,3} ...\\n')\n-        self.assertEqual(self.parser.format_help(), textwrap.dedent('''\\\n+        self.assertEqual(\n+            self.parser.format_usage(),\n+            \"usage: PROG [-h] [--foo] bar {1,2,3} ...\\n\",\n+        )\n+        self.assertEqual(\n+            self.parser.format_help(),\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [--foo] bar {1,2,3} ...\n \n             main description\n@@ -2703,14 +2893,18 @@ def test_help(self):\n             options:\n               -h, --help  show this help message and exit\n               --foo       foo help\n-            '''))\n+            \"\"\"),\n+        )\n \n     def test_help_extra_prefix_chars(self):\n         # Make sure - is still used for help if it is a non-first prefix char\n-        parser = self._get_parser(prefix_chars='+:-')\n-        self.assertEqual(parser.format_usage(),\n-                         'usage: PROG [-h] [++foo] bar {1,2,3} ...\\n')\n-        self.assertEqual(parser.format_help(), textwrap.dedent('''\\\n+        parser = self._get_parser(prefix_chars=\"+:-\")\n+        self.assertEqual(\n+            parser.format_usage(), \"usage: PROG [-h] [++foo] bar {1,2,3} ...\\n\"\n+        )\n+        self.assertEqual(\n+            parser.format_help(),\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [++foo] bar {1,2,3} ...\n \n             main description\n@@ -2722,16 +2916,22 @@ def test_help_extra_prefix_chars(self):\n             options:\n               -h, --help  show this help message and exit\n               ++foo       foo help\n-            '''))\n+            \"\"\"),\n+        )\n \n     def test_help_non_breaking_spaces(self):\n         parser = ErrorRaisingArgumentParser(\n-            prog='PROG', description='main description')\n+            prog=\"PROG\", description=\"main description\"\n+        )\n         parser.add_argument(\n-            \"--non-breaking\", action='store_false',\n-            help='help message containing non-breaking spaces shall not '\n-            'wrap\\N{NO-BREAK SPACE}at non-breaking spaces')\n-        self.assertEqual(parser.format_help(), textwrap.dedent('''\\\n+            \"--non-breaking\",\n+            action=\"store_false\",\n+            help=\"help message containing non-breaking spaces shall not \"\n+            \"wrap\\N{NO-BREAK SPACE}at non-breaking spaces\",\n+        )\n+        self.assertEqual(\n+            parser.format_help(),\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [--non-breaking]\n \n             main description\n@@ -2740,16 +2940,18 @@ def test_help_non_breaking_spaces(self):\n               -h, --help      show this help message and exit\n               --non-breaking  help message containing non-breaking spaces shall not\n                               wrap\\N{NO-BREAK SPACE}at non-breaking spaces\n-        '''))\n+        \"\"\"),\n+        )\n \n     def test_help_blank(self):\n         # Issue 24444\n         parser = ErrorRaisingArgumentParser(\n-            prog='PROG', description='main description')\n-        parser.add_argument(\n-            'foo',\n-            help='    ')\n-        self.assertEqual(parser.format_help(), textwrap.dedent('''\\\n+            prog=\"PROG\", description=\"main description\"\n+        )\n+        parser.add_argument(\"foo\", help=\"    \")\n+        self.assertEqual(\n+            parser.format_help(),\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] foo\n \n             main description\n@@ -2758,14 +2960,16 @@ def test_help_blank(self):\n               foo         \\n\n             options:\n               -h, --help  show this help message and exit\n-        '''))\n+        \"\"\"),\n+        )\n \n         parser = ErrorRaisingArgumentParser(\n-            prog='PROG', description='main description')\n-        parser.add_argument(\n-            'foo', choices=[],\n-            help='%(choices)s')\n-        self.assertEqual(parser.format_help(), textwrap.dedent('''\\\n+            prog=\"PROG\", description=\"main description\"\n+        )\n+        parser.add_argument(\"foo\", choices=[], help=\"%(choices)s\")\n+        self.assertEqual(\n+            parser.format_help(),\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] {}\n \n             main description\n@@ -2774,13 +2978,17 @@ def test_help_blank(self):\n               {}          \\n\n             options:\n               -h, --help  show this help message and exit\n-        '''))\n+        \"\"\"),\n+        )\n \n     def test_help_alternate_prefix_chars(self):\n-        parser = self._get_parser(prefix_chars='+:/')\n-        self.assertEqual(parser.format_usage(),\n-                         'usage: PROG [+h] [++foo] bar {1,2,3} ...\\n')\n-        self.assertEqual(parser.format_help(), textwrap.dedent('''\\\n+        parser = self._get_parser(prefix_chars=\"+:/\")\n+        self.assertEqual(\n+            parser.format_usage(), \"usage: PROG [+h] [++foo] bar {1,2,3} ...\\n\"\n+        )\n+        self.assertEqual(\n+            parser.format_help(),\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [+h] [++foo] bar {1,2,3} ...\n \n             main description\n@@ -2792,13 +3000,17 @@ def test_help_alternate_prefix_chars(self):\n             options:\n               +h, ++help  show this help message and exit\n               ++foo       foo help\n-            '''))\n+            \"\"\"),\n+        )\n \n     def test_parser_command_help(self):\n-        self.assertEqual(self.command_help_parser.format_usage(),\n-                         'usage: PROG [-h] [--foo] bar {1,2,3} ...\\n')\n-        self.assertEqual(self.command_help_parser.format_help(),\n-                         textwrap.dedent('''\\\n+        self.assertEqual(\n+            self.command_help_parser.format_usage(),\n+            \"usage: PROG [-h] [--foo] bar {1,2,3} ...\\n\",\n+        )\n+        self.assertEqual(\n+            self.command_help_parser.format_help(),\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [--foo] bar {1,2,3} ...\n \n             main description\n@@ -2813,44 +3025,58 @@ def test_parser_command_help(self):\n             options:\n               -h, --help  show this help message and exit\n               --foo       foo help\n-            '''))\n+            \"\"\"),\n+        )\n \n     def assert_bad_help(self, context_type, func, *args, **kwargs):\n-        with self.assertRaisesRegex(ValueError, 'badly formed help string') as cm:\n+        with self.assertRaisesRegex(\n+            ValueError, \"badly formed help string\"\n+        ) as cm:\n             func(*args, **kwargs)\n         self.assertIsInstance(cm.exception.__context__, context_type)\n \n     def test_invalid_subparsers_help(self):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n-        self.assert_bad_help(ValueError, parser.add_subparsers, help='%Y-%m-%d')\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n-        self.assert_bad_help(KeyError, parser.add_subparsers, help='%(spam)s')\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n-        self.assert_bad_help(TypeError, parser.add_subparsers, help='%(prog)d')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n+        self.assert_bad_help(\n+            ValueError, parser.add_subparsers, help=\"%Y-%m-%d\"\n+        )\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n+        self.assert_bad_help(KeyError, parser.add_subparsers, help=\"%(spam)s\")\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n+        self.assert_bad_help(TypeError, parser.add_subparsers, help=\"%(prog)d\")\n \n     def test_invalid_subparser_help(self):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         subparsers = parser.add_subparsers()\n-        self.assert_bad_help(ValueError, subparsers.add_parser, '1',\n-                             help='%Y-%m-%d')\n-        self.assert_bad_help(KeyError, subparsers.add_parser, '1',\n-                             help='%(spam)s')\n-        self.assert_bad_help(TypeError, subparsers.add_parser, '1',\n-                             help='%(prog)d')\n+        self.assert_bad_help(\n+            ValueError, subparsers.add_parser, \"1\", help=\"%Y-%m-%d\"\n+        )\n+        self.assert_bad_help(\n+            KeyError, subparsers.add_parser, \"1\", help=\"%(spam)s\"\n+        )\n+        self.assert_bad_help(\n+            TypeError, subparsers.add_parser, \"1\", help=\"%(prog)d\"\n+        )\n \n     def test_subparser_title_help(self):\n-        parser = ErrorRaisingArgumentParser(prog='PROG',\n-                                            description='main description')\n-        parser.add_argument('--foo', action='store_true', help='foo help')\n-        parser.add_argument('bar', help='bar help')\n-        subparsers = parser.add_subparsers(title='subcommands',\n-                                           description='command help',\n-                                           help='additional text')\n-        parser1 = subparsers.add_parser('1')\n-        parser2 = subparsers.add_parser('2')\n-        self.assertEqual(parser.format_usage(),\n-                         'usage: PROG [-h] [--foo] bar {1,2} ...\\n')\n-        self.assertEqual(parser.format_help(), textwrap.dedent('''\\\n+        parser = ErrorRaisingArgumentParser(\n+            prog=\"PROG\", description=\"main description\"\n+        )\n+        parser.add_argument(\"--foo\", action=\"store_true\", help=\"foo help\")\n+        parser.add_argument(\"bar\", help=\"bar help\")\n+        subparsers = parser.add_subparsers(\n+            title=\"subcommands\",\n+            description=\"command help\",\n+            help=\"additional text\",\n+        )\n+        parser1 = subparsers.add_parser(\"1\")\n+        parser2 = subparsers.add_parser(\"2\")\n+        self.assertEqual(\n+            parser.format_usage(), \"usage: PROG [-h] [--foo] bar {1,2} ...\\n\"\n+        )\n+        self.assertEqual(\n+            parser.format_help(),\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [--foo] bar {1,2} ...\n \n             main description\n@@ -2866,7 +3092,8 @@ def test_subparser_title_help(self):\n               command help\n \n               {1,2}       additional text\n-            '''))\n+            \"\"\"),\n+        )\n \n     def _test_subparser_help(self, args_str, expected_help):\n         with self.assertRaises(ArgumentParserError) as cm:\n@@ -2874,7 +3101,9 @@ def _test_subparser_help(self, args_str, expected_help):\n         self.assertEqual(expected_help, cm.exception.stdout)\n \n     def test_subparser1_help(self):\n-        self._test_subparser_help('5.0 1 -h', textwrap.dedent('''\\\n+        self._test_subparser_help(\n+            \"5.0 1 -h\",\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG bar 1 [-h] [-w W] {a,b,c}\n \n             1 description\n@@ -2885,10 +3114,13 @@ def test_subparser1_help(self):\n             options:\n               -h, --help  show this help message and exit\n               -w W        w help\n-            '''))\n+            \"\"\"),\n+        )\n \n     def test_subparser2_help(self):\n-        self._test_subparser_help('5.0 2 -h', textwrap.dedent('''\\\n+        self._test_subparser_help(\n+            \"5.0 2 -h\",\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG bar 2 [-h] [-y {1,2,3}] [z ...]\n \n             2 description\n@@ -2899,28 +3131,32 @@ def test_subparser2_help(self):\n             options:\n               -h, --help  show this help message and exit\n               -y {1,2,3}  y help\n-            '''))\n+            \"\"\"),\n+        )\n \n     def test_alias_invocation(self):\n         parser = self._get_parser(aliases=True)\n         self.assertEqual(\n-            parser.parse_known_args('0.5 1alias1 b'.split()),\n-            (NS(foo=False, bar=0.5, w=None, x='b'), []),\n+            parser.parse_known_args(\"0.5 1alias1 b\".split()),\n+            (NS(foo=False, bar=0.5, w=None, x=\"b\"), []),\n         )\n         self.assertEqual(\n-            parser.parse_known_args('0.5 1alias2 b'.split()),\n-            (NS(foo=False, bar=0.5, w=None, x='b'), []),\n+            parser.parse_known_args(\"0.5 1alias2 b\".split()),\n+            (NS(foo=False, bar=0.5, w=None, x=\"b\"), []),\n         )\n \n     def test_error_alias_invocation(self):\n         parser = self._get_parser(aliases=True)\n-        self.assertArgumentParserError(parser.parse_args,\n-                                       '0.5 1alias3 b'.split())\n+        self.assertArgumentParserError(\n+            parser.parse_args, \"0.5 1alias3 b\".split()\n+        )\n \n     def test_alias_help(self):\n         parser = self._get_parser(aliases=True, subparser_help=True)\n         self.maxDiff = None\n-        self.assertEqual(parser.format_help(), textwrap.dedent(\"\"\"\\\n+        self.assertEqual(\n+            parser.format_help(),\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [--foo] bar COMMAND ...\n \n             main description\n@@ -2938,47 +3174,51 @@ def test_alias_help(self):\n                                     1 help\n                 2                   2 help\n                 3                   3 help\n-            \"\"\"))\n+            \"\"\"),\n+        )\n+\n \n # ============\n # Groups tests\n # ============\n \n+\n class TestPositionalsGroups(TestCase):\n     \"\"\"Tests that order of group positionals matches construction order\"\"\"\n \n     def test_nongroup_first(self):\n         parser = ErrorRaisingArgumentParser()\n-        parser.add_argument('foo')\n-        group = parser.add_argument_group('g')\n-        group.add_argument('bar')\n-        parser.add_argument('baz')\n-        expected = NS(foo='1', bar='2', baz='3')\n-        result = parser.parse_args('1 2 3'.split())\n+        parser.add_argument(\"foo\")\n+        group = parser.add_argument_group(\"g\")\n+        group.add_argument(\"bar\")\n+        parser.add_argument(\"baz\")\n+        expected = NS(foo=\"1\", bar=\"2\", baz=\"3\")\n+        result = parser.parse_args(\"1 2 3\".split())\n         self.assertEqual(expected, result)\n \n     def test_group_first(self):\n         parser = ErrorRaisingArgumentParser()\n-        group = parser.add_argument_group('xxx')\n-        group.add_argument('foo')\n-        parser.add_argument('bar')\n-        parser.add_argument('baz')\n-        expected = NS(foo='1', bar='2', baz='3')\n-        result = parser.parse_args('1 2 3'.split())\n+        group = parser.add_argument_group(\"xxx\")\n+        group.add_argument(\"foo\")\n+        parser.add_argument(\"bar\")\n+        parser.add_argument(\"baz\")\n+        expected = NS(foo=\"1\", bar=\"2\", baz=\"3\")\n+        result = parser.parse_args(\"1 2 3\".split())\n         self.assertEqual(expected, result)\n \n     def test_interleaved_groups(self):\n         parser = ErrorRaisingArgumentParser()\n-        group = parser.add_argument_group('xxx')\n-        parser.add_argument('foo')\n-        group.add_argument('bar')\n-        parser.add_argument('baz')\n-        group = parser.add_argument_group('yyy')\n-        group.add_argument('frell')\n-        expected = NS(foo='1', bar='2', baz='3', frell='4')\n-        result = parser.parse_args('1 2 3 4'.split())\n+        group = parser.add_argument_group(\"xxx\")\n+        parser.add_argument(\"foo\")\n+        group.add_argument(\"bar\")\n+        parser.add_argument(\"baz\")\n+        group = parser.add_argument_group(\"yyy\")\n+        group.add_argument(\"frell\")\n+        expected = NS(foo=\"1\", bar=\"2\", baz=\"3\", frell=\"4\")\n+        result = parser.parse_args(\"1 2 3 4\".split())\n         self.assertEqual(expected, result)\n \n+\n class TestGroupConstructor(TestCase):\n     def test_group_prefix_chars(self):\n         parser = ErrorRaisingArgumentParser()\n@@ -2987,7 +3227,7 @@ def test_group_prefix_chars(self):\n             \"ArgumentParser.add_argument_group() is deprecated.\"\n         )\n         with self.assertWarns(DeprecationWarning) as cm:\n-            parser.add_argument_group(prefix_chars='-+')\n+            parser.add_argument_group(prefix_chars=\"-+\")\n         self.assertEqual(msg, str(cm.warning))\n         self.assertEqual(cm.filename, __file__)\n \n@@ -3000,21 +3240,25 @@ def test_group_prefix_chars_default(self):\n             \"ArgumentParser.add_argument_group() is deprecated.\"\n         )\n         with self.assertWarns(DeprecationWarning) as cm:\n-            parser.add_argument_group(prefix_chars='-')\n+            parser.add_argument_group(prefix_chars=\"-\")\n         self.assertEqual(msg, str(cm.warning))\n         self.assertEqual(cm.filename, __file__)\n \n     def test_nested_argument_group(self):\n         parser = argparse.ArgumentParser()\n         g = parser.add_argument_group()\n-        self.assertRaisesRegex(ValueError,\n-                                 'argument groups cannot be nested',\n-                                 g.add_argument_group)\n+        self.assertRaisesRegex(\n+            ValueError,\n+            \"argument groups cannot be nested\",\n+            g.add_argument_group,\n+        )\n+\n \n # ===================\n # Parent parser tests\n # ===================\n \n+\n @force_not_colorized_test_class\n class TestParentParsers(TestCase):\n     \"\"\"Tests that parsers can be created with parent parsers\"\"\"\n@@ -3025,33 +3269,34 @@ def assertArgumentParserError(self, *args, **kwargs):\n     def setUp(self):\n         super().setUp()\n         self.wxyz_parent = ErrorRaisingArgumentParser(add_help=False)\n-        self.wxyz_parent.add_argument('--w')\n-        x_group = self.wxyz_parent.add_argument_group('x')\n-        x_group.add_argument('-y')\n-        self.wxyz_parent.add_argument('z')\n+        self.wxyz_parent.add_argument(\"--w\")\n+        x_group = self.wxyz_parent.add_argument_group(\"x\")\n+        x_group.add_argument(\"-y\")\n+        self.wxyz_parent.add_argument(\"z\")\n \n         self.abcd_parent = ErrorRaisingArgumentParser(add_help=False)\n-        self.abcd_parent.add_argument('a')\n-        self.abcd_parent.add_argument('-b')\n-        c_group = self.abcd_parent.add_argument_group('c')\n-        c_group.add_argument('--d')\n+        self.abcd_parent.add_argument(\"a\")\n+        self.abcd_parent.add_argument(\"-b\")\n+        c_group = self.abcd_parent.add_argument_group(\"c\")\n+        c_group.add_argument(\"--d\")\n \n         self.w_parent = ErrorRaisingArgumentParser(add_help=False)\n-        self.w_parent.add_argument('--w')\n+        self.w_parent.add_argument(\"--w\")\n \n         self.z_parent = ErrorRaisingArgumentParser(add_help=False)\n-        self.z_parent.add_argument('z')\n+        self.z_parent.add_argument(\"z\")\n \n         # parents with mutually exclusive groups\n         self.ab_mutex_parent = ErrorRaisingArgumentParser(add_help=False)\n         group = self.ab_mutex_parent.add_mutually_exclusive_group()\n-        group.add_argument('-a', action='store_true')\n-        group.add_argument('-b', action='store_true')\n+        group.add_argument(\"-a\", action=\"store_true\")\n+        group.add_argument(\"-b\", action=\"store_true\")\n \n     def test_single_parent(self):\n         parser = ErrorRaisingArgumentParser(parents=[self.wxyz_parent])\n-        self.assertEqual(parser.parse_args('-y 1 2 --w 3'.split()),\n-                         NS(w='3', y='1', z='2'))\n+        self.assertEqual(\n+            parser.parse_args(\"-y 1 2 --w 3\".split()), NS(w=\"3\", y=\"1\", z=\"2\")\n+        )\n \n     def test_single_parent_mutex(self):\n         self._test_mutex_ab(self.ab_mutex_parent.parse_args)\n@@ -3066,80 +3311,98 @@ def test_single_grandparent_mutex(self):\n \n     def _test_mutex_ab(self, parse_args):\n         self.assertEqual(parse_args([]), NS(a=False, b=False))\n-        self.assertEqual(parse_args(['-a']), NS(a=True, b=False))\n-        self.assertEqual(parse_args(['-b']), NS(a=False, b=True))\n-        self.assertArgumentParserError(parse_args, ['-a', '-b'])\n-        self.assertArgumentParserError(parse_args, ['-b', '-a'])\n-        self.assertArgumentParserError(parse_args, ['-c'])\n-        self.assertArgumentParserError(parse_args, ['-a', '-c'])\n-        self.assertArgumentParserError(parse_args, ['-b', '-c'])\n+        self.assertEqual(parse_args([\"-a\"]), NS(a=True, b=False))\n+        self.assertEqual(parse_args([\"-b\"]), NS(a=False, b=True))\n+        self.assertArgumentParserError(parse_args, [\"-a\", \"-b\"])\n+        self.assertArgumentParserError(parse_args, [\"-b\", \"-a\"])\n+        self.assertArgumentParserError(parse_args, [\"-c\"])\n+        self.assertArgumentParserError(parse_args, [\"-a\", \"-c\"])\n+        self.assertArgumentParserError(parse_args, [\"-b\", \"-c\"])\n \n     def test_multiple_parents(self):\n         parents = [self.abcd_parent, self.wxyz_parent]\n         parser = ErrorRaisingArgumentParser(parents=parents)\n-        self.assertEqual(parser.parse_args('--d 1 --w 2 3 4'.split()),\n-                         NS(a='3', b=None, d='1', w='2', y=None, z='4'))\n+        self.assertEqual(\n+            parser.parse_args(\"--d 1 --w 2 3 4\".split()),\n+            NS(a=\"3\", b=None, d=\"1\", w=\"2\", y=None, z=\"4\"),\n+        )\n \n     def test_multiple_parents_mutex(self):\n         parents = [self.ab_mutex_parent, self.wxyz_parent]\n         parser = ErrorRaisingArgumentParser(parents=parents)\n-        self.assertEqual(parser.parse_args('-a --w 2 3'.split()),\n-                         NS(a=True, b=False, w='2', y=None, z='3'))\n+        self.assertEqual(\n+            parser.parse_args(\"-a --w 2 3\".split()),\n+            NS(a=True, b=False, w=\"2\", y=None, z=\"3\"),\n+        )\n         self.assertArgumentParserError(\n-            parser.parse_args, '-a --w 2 3 -b'.split())\n+            parser.parse_args, \"-a --w 2 3 -b\".split()\n+        )\n         self.assertArgumentParserError(\n-            parser.parse_args, '-a -b --w 2 3'.split())\n+            parser.parse_args, \"-a -b --w 2 3\".split()\n+        )\n \n     def test_conflicting_parents(self):\n         self.assertRaises(\n             argparse.ArgumentError,\n             argparse.ArgumentParser,\n-            parents=[self.w_parent, self.wxyz_parent])\n+            parents=[self.w_parent, self.wxyz_parent],\n+        )\n \n     def test_conflicting_parents_mutex(self):\n         self.assertRaises(\n             argparse.ArgumentError,\n             argparse.ArgumentParser,\n-            parents=[self.abcd_parent, self.ab_mutex_parent])\n+            parents=[self.abcd_parent, self.ab_mutex_parent],\n+        )\n \n     def test_same_argument_name_parents(self):\n         parents = [self.wxyz_parent, self.z_parent]\n         parser = ErrorRaisingArgumentParser(parents=parents)\n-        self.assertEqual(parser.parse_args('1 2'.split()),\n-                         NS(w=None, y=None, z='2'))\n+        self.assertEqual(\n+            parser.parse_args(\"1 2\".split()), NS(w=None, y=None, z=\"2\")\n+        )\n \n     def test_subparser_parents(self):\n         parser = ErrorRaisingArgumentParser()\n         subparsers = parser.add_subparsers()\n-        abcde_parser = subparsers.add_parser('bar', parents=[self.abcd_parent])\n-        abcde_parser.add_argument('e')\n-        self.assertEqual(parser.parse_args('bar -b 1 --d 2 3 4'.split()),\n-                         NS(a='3', b='1', d='2', e='4'))\n+        abcde_parser = subparsers.add_parser(\"bar\", parents=[self.abcd_parent])\n+        abcde_parser.add_argument(\"e\")\n+        self.assertEqual(\n+            parser.parse_args(\"bar -b 1 --d 2 3 4\".split()),\n+            NS(a=\"3\", b=\"1\", d=\"2\", e=\"4\"),\n+        )\n \n     def test_subparser_parents_mutex(self):\n         parser = ErrorRaisingArgumentParser()\n         subparsers = parser.add_subparsers()\n         parents = [self.ab_mutex_parent]\n-        abc_parser = subparsers.add_parser('foo', parents=parents)\n-        c_group = abc_parser.add_argument_group('c_group')\n-        c_group.add_argument('c')\n+        abc_parser = subparsers.add_parser(\"foo\", parents=parents)\n+        c_group = abc_parser.add_argument_group(\"c_group\")\n+        c_group.add_argument(\"c\")\n         parents = [self.wxyz_parent, self.ab_mutex_parent]\n-        wxyzabe_parser = subparsers.add_parser('bar', parents=parents)\n-        wxyzabe_parser.add_argument('e')\n-        self.assertEqual(parser.parse_args('foo -a 4'.split()),\n-                         NS(a=True, b=False, c='4'))\n-        self.assertEqual(parser.parse_args('bar -b  --w 2 3 4'.split()),\n-                         NS(a=False, b=True, w='2', y=None, z='3', e='4'))\n+        wxyzabe_parser = subparsers.add_parser(\"bar\", parents=parents)\n+        wxyzabe_parser.add_argument(\"e\")\n+        self.assertEqual(\n+            parser.parse_args(\"foo -a 4\".split()), NS(a=True, b=False, c=\"4\")\n+        )\n+        self.assertEqual(\n+            parser.parse_args(\"bar -b  --w 2 3 4\".split()),\n+            NS(a=False, b=True, w=\"2\", y=None, z=\"3\", e=\"4\"),\n+        )\n         self.assertArgumentParserError(\n-            parser.parse_args, 'foo -a -b 4'.split())\n+            parser.parse_args, \"foo -a -b 4\".split()\n+        )\n         self.assertArgumentParserError(\n-            parser.parse_args, 'bar -b -a 4'.split())\n+            parser.parse_args, \"bar -b -a 4\".split()\n+        )\n \n     def test_parent_help(self):\n         parents = [self.abcd_parent, self.wxyz_parent]\n-        parser = ErrorRaisingArgumentParser(prog='PROG', parents=parents)\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\", parents=parents)\n         parser_help = parser.format_help()\n-        self.assertEqual(parser_help, textwrap.dedent('''\\\n+        self.assertEqual(\n+            parser_help,\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [-b B] [--d D] [--w W] [-y Y] a z\n \n             positional arguments:\n@@ -3156,23 +3419,27 @@ def test_parent_help(self):\n \n             x:\n               -y Y\n-        '''))\n+        \"\"\"),\n+        )\n \n     def test_groups_parents(self):\n         parent = ErrorRaisingArgumentParser(add_help=False)\n-        g = parent.add_argument_group(title='g', description='gd')\n-        g.add_argument('-w')\n-        g.add_argument('-x')\n+        g = parent.add_argument_group(title=\"g\", description=\"gd\")\n+        g.add_argument(\"-w\")\n+        g.add_argument(\"-x\")\n         m = parent.add_mutually_exclusive_group()\n-        m.add_argument('-y')\n-        m.add_argument('-z')\n-        parser = ErrorRaisingArgumentParser(prog='PROG', parents=[parent])\n+        m.add_argument(\"-y\")\n+        m.add_argument(\"-z\")\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\", parents=[parent])\n \n-        self.assertRaises(ArgumentParserError, parser.parse_args,\n-            ['-y', 'Y', '-z', 'Z'])\n+        self.assertRaises(\n+            ArgumentParserError, parser.parse_args, [\"-y\", \"Y\", \"-z\", \"Z\"]\n+        )\n \n         parser_help = parser.format_help()\n-        self.assertEqual(parser_help, textwrap.dedent('''\\\n+        self.assertEqual(\n+            parser_help,\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [-w W] [-x X] [-y Y | -z Z]\n \n             options:\n@@ -3185,26 +3452,30 @@ def test_groups_parents(self):\n \n               -w W\n               -x X\n-        '''))\n+        \"\"\"),\n+        )\n \n     def test_wrong_type_parents(self):\n         self.assertRaises(TypeError, ErrorRaisingArgumentParser, parents=[1])\n \n     def test_mutex_groups_parents(self):\n         parent = ErrorRaisingArgumentParser(add_help=False)\n-        g = parent.add_argument_group(title='g', description='gd')\n-        g.add_argument('-w')\n-        g.add_argument('-x')\n+        g = parent.add_argument_group(title=\"g\", description=\"gd\")\n+        g.add_argument(\"-w\")\n+        g.add_argument(\"-x\")\n         m = g.add_mutually_exclusive_group()\n-        m.add_argument('-y')\n-        m.add_argument('-z')\n-        parser = ErrorRaisingArgumentParser(prog='PROG', parents=[parent])\n+        m.add_argument(\"-y\")\n+        m.add_argument(\"-z\")\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\", parents=[parent])\n \n-        self.assertRaises(ArgumentParserError, parser.parse_args,\n-            ['-y', 'Y', '-z', 'Z'])\n+        self.assertRaises(\n+            ArgumentParserError, parser.parse_args, [\"-y\", \"Y\", \"-z\", \"Z\"]\n+        )\n \n         parser_help = parser.format_help()\n-        self.assertEqual(parser_help, textwrap.dedent('''\\\n+        self.assertEqual(\n+            parser_help,\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [-w W] [-x X] [-y Y | -z Z]\n \n             options:\n@@ -3217,40 +3488,42 @@ def test_mutex_groups_parents(self):\n               -x X\n               -y Y\n               -z Z\n-        '''))\n+        \"\"\"),\n+        )\n+\n \n # ==============================\n # Mutually exclusive group tests\n # ==============================\n \n+\n @force_not_colorized_test_class\n class TestMutuallyExclusiveGroupErrors(TestCase):\n-\n     def test_invalid_add_argument_group(self):\n         parser = ErrorRaisingArgumentParser()\n         raises = self.assertRaises\n-        raises(TypeError, parser.add_mutually_exclusive_group, title='foo')\n+        raises(TypeError, parser.add_mutually_exclusive_group, title=\"foo\")\n \n     def test_invalid_add_argument(self):\n         parser = ErrorRaisingArgumentParser()\n         group = parser.add_mutually_exclusive_group()\n         add_argument = group.add_argument\n         raises = self.assertRaises\n-        raises(ValueError, add_argument, '--foo', required=True)\n-        raises(ValueError, add_argument, 'bar')\n-        raises(ValueError, add_argument, 'bar', nargs='+')\n-        raises(ValueError, add_argument, 'bar', nargs=1)\n-        raises(ValueError, add_argument, 'bar', nargs=argparse.PARSER)\n+        raises(ValueError, add_argument, \"--foo\", required=True)\n+        raises(ValueError, add_argument, \"bar\")\n+        raises(ValueError, add_argument, \"bar\", nargs=\"+\")\n+        raises(ValueError, add_argument, \"bar\", nargs=1)\n+        raises(ValueError, add_argument, \"bar\", nargs=argparse.PARSER)\n \n     def test_help(self):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         group1 = parser.add_mutually_exclusive_group()\n-        group1.add_argument('--foo', action='store_true')\n-        group1.add_argument('--bar', action='store_false')\n+        group1.add_argument(\"--foo\", action=\"store_true\")\n+        group1.add_argument(\"--bar\", action=\"store_false\")\n         group2 = parser.add_mutually_exclusive_group()\n-        group2.add_argument('--soup', action='store_true')\n-        group2.add_argument('--nuts', action='store_false')\n-        expected = '''\\\n+        group2.add_argument(\"--soup\", action=\"store_true\")\n+        group2.add_argument(\"--nuts\", action=\"store_false\")\n+        expected = \"\"\"\\\n             usage: PROG [-h] [--foo | --bar] [--soup | --nuts]\n \n             options:\n@@ -3259,15 +3532,15 @@ def test_help(self):\n               --bar\n               --soup\n               --nuts\n-              '''\n+              \"\"\"\n         self.assertEqual(parser.format_help(), textwrap.dedent(expected))\n \n     def test_optional_order(self):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         group = parser.add_mutually_exclusive_group(required=True)\n-        group.add_argument('--foo')\n-        group.add_argument('bar', nargs='?')\n-        expected = '''\\\n+        group.add_argument(\"--foo\")\n+        group.add_argument(\"bar\", nargs=\"?\")\n+        expected = \"\"\"\\\n             usage: PROG [-h] (--foo FOO | bar)\n \n             positional arguments:\n@@ -3276,34 +3549,40 @@ def test_optional_order(self):\n             options:\n               -h, --help  show this help message and exit\n               --foo FOO\n-              '''\n+              \"\"\"\n         self.assertEqual(parser.format_help(), textwrap.dedent(expected))\n \n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         group = parser.add_mutually_exclusive_group(required=True)\n-        group.add_argument('bar', nargs='?')\n-        group.add_argument('--foo')\n+        group.add_argument(\"bar\", nargs=\"?\")\n+        group.add_argument(\"--foo\")\n         self.assertEqual(parser.format_help(), textwrap.dedent(expected))\n \n-    def test_help_subparser_all_mutually_exclusive_group_members_suppressed(self):\n+    def test_help_subparser_all_mutually_exclusive_group_members_suppressed(\n+        self,\n+    ):\n         self.maxDiff = None\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         commands = parser.add_subparsers(title=\"commands\", dest=\"command\")\n         cmd_foo = commands.add_parser(\"foo\")\n         group = cmd_foo.add_mutually_exclusive_group()\n-        group.add_argument('--verbose', action='store_true', help=argparse.SUPPRESS)\n-        group.add_argument('--quiet', action='store_true', help=argparse.SUPPRESS)\n-        longopt = '--' + 'long'*32\n-        longmeta = 'LONG'*32\n+        group.add_argument(\n+            \"--verbose\", action=\"store_true\", help=argparse.SUPPRESS\n+        )\n+        group.add_argument(\n+            \"--quiet\", action=\"store_true\", help=argparse.SUPPRESS\n+        )\n+        longopt = \"--\" + \"long\" * 32\n+        longmeta = \"LONG\" * 32\n         cmd_foo.add_argument(longopt)\n-        expected = f'''\\\n+        expected = f\"\"\"\\\n             usage: PROG foo [-h]\n                             [{longopt} {longmeta}]\n \n             options:\n               -h, --help            show this help message and exit\n               {longopt} {longmeta}\n-              '''\n+              \"\"\"\n         self.assertEqual(cmd_foo.format_help(), textwrap.dedent(expected))\n \n     def test_empty_group(self):\n@@ -3311,18 +3590,20 @@ def test_empty_group(self):\n         parser = argparse.ArgumentParser()\n         group = parser.add_mutually_exclusive_group()\n         with self.assertRaises(ValueError):\n-            parser.parse_args(['-h'])\n+            parser.parse_args([\"-h\"])\n \n     def test_nested_mutex_groups(self):\n-        parser = argparse.ArgumentParser(prog='PROG')\n+        parser = argparse.ArgumentParser(prog=\"PROG\")\n         g = parser.add_mutually_exclusive_group()\n         g.add_argument(\"--spam\")\n-        self.assertRaisesRegex(ValueError,\n-                               'mutually exclusive groups cannot be nested',\n-                               g.add_mutually_exclusive_group)\n+        self.assertRaisesRegex(\n+            ValueError,\n+            \"mutually exclusive groups cannot be nested\",\n+            g.add_mutually_exclusive_group,\n+        )\n \n-class MEMixin(object):\n \n+class MEMixin(object):\n     def test_failures_when_not_required(self):\n         parse_args = self.get_parser(required=False).parse_args\n         error = ArgumentParserError\n@@ -3333,7 +3614,7 @@ def test_failures_when_not_required(self):\n     def test_failures_when_required(self):\n         parse_args = self.get_parser(required=True).parse_args\n         error = ArgumentParserError\n-        for args_string in self.failures + ['']:\n+        for args_string in self.failures + [\"\"]:\n             with self.subTest(args=args_string):\n                 self.assertRaises(error, parse_args, args_string.split())\n \n@@ -3378,73 +3659,75 @@ def test_help_when_required(self):\n \n \n class TestMutuallyExclusiveSimple(MEMixin, TestCase):\n-\n     def get_parser(self, required=None):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         group = parser.add_mutually_exclusive_group(required=required)\n-        group.add_argument('--bar', help='bar help')\n-        group.add_argument('--baz', nargs='?', const='Z', help='baz help')\n+        group.add_argument(\"--bar\", help=\"bar help\")\n+        group.add_argument(\"--baz\", nargs=\"?\", const=\"Z\", help=\"baz help\")\n         return parser\n \n-    failures = ['--bar X --baz Y', '--bar X --baz']\n+    failures = [\"--bar X --baz Y\", \"--bar X --baz\"]\n     successes = [\n-        ('--bar X', NS(bar='X', baz=None)),\n-        ('--bar X --bar Z', NS(bar='Z', baz=None)),\n-        ('--baz Y', NS(bar=None, baz='Y')),\n-        ('--baz', NS(bar=None, baz='Z')),\n+        (\"--bar X\", NS(bar=\"X\", baz=None)),\n+        (\"--bar X --bar Z\", NS(bar=\"Z\", baz=None)),\n+        (\"--baz Y\", NS(bar=None, baz=\"Y\")),\n+        (\"--baz\", NS(bar=None, baz=\"Z\")),\n     ]\n     successes_when_not_required = [\n-        ('', NS(bar=None, baz=None)),\n+        (\"\", NS(bar=None, baz=None)),\n     ]\n \n-    usage_when_not_required = '''\\\n+    usage_when_not_required = \"\"\"\\\n         usage: PROG [-h] [--bar BAR | --baz [BAZ]]\n-        '''\n-    usage_when_required = '''\\\n+        \"\"\"\n+    usage_when_required = \"\"\"\\\n         usage: PROG [-h] (--bar BAR | --baz [BAZ])\n-        '''\n-    help = '''\\\n+        \"\"\"\n+    help = \"\"\"\\\n \n         options:\n           -h, --help   show this help message and exit\n           --bar BAR    bar help\n           --baz [BAZ]  baz help\n-        '''\n+        \"\"\"\n \n \n class TestMutuallyExclusiveLong(MEMixin, TestCase):\n-\n     def get_parser(self, required=None):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n-        parser.add_argument('--abcde', help='abcde help')\n-        parser.add_argument('--fghij', help='fghij help')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n+        parser.add_argument(\"--abcde\", help=\"abcde help\")\n+        parser.add_argument(\"--fghij\", help=\"fghij help\")\n         group = parser.add_mutually_exclusive_group(required=required)\n-        group.add_argument('--klmno', help='klmno help')\n-        group.add_argument('--pqrst', help='pqrst help')\n+        group.add_argument(\"--klmno\", help=\"klmno help\")\n+        group.add_argument(\"--pqrst\", help=\"pqrst help\")\n         return parser\n \n-    failures = ['--klmno X --pqrst Y']\n+    failures = [\"--klmno X --pqrst Y\"]\n     successes = [\n-        ('--klmno X', NS(abcde=None, fghij=None, klmno='X', pqrst=None)),\n-        ('--abcde Y --klmno X',\n-            NS(abcde='Y', fghij=None, klmno='X', pqrst=None)),\n-        ('--pqrst X', NS(abcde=None, fghij=None, klmno=None, pqrst='X')),\n-        ('--pqrst X --fghij Y',\n-            NS(abcde=None, fghij='Y', klmno=None, pqrst='X')),\n+        (\"--klmno X\", NS(abcde=None, fghij=None, klmno=\"X\", pqrst=None)),\n+        (\n+            \"--abcde Y --klmno X\",\n+            NS(abcde=\"Y\", fghij=None, klmno=\"X\", pqrst=None),\n+        ),\n+        (\"--pqrst X\", NS(abcde=None, fghij=None, klmno=None, pqrst=\"X\")),\n+        (\n+            \"--pqrst X --fghij Y\",\n+            NS(abcde=None, fghij=\"Y\", klmno=None, pqrst=\"X\"),\n+        ),\n     ]\n     successes_when_not_required = [\n-        ('', NS(abcde=None, fghij=None, klmno=None, pqrst=None)),\n+        (\"\", NS(abcde=None, fghij=None, klmno=None, pqrst=None)),\n     ]\n \n-    usage_when_not_required = '''\\\n+    usage_when_not_required = \"\"\"\\\n     usage: PROG [-h] [--abcde ABCDE] [--fghij FGHIJ] [--klmno KLMNO |\n                 --pqrst PQRST]\n-    '''\n-    usage_when_required = '''\\\n+    \"\"\"\n+    usage_when_required = \"\"\"\\\n     usage: PROG [-h] [--abcde ABCDE] [--fghij FGHIJ] (--klmno KLMNO |\n                 --pqrst PQRST)\n-    '''\n-    help = '''\\\n+    \"\"\"\n+    help = \"\"\"\\\n \n     options:\n       -h, --help     show this help message and exit\n@@ -3452,112 +3735,109 @@ def get_parser(self, required=None):\n       --fghij FGHIJ  fghij help\n       --klmno KLMNO  klmno help\n       --pqrst PQRST  pqrst help\n-    '''\n+    \"\"\"\n \n \n class TestMutuallyExclusiveFirstSuppressed(MEMixin, TestCase):\n-\n     def get_parser(self, required):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         group = parser.add_mutually_exclusive_group(required=required)\n-        group.add_argument('-x', help=argparse.SUPPRESS)\n-        group.add_argument('-y', action='store_false', help='y help')\n+        group.add_argument(\"-x\", help=argparse.SUPPRESS)\n+        group.add_argument(\"-y\", action=\"store_false\", help=\"y help\")\n         return parser\n \n-    failures = ['-x X -y']\n+    failures = [\"-x X -y\"]\n     successes = [\n-        ('-x X', NS(x='X', y=True)),\n-        ('-x X -x Y', NS(x='Y', y=True)),\n-        ('-y', NS(x=None, y=False)),\n+        (\"-x X\", NS(x=\"X\", y=True)),\n+        (\"-x X -x Y\", NS(x=\"Y\", y=True)),\n+        (\"-y\", NS(x=None, y=False)),\n     ]\n     successes_when_not_required = [\n-        ('', NS(x=None, y=True)),\n+        (\"\", NS(x=None, y=True)),\n     ]\n \n-    usage_when_not_required = '''\\\n+    usage_when_not_required = \"\"\"\\\n         usage: PROG [-h] [-y]\n-        '''\n-    usage_when_required = '''\\\n+        \"\"\"\n+    usage_when_required = \"\"\"\\\n         usage: PROG [-h] -y\n-        '''\n-    help = '''\\\n+        \"\"\"\n+    help = \"\"\"\\\n \n         options:\n           -h, --help  show this help message and exit\n           -y          y help\n-        '''\n+        \"\"\"\n \n \n class TestMutuallyExclusiveManySuppressed(MEMixin, TestCase):\n-\n     def get_parser(self, required):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         group = parser.add_mutually_exclusive_group(required=required)\n         add = group.add_argument\n-        add('--spam', action='store_true', help=argparse.SUPPRESS)\n-        add('--badger', action='store_false', help=argparse.SUPPRESS)\n-        add('--bladder', help=argparse.SUPPRESS)\n+        add(\"--spam\", action=\"store_true\", help=argparse.SUPPRESS)\n+        add(\"--badger\", action=\"store_false\", help=argparse.SUPPRESS)\n+        add(\"--bladder\", help=argparse.SUPPRESS)\n         return parser\n \n     failures = [\n-        '--spam --badger',\n-        '--badger --bladder B',\n-        '--bladder B --spam',\n+        \"--spam --badger\",\n+        \"--badger --bladder B\",\n+        \"--bladder B --spam\",\n     ]\n     successes = [\n-        ('--spam', NS(spam=True, badger=True, bladder=None)),\n-        ('--badger', NS(spam=False, badger=False, bladder=None)),\n-        ('--bladder B', NS(spam=False, badger=True, bladder='B')),\n-        ('--spam --spam', NS(spam=True, badger=True, bladder=None)),\n+        (\"--spam\", NS(spam=True, badger=True, bladder=None)),\n+        (\"--badger\", NS(spam=False, badger=False, bladder=None)),\n+        (\"--bladder B\", NS(spam=False, badger=True, bladder=\"B\")),\n+        (\"--spam --spam\", NS(spam=True, badger=True, bladder=None)),\n     ]\n     successes_when_not_required = [\n-        ('', NS(spam=False, badger=True, bladder=None)),\n+        (\"\", NS(spam=False, badger=True, bladder=None)),\n     ]\n \n-    usage_when_required = usage_when_not_required = '''\\\n+    usage_when_required = usage_when_not_required = \"\"\"\\\n         usage: PROG [-h]\n-        '''\n-    help = '''\\\n+        \"\"\"\n+    help = \"\"\"\\\n \n         options:\n           -h, --help  show this help message and exit\n-        '''\n+        \"\"\"\n \n \n class TestMutuallyExclusiveOptionalAndPositional(MEMixin, TestCase):\n-\n     def get_parser(self, required):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         group = parser.add_mutually_exclusive_group(required=required)\n-        group.add_argument('--foo', action='store_true', help='FOO')\n-        group.add_argument('--spam', help='SPAM')\n-        group.add_argument('badger', nargs='*', help='BADGER')\n+        group.add_argument(\"--foo\", action=\"store_true\", help=\"FOO\")\n+        group.add_argument(\"--spam\", help=\"SPAM\")\n+        group.add_argument(\"badger\", nargs=\"*\", help=\"BADGER\")\n         return parser\n \n     failures = [\n-        '--foo --spam S',\n-        '--spam S X',\n-        'X --foo',\n-        'X Y Z --spam S',\n-        '--foo X Y',\n+        \"--foo --spam S\",\n+        \"--spam S X\",\n+        \"X --foo\",\n+        \"X Y Z --spam S\",\n+        \"--foo X Y\",\n     ]\n     successes = [\n-        ('--foo', NS(foo=True, spam=None, badger=[])),\n-        ('--spam S', NS(foo=False, spam='S', badger=[])),\n-        ('X', NS(foo=False, spam=None, badger=['X'])),\n-        ('X Y Z', NS(foo=False, spam=None, badger=['X', 'Y', 'Z'])),\n+        (\"--foo\", NS(foo=True, spam=None, badger=[])),\n+        (\"--spam S\", NS(foo=False, spam=\"S\", badger=[])),\n+        (\"X\", NS(foo=False, spam=None, badger=[\"X\"])),\n+        (\"X Y Z\", NS(foo=False, spam=None, badger=[\"X\", \"Y\", \"Z\"])),\n     ]\n     successes_when_not_required = [\n-        ('', NS(foo=False, spam=None, badger=[])),\n+        (\"\", NS(foo=False, spam=None, badger=[])),\n     ]\n \n-    usage_when_not_required = '''\\\n+    usage_when_not_required = \"\"\"\\\n         usage: PROG [-h] [--foo | --spam SPAM | badger ...]\n-        '''\n-    usage_when_required = '''\\\n+        \"\"\"\n+    usage_when_required = \"\"\"\\\n         usage: PROG [-h] (--foo | --spam SPAM | badger ...)\n-        '''\n-    help = '''\\\n+        \"\"\"\n+    help = \"\"\"\\\n \n         positional arguments:\n           badger       BADGER\n@@ -3566,40 +3846,39 @@ def get_parser(self, required):\n           -h, --help   show this help message and exit\n           --foo        FOO\n           --spam SPAM  SPAM\n-        '''\n+        \"\"\"\n \n \n class TestMutuallyExclusiveOptionalsMixed(MEMixin, TestCase):\n-\n     def get_parser(self, required):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n-        parser.add_argument('-x', action='store_true', help='x help')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n+        parser.add_argument(\"-x\", action=\"store_true\", help=\"x help\")\n         group = parser.add_mutually_exclusive_group(required=required)\n-        group.add_argument('-a', action='store_true', help='a help')\n-        group.add_argument('-b', action='store_true', help='b help')\n-        parser.add_argument('-y', action='store_true', help='y help')\n-        group.add_argument('-c', action='store_true', help='c help')\n+        group.add_argument(\"-a\", action=\"store_true\", help=\"a help\")\n+        group.add_argument(\"-b\", action=\"store_true\", help=\"b help\")\n+        parser.add_argument(\"-y\", action=\"store_true\", help=\"y help\")\n+        group.add_argument(\"-c\", action=\"store_true\", help=\"c help\")\n         return parser\n \n-    failures = ['-a -b', '-b -c', '-a -c', '-a -b -c']\n+    failures = [\"-a -b\", \"-b -c\", \"-a -c\", \"-a -b -c\"]\n     successes = [\n-        ('-a', NS(a=True, b=False, c=False, x=False, y=False)),\n-        ('-b', NS(a=False, b=True, c=False, x=False, y=False)),\n-        ('-c', NS(a=False, b=False, c=True, x=False, y=False)),\n-        ('-a -x', NS(a=True, b=False, c=False, x=True, y=False)),\n-        ('-y -b', NS(a=False, b=True, c=False, x=False, y=True)),\n-        ('-x -y -c', NS(a=False, b=False, c=True, x=True, y=True)),\n+        (\"-a\", NS(a=True, b=False, c=False, x=False, y=False)),\n+        (\"-b\", NS(a=False, b=True, c=False, x=False, y=False)),\n+        (\"-c\", NS(a=False, b=False, c=True, x=False, y=False)),\n+        (\"-a -x\", NS(a=True, b=False, c=False, x=True, y=False)),\n+        (\"-y -b\", NS(a=False, b=True, c=False, x=False, y=True)),\n+        (\"-x -y -c\", NS(a=False, b=False, c=True, x=True, y=True)),\n     ]\n     successes_when_not_required = [\n-        ('', NS(a=False, b=False, c=False, x=False, y=False)),\n-        ('-x', NS(a=False, b=False, c=False, x=True, y=False)),\n-        ('-y', NS(a=False, b=False, c=False, x=False, y=True)),\n+        (\"\", NS(a=False, b=False, c=False, x=False, y=False)),\n+        (\"-x\", NS(a=False, b=False, c=False, x=True, y=False)),\n+        (\"-y\", NS(a=False, b=False, c=False, x=False, y=True)),\n     ]\n \n-    usage_when_required = usage_when_not_required = '''\\\n+    usage_when_required = usage_when_not_required = \"\"\"\\\n         usage: PROG [-h] [-x] [-a] [-b] [-y] [-c]\n-        '''\n-    help = '''\\\n+        \"\"\"\n+    help = \"\"\"\\\n \n         options:\n           -h, --help  show this help message and exit\n@@ -3608,37 +3887,38 @@ def get_parser(self, required):\n           -b          b help\n           -y          y help\n           -c          c help\n-        '''\n+        \"\"\"\n \n \n class TestMutuallyExclusiveInGroup(MEMixin, TestCase):\n-\n     def get_parser(self, required=None):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         titled_group = parser.add_argument_group(\n-            title='Titled group', description='Group description')\n-        mutex_group = \\\n-            titled_group.add_mutually_exclusive_group(required=required)\n-        mutex_group.add_argument('--bar', help='bar help')\n-        mutex_group.add_argument('--baz', help='baz help')\n+            title=\"Titled group\", description=\"Group description\"\n+        )\n+        mutex_group = titled_group.add_mutually_exclusive_group(\n+            required=required\n+        )\n+        mutex_group.add_argument(\"--bar\", help=\"bar help\")\n+        mutex_group.add_argument(\"--baz\", help=\"baz help\")\n         return parser\n \n-    failures = ['--bar X --baz Y', '--baz X --bar Y']\n+    failures = [\"--bar X --baz Y\", \"--baz X --bar Y\"]\n     successes = [\n-        ('--bar X', NS(bar='X', baz=None)),\n-        ('--baz Y', NS(bar=None, baz='Y')),\n+        (\"--bar X\", NS(bar=\"X\", baz=None)),\n+        (\"--baz Y\", NS(bar=None, baz=\"Y\")),\n     ]\n     successes_when_not_required = [\n-        ('', NS(bar=None, baz=None)),\n+        (\"\", NS(bar=None, baz=None)),\n     ]\n \n-    usage_when_not_required = '''\\\n+    usage_when_not_required = \"\"\"\\\n         usage: PROG [-h] [--bar BAR | --baz BAZ]\n-        '''\n-    usage_when_required = '''\\\n+        \"\"\"\n+    usage_when_required = \"\"\"\\\n         usage: PROG [-h] (--bar BAR | --baz BAZ)\n-        '''\n-    help = '''\\\n+        \"\"\"\n+    help = \"\"\"\\\n \n         options:\n           -h, --help  show this help message and exit\n@@ -3648,38 +3928,37 @@ def get_parser(self, required=None):\n \n           --bar BAR   bar help\n           --baz BAZ   baz help\n-        '''\n+        \"\"\"\n \n \n class TestMutuallyExclusiveOptionalsAndPositionalsMixed(MEMixin, TestCase):\n-\n     def get_parser(self, required):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n-        parser.add_argument('x', help='x help')\n-        parser.add_argument('-y', action='store_true', help='y help')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n+        parser.add_argument(\"x\", help=\"x help\")\n+        parser.add_argument(\"-y\", action=\"store_true\", help=\"y help\")\n         group = parser.add_mutually_exclusive_group(required=required)\n-        group.add_argument('a', nargs='?', help='a help')\n-        group.add_argument('-b', action='store_true', help='b help')\n-        group.add_argument('-c', action='store_true', help='c help')\n+        group.add_argument(\"a\", nargs=\"?\", help=\"a help\")\n+        group.add_argument(\"-b\", action=\"store_true\", help=\"b help\")\n+        group.add_argument(\"-c\", action=\"store_true\", help=\"c help\")\n         return parser\n \n-    failures = ['X A -b', '-b -c', '-c X A']\n+    failures = [\"X A -b\", \"-b -c\", \"-c X A\"]\n     successes = [\n-        ('X A', NS(a='A', b=False, c=False, x='X', y=False)),\n-        ('X -b', NS(a=None, b=True, c=False, x='X', y=False)),\n-        ('X -c', NS(a=None, b=False, c=True, x='X', y=False)),\n-        ('X A -y', NS(a='A', b=False, c=False, x='X', y=True)),\n-        ('X -y -b', NS(a=None, b=True, c=False, x='X', y=True)),\n+        (\"X A\", NS(a=\"A\", b=False, c=False, x=\"X\", y=False)),\n+        (\"X -b\", NS(a=None, b=True, c=False, x=\"X\", y=False)),\n+        (\"X -c\", NS(a=None, b=False, c=True, x=\"X\", y=False)),\n+        (\"X A -y\", NS(a=\"A\", b=False, c=False, x=\"X\", y=True)),\n+        (\"X -y -b\", NS(a=None, b=True, c=False, x=\"X\", y=True)),\n     ]\n     successes_when_not_required = [\n-        ('X', NS(a=None, b=False, c=False, x='X', y=False)),\n-        ('X -y', NS(a=None, b=False, c=False, x='X', y=True)),\n+        (\"X\", NS(a=None, b=False, c=False, x=\"X\", y=False)),\n+        (\"X -y\", NS(a=None, b=False, c=False, x=\"X\", y=True)),\n     ]\n \n-    usage_when_required = usage_when_not_required = '''\\\n+    usage_when_required = usage_when_not_required = \"\"\"\\\n         usage: PROG [-h] [-y] [-b] [-c] x [a]\n-        '''\n-    help = '''\\\n+        \"\"\"\n+    help = \"\"\"\\\n \n         positional arguments:\n           x           x help\n@@ -3690,104 +3969,104 @@ def get_parser(self, required):\n           -y          y help\n           -b          b help\n           -c          c help\n-        '''\n+        \"\"\"\n \n \n class TestMutuallyExclusiveOptionalOptional(MEMixin, TestCase):\n     def get_parser(self, required=None):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         group = parser.add_mutually_exclusive_group(required=required)\n-        group.add_argument('--foo')\n-        group.add_argument('--bar', nargs='?')\n+        group.add_argument(\"--foo\")\n+        group.add_argument(\"--bar\", nargs=\"?\")\n         return parser\n \n     failures = [\n-        '--foo X --bar Y',\n-        '--foo X --bar',\n+        \"--foo X --bar Y\",\n+        \"--foo X --bar\",\n     ]\n     successes = [\n-        ('--foo X', NS(foo='X', bar=None)),\n-        ('--bar X', NS(foo=None, bar='X')),\n-        ('--bar', NS(foo=None, bar=None)),\n+        (\"--foo X\", NS(foo=\"X\", bar=None)),\n+        (\"--bar X\", NS(foo=None, bar=\"X\")),\n+        (\"--bar\", NS(foo=None, bar=None)),\n     ]\n     successes_when_not_required = [\n-        ('', NS(foo=None, bar=None)),\n+        (\"\", NS(foo=None, bar=None)),\n     ]\n-    usage_when_required = '''\\\n+    usage_when_required = \"\"\"\\\n         usage: PROG [-h] (--foo FOO | --bar [BAR])\n-        '''\n-    usage_when_not_required = '''\\\n+        \"\"\"\n+    usage_when_not_required = \"\"\"\\\n         usage: PROG [-h] [--foo FOO | --bar [BAR]]\n-        '''\n-    help = '''\\\n+        \"\"\"\n+    help = \"\"\"\\\n \n         options:\n           -h, --help   show this help message and exit\n           --foo FOO\n           --bar [BAR]\n-        '''\n+        \"\"\"\n \n \n class TestMutuallyExclusiveOptionalWithDefault(MEMixin, TestCase):\n     def get_parser(self, required=None):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         group = parser.add_mutually_exclusive_group(required=required)\n-        group.add_argument('--foo')\n-        group.add_argument('--bar', type=bool, default=True)\n+        group.add_argument(\"--foo\")\n+        group.add_argument(\"--bar\", type=bool, default=True)\n         return parser\n \n     failures = [\n-        '--foo X --bar Y',\n-        '--foo X --bar=',\n+        \"--foo X --bar Y\",\n+        \"--foo X --bar=\",\n     ]\n     successes = [\n-        ('--foo X', NS(foo='X', bar=True)),\n-        ('--bar X', NS(foo=None, bar=True)),\n-        ('--bar=', NS(foo=None, bar=False)),\n+        (\"--foo X\", NS(foo=\"X\", bar=True)),\n+        (\"--bar X\", NS(foo=None, bar=True)),\n+        (\"--bar=\", NS(foo=None, bar=False)),\n     ]\n     successes_when_not_required = [\n-        ('', NS(foo=None, bar=True)),\n+        (\"\", NS(foo=None, bar=True)),\n     ]\n-    usage_when_required = '''\\\n+    usage_when_required = \"\"\"\\\n         usage: PROG [-h] (--foo FOO | --bar BAR)\n-        '''\n-    usage_when_not_required = '''\\\n+        \"\"\"\n+    usage_when_not_required = \"\"\"\\\n         usage: PROG [-h] [--foo FOO | --bar BAR]\n-        '''\n-    help = '''\\\n+        \"\"\"\n+    help = \"\"\"\\\n \n         options:\n           -h, --help  show this help message and exit\n           --foo FOO\n           --bar BAR\n-        '''\n+        \"\"\"\n \n \n class TestMutuallyExclusivePositionalWithDefault(MEMixin, TestCase):\n     def get_parser(self, required=None):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n         group = parser.add_mutually_exclusive_group(required=required)\n-        group.add_argument('--foo')\n-        group.add_argument('bar', nargs='?', type=bool, default=True)\n+        group.add_argument(\"--foo\")\n+        group.add_argument(\"bar\", nargs=\"?\", type=bool, default=True)\n         return parser\n \n     failures = [\n-        '--foo X Y',\n+        \"--foo X Y\",\n     ]\n     successes = [\n-        ('--foo X', NS(foo='X', bar=True)),\n-        ('X', NS(foo=None, bar=True)),\n+        (\"--foo X\", NS(foo=\"X\", bar=True)),\n+        (\"X\", NS(foo=None, bar=True)),\n     ]\n     successes_when_not_required = [\n-        ('', NS(foo=None, bar=True)),\n+        (\"\", NS(foo=None, bar=True)),\n     ]\n-    usage_when_required = '''\\\n+    usage_when_required = \"\"\"\\\n         usage: PROG [-h] (--foo FOO | bar)\n-        '''\n-    usage_when_not_required = '''\\\n+        \"\"\"\n+    usage_when_not_required = \"\"\"\\\n         usage: PROG [-h] [--foo FOO | bar]\n-        '''\n-    help = '''\\\n+        \"\"\"\n+    help = \"\"\"\\\n \n         positional arguments:\n           bar\n@@ -3795,160 +4074,172 @@ def get_parser(self, required=None):\n         options:\n           -h, --help  show this help message and exit\n           --foo FOO\n-        '''\n+        \"\"\"\n+\n \n # =================================================\n # Mutually exclusive group in parent parser tests\n # =================================================\n \n-class MEPBase(object):\n \n+class MEPBase(object):\n     def get_parser(self, required=None):\n         parent = super(MEPBase, self).get_parser(required=required)\n         parser = ErrorRaisingArgumentParser(\n-            prog=parent.prog, add_help=False, parents=[parent])\n+            prog=parent.prog, add_help=False, parents=[parent]\n+        )\n         return parser\n \n \n class TestMutuallyExclusiveGroupErrorsParent(\n-    MEPBase, TestMutuallyExclusiveGroupErrors):\n+    MEPBase, TestMutuallyExclusiveGroupErrors\n+):\n     pass\n \n \n-class TestMutuallyExclusiveSimpleParent(\n-    MEPBase, TestMutuallyExclusiveSimple):\n+class TestMutuallyExclusiveSimpleParent(MEPBase, TestMutuallyExclusiveSimple):\n     pass\n \n \n-class TestMutuallyExclusiveLongParent(\n-    MEPBase, TestMutuallyExclusiveLong):\n+class TestMutuallyExclusiveLongParent(MEPBase, TestMutuallyExclusiveLong):\n     pass\n \n \n class TestMutuallyExclusiveFirstSuppressedParent(\n-    MEPBase, TestMutuallyExclusiveFirstSuppressed):\n+    MEPBase, TestMutuallyExclusiveFirstSuppressed\n+):\n     pass\n \n \n class TestMutuallyExclusiveManySuppressedParent(\n-    MEPBase, TestMutuallyExclusiveManySuppressed):\n+    MEPBase, TestMutuallyExclusiveManySuppressed\n+):\n     pass\n \n \n class TestMutuallyExclusiveOptionalAndPositionalParent(\n-    MEPBase, TestMutuallyExclusiveOptionalAndPositional):\n+    MEPBase, TestMutuallyExclusiveOptionalAndPositional\n+):\n     pass\n \n \n class TestMutuallyExclusiveOptionalsMixedParent(\n-    MEPBase, TestMutuallyExclusiveOptionalsMixed):\n+    MEPBase, TestMutuallyExclusiveOptionalsMixed\n+):\n     pass\n \n \n class TestMutuallyExclusiveOptionalsAndPositionalsMixedParent(\n-    MEPBase, TestMutuallyExclusiveOptionalsAndPositionalsMixed):\n+    MEPBase, TestMutuallyExclusiveOptionalsAndPositionalsMixed\n+):\n     pass\n \n+\n # =================\n # Set default tests\n # =================\n \n-class TestSetDefaults(TestCase):\n \n+class TestSetDefaults(TestCase):\n     def test_set_defaults_no_args(self):\n         parser = ErrorRaisingArgumentParser()\n-        parser.set_defaults(x='foo')\n-        parser.set_defaults(y='bar', z=1)\n-        self.assertEqual(NS(x='foo', y='bar', z=1),\n-                         parser.parse_args([]))\n-        self.assertEqual(NS(x='foo', y='bar', z=1),\n-                         parser.parse_args([], NS()))\n-        self.assertEqual(NS(x='baz', y='bar', z=1),\n-                         parser.parse_args([], NS(x='baz')))\n-        self.assertEqual(NS(x='baz', y='bar', z=2),\n-                         parser.parse_args([], NS(x='baz', z=2)))\n-\n-    def test_set_defaults_with_args(self):\n-        parser = ErrorRaisingArgumentParser()\n-        parser.set_defaults(x='foo', y='bar')\n-        parser.add_argument('-x', default='xfoox')\n-        self.assertEqual(NS(x='xfoox', y='bar'),\n-                         parser.parse_args([]))\n-        self.assertEqual(NS(x='xfoox', y='bar'),\n-                         parser.parse_args([], NS()))\n-        self.assertEqual(NS(x='baz', y='bar'),\n-                         parser.parse_args([], NS(x='baz')))\n-        self.assertEqual(NS(x='1', y='bar'),\n-                         parser.parse_args('-x 1'.split()))\n-        self.assertEqual(NS(x='1', y='bar'),\n-                         parser.parse_args('-x 1'.split(), NS()))\n-        self.assertEqual(NS(x='1', y='bar'),\n-                         parser.parse_args('-x 1'.split(), NS(x='baz')))\n-\n+        parser.set_defaults(x=\"foo\")\n+        parser.set_defaults(y=\"bar\", z=1)\n+        self.assertEqual(NS(x=\"foo\", y=\"bar\", z=1), parser.parse_args([]))\n+        self.assertEqual(\n+            NS(x=\"foo\", y=\"bar\", z=1), parser.parse_args([], NS())\n+        )\n+        self.assertEqual(\n+            NS(x=\"baz\", y=\"bar\", z=1), parser.parse_args([], NS(x=\"baz\"))\n+        )\n+        self.assertEqual(\n+            NS(x=\"baz\", y=\"bar\", z=2), parser.parse_args([], NS(x=\"baz\", z=2))\n+        )\n+\n+    def test_set_defaults_with_args(self):\n+        parser = ErrorRaisingArgumentParser()\n+        parser.set_defaults(x=\"foo\", y=\"bar\")\n+        parser.add_argument(\"-x\", default=\"xfoox\")\n+        self.assertEqual(NS(x=\"xfoox\", y=\"bar\"), parser.parse_args([]))\n+        self.assertEqual(NS(x=\"xfoox\", y=\"bar\"), parser.parse_args([], NS()))\n+        self.assertEqual(\n+            NS(x=\"baz\", y=\"bar\"), parser.parse_args([], NS(x=\"baz\"))\n+        )\n+        self.assertEqual(NS(x=\"1\", y=\"bar\"), parser.parse_args(\"-x 1\".split()))\n+        self.assertEqual(\n+            NS(x=\"1\", y=\"bar\"), parser.parse_args(\"-x 1\".split(), NS())\n+        )\n+        self.assertEqual(\n+            NS(x=\"1\", y=\"bar\"), parser.parse_args(\"-x 1\".split(), NS(x=\"baz\"))\n+        )\n+\n     def test_set_defaults_subparsers(self):\n         parser = ErrorRaisingArgumentParser()\n-        parser.set_defaults(x='foo')\n+        parser.set_defaults(x=\"foo\")\n         subparsers = parser.add_subparsers()\n-        parser_a = subparsers.add_parser('a')\n-        parser_a.set_defaults(y='bar')\n-        self.assertEqual(NS(x='foo', y='bar'),\n-                         parser.parse_args('a'.split()))\n+        parser_a = subparsers.add_parser(\"a\")\n+        parser_a.set_defaults(y=\"bar\")\n+        self.assertEqual(NS(x=\"foo\", y=\"bar\"), parser.parse_args(\"a\".split()))\n \n     def test_set_defaults_parents(self):\n         parent = ErrorRaisingArgumentParser(add_help=False)\n-        parent.set_defaults(x='foo')\n+        parent.set_defaults(x=\"foo\")\n         parser = ErrorRaisingArgumentParser(parents=[parent])\n-        self.assertEqual(NS(x='foo'), parser.parse_args([]))\n+        self.assertEqual(NS(x=\"foo\"), parser.parse_args([]))\n \n     def test_set_defaults_on_parent_and_subparser(self):\n         parser = argparse.ArgumentParser()\n-        xparser = parser.add_subparsers().add_parser('X')\n+        xparser = parser.add_subparsers().add_parser(\"X\")\n         parser.set_defaults(foo=1)\n         xparser.set_defaults(foo=2)\n-        self.assertEqual(NS(foo=2), parser.parse_args(['X']))\n+        self.assertEqual(NS(foo=2), parser.parse_args([\"X\"]))\n \n     def test_set_defaults_same_as_add_argument(self):\n         parser = ErrorRaisingArgumentParser()\n-        parser.set_defaults(w='W', x='X', y='Y', z='Z')\n-        parser.add_argument('-w')\n-        parser.add_argument('-x', default='XX')\n-        parser.add_argument('y', nargs='?')\n-        parser.add_argument('z', nargs='?', default='ZZ')\n+        parser.set_defaults(w=\"W\", x=\"X\", y=\"Y\", z=\"Z\")\n+        parser.add_argument(\"-w\")\n+        parser.add_argument(\"-x\", default=\"XX\")\n+        parser.add_argument(\"y\", nargs=\"?\")\n+        parser.add_argument(\"z\", nargs=\"?\", default=\"ZZ\")\n \n         # defaults set previously\n-        self.assertEqual(NS(w='W', x='XX', y='Y', z='ZZ'),\n-                         parser.parse_args([]))\n+        self.assertEqual(\n+            NS(w=\"W\", x=\"XX\", y=\"Y\", z=\"ZZ\"), parser.parse_args([])\n+        )\n \n         # reset defaults\n-        parser.set_defaults(w='WW', x='X', y='YY', z='Z')\n-        self.assertEqual(NS(w='WW', x='X', y='YY', z='Z'),\n-                         parser.parse_args([]))\n+        parser.set_defaults(w=\"WW\", x=\"X\", y=\"YY\", z=\"Z\")\n+        self.assertEqual(\n+            NS(w=\"WW\", x=\"X\", y=\"YY\", z=\"Z\"), parser.parse_args([])\n+        )\n \n     def test_set_defaults_same_as_add_argument_group(self):\n         parser = ErrorRaisingArgumentParser()\n-        parser.set_defaults(w='W', x='X', y='Y', z='Z')\n-        group = parser.add_argument_group('foo')\n-        group.add_argument('-w')\n-        group.add_argument('-x', default='XX')\n-        group.add_argument('y', nargs='?')\n-        group.add_argument('z', nargs='?', default='ZZ')\n-\n+        parser.set_defaults(w=\"W\", x=\"X\", y=\"Y\", z=\"Z\")\n+        group = parser.add_argument_group(\"foo\")\n+        group.add_argument(\"-w\")\n+        group.add_argument(\"-x\", default=\"XX\")\n+        group.add_argument(\"y\", nargs=\"?\")\n+        group.add_argument(\"z\", nargs=\"?\", default=\"ZZ\")\n \n         # defaults set previously\n-        self.assertEqual(NS(w='W', x='XX', y='Y', z='ZZ'),\n-                         parser.parse_args([]))\n+        self.assertEqual(\n+            NS(w=\"W\", x=\"XX\", y=\"Y\", z=\"ZZ\"), parser.parse_args([])\n+        )\n \n         # reset defaults\n-        parser.set_defaults(w='WW', x='X', y='YY', z='Z')\n-        self.assertEqual(NS(w='WW', x='X', y='YY', z='Z'),\n-                         parser.parse_args([]))\n+        parser.set_defaults(w=\"WW\", x=\"X\", y=\"YY\", z=\"Z\")\n+        self.assertEqual(\n+            NS(w=\"WW\", x=\"X\", y=\"YY\", z=\"Z\"), parser.parse_args([])\n+        )\n+\n \n # =================\n # Get default tests\n # =================\n \n-class TestGetDefault(TestCase):\n \n+class TestGetDefault(TestCase):\n     def test_get_default(self):\n         parser = ErrorRaisingArgumentParser()\n         self.assertIsNone(parser.get_default(\"foo\"))\n@@ -3966,48 +4257,52 @@ def test_get_default(self):\n         self.assertEqual(\"badger\", parser.get_default(\"foo\"))\n         self.assertEqual(42, parser.get_default(\"bar\"))\n \n+\n # ==========================\n # Namespace 'contains' tests\n # ==========================\n \n-class TestNamespaceContainsSimple(TestCase):\n \n+class TestNamespaceContainsSimple(TestCase):\n     def test_empty(self):\n         ns = argparse.Namespace()\n-        self.assertNotIn('', ns)\n-        self.assertNotIn('x', ns)\n+        self.assertNotIn(\"\", ns)\n+        self.assertNotIn(\"x\", ns)\n \n     def test_non_empty(self):\n         ns = argparse.Namespace(x=1, y=2)\n-        self.assertNotIn('', ns)\n-        self.assertIn('x', ns)\n-        self.assertIn('y', ns)\n-        self.assertNotIn('xx', ns)\n-        self.assertNotIn('z', ns)\n+        self.assertNotIn(\"\", ns)\n+        self.assertIn(\"x\", ns)\n+        self.assertIn(\"y\", ns)\n+        self.assertNotIn(\"xx\", ns)\n+        self.assertNotIn(\"z\", ns)\n+\n \n # =====================\n # Help formatting tests\n # =====================\n \n-class TestHelpFormattingMetaclass(type):\n \n+class TestHelpFormattingMetaclass(type):\n     def __init__(cls, name, bases, bodydict):\n-        if name == 'HelpTestCase':\n+        if name == \"HelpTestCase\":\n             return\n \n         class AddTests(object):\n-\n             def __init__(self, test_class, func_suffix, std_name):\n                 self.func_suffix = func_suffix\n                 self.std_name = std_name\n \n-                for test_func in [self.test_format,\n-                                  self.test_print,\n-                                  self.test_print_file]:\n-                    test_name = '%s_%s' % (test_func.__name__, func_suffix)\n+                for test_func in [\n+                    self.test_format,\n+                    self.test_print,\n+                    self.test_print_file,\n+                ]:\n+                    test_name = \"%s_%s\" % (test_func.__name__, func_suffix)\n \n                     def test_wrapper(self, test_func=test_func):\n                         test_func(self)\n+\n                     try:\n                         test_wrapper.__name__ = test_name\n                     except TypeError:\n@@ -4017,23 +4312,28 @@ def test_wrapper(self, test_func=test_func):\n             def _get_parser(self, tester):\n                 parser = argparse.ArgumentParser(\n                     *tester.parser_signature.args,\n-                    **tester.parser_signature.kwargs)\n-                for argument_sig in getattr(tester, 'argument_signatures', []):\n-                    parser.add_argument(*argument_sig.args,\n-                                        **argument_sig.kwargs)\n-                group_sigs = getattr(tester, 'argument_group_signatures', [])\n+                    **tester.parser_signature.kwargs,\n+                )\n+                for argument_sig in getattr(tester, \"argument_signatures\", []):\n+                    parser.add_argument(\n+                        *argument_sig.args, **argument_sig.kwargs\n+                    )\n+                group_sigs = getattr(tester, \"argument_group_signatures\", [])\n                 for group_sig, argument_sigs in group_sigs:\n-                    group = parser.add_argument_group(*group_sig.args,\n-                                                      **group_sig.kwargs)\n+                    group = parser.add_argument_group(\n+                        *group_sig.args, **group_sig.kwargs\n+                    )\n                     for argument_sig in argument_sigs:\n-                        group.add_argument(*argument_sig.args,\n-                                           **argument_sig.kwargs)\n-                subparsers_sigs = getattr(tester, 'subparsers_signatures', [])\n+                        group.add_argument(\n+                            *argument_sig.args, **argument_sig.kwargs\n+                        )\n+                subparsers_sigs = getattr(tester, \"subparsers_signatures\", [])\n                 if subparsers_sigs:\n                     subparsers = parser.add_subparsers()\n                     for subparser_sig in subparsers_sigs:\n-                        subparsers.add_parser(*subparser_sig.args,\n-                                               **subparser_sig.kwargs)\n+                        subparsers.add_parser(\n+                            *subparser_sig.args, **subparser_sig.kwargs\n+                        )\n                 return parser\n \n             def _test(self, tester, parser_text):\n@@ -4045,13 +4345,13 @@ def _test(self, tester, parser_text):\n             @force_not_colorized\n             def test_format(self, tester):\n                 parser = self._get_parser(tester)\n-                format = getattr(parser, 'format_%s' % self.func_suffix)\n+                format = getattr(parser, \"format_%s\" % self.func_suffix)\n                 self._test(tester, format())\n \n             @force_not_colorized\n             def test_print(self, tester):\n                 parser = self._get_parser(tester)\n-                print_ = getattr(parser, 'print_%s' % self.func_suffix)\n+                print_ = getattr(parser, \"print_%s\" % self.func_suffix)\n                 old_stream = getattr(sys, self.std_name)\n                 setattr(sys, self.std_name, StdIOBuffer())\n                 try:\n@@ -4064,38 +4364,41 @@ def test_print(self, tester):\n             @force_not_colorized\n             def test_print_file(self, tester):\n                 parser = self._get_parser(tester)\n-                print_ = getattr(parser, 'print_%s' % self.func_suffix)\n+                print_ = getattr(parser, \"print_%s\" % self.func_suffix)\n                 sfile = StdIOBuffer()\n                 print_(sfile)\n                 parser_text = sfile.getvalue()\n                 self._test(tester, parser_text)\n \n         # add tests for {format,print}_{usage,help}\n-        for func_suffix, std_name in [('usage', 'stdout'),\n-                                      ('help', 'stdout')]:\n+        for func_suffix, std_name in [(\"usage\", \"stdout\"), (\"help\", \"stdout\")]:\n             AddTests(cls, func_suffix, std_name)\n \n-bases = TestCase,\n-HelpTestCase = TestHelpFormattingMetaclass('HelpTestCase', bases, {})\n+\n+bases = (TestCase,)\n+HelpTestCase = TestHelpFormattingMetaclass(\"HelpTestCase\", bases, {})\n \n \n class TestHelpBiggerOptionals(HelpTestCase):\n     \"\"\"Make sure that argument help aligns when options are longer\"\"\"\n \n-    parser_signature = Sig(prog='PROG', description='DESCRIPTION',\n-                           epilog='EPILOG')\n+    parser_signature = Sig(\n+        prog=\"PROG\", description=\"DESCRIPTION\", epilog=\"EPILOG\"\n+    )\n     argument_signatures = [\n-        Sig('-v', '--version', action='version', version='0.1'),\n-        Sig('-x', action='store_true', help='X HELP'),\n-        Sig('--y', help='Y HELP'),\n-        Sig('foo', help='FOO HELP'),\n-        Sig('bar', help='BAR HELP'),\n+        Sig(\"-v\", \"--version\", action=\"version\", version=\"0.1\"),\n+        Sig(\"-x\", action=\"store_true\", help=\"X HELP\"),\n+        Sig(\"--y\", help=\"Y HELP\"),\n+        Sig(\"foo\", help=\"FOO HELP\"),\n+        Sig(\"bar\", help=\"BAR HELP\"),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-v] [-x] [--y Y] foo bar\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         DESCRIPTION\n \n@@ -4110,25 +4413,30 @@ class TestHelpBiggerOptionals(HelpTestCase):\n           --y Y          Y HELP\n \n         EPILOG\n-    '''\n-    version = '''\\\n+    \"\"\"\n+    )\n+    version = \"\"\"\\\n         0.1\n-        '''\n+        \"\"\"\n+\n \n class TestShortColumns(HelpTestCase):\n-    '''Test extremely small number of columns.\n+    \"\"\"Test extremely small number of columns.\n \n     TestCase prevents \"COLUMNS\" from being too small in the tests themselves,\n     but we don't want any exceptions thrown in such cases. Only ugly representation.\n-    '''\n+    \"\"\"\n+\n     def setUp(self):\n         env = self.enterContext(os_helper.EnvironmentVarGuard())\n-        env.set(\"COLUMNS\", '15')\n-\n-    parser_signature            = TestHelpBiggerOptionals.parser_signature\n-    argument_signatures         = TestHelpBiggerOptionals.argument_signatures\n-    argument_group_signatures   = TestHelpBiggerOptionals.argument_group_signatures\n-    usage = '''\\\n+        env.set(\"COLUMNS\", \"15\")\n+\n+    parser_signature = TestHelpBiggerOptionals.parser_signature\n+    argument_signatures = TestHelpBiggerOptionals.argument_signatures\n+    argument_group_signatures = (\n+        TestHelpBiggerOptionals.argument_group_signatures\n+    )\n+    usage = \"\"\"\\\n         usage: PROG\n                [-h]\n                [-v]\n@@ -4136,8 +4444,10 @@ def setUp(self):\n                [--y Y]\n                foo\n                bar\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         DESCRIPTION\n \n@@ -4165,31 +4475,36 @@ def setUp(self):\n             Y HELP\n \n         EPILOG\n-    '''\n-    version                     = TestHelpBiggerOptionals.version\n+    \"\"\"\n+    )\n+    version = TestHelpBiggerOptionals.version\n \n \n class TestHelpBiggerOptionalGroups(HelpTestCase):\n     \"\"\"Make sure that argument help aligns when options are longer\"\"\"\n \n-    parser_signature = Sig(prog='PROG', description='DESCRIPTION',\n-                           epilog='EPILOG')\n+    parser_signature = Sig(\n+        prog=\"PROG\", description=\"DESCRIPTION\", epilog=\"EPILOG\"\n+    )\n     argument_signatures = [\n-        Sig('-v', '--version', action='version', version='0.1'),\n-        Sig('-x', action='store_true', help='X HELP'),\n-        Sig('--y', help='Y HELP'),\n-        Sig('foo', help='FOO HELP'),\n-        Sig('bar', help='BAR HELP'),\n+        Sig(\"-v\", \"--version\", action=\"version\", version=\"0.1\"),\n+        Sig(\"-x\", action=\"store_true\", help=\"X HELP\"),\n+        Sig(\"--y\", help=\"Y HELP\"),\n+        Sig(\"foo\", help=\"FOO HELP\"),\n+        Sig(\"bar\", help=\"BAR HELP\"),\n     ]\n     argument_group_signatures = [\n-        (Sig('GROUP TITLE', description='GROUP DESCRIPTION'), [\n-            Sig('baz', help='BAZ HELP'),\n-            Sig('-z', nargs='+', help='Z HELP')]),\n+        (\n+            Sig(\"GROUP TITLE\", description=\"GROUP DESCRIPTION\"),\n+            [Sig(\"baz\", help=\"BAZ HELP\"), Sig(\"-z\", nargs=\"+\", help=\"Z HELP\")],\n+        ),\n     ]\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-v] [-x] [--y Y] [-z Z [Z ...]] foo bar baz\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         DESCRIPTION\n \n@@ -4210,27 +4525,30 @@ class TestHelpBiggerOptionalGroups(HelpTestCase):\n           -z Z [Z ...]   Z HELP\n \n         EPILOG\n-    '''\n-    version = '''\\\n+    \"\"\"\n+    )\n+    version = \"\"\"\\\n         0.1\n-        '''\n+        \"\"\"\n \n \n class TestHelpBiggerPositionals(HelpTestCase):\n     \"\"\"Make sure that help aligns when arguments are longer\"\"\"\n \n-    parser_signature = Sig(usage='USAGE', description='DESCRIPTION')\n+    parser_signature = Sig(usage=\"USAGE\", description=\"DESCRIPTION\")\n     argument_signatures = [\n-        Sig('-x', action='store_true', help='X HELP'),\n-        Sig('--y', help='Y HELP'),\n-        Sig('ekiekiekifekang', help='EKI HELP'),\n-        Sig('bar', help='BAR HELP'),\n+        Sig(\"-x\", action=\"store_true\", help=\"X HELP\"),\n+        Sig(\"--y\", help=\"Y HELP\"),\n+        Sig(\"ekiekiekifekang\", help=\"EKI HELP\"),\n+        Sig(\"bar\", help=\"BAR HELP\"),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: USAGE\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         DESCRIPTION\n \n@@ -4242,41 +4560,51 @@ class TestHelpBiggerPositionals(HelpTestCase):\n           -h, --help       show this help message and exit\n           -x               X HELP\n           --y Y            Y HELP\n-        '''\n+        \"\"\"\n+    )\n \n-    version = ''\n+    version = \"\"\n \n \n class TestHelpReformatting(HelpTestCase):\n     \"\"\"Make sure that text after short names starts on the first line\"\"\"\n \n     parser_signature = Sig(\n-        prog='PROG',\n-        description='   oddly    formatted\\n'\n-                    'description\\n'\n-                    '\\n'\n-                    'that is so long that it should go onto multiple '\n-                    'lines when wrapped')\n+        prog=\"PROG\",\n+        description=\"   oddly    formatted\\n\"\n+        \"description\\n\"\n+        \"\\n\"\n+        \"that is so long that it should go onto multiple \"\n+        \"lines when wrapped\",\n+    )\n     argument_signatures = [\n-        Sig('-x', metavar='XX', help='oddly\\n'\n-                                     '    formatted -x help'),\n-        Sig('y', metavar='yyy', help='normal y help'),\n+        Sig(\"-x\", metavar=\"XX\", help=\"oddly\\n    formatted -x help\"),\n+        Sig(\"y\", metavar=\"yyy\", help=\"normal y help\"),\n     ]\n     argument_group_signatures = [\n-        (Sig('title', description='\\n'\n-                                  '    oddly formatted group\\n'\n-                                  '\\n'\n-                                  'description'),\n-         [Sig('-a', action='store_true',\n-              help=' oddly \\n'\n-                   'formatted    -a  help  \\n'\n-                   '    again, so long that it should be wrapped over '\n-                   'multiple lines')]),\n-    ]\n-    usage = '''\\\n+        (\n+            Sig(\n+                \"title\",\n+                description=\"\\n    oddly formatted group\\n\\ndescription\",\n+            ),\n+            [\n+                Sig(\n+                    \"-a\",\n+                    action=\"store_true\",\n+                    help=\" oddly \\n\"\n+                    \"formatted    -a  help  \\n\"\n+                    \"    again, so long that it should be wrapped over \"\n+                    \"multiple lines\",\n+                )\n+            ],\n+        ),\n+    ]\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-x XX] [-a] yyy\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         oddly formatted description that is so long that it should go onto \\\n multiple\n@@ -4295,26 +4623,31 @@ class TestHelpReformatting(HelpTestCase):\n           -a          oddly formatted -a help again, so long that it should \\\n be wrapped\n                       over multiple lines\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpWrappingShortNames(HelpTestCase):\n     \"\"\"Make sure that text after short names starts on the first line\"\"\"\n \n-    parser_signature = Sig(prog='PROG', description= 'D\\nD' * 30)\n+    parser_signature = Sig(prog=\"PROG\", description=\"D\\nD\" * 30)\n     argument_signatures = [\n-        Sig('-x', metavar='XX', help='XHH HX' * 20),\n-        Sig('y', metavar='yyy', help='YH YH' * 20),\n+        Sig(\"-x\", metavar=\"XX\", help=\"XHH HX\" * 20),\n+        Sig(\"y\", metavar=\"yyy\", help=\"YH YH\" * 20),\n     ]\n     argument_group_signatures = [\n-        (Sig('ALPHAS'), [\n-            Sig('-a', action='store_true', help='AHHH HHA' * 10)]),\n+        (\n+            Sig(\"ALPHAS\"),\n+            [Sig(\"-a\", action=\"store_true\", help=\"AHHH HHA\" * 10)],\n+        ),\n     ]\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-x XX] [-a] yyy\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         D DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD \\\n DD DD DD\n@@ -4335,28 +4668,35 @@ class TestHelpWrappingShortNames(HelpTestCase):\n           -a          AHHH HHAAHHH HHAAHHH HHAAHHH HHAAHHH HHAAHHH HHAAHHH \\\n HHAAHHH\n                       HHAAHHH HHAAHHH HHA\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpWrappingLongNames(HelpTestCase):\n     \"\"\"Make sure that text after long names starts on the next line\"\"\"\n \n-    parser_signature = Sig(usage='USAGE', description= 'D D' * 30)\n+    parser_signature = Sig(usage=\"USAGE\", description=\"D D\" * 30)\n     argument_signatures = [\n-        Sig('-v', '--version', action='version', version='V V' * 30),\n-        Sig('-x', metavar='X' * 25, help='XH XH' * 20),\n-        Sig('y', metavar='y' * 25, help='YH YH' * 20),\n+        Sig(\"-v\", \"--version\", action=\"version\", version=\"V V\" * 30),\n+        Sig(\"-x\", metavar=\"X\" * 25, help=\"XH XH\" * 20),\n+        Sig(\"y\", metavar=\"y\" * 25, help=\"YH YH\" * 20),\n     ]\n     argument_group_signatures = [\n-        (Sig('ALPHAS'), [\n-            Sig('-a', metavar='A' * 25, help='AH AH' * 20),\n-            Sig('z', metavar='z' * 25, help='ZH ZH' * 20)]),\n-    ]\n-    usage = '''\\\n+        (\n+            Sig(\"ALPHAS\"),\n+            [\n+                Sig(\"-a\", metavar=\"A\" * 25, help=\"AH AH\" * 20),\n+                Sig(\"z\", metavar=\"z\" * 25, help=\"ZH ZH\" * 20),\n+            ],\n+        ),\n+    ]\n+    usage = \"\"\"\\\n         usage: USAGE\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         D DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD DD \\\n DD DD DD\n@@ -4385,47 +4725,67 @@ class TestHelpWrappingLongNames(HelpTestCase):\n                                 ZH ZHZH ZHZH ZHZH ZHZH ZHZH ZHZH ZHZH ZHZH \\\n ZHZH ZHZH\n                                 ZHZH ZHZH ZHZH ZHZH ZHZH ZHZH ZHZH ZHZH ZHZH ZH\n-        '''\n-    version = '''\\\n+        \"\"\"\n+    )\n+    version = \"\"\"\\\n         V VV VV VV VV VV VV VV VV VV VV VV VV VV VV VV VV VV VV VV VV VV VV \\\n VV VV VV\n         VV VV VV VV V\n-        '''\n+        \"\"\"\n \n \n class TestHelpUsage(HelpTestCase):\n     \"\"\"Test basic usage messages\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('-w', nargs='+', help='w'),\n-        Sig('-x', nargs='*', help='x'),\n-        Sig('a', help='a'),\n-        Sig('b', help='b', nargs=2),\n-        Sig('c', help='c', nargs='?'),\n-        Sig('--foo', help='Whether to foo', action=argparse.BooleanOptionalAction),\n-        Sig('--bar', help='Whether to bar', default=True,\n-                     action=argparse.BooleanOptionalAction),\n-        Sig('-f', '--foobar', '--barfoo', action=argparse.BooleanOptionalAction),\n-        Sig('--bazz', action=argparse.BooleanOptionalAction,\n-                      default=argparse.SUPPRESS, help='Bazz!'),\n+        Sig(\"-w\", nargs=\"+\", help=\"w\"),\n+        Sig(\"-x\", nargs=\"*\", help=\"x\"),\n+        Sig(\"a\", help=\"a\"),\n+        Sig(\"b\", help=\"b\", nargs=2),\n+        Sig(\"c\", help=\"c\", nargs=\"?\"),\n+        Sig(\n+            \"--foo\",\n+            help=\"Whether to foo\",\n+            action=argparse.BooleanOptionalAction,\n+        ),\n+        Sig(\n+            \"--bar\",\n+            help=\"Whether to bar\",\n+            default=True,\n+            action=argparse.BooleanOptionalAction,\n+        ),\n+        Sig(\n+            \"-f\", \"--foobar\", \"--barfoo\", action=argparse.BooleanOptionalAction\n+        ),\n+        Sig(\n+            \"--bazz\",\n+            action=argparse.BooleanOptionalAction,\n+            default=argparse.SUPPRESS,\n+            help=\"Bazz!\",\n+        ),\n     ]\n     argument_group_signatures = [\n-        (Sig('group'), [\n-            Sig('-y', nargs='?', help='y'),\n-            Sig('-z', nargs=3, help='z'),\n-            Sig('d', help='d', nargs='*'),\n-            Sig('e', help='e', nargs='+'),\n-        ])\n-    ]\n-    usage = '''\\\n+        (\n+            Sig(\"group\"),\n+            [\n+                Sig(\"-y\", nargs=\"?\", help=\"y\"),\n+                Sig(\"-z\", nargs=3, help=\"z\"),\n+                Sig(\"d\", help=\"d\", nargs=\"*\"),\n+                Sig(\"e\", help=\"e\", nargs=\"+\"),\n+            ],\n+        )\n+    ]\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-w W [W ...]] [-x [X ...]] [--foo | --no-foo]\n                     [--bar | --no-bar]\n                     [-f | --foobar | --no-foobar | --barfoo | --no-barfoo]\n                     [--bazz | --no-bazz] [-y [Y]] [-z Z Z Z]\n                     a b b [c] [d ...] e [e ...]\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           a                     a\n@@ -4446,21 +4806,24 @@ class TestHelpUsage(HelpTestCase):\n           -z Z Z Z              z\n           d                     d\n           e                     e\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpUsageWithParentheses(HelpTestCase):\n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('positional', metavar='(example) positional'),\n-        Sig('-p', '--optional', metavar='{1 (option A), 2 (option B)}'),\n+        Sig(\"positional\", metavar=\"(example) positional\"),\n+        Sig(\"-p\", \"--optional\", metavar=\"{1 (option A), 2 (option B)}\"),\n     ]\n \n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-p {1 (option A), 2 (option B)}] (example) positional\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           (example) positional\n@@ -4468,29 +4831,38 @@ class TestHelpUsageWithParentheses(HelpTestCase):\n         options:\n           -h, --help            show this help message and exit\n           -p, --optional {1 (option A), 2 (option B)}\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpOnlyUserGroups(HelpTestCase):\n     \"\"\"Test basic usage messages\"\"\"\n \n-    parser_signature = Sig(prog='PROG', add_help=False)\n+    parser_signature = Sig(prog=\"PROG\", add_help=False)\n     argument_signatures = []\n     argument_group_signatures = [\n-        (Sig('xxxx'), [\n-            Sig('-x', help='x'),\n-            Sig('a', help='a'),\n-        ]),\n-        (Sig('yyyy'), [\n-            Sig('b', help='b'),\n-            Sig('-y', help='y'),\n-        ]),\n-    ]\n-    usage = '''\\\n+        (\n+            Sig(\"xxxx\"),\n+            [\n+                Sig(\"-x\", help=\"x\"),\n+                Sig(\"a\", help=\"a\"),\n+            ],\n+        ),\n+        (\n+            Sig(\"yyyy\"),\n+            [\n+                Sig(\"b\", help=\"b\"),\n+                Sig(\"-y\", help=\"y\"),\n+            ],\n+        ),\n+    ]\n+    usage = \"\"\"\\\n         usage: PROG [-x X] [-y Y] a b\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         xxxx:\n           -x X  x\n@@ -4499,26 +4871,29 @@ class TestHelpOnlyUserGroups(HelpTestCase):\n         yyyy:\n           b     b\n           -y Y  y\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpUsageLongProg(HelpTestCase):\n     \"\"\"Test usage messages where the prog is long\"\"\"\n \n-    parser_signature = Sig(prog='P' * 60)\n+    parser_signature = Sig(prog=\"P\" * 60)\n     argument_signatures = [\n-        Sig('-w', metavar='W'),\n-        Sig('-x', metavar='X'),\n-        Sig('a'),\n-        Sig('b'),\n+        Sig(\"-w\", metavar=\"W\"),\n+        Sig(\"-x\", metavar=\"X\"),\n+        Sig(\"a\"),\n+        Sig(\"b\"),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP\n                [-h] [-w W] [-x X] a b\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           a\n@@ -4528,31 +4903,34 @@ class TestHelpUsageLongProg(HelpTestCase):\n           -h, --help  show this help message and exit\n           -w W\n           -x X\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpUsageLongProgOptionsWrap(HelpTestCase):\n     \"\"\"Test usage messages where the prog is long and the optionals wrap\"\"\"\n \n-    parser_signature = Sig(prog='P' * 60)\n+    parser_signature = Sig(prog=\"P\" * 60)\n     argument_signatures = [\n-        Sig('-w', metavar='W' * 25),\n-        Sig('-x', metavar='X' * 25),\n-        Sig('-y', metavar='Y' * 25),\n-        Sig('-z', metavar='Z' * 25),\n-        Sig('a'),\n-        Sig('b'),\n+        Sig(\"-w\", metavar=\"W\" * 25),\n+        Sig(\"-x\", metavar=\"X\" * 25),\n+        Sig(\"-y\", metavar=\"Y\" * 25),\n+        Sig(\"-z\", metavar=\"Z\" * 25),\n+        Sig(\"a\"),\n+        Sig(\"b\"),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP\n                [-h] [-w WWWWWWWWWWWWWWWWWWWWWWWWW] \\\n [-x XXXXXXXXXXXXXXXXXXXXXXXXX]\n                [-y YYYYYYYYYYYYYYYYYYYYYYYYY] [-z ZZZZZZZZZZZZZZZZZZZZZZZZZ]\n                a b\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           a\n@@ -4564,57 +4942,63 @@ class TestHelpUsageLongProgOptionsWrap(HelpTestCase):\n           -x XXXXXXXXXXXXXXXXXXXXXXXXX\n           -y YYYYYYYYYYYYYYYYYYYYYYYYY\n           -z ZZZZZZZZZZZZZZZZZZZZZZZZZ\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpUsageLongProgPositionalsWrap(HelpTestCase):\n     \"\"\"Test usage messages where the prog is long and the positionals wrap\"\"\"\n \n-    parser_signature = Sig(prog='P' * 60, add_help=False)\n+    parser_signature = Sig(prog=\"P\" * 60, add_help=False)\n     argument_signatures = [\n-        Sig('a' * 25),\n-        Sig('b' * 25),\n-        Sig('c' * 25),\n+        Sig(\"a\" * 25),\n+        Sig(\"b\" * 25),\n+        Sig(\"c\" * 25),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPP\n                aaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbbb\n                ccccccccccccccccccccccccc\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           aaaaaaaaaaaaaaaaaaaaaaaaa\n           bbbbbbbbbbbbbbbbbbbbbbbbb\n           ccccccccccccccccccccccccc\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpUsageOptionalsWrap(HelpTestCase):\n     \"\"\"Test usage messages where the optionals wrap\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('-w', metavar='W' * 25),\n-        Sig('-x', metavar='X' * 25),\n-        Sig('-y', metavar='Y' * 25),\n-        Sig('-z', metavar='Z' * 25),\n-        Sig('a'),\n-        Sig('b'),\n-        Sig('c'),\n+        Sig(\"-w\", metavar=\"W\" * 25),\n+        Sig(\"-x\", metavar=\"X\" * 25),\n+        Sig(\"-y\", metavar=\"Y\" * 25),\n+        Sig(\"-z\", metavar=\"Z\" * 25),\n+        Sig(\"a\"),\n+        Sig(\"b\"),\n+        Sig(\"c\"),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-w WWWWWWWWWWWWWWWWWWWWWWWWW] \\\n [-x XXXXXXXXXXXXXXXXXXXXXXXXX]\n                     [-y YYYYYYYYYYYYYYYYYYYYYYYYY] \\\n [-z ZZZZZZZZZZZZZZZZZZZZZZZZZ]\n                     a b c\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           a\n@@ -4627,29 +5011,32 @@ class TestHelpUsageOptionalsWrap(HelpTestCase):\n           -x XXXXXXXXXXXXXXXXXXXXXXXXX\n           -y YYYYYYYYYYYYYYYYYYYYYYYYY\n           -z ZZZZZZZZZZZZZZZZZZZZZZZZZ\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpUsagePositionalsWrap(HelpTestCase):\n     \"\"\"Test usage messages where the positionals wrap\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('-x'),\n-        Sig('-y'),\n-        Sig('-z'),\n-        Sig('a' * 25),\n-        Sig('b' * 25),\n-        Sig('c' * 25),\n+        Sig(\"-x\"),\n+        Sig(\"-y\"),\n+        Sig(\"-z\"),\n+        Sig(\"a\" * 25),\n+        Sig(\"b\" * 25),\n+        Sig(\"c\" * 25),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-x X] [-y Y] [-z Z]\n                     aaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbbb\n                     ccccccccccccccccccccccccc\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           aaaaaaaaaaaaaaaaaaaaaaaaa\n@@ -4661,31 +5048,34 @@ class TestHelpUsagePositionalsWrap(HelpTestCase):\n           -x X\n           -y Y\n           -z Z\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpUsageOptionalsPositionalsWrap(HelpTestCase):\n     \"\"\"Test usage messages where the optionals and positionals wrap\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('-x', metavar='X' * 25),\n-        Sig('-y', metavar='Y' * 25),\n-        Sig('-z', metavar='Z' * 25),\n-        Sig('a' * 25),\n-        Sig('b' * 25),\n-        Sig('c' * 25),\n+        Sig(\"-x\", metavar=\"X\" * 25),\n+        Sig(\"-y\", metavar=\"Y\" * 25),\n+        Sig(\"-z\", metavar=\"Z\" * 25),\n+        Sig(\"a\" * 25),\n+        Sig(\"b\" * 25),\n+        Sig(\"c\" * 25),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-x XXXXXXXXXXXXXXXXXXXXXXXXX] \\\n [-y YYYYYYYYYYYYYYYYYYYYYYYYY]\n                     [-z ZZZZZZZZZZZZZZZZZZZZZZZZZ]\n                     aaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbbb\n                     ccccccccccccccccccccccccc\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           aaaaaaaaaaaaaaaaaaaaaaaaa\n@@ -4697,89 +5087,98 @@ class TestHelpUsageOptionalsPositionalsWrap(HelpTestCase):\n           -x XXXXXXXXXXXXXXXXXXXXXXXXX\n           -y YYYYYYYYYYYYYYYYYYYYYYYYY\n           -z ZZZZZZZZZZZZZZZZZZZZZZZZZ\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpUsageOptionalsOnlyWrap(HelpTestCase):\n     \"\"\"Test usage messages where there are only optionals and they wrap\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('-x', metavar='X' * 25),\n-        Sig('-y', metavar='Y' * 25),\n-        Sig('-z', metavar='Z' * 25),\n+        Sig(\"-x\", metavar=\"X\" * 25),\n+        Sig(\"-y\", metavar=\"Y\" * 25),\n+        Sig(\"-z\", metavar=\"Z\" * 25),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-x XXXXXXXXXXXXXXXXXXXXXXXXX] \\\n [-y YYYYYYYYYYYYYYYYYYYYYYYYY]\n                     [-z ZZZZZZZZZZZZZZZZZZZZZZZZZ]\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         options:\n           -h, --help            show this help message and exit\n           -x XXXXXXXXXXXXXXXXXXXXXXXXX\n           -y YYYYYYYYYYYYYYYYYYYYYYYYY\n           -z ZZZZZZZZZZZZZZZZZZZZZZZZZ\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpUsagePositionalsOnlyWrap(HelpTestCase):\n     \"\"\"Test usage messages where there are only positionals and they wrap\"\"\"\n \n-    parser_signature = Sig(prog='PROG', add_help=False)\n+    parser_signature = Sig(prog=\"PROG\", add_help=False)\n     argument_signatures = [\n-        Sig('a' * 25),\n-        Sig('b' * 25),\n-        Sig('c' * 25),\n+        Sig(\"a\" * 25),\n+        Sig(\"b\" * 25),\n+        Sig(\"c\" * 25),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG aaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbbb\n                     ccccccccccccccccccccccccc\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           aaaaaaaaaaaaaaaaaaaaaaaaa\n           bbbbbbbbbbbbbbbbbbbbbbbbb\n           ccccccccccccccccccccccccc\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpUsageMetavarsSpacesParentheses(HelpTestCase):\n     # https://github.com/python/cpython/issues/62549\n     # https://github.com/python/cpython/issues/89743\n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('-n1', metavar='()', help='n1'),\n-        Sig('-o1', metavar='(1, 2)', help='o1'),\n-        Sig('-u1', metavar=' (uu) ', help='u1'),\n-        Sig('-v1', metavar='( vv )', help='v1'),\n-        Sig('-w1', metavar='(w)w', help='w1'),\n-        Sig('-x1', metavar='x(x)', help='x1'),\n-        Sig('-y1', metavar='yy)', help='y1'),\n-        Sig('-z1', metavar='(zz', help='z1'),\n-        Sig('-n2', metavar='[]', help='n2'),\n-        Sig('-o2', metavar='[1, 2]', help='o2'),\n-        Sig('-u2', metavar=' [uu] ', help='u2'),\n-        Sig('-v2', metavar='[ vv ]', help='v2'),\n-        Sig('-w2', metavar='[w]w', help='w2'),\n-        Sig('-x2', metavar='x[x]', help='x2'),\n-        Sig('-y2', metavar='yy]', help='y2'),\n-        Sig('-z2', metavar='[zz', help='z2'),\n-    ]\n-\n-    usage = '''\\\n+        Sig(\"-n1\", metavar=\"()\", help=\"n1\"),\n+        Sig(\"-o1\", metavar=\"(1, 2)\", help=\"o1\"),\n+        Sig(\"-u1\", metavar=\" (uu) \", help=\"u1\"),\n+        Sig(\"-v1\", metavar=\"( vv )\", help=\"v1\"),\n+        Sig(\"-w1\", metavar=\"(w)w\", help=\"w1\"),\n+        Sig(\"-x1\", metavar=\"x(x)\", help=\"x1\"),\n+        Sig(\"-y1\", metavar=\"yy)\", help=\"y1\"),\n+        Sig(\"-z1\", metavar=\"(zz\", help=\"z1\"),\n+        Sig(\"-n2\", metavar=\"[]\", help=\"n2\"),\n+        Sig(\"-o2\", metavar=\"[1, 2]\", help=\"o2\"),\n+        Sig(\"-u2\", metavar=\" [uu] \", help=\"u2\"),\n+        Sig(\"-v2\", metavar=\"[ vv ]\", help=\"v2\"),\n+        Sig(\"-w2\", metavar=\"[w]w\", help=\"w2\"),\n+        Sig(\"-x2\", metavar=\"x[x]\", help=\"x2\"),\n+        Sig(\"-y2\", metavar=\"yy]\", help=\"y2\"),\n+        Sig(\"-z2\", metavar=\"[zz\", help=\"z2\"),\n+    ]\n+\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-n1 ()] [-o1 (1, 2)] [-u1  (uu) ] [-v1 ( vv )] [-w1 (w)w]\n                     [-x1 x(x)] [-y1 yy)] [-z1 (zz] [-n2 []] [-o2 [1, 2]] [-u2  [uu] ]\n                     [-v2 [ vv ]] [-w2 [w]w] [-x2 x[x]] [-y2 yy]] [-z2 [zz]\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         options:\n           -h, --help  show this help message and exit\n@@ -4799,37 +5198,40 @@ class TestHelpUsageMetavarsSpacesParentheses(HelpTestCase):\n           -x2 x[x]    x2\n           -y2 yy]     y2\n           -z2 [zz     z2\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n @force_not_colorized_test_class\n class TestHelpUsageNoWhitespaceCrash(TestCase):\n-\n     def test_all_suppressed_mutex_followed_by_long_arg(self):\n         # https://github.com/python/cpython/issues/62090\n         # https://github.com/python/cpython/issues/96310\n-        parser = argparse.ArgumentParser(prog='PROG')\n+        parser = argparse.ArgumentParser(prog=\"PROG\")\n         mutex = parser.add_mutually_exclusive_group()\n-        mutex.add_argument('--spam', help=argparse.SUPPRESS)\n-        parser.add_argument('--eggs-eggs-eggs-eggs-eggs-eggs')\n-        usage = textwrap.dedent('''\\\n+        mutex.add_argument(\"--spam\", help=argparse.SUPPRESS)\n+        parser.add_argument(\"--eggs-eggs-eggs-eggs-eggs-eggs\")\n+        usage = textwrap.dedent(\"\"\"\\\n         usage: PROG [-h]\n                     [--eggs-eggs-eggs-eggs-eggs-eggs EGGS_EGGS_EGGS_EGGS_EGGS_EGGS]\n-        ''')\n+        \"\"\")\n         self.assertEqual(parser.format_usage(), usage)\n \n     def test_newline_in_metavar(self):\n         # https://github.com/python/cpython/issues/77048\n-        mapping = ['123456', '12345', '12345', '123']\n-        parser = argparse.ArgumentParser('11111111111111')\n-        parser.add_argument('-v', '--verbose',\n-                            help='verbose mode', action='store_true')\n-        parser.add_argument('targets',\n-                            help='installation targets',\n-                            nargs='+',\n-                            metavar='\\n'.join(mapping))\n-        usage = textwrap.dedent('''\\\n+        mapping = [\"123456\", \"12345\", \"12345\", \"123\"]\n+        parser = argparse.ArgumentParser(\"11111111111111\")\n+        parser.add_argument(\n+            \"-v\", \"--verbose\", help=\"verbose mode\", action=\"store_true\"\n+        )\n+        parser.add_argument(\n+            \"targets\",\n+            help=\"installation targets\",\n+            nargs=\"+\",\n+            metavar=\"\\n\".join(mapping),\n+        )\n+        usage = textwrap.dedent(\"\"\"\\\n         usage: 11111111111111 [-h] [-v]\n                               123456\n         12345\n@@ -4838,80 +5240,105 @@ def test_newline_in_metavar(self):\n         12345\n         12345\n         123 ...]\n-        ''')\n+        \"\"\")\n         self.assertEqual(parser.format_usage(), usage)\n \n     def test_empty_metavar_required_arg(self):\n         # https://github.com/python/cpython/issues/82091\n-        parser = argparse.ArgumentParser(prog='PROG')\n-        parser.add_argument('--nil', metavar='', required=True)\n-        parser.add_argument('--a', metavar='A' * 70)\n+        parser = argparse.ArgumentParser(prog=\"PROG\")\n+        parser.add_argument(\"--nil\", metavar=\"\", required=True)\n+        parser.add_argument(\"--a\", metavar=\"A\" * 70)\n         usage = (\n-            'usage: PROG [-h] --nil \\n'\n-            '            [--a AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA'\n-            'AAAAAAAAAAAAAAAAAAAAAAA]\\n'\n+            \"usage: PROG [-h] --nil \\n\"\n+            \"            [--a AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\n+            \"AAAAAAAAAAAAAAAAAAAAAAA]\\n\"\n         )\n         self.assertEqual(parser.format_usage(), usage)\n \n     def test_all_suppressed_mutex_with_optional_nargs(self):\n         # https://github.com/python/cpython/issues/98666\n-        parser = argparse.ArgumentParser(prog='PROG')\n+        parser = argparse.ArgumentParser(prog=\"PROG\")\n         mutex = parser.add_mutually_exclusive_group()\n         mutex.add_argument(\n-            '--param1',\n-            nargs='?', const='default', metavar='NAME', help=argparse.SUPPRESS)\n+            \"--param1\",\n+            nargs=\"?\",\n+            const=\"default\",\n+            metavar=\"NAME\",\n+            help=argparse.SUPPRESS,\n+        )\n         mutex.add_argument(\n-            '--param2',\n-            nargs='?', const='default', metavar='NAME', help=argparse.SUPPRESS)\n-        usage = 'usage: PROG [-h]\\n'\n+            \"--param2\",\n+            nargs=\"?\",\n+            const=\"default\",\n+            metavar=\"NAME\",\n+            help=argparse.SUPPRESS,\n+        )\n+        usage = \"usage: PROG [-h]\\n\"\n         self.assertEqual(parser.format_usage(), usage)\n \n     def test_long_mutex_groups_wrap(self):\n-        parser = argparse.ArgumentParser(prog='PROG')\n+        parser = argparse.ArgumentParser(prog=\"PROG\")\n         g = parser.add_mutually_exclusive_group()\n-        g.add_argument('--op1', metavar='MET', nargs='?')\n-        g.add_argument('--op2', metavar=('MET1', 'MET2'), nargs='*')\n-        g.add_argument('--op3', nargs='*')\n-        g.add_argument('--op4', metavar=('MET1', 'MET2'), nargs='+')\n-        g.add_argument('--op5', nargs='+')\n-        g.add_argument('--op6', nargs=3)\n-        g.add_argument('--op7', metavar=('MET1', 'MET2', 'MET3'), nargs=3)\n-\n-        usage = textwrap.dedent('''\\\n+        g.add_argument(\"--op1\", metavar=\"MET\", nargs=\"?\")\n+        g.add_argument(\"--op2\", metavar=(\"MET1\", \"MET2\"), nargs=\"*\")\n+        g.add_argument(\"--op3\", nargs=\"*\")\n+        g.add_argument(\"--op4\", metavar=(\"MET1\", \"MET2\"), nargs=\"+\")\n+        g.add_argument(\"--op5\", nargs=\"+\")\n+        g.add_argument(\"--op6\", nargs=3)\n+        g.add_argument(\"--op7\", metavar=(\"MET1\", \"MET2\", \"MET3\"), nargs=3)\n+\n+        usage = textwrap.dedent(\"\"\"\\\n         usage: PROG [-h] [--op1 [MET] | --op2 [MET1 [MET2 ...]] | --op3 [OP3 ...] |\n                     --op4 MET1 [MET2 ...] | --op5 OP5 [OP5 ...] | --op6 OP6 OP6 OP6 |\n                     --op7 MET1 MET2 MET3]\n-        ''')\n+        \"\"\")\n         self.assertEqual(parser.format_usage(), usage)\n \n \n class TestHelpVariableExpansion(HelpTestCase):\n     \"\"\"Test that variables are expanded properly in help messages\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('-x', type=int,\n-            help='x %(prog)s %(default)s %(type)s %%'),\n-        Sig('-y', action='store_const', default=42, const='XXX',\n-            help='y %(prog)s %(default)s %(const)s'),\n-        Sig('--foo', choices=['a', 'b', 'c'],\n-            help='foo %(prog)s %(default)s %(choices)s'),\n-        Sig('--bar', default='baz', choices=[1, 2], metavar='BBB',\n-            help='bar %(prog)s %(default)s %(dest)s'),\n-        Sig('spam', help='spam %(prog)s %(default)s'),\n-        Sig('badger', default=0.5, help='badger %(prog)s %(default)s'),\n+        Sig(\"-x\", type=int, help=\"x %(prog)s %(default)s %(type)s %%\"),\n+        Sig(\n+            \"-y\",\n+            action=\"store_const\",\n+            default=42,\n+            const=\"XXX\",\n+            help=\"y %(prog)s %(default)s %(const)s\",\n+        ),\n+        Sig(\n+            \"--foo\",\n+            choices=[\"a\", \"b\", \"c\"],\n+            help=\"foo %(prog)s %(default)s %(choices)s\",\n+        ),\n+        Sig(\n+            \"--bar\",\n+            default=\"baz\",\n+            choices=[1, 2],\n+            metavar=\"BBB\",\n+            help=\"bar %(prog)s %(default)s %(dest)s\",\n+        ),\n+        Sig(\"spam\", help=\"spam %(prog)s %(default)s\"),\n+        Sig(\"badger\", default=0.5, help=\"badger %(prog)s %(default)s\"),\n     ]\n     argument_group_signatures = [\n-        (Sig('group'), [\n-            Sig('-a', help='a %(prog)s %(default)s'),\n-            Sig('-b', default=-1, help='b %(prog)s %(default)s'),\n-        ])\n+        (\n+            Sig(\"group\"),\n+            [\n+                Sig(\"-a\", help=\"a %(prog)s %(default)s\"),\n+                Sig(\"-b\", default=-1, help=\"b %(prog)s %(default)s\"),\n+            ],\n+        )\n     ]\n-    usage = ('''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-x X] [-y] [--foo {a,b,c}] [--bar BBB] [-a A] [-b B]\n                     spam badger\n-        ''')\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           spam           spam PROG None\n@@ -4927,96 +5354,105 @@ class TestHelpVariableExpansion(HelpTestCase):\n         group:\n           -a A           a PROG None\n           -b B           b PROG -1\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpVariableExpansionUsageSupplied(HelpTestCase):\n     \"\"\"Test that variables are expanded properly when usage= is present\"\"\"\n \n-    parser_signature = Sig(prog='PROG', usage='%(prog)s FOO')\n+    parser_signature = Sig(prog=\"PROG\", usage=\"%(prog)s FOO\")\n     argument_signatures = []\n     argument_group_signatures = []\n-    usage = ('''\\\n+    usage = \"\"\"\\\n         usage: PROG FOO\n-        ''')\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         options:\n           -h, --help  show this help message and exit\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpVariableExpansionNoArguments(HelpTestCase):\n     \"\"\"Test that variables are expanded properly with no arguments\"\"\"\n \n-    parser_signature = Sig(prog='PROG', add_help=False)\n+    parser_signature = Sig(prog=\"PROG\", add_help=False)\n     argument_signatures = []\n     argument_group_signatures = []\n-    usage = ('''\\\n+    usage = \"\"\"\\\n         usage: PROG\n-        ''')\n+        \"\"\"\n     help = usage\n-    version = ''\n+    version = \"\"\n \n \n class TestHelpSuppressUsage(HelpTestCase):\n     \"\"\"Test that items can be suppressed in usage messages\"\"\"\n \n-    parser_signature = Sig(prog='PROG', usage=argparse.SUPPRESS)\n+    parser_signature = Sig(prog=\"PROG\", usage=argparse.SUPPRESS)\n     argument_signatures = [\n-        Sig('--foo', help='foo help'),\n-        Sig('spam', help='spam help'),\n+        Sig(\"--foo\", help=\"foo help\"),\n+        Sig(\"spam\", help=\"spam help\"),\n     ]\n     argument_group_signatures = []\n-    help = '''\\\n+    help = \"\"\"\\\n         positional arguments:\n           spam        spam help\n \n         options:\n           -h, --help  show this help message and exit\n           --foo FOO   foo help\n-        '''\n-    usage = ''\n-    version = ''\n+        \"\"\"\n+    usage = \"\"\n+    version = \"\"\n \n \n class TestHelpSuppressOptional(HelpTestCase):\n     \"\"\"Test that optional arguments can be suppressed in help messages\"\"\"\n \n-    parser_signature = Sig(prog='PROG', add_help=False)\n+    parser_signature = Sig(prog=\"PROG\", add_help=False)\n     argument_signatures = [\n-        Sig('--foo', help=argparse.SUPPRESS),\n-        Sig('spam', help='spam help'),\n+        Sig(\"--foo\", help=argparse.SUPPRESS),\n+        Sig(\"spam\", help=\"spam help\"),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG spam\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           spam  spam help\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpSuppressOptionalGroup(HelpTestCase):\n     \"\"\"Test that optional groups can be suppressed in help messages\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('--foo', help='foo help'),\n-        Sig('spam', help='spam help'),\n+        Sig(\"--foo\", help=\"foo help\"),\n+        Sig(\"spam\", help=\"spam help\"),\n     ]\n     argument_group_signatures = [\n-        (Sig('group'), [Sig('--bar', help=argparse.SUPPRESS)]),\n+        (Sig(\"group\"), [Sig(\"--bar\", help=argparse.SUPPRESS)]),\n     ]\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [--foo FOO] spam\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           spam        spam help\n@@ -5024,108 +5460,123 @@ class TestHelpSuppressOptionalGroup(HelpTestCase):\n         options:\n           -h, --help  show this help message and exit\n           --foo FOO   foo help\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpSuppressPositional(HelpTestCase):\n     \"\"\"Test that positional arguments can be suppressed in help messages\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('--foo', help='foo help'),\n-        Sig('spam', help=argparse.SUPPRESS),\n+        Sig(\"--foo\", help=\"foo help\"),\n+        Sig(\"spam\", help=argparse.SUPPRESS),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [--foo FOO]\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         options:\n           -h, --help  show this help message and exit\n           --foo FOO   foo help\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpRequiredOptional(HelpTestCase):\n     \"\"\"Test that required options don't look optional\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('--foo', required=True, help='foo help'),\n+        Sig(\"--foo\", required=True, help=\"foo help\"),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] --foo FOO\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         options:\n           -h, --help  show this help message and exit\n           --foo FOO   foo help\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpAlternatePrefixChars(HelpTestCase):\n     \"\"\"Test that options display with different prefix characters\"\"\"\n \n-    parser_signature = Sig(prog='PROG', prefix_chars='^;', add_help=False)\n+    parser_signature = Sig(prog=\"PROG\", prefix_chars=\"^;\", add_help=False)\n     argument_signatures = [\n-        Sig('^^foo', action='store_true', help='foo help'),\n-        Sig(';b', ';;bar', help='bar help'),\n+        Sig(\"^^foo\", action=\"store_true\", help=\"foo help\"),\n+        Sig(\";b\", \";;bar\", help=\"bar help\"),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [^^foo] [;b BAR]\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         options:\n           ^^foo          foo help\n           ;b, ;;bar BAR  bar help\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpNoHelpOptional(HelpTestCase):\n     \"\"\"Test that the --help argument can be suppressed help messages\"\"\"\n \n-    parser_signature = Sig(prog='PROG', add_help=False)\n+    parser_signature = Sig(prog=\"PROG\", add_help=False)\n     argument_signatures = [\n-        Sig('--foo', help='foo help'),\n-        Sig('spam', help='spam help'),\n+        Sig(\"--foo\", help=\"foo help\"),\n+        Sig(\"spam\", help=\"spam help\"),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [--foo FOO] spam\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           spam       spam help\n \n         options:\n           --foo FOO  foo help\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpNone(HelpTestCase):\n     \"\"\"Test that no errors occur if no help is specified\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('--foo'),\n-        Sig('spam'),\n+        Sig(\"--foo\"),\n+        Sig(\"spam\"),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [--foo FOO] spam\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           spam\n@@ -5133,26 +5584,29 @@ class TestHelpNone(HelpTestCase):\n         options:\n           -h, --help  show this help message and exit\n           --foo FOO\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpTupleMetavarOptional(HelpTestCase):\n     \"\"\"Test specifying metavar as a tuple\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('-w', help='w', nargs='+', metavar=('W1', 'W2')),\n-        Sig('-x', help='x', nargs='*', metavar=('X1', 'X2')),\n-        Sig('-y', help='y', nargs=3, metavar=('Y1', 'Y2', 'Y3')),\n-        Sig('-z', help='z', nargs='?', metavar=('Z1', )),\n+        Sig(\"-w\", help=\"w\", nargs=\"+\", metavar=(\"W1\", \"W2\")),\n+        Sig(\"-x\", help=\"x\", nargs=\"*\", metavar=(\"X1\", \"X2\")),\n+        Sig(\"-y\", help=\"y\", nargs=3, metavar=(\"Y1\", \"Y2\", \"Y3\")),\n+        Sig(\"-z\", help=\"z\", nargs=\"?\", metavar=(\"Z1\",)),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-w W1 [W2 ...]] [-x [X1 [X2 ...]]] [-y Y1 Y2 Y3] \\\n [-z [Z1]]\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         options:\n           -h, --help        show this help message and exit\n@@ -5160,25 +5614,28 @@ class TestHelpTupleMetavarOptional(HelpTestCase):\n           -x [X1 [X2 ...]]  x\n           -y Y1 Y2 Y3       y\n           -z [Z1]           z\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpTupleMetavarPositional(HelpTestCase):\n     \"\"\"Test specifying metavar on a Positional as a tuple\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('w', help='w help', nargs='+', metavar=('W1', 'W2')),\n-        Sig('x', help='x help', nargs='*', metavar=('X1', 'X2')),\n-        Sig('y', help='y help', nargs=3, metavar=('Y1', 'Y2', 'Y3')),\n-        Sig('z', help='z help', nargs='?', metavar=('Z1',)),\n+        Sig(\"w\", help=\"w help\", nargs=\"+\", metavar=(\"W1\", \"W2\")),\n+        Sig(\"x\", help=\"x help\", nargs=\"*\", metavar=(\"X1\", \"X2\")),\n+        Sig(\"y\", help=\"y help\", nargs=3, metavar=(\"Y1\", \"Y2\", \"Y3\")),\n+        Sig(\"z\", help=\"z help\", nargs=\"?\", metavar=(\"Z1\",)),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] W1 [W2 ...] [X1 [X2 ...]] Y1 Y2 Y3 [Z1]\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           W1 W2       w help\n@@ -5188,35 +5645,44 @@ class TestHelpTupleMetavarPositional(HelpTestCase):\n \n         options:\n           -h, --help  show this help message and exit\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpRawText(HelpTestCase):\n     \"\"\"Test the RawTextHelpFormatter\"\"\"\n \n     parser_signature = Sig(\n-        prog='PROG', formatter_class=argparse.RawTextHelpFormatter,\n-        description='Keep the formatting\\n'\n-                    '    exactly as it is written\\n'\n-                    '\\n'\n-                    'here\\n')\n+        prog=\"PROG\",\n+        formatter_class=argparse.RawTextHelpFormatter,\n+        description=\"Keep the formatting\\n\"\n+        \"    exactly as it is written\\n\"\n+        \"\\n\"\n+        \"here\\n\",\n+    )\n \n     argument_signatures = [\n-        Sig('--foo', help='    foo help should also\\n'\n-                          'appear as given here'),\n-        Sig('spam', help='spam help'),\n+        Sig(\"--foo\", help=\"    foo help should also\\nappear as given here\"),\n+        Sig(\"spam\", help=\"spam help\"),\n     ]\n     argument_group_signatures = [\n-        (Sig('title', description='    This text\\n'\n-                                  '  should be indented\\n'\n-                                  '    exactly like it is here\\n'),\n-         [Sig('--bar', help='bar help')]),\n+        (\n+            Sig(\n+                \"title\",\n+                description=\"    This text\\n\"\n+                \"  should be indented\\n\"\n+                \"    exactly like it is here\\n\",\n+            ),\n+            [Sig(\"--bar\", help=\"bar help\")],\n+        ),\n     ]\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [--foo FOO] [--bar BAR] spam\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         Keep the formatting\n             exactly as it is written\n@@ -5237,35 +5703,47 @@ class TestHelpRawText(HelpTestCase):\n               exactly like it is here\n \n           --bar BAR   bar help\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpRawDescription(HelpTestCase):\n     \"\"\"Test the RawTextHelpFormatter\"\"\"\n \n     parser_signature = Sig(\n-        prog='PROG', formatter_class=argparse.RawDescriptionHelpFormatter,\n-        description='Keep the formatting\\n'\n-                    '    exactly as it is written\\n'\n-                    '\\n'\n-                    'here\\n')\n+        prog=\"PROG\",\n+        formatter_class=argparse.RawDescriptionHelpFormatter,\n+        description=\"Keep the formatting\\n\"\n+        \"    exactly as it is written\\n\"\n+        \"\\n\"\n+        \"here\\n\",\n+    )\n \n     argument_signatures = [\n-        Sig('--foo', help='  foo help should not\\n'\n-                          '    retain this odd formatting'),\n-        Sig('spam', help='spam help'),\n+        Sig(\n+            \"--foo\",\n+            help=\"  foo help should not\\n    retain this odd formatting\",\n+        ),\n+        Sig(\"spam\", help=\"spam help\"),\n     ]\n     argument_group_signatures = [\n-        (Sig('title', description='    This text\\n'\n-                                  '  should be indented\\n'\n-                                  '    exactly like it is here\\n'),\n-         [Sig('--bar', help='bar help')]),\n+        (\n+            Sig(\n+                \"title\",\n+                description=\"    This text\\n\"\n+                \"  should be indented\\n\"\n+                \"    exactly like it is here\\n\",\n+            ),\n+            [Sig(\"--bar\", help=\"bar help\")],\n+        ),\n     ]\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [--foo FOO] [--bar BAR] spam\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         Keep the formatting\n             exactly as it is written\n@@ -5285,38 +5763,53 @@ class TestHelpRawDescription(HelpTestCase):\n               exactly like it is here\n \n           --bar BAR   bar help\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpArgumentDefaults(HelpTestCase):\n     \"\"\"Test the ArgumentDefaultsHelpFormatter\"\"\"\n \n     parser_signature = Sig(\n-        prog='PROG', formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n-        description='description')\n+        prog=\"PROG\",\n+        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n+        description=\"description\",\n+    )\n \n     argument_signatures = [\n-        Sig('--foo', help='foo help - oh and by the way, %(default)s'),\n-        Sig('--bar', action='store_true', help='bar help'),\n-        Sig('--taz', action=argparse.BooleanOptionalAction,\n-            help='Whether to taz it', default=True),\n-        Sig('--corge', action=argparse.BooleanOptionalAction,\n-            help='Whether to corge it', default=argparse.SUPPRESS),\n-        Sig('--quux', help=\"Set the quux\", default=42),\n-        Sig('spam', help='spam help'),\n-        Sig('badger', nargs='?', default='wooden', help='badger help'),\n+        Sig(\"--foo\", help=\"foo help - oh and by the way, %(default)s\"),\n+        Sig(\"--bar\", action=\"store_true\", help=\"bar help\"),\n+        Sig(\n+            \"--taz\",\n+            action=argparse.BooleanOptionalAction,\n+            help=\"Whether to taz it\",\n+            default=True,\n+        ),\n+        Sig(\n+            \"--corge\",\n+            action=argparse.BooleanOptionalAction,\n+            help=\"Whether to corge it\",\n+            default=argparse.SUPPRESS,\n+        ),\n+        Sig(\"--quux\", help=\"Set the quux\", default=42),\n+        Sig(\"spam\", help=\"spam help\"),\n+        Sig(\"badger\", nargs=\"?\", default=\"wooden\", help=\"badger help\"),\n     ]\n     argument_group_signatures = [\n-        (Sig('title', description='description'),\n-         [Sig('--baz', type=int, default=42, help='baz help')]),\n+        (\n+            Sig(\"title\", description=\"description\"),\n+            [Sig(\"--baz\", type=int, default=42, help=\"baz help\")],\n+        ),\n     ]\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [--foo FOO] [--bar] [--taz | --no-taz] [--corge | --no-corge]\n                     [--quux QUUX] [--baz BAZ]\n                     spam [badger]\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         description\n \n@@ -5336,44 +5829,58 @@ class TestHelpArgumentDefaults(HelpTestCase):\n           description\n \n           --baz BAZ            baz help (default: 42)\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n+\n \n class TestHelpVersionAction(HelpTestCase):\n     \"\"\"Test the default help for the version action\"\"\"\n \n-    parser_signature = Sig(prog='PROG', description='description')\n-    argument_signatures = [Sig('-V', '--version', action='version', version='3.6')]\n+    parser_signature = Sig(prog=\"PROG\", description=\"description\")\n+    argument_signatures = [\n+        Sig(\"-V\", \"--version\", action=\"version\", version=\"3.6\")\n+    ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-V]\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         description\n \n         options:\n           -h, --help     show this help message and exit\n           -V, --version  show program's version number and exit\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n class TestHelpVersionActionSuppress(HelpTestCase):\n     \"\"\"Test that the --version argument can be suppressed in help messages\"\"\"\n \n-    parser_signature = Sig(prog='PROG')\n+    parser_signature = Sig(prog=\"PROG\")\n     argument_signatures = [\n-        Sig('-v', '--version', action='version', version='1.0',\n-            help=argparse.SUPPRESS),\n-        Sig('--foo', help='foo help'),\n-        Sig('spam', help='spam help'),\n+        Sig(\n+            \"-v\",\n+            \"--version\",\n+            action=\"version\",\n+            version=\"1.0\",\n+            help=argparse.SUPPRESS,\n+        ),\n+        Sig(\"--foo\", help=\"foo help\"),\n+        Sig(\"spam\", help=\"spam help\"),\n     ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [--foo FOO] spam\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         positional arguments:\n           spam        spam help\n@@ -5381,23 +5888,29 @@ class TestHelpVersionActionSuppress(HelpTestCase):\n         options:\n           -h, --help  show this help message and exit\n           --foo FOO   foo help\n-        '''\n+        \"\"\"\n+    )\n \n \n class TestHelpSubparsersOrdering(HelpTestCase):\n     \"\"\"Test ordering of subcommands in help matches the code\"\"\"\n-    parser_signature = Sig(prog='PROG',\n-                           description='display some subcommands')\n-    argument_signatures = [Sig('-v', '--version', action='version', version='0.1')]\n \n-    subparsers_signatures = [Sig(name=name)\n-                             for name in ('a', 'b', 'c', 'd', 'e')]\n+    parser_signature = Sig(prog=\"PROG\", description=\"display some subcommands\")\n+    argument_signatures = [\n+        Sig(\"-v\", \"--version\", action=\"version\", version=\"0.1\")\n+    ]\n \n-    usage = '''\\\n+    subparsers_signatures = [\n+        Sig(name=name) for name in (\"a\", \"b\", \"c\", \"d\", \"e\")\n+    ]\n+\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-v] {a,b,c,d,e} ...\n-        '''\n+        \"\"\"\n \n-    help = usage + '''\\\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         display some subcommands\n \n@@ -5407,33 +5920,41 @@ class TestHelpSubparsersOrdering(HelpTestCase):\n         options:\n           -h, --help     show this help message and exit\n           -v, --version  show program's version number and exit\n-        '''\n+        \"\"\"\n+    )\n \n-    version = '''\\\n+    version = \"\"\"\\\n         0.1\n-        '''\n+        \"\"\"\n+\n \n class TestHelpSubparsersWithHelpOrdering(HelpTestCase):\n     \"\"\"Test ordering of subcommands in help matches the code\"\"\"\n-    parser_signature = Sig(prog='PROG',\n-                           description='display some subcommands')\n-    argument_signatures = [Sig('-v', '--version', action='version', version='0.1')]\n \n-    subcommand_data = (('a', 'a subcommand help'),\n-                       ('b', 'b subcommand help'),\n-                       ('c', 'c subcommand help'),\n-                       ('d', 'd subcommand help'),\n-                       ('e', 'e subcommand help'),\n-                       )\n+    parser_signature = Sig(prog=\"PROG\", description=\"display some subcommands\")\n+    argument_signatures = [\n+        Sig(\"-v\", \"--version\", action=\"version\", version=\"0.1\")\n+    ]\n \n-    subparsers_signatures = [Sig(name=name, help=help)\n-                             for name, help in subcommand_data]\n+    subcommand_data = (\n+        (\"a\", \"a subcommand help\"),\n+        (\"b\", \"b subcommand help\"),\n+        (\"c\", \"c subcommand help\"),\n+        (\"d\", \"d subcommand help\"),\n+        (\"e\", \"e subcommand help\"),\n+    )\n \n-    usage = '''\\\n+    subparsers_signatures = [\n+        Sig(name=name, help=help) for name, help in subcommand_data\n+    ]\n+\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-v] {a,b,c,d,e} ...\n-        '''\n+        \"\"\"\n \n-    help = usage + '''\\\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         display some subcommands\n \n@@ -5448,29 +5969,35 @@ class TestHelpSubparsersWithHelpOrdering(HelpTestCase):\n         options:\n           -h, --help     show this help message and exit\n           -v, --version  show program's version number and exit\n-        '''\n+        \"\"\"\n+    )\n \n-    version = '''\\\n+    version = \"\"\"\\\n         0.1\n-        '''\n-\n+        \"\"\"\n \n \n class TestHelpMetavarTypeFormatter(HelpTestCase):\n-\n     def custom_type(string):\n         return string\n \n-    parser_signature = Sig(prog='PROG', description='description',\n-                           formatter_class=argparse.MetavarTypeHelpFormatter)\n-    argument_signatures = [Sig('a', type=int),\n-                           Sig('-b', type=custom_type),\n-                           Sig('-c', type=float, metavar='SOME FLOAT')]\n+    parser_signature = Sig(\n+        prog=\"PROG\",\n+        description=\"description\",\n+        formatter_class=argparse.MetavarTypeHelpFormatter,\n+    )\n+    argument_signatures = [\n+        Sig(\"a\", type=int),\n+        Sig(\"-b\", type=custom_type),\n+        Sig(\"-c\", type=float, metavar=\"SOME FLOAT\"),\n+    ]\n     argument_group_signatures = []\n-    usage = '''\\\n+    usage = \"\"\"\\\n         usage: PROG [-h] [-b custom_type] [-c SOME FLOAT] int\n-        '''\n-    help = usage + '''\\\n+        \"\"\"\n+    help = (\n+        usage\n+        + \"\"\"\\\n \n         description\n \n@@ -5481,8 +6008,9 @@ def custom_type(string):\n           -h, --help      show this help message and exit\n           -b custom_type\n           -c SOME FLOAT\n-        '''\n-    version = ''\n+        \"\"\"\n+    )\n+    version = \"\"\n \n \n @force_not_colorized_test_class\n@@ -5494,15 +6022,15 @@ def custom_formatter(prog):\n             return argparse.RawTextHelpFormatter(prog, indent_increment=5)\n \n         parser = argparse.ArgumentParser(\n-                prog='PROG',\n-                prefix_chars='-+',\n-                formatter_class=custom_formatter\n+            prog=\"PROG\", prefix_chars=\"-+\", formatter_class=custom_formatter\n         )\n-        parser.add_argument('+f', '++foo', help=\"foo help\")\n-        parser.add_argument('spam', help=\"spam help\")\n+        parser.add_argument(\"+f\", \"++foo\", help=\"foo help\")\n+        parser.add_argument(\"spam\", help=\"spam help\")\n \n         parser_help = parser.format_help()\n-        self.assertEqual(parser_help, textwrap.dedent('''\\\n+        self.assertEqual(\n+            parser_help,\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [+f FOO] spam\n \n             positional arguments:\n@@ -5511,7 +6039,8 @@ def custom_formatter(prog):\n             options:\n                  -h, --help     show this help message and exit\n                  +f, ++foo FOO  foo help\n-        '''))\n+        \"\"\"),\n+        )\n \n     def test_custom_formatter_class(self):\n         class CustomFormatter(argparse.RawTextHelpFormatter):\n@@ -5519,15 +6048,15 @@ def __init__(self, prog):\n                 super().__init__(prog, indent_increment=5)\n \n         parser = argparse.ArgumentParser(\n-                prog='PROG',\n-                prefix_chars='-+',\n-                formatter_class=CustomFormatter\n+            prog=\"PROG\", prefix_chars=\"-+\", formatter_class=CustomFormatter\n         )\n-        parser.add_argument('+f', '++foo', help=\"foo help\")\n-        parser.add_argument('spam', help=\"spam help\")\n+        parser.add_argument(\"+f\", \"++foo\", help=\"foo help\")\n+        parser.add_argument(\"spam\", help=\"spam help\")\n \n         parser_help = parser.format_help()\n-        self.assertEqual(parser_help, textwrap.dedent('''\\\n+        self.assertEqual(\n+            parser_help,\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [+f FOO] spam\n \n             positional arguments:\n@@ -5536,32 +6065,34 @@ def __init__(self, prog):\n             options:\n                  -h, --help     show this help message and exit\n                  +f, ++foo FOO  foo help\n-        '''))\n+        \"\"\"),\n+        )\n \n     def test_usage_long_subparser_command(self):\n         \"\"\"Test that subparser commands are formatted correctly in help\"\"\"\n+\n         def custom_formatter(prog):\n             return argparse.RawTextHelpFormatter(prog, max_help_position=50)\n \n         parent_parser = argparse.ArgumentParser(\n-                prog='PROG',\n-                formatter_class=custom_formatter\n+            prog=\"PROG\", formatter_class=custom_formatter\n         )\n \n-        cmd_subparsers = parent_parser.add_subparsers(title=\"commands\",\n-                                                      metavar='CMD',\n-                                                      help='command to use')\n-        cmd_subparsers.add_parser(\"add\",\n-                                  help=\"add something\")\n+        cmd_subparsers = parent_parser.add_subparsers(\n+            title=\"commands\", metavar=\"CMD\", help=\"command to use\"\n+        )\n+        cmd_subparsers.add_parser(\"add\", help=\"add something\")\n \n-        cmd_subparsers.add_parser(\"remove\",\n-                                  help=\"remove something\")\n+        cmd_subparsers.add_parser(\"remove\", help=\"remove something\")\n \n-        cmd_subparsers.add_parser(\"a-very-long-command\",\n-                                  help=\"command that does something\")\n+        cmd_subparsers.add_parser(\n+            \"a-very-long-command\", help=\"command that does something\"\n+        )\n \n         parser_help = parent_parser.format_help()\n-        self.assertEqual(parser_help, textwrap.dedent('''\\\n+        self.assertEqual(\n+            parser_help,\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] CMD ...\n \n             options:\n@@ -5572,154 +6103,187 @@ def custom_formatter(prog):\n                 add                  add something\n                 remove               remove something\n                 a-very-long-command  command that does something\n-        '''))\n+        \"\"\"),\n+        )\n \n \n # =====================================\n # Optional/Positional constructor tests\n # =====================================\n \n+\n class TestInvalidArgumentConstructors(TestCase):\n     \"\"\"Test a bunch of invalid Argument constructors\"\"\"\n \n     def assertTypeError(self, *args, errmsg=None, **kwargs):\n         parser = argparse.ArgumentParser()\n-        self.assertRaisesRegex(TypeError, errmsg, parser.add_argument,\n-                               *args, **kwargs)\n+        self.assertRaisesRegex(\n+            TypeError, errmsg, parser.add_argument, *args, **kwargs\n+        )\n \n     def assertValueError(self, *args, errmsg=None, **kwargs):\n         parser = argparse.ArgumentParser()\n-        self.assertRaisesRegex(ValueError, errmsg, parser.add_argument,\n-                               *args, **kwargs)\n+        self.assertRaisesRegex(\n+            ValueError, errmsg, parser.add_argument, *args, **kwargs\n+        )\n \n     def test_invalid_keyword_arguments(self):\n-        self.assertTypeError('-x', bar=None)\n-        self.assertTypeError('-y', callback='foo')\n-        self.assertTypeError('-y', callback_args=())\n-        self.assertTypeError('-y', callback_kwargs={})\n+        self.assertTypeError(\"-x\", bar=None)\n+        self.assertTypeError(\"-y\", callback=\"foo\")\n+        self.assertTypeError(\"-y\", callback_args=())\n+        self.assertTypeError(\"-y\", callback_kwargs={})\n \n     def test_missing_destination(self):\n         self.assertTypeError()\n-        for action in ['store', 'append', 'extend']:\n+        for action in [\"store\", \"append\", \"extend\"]:\n             with self.subTest(action=action):\n                 self.assertTypeError(action=action)\n \n     def test_invalid_option_strings(self):\n-        self.assertTypeError('-', errmsg='dest= is required')\n-        self.assertTypeError('--', errmsg='dest= is required')\n-        self.assertTypeError('---', errmsg='dest= is required')\n+        self.assertTypeError(\"-\", errmsg=\"dest= is required\")\n+        self.assertTypeError(\"--\", errmsg=\"dest= is required\")\n+        self.assertTypeError(\"---\", errmsg=\"dest= is required\")\n \n     def test_invalid_prefix(self):\n-        self.assertValueError('--foo', '+foo',\n-                              errmsg='must start with a character')\n+        self.assertValueError(\n+            \"--foo\", \"+foo\", errmsg=\"must start with a character\"\n+        )\n \n     def test_invalid_type(self):\n-        self.assertTypeError('--foo', type='int',\n-                             errmsg=\"'int' is not callable\")\n-        self.assertTypeError('--foo', type=(int, float),\n-                             errmsg='is not callable')\n+        self.assertTypeError(\n+            \"--foo\", type=\"int\", errmsg=\"'int' is not callable\"\n+        )\n+        self.assertTypeError(\n+            \"--foo\", type=(int, float), errmsg=\"is not callable\"\n+        )\n \n     def test_invalid_action(self):\n-        self.assertValueError('-x', action='foo',\n-                              errmsg='unknown action')\n-        self.assertValueError('foo', action='baz',\n-                              errmsg='unknown action')\n-        self.assertValueError('--foo', action=('store', 'append'),\n-                              errmsg='unknown action')\n-        self.assertValueError('--foo', action=\"store-true\",\n-                              errmsg='unknown action')\n+        self.assertValueError(\"-x\", action=\"foo\", errmsg=\"unknown action\")\n+        self.assertValueError(\"foo\", action=\"baz\", errmsg=\"unknown action\")\n+        self.assertValueError(\n+            \"--foo\", action=(\"store\", \"append\"), errmsg=\"unknown action\"\n+        )\n+        self.assertValueError(\n+            \"--foo\", action=\"store-true\", errmsg=\"unknown action\"\n+        )\n \n     def test_invalid_help(self):\n-        self.assertValueError('--foo', help='%Y-%m-%d',\n-                              errmsg='badly formed help string')\n-        self.assertValueError('--foo', help='%(spam)s',\n-                              errmsg='badly formed help string')\n-        self.assertValueError('--foo', help='%(prog)d',\n-                              errmsg='badly formed help string')\n+        self.assertValueError(\n+            \"--foo\", help=\"%Y-%m-%d\", errmsg=\"badly formed help string\"\n+        )\n+        self.assertValueError(\n+            \"--foo\", help=\"%(spam)s\", errmsg=\"badly formed help string\"\n+        )\n+        self.assertValueError(\n+            \"--foo\", help=\"%(prog)d\", errmsg=\"badly formed help string\"\n+        )\n \n     def test_multiple_dest(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument(dest='foo')\n+        parser.add_argument(dest=\"foo\")\n         with self.assertRaises(TypeError) as cm:\n-            parser.add_argument('bar', dest='baz')\n-        self.assertIn('dest supplied twice for positional argument,'\n-                      ' did you mean metavar?',\n-                      str(cm.exception))\n+            parser.add_argument(\"bar\", dest=\"baz\")\n+        self.assertIn(\n+            \"dest supplied twice for positional argument,\"\n+            \" did you mean metavar?\",\n+            str(cm.exception),\n+        )\n \n     def test_no_argument_actions(self):\n-        for action in ['store_const', 'store_true', 'store_false',\n-                       'append_const', 'count']:\n+        for action in [\n+            \"store_const\",\n+            \"store_true\",\n+            \"store_false\",\n+            \"append_const\",\n+            \"count\",\n+        ]:\n             with self.subTest(action=action):\n-                for attrs in [dict(type=int), dict(nargs='+'),\n-                              dict(choices=['a', 'b'])]:\n+                for attrs in [\n+                    dict(type=int),\n+                    dict(nargs=\"+\"),\n+                    dict(choices=[\"a\", \"b\"]),\n+                ]:\n                     with self.subTest(attrs=attrs):\n-                        self.assertTypeError('-x', action=action, **attrs)\n-                        self.assertTypeError('x', action=action, **attrs)\n-                self.assertValueError('x', action=action,\n-                    errmsg=f\"action '{action}' is not valid for positional arguments\")\n-                self.assertTypeError('-x', action=action, nargs=0)\n-                self.assertValueError('x', action=action, nargs=0,\n-                    errmsg='nargs for positionals must be != 0')\n+                        self.assertTypeError(\"-x\", action=action, **attrs)\n+                        self.assertTypeError(\"x\", action=action, **attrs)\n+                self.assertValueError(\n+                    \"x\",\n+                    action=action,\n+                    errmsg=f\"action '{action}' is not valid for positional arguments\",\n+                )\n+                self.assertTypeError(\"-x\", action=action, nargs=0)\n+                self.assertValueError(\n+                    \"x\",\n+                    action=action,\n+                    nargs=0,\n+                    errmsg=\"nargs for positionals must be != 0\",\n+                )\n \n     def test_no_argument_no_const_actions(self):\n         # options with zero arguments\n-        for action in ['store_true', 'store_false', 'count']:\n+        for action in [\"store_true\", \"store_false\", \"count\"]:\n             with self.subTest(action=action):\n                 # const is always disallowed\n-                self.assertTypeError('-x', const='foo', action=action)\n+                self.assertTypeError(\"-x\", const=\"foo\", action=action)\n \n                 # nargs is always disallowed\n-                self.assertTypeError('-x', nargs='*', action=action)\n+                self.assertTypeError(\"-x\", nargs=\"*\", action=action)\n \n     def test_more_than_one_argument_actions(self):\n-        for action in ['store', 'append', 'extend']:\n+        for action in [\"store\", \"append\", \"extend\"]:\n             with self.subTest(action=action):\n                 # nargs=0 is disallowed\n-                action_name = 'append' if action == 'extend' else action\n-                self.assertValueError('-x', nargs=0, action=action,\n-                    errmsg=f'nargs for {action_name} actions must be != 0')\n-                self.assertValueError('spam', nargs=0, action=action,\n-                    errmsg='nargs for positionals must be != 0')\n+                action_name = \"append\" if action == \"extend\" else action\n+                self.assertValueError(\n+                    \"-x\",\n+                    nargs=0,\n+                    action=action,\n+                    errmsg=f\"nargs for {action_name} actions must be != 0\",\n+                )\n+                self.assertValueError(\n+                    \"spam\",\n+                    nargs=0,\n+                    action=action,\n+                    errmsg=\"nargs for positionals must be != 0\",\n+                )\n \n                 # const is disallowed with non-optional arguments\n-                for nargs in [1, '*', '+']:\n-                    self.assertValueError('-x', const='foo',\n-                                          nargs=nargs, action=action)\n-                    self.assertValueError('spam', const='foo',\n-                                          nargs=nargs, action=action)\n+                for nargs in [1, \"*\", \"+\"]:\n+                    self.assertValueError(\n+                        \"-x\", const=\"foo\", nargs=nargs, action=action\n+                    )\n+                    self.assertValueError(\n+                        \"spam\", const=\"foo\", nargs=nargs, action=action\n+                    )\n \n     def test_required_const_actions(self):\n-        for action in ['store_const', 'append_const']:\n+        for action in [\"store_const\", \"append_const\"]:\n             with self.subTest(action=action):\n                 # nargs is always disallowed\n-                self.assertTypeError('-x', nargs='+', action=action)\n+                self.assertTypeError(\"-x\", nargs=\"+\", action=action)\n \n     def test_parsers_action_missing_params(self):\n-        self.assertTypeError('command', action='parsers')\n-        self.assertTypeError('command', action='parsers', prog='PROG')\n-        self.assertTypeError('command', action='parsers',\n-                             parser_class=argparse.ArgumentParser)\n+        self.assertTypeError(\"command\", action=\"parsers\")\n+        self.assertTypeError(\"command\", action=\"parsers\", prog=\"PROG\")\n+        self.assertTypeError(\n+            \"command\", action=\"parsers\", parser_class=argparse.ArgumentParser\n+        )\n \n     def test_version_missing_params(self):\n-        self.assertTypeError('command', action='version')\n+        self.assertTypeError(\"command\", action=\"version\")\n \n     def test_required_positional(self):\n-        self.assertTypeError('foo', required=True)\n+        self.assertTypeError(\"foo\", required=True)\n \n     def test_user_defined_action(self):\n-\n         class Success(Exception):\n             pass\n \n         class Action(object):\n-\n-            def __init__(self,\n-                         option_strings,\n-                         dest,\n-                         const,\n-                         default,\n-                         required=False):\n-                if dest == 'spam':\n+            def __init__(\n+                self, option_strings, dest, const, default, required=False\n+            ):\n+                if dest == \"spam\":\n                     if const is Success:\n                         if default is Success:\n                             raise Success()\n@@ -5728,108 +6292,148 @@ def __call__(self, *args, **kwargs):\n                 pass\n \n         parser = argparse.ArgumentParser()\n-        self.assertRaises(Success, parser.add_argument, '--spam',\n-                          action=Action, default=Success, const=Success)\n-        self.assertRaises(Success, parser.add_argument, 'spam',\n-                          action=Action, default=Success, const=Success)\n+        self.assertRaises(\n+            Success,\n+            parser.add_argument,\n+            \"--spam\",\n+            action=Action,\n+            default=Success,\n+            const=Success,\n+        )\n+        self.assertRaises(\n+            Success,\n+            parser.add_argument,\n+            \"spam\",\n+            action=Action,\n+            default=Success,\n+            const=Success,\n+        )\n+\n \n # ================================\n # Actions returned by add_argument\n # ================================\n \n-class TestActionsReturned(TestCase):\n \n+class TestActionsReturned(TestCase):\n     def test_dest(self):\n         parser = argparse.ArgumentParser()\n-        action = parser.add_argument('--foo')\n-        self.assertEqual(action.dest, 'foo')\n-        action = parser.add_argument('-b', '--bar')\n-        self.assertEqual(action.dest, 'bar')\n-        action = parser.add_argument('-x', '-y')\n-        self.assertEqual(action.dest, 'x')\n+        action = parser.add_argument(\"--foo\")\n+        self.assertEqual(action.dest, \"foo\")\n+        action = parser.add_argument(\"-b\", \"--bar\")\n+        self.assertEqual(action.dest, \"bar\")\n+        action = parser.add_argument(\"-x\", \"-y\")\n+        self.assertEqual(action.dest, \"x\")\n \n     def test_misc(self):\n         parser = argparse.ArgumentParser()\n-        action = parser.add_argument('--foo', nargs='?', const=42,\n-                                     default=84, type=int, choices=[1, 2],\n-                                     help='FOO', metavar='BAR', dest='baz')\n-        self.assertEqual(action.nargs, '?')\n+        action = parser.add_argument(\n+            \"--foo\",\n+            nargs=\"?\",\n+            const=42,\n+            default=84,\n+            type=int,\n+            choices=[1, 2],\n+            help=\"FOO\",\n+            metavar=\"BAR\",\n+            dest=\"baz\",\n+        )\n+        self.assertEqual(action.nargs, \"?\")\n         self.assertEqual(action.const, 42)\n         self.assertEqual(action.default, 84)\n         self.assertEqual(action.type, int)\n         self.assertEqual(action.choices, [1, 2])\n-        self.assertEqual(action.help, 'FOO')\n-        self.assertEqual(action.metavar, 'BAR')\n-        self.assertEqual(action.dest, 'baz')\n+        self.assertEqual(action.help, \"FOO\")\n+        self.assertEqual(action.metavar, \"BAR\")\n+        self.assertEqual(action.dest, \"baz\")\n \n \n # ================================\n # Argument conflict handling tests\n # ================================\n \n-class TestConflictHandling(TestCase):\n \n+class TestConflictHandling(TestCase):\n     def test_bad_type(self):\n-        self.assertRaises(ValueError, argparse.ArgumentParser,\n-                          conflict_handler='foo')\n+        self.assertRaises(\n+            ValueError, argparse.ArgumentParser, conflict_handler=\"foo\"\n+        )\n \n     def test_conflict_error(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('-x')\n-        self.assertRaises(argparse.ArgumentError,\n-                          parser.add_argument, '-x')\n-        parser.add_argument('--spam')\n-        self.assertRaises(argparse.ArgumentError,\n-                          parser.add_argument, '--spam')\n+        parser.add_argument(\"-x\")\n+        self.assertRaises(argparse.ArgumentError, parser.add_argument, \"-x\")\n+        parser.add_argument(\"--spam\")\n+        self.assertRaises(\n+            argparse.ArgumentError, parser.add_argument, \"--spam\"\n+        )\n \n     @force_not_colorized\n     def test_resolve_error(self):\n         get_parser = argparse.ArgumentParser\n-        parser = get_parser(prog='PROG', conflict_handler='resolve')\n+        parser = get_parser(prog=\"PROG\", conflict_handler=\"resolve\")\n \n-        parser.add_argument('-x', help='OLD X')\n-        parser.add_argument('-x', help='NEW X')\n-        self.assertEqual(parser.format_help(), textwrap.dedent('''\\\n+        parser.add_argument(\"-x\", help=\"OLD X\")\n+        parser.add_argument(\"-x\", help=\"NEW X\")\n+        self.assertEqual(\n+            parser.format_help(),\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [-x X]\n \n             options:\n               -h, --help  show this help message and exit\n               -x X        NEW X\n-            '''))\n+            \"\"\"),\n+        )\n \n-        parser.add_argument('--spam', metavar='OLD_SPAM')\n-        parser.add_argument('--spam', metavar='NEW_SPAM')\n-        self.assertEqual(parser.format_help(), textwrap.dedent('''\\\n+        parser.add_argument(\"--spam\", metavar=\"OLD_SPAM\")\n+        parser.add_argument(\"--spam\", metavar=\"NEW_SPAM\")\n+        self.assertEqual(\n+            parser.format_help(),\n+            textwrap.dedent(\"\"\"\\\n             usage: PROG [-h] [-x X] [--spam NEW_SPAM]\n \n             options:\n               -h, --help       show this help message and exit\n               -x X             NEW X\n               --spam NEW_SPAM\n-            '''))\n+            \"\"\"),\n+        )\n \n     def test_subparser_conflict(self):\n         parser = argparse.ArgumentParser()\n         sp = parser.add_subparsers()\n-        sp.add_parser('fullname', aliases=['alias'])\n-        self.assertRaisesRegex(ValueError,\n-                               'conflicting subparser: fullname',\n-                               sp.add_parser, 'fullname')\n-        self.assertRaisesRegex(ValueError,\n-                               'conflicting subparser: alias',\n-                               sp.add_parser, 'alias')\n-        self.assertRaisesRegex(ValueError,\n-                               'conflicting subparser alias: fullname',\n-                               sp.add_parser, 'other', aliases=['fullname'])\n-        self.assertRaisesRegex(ValueError,\n-                               'conflicting subparser alias: alias',\n-                               sp.add_parser, 'other', aliases=['alias'])\n+        sp.add_parser(\"fullname\", aliases=[\"alias\"])\n+        self.assertRaisesRegex(\n+            ValueError,\n+            \"conflicting subparser: fullname\",\n+            sp.add_parser,\n+            \"fullname\",\n+        )\n+        self.assertRaisesRegex(\n+            ValueError, \"conflicting subparser: alias\", sp.add_parser, \"alias\"\n+        )\n+        self.assertRaisesRegex(\n+            ValueError,\n+            \"conflicting subparser alias: fullname\",\n+            sp.add_parser,\n+            \"other\",\n+            aliases=[\"fullname\"],\n+        )\n+        self.assertRaisesRegex(\n+            ValueError,\n+            \"conflicting subparser alias: alias\",\n+            sp.add_parser,\n+            \"other\",\n+            aliases=[\"alias\"],\n+        )\n \n \n # =============================\n # Help and Version option tests\n # =============================\n \n+\n class TestOptionalsHelpVersionActions(TestCase):\n     \"\"\"Test the help and version actions\"\"\"\n \n@@ -5843,69 +6447,74 @@ def assertArgumentParserError(self, parser, *args):\n \n     def test_version(self):\n         parser = ErrorRaisingArgumentParser()\n-        parser.add_argument('-v', '--version', action='version', version='1.0')\n-        self.assertPrintHelpExit(parser, '-h')\n-        self.assertPrintHelpExit(parser, '--help')\n-        self.assertRaises(AttributeError, getattr, parser, 'format_version')\n+        parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"1.0\")\n+        self.assertPrintHelpExit(parser, \"-h\")\n+        self.assertPrintHelpExit(parser, \"--help\")\n+        self.assertRaises(AttributeError, getattr, parser, \"format_version\")\n \n     def test_version_format(self):\n-        parser = ErrorRaisingArgumentParser(prog='PPP')\n-        parser.add_argument('-v', '--version', action='version', version='%(prog)s 3.5')\n+        parser = ErrorRaisingArgumentParser(prog=\"PPP\")\n+        parser.add_argument(\n+            \"-v\", \"--version\", action=\"version\", version=\"%(prog)s 3.5\"\n+        )\n         with self.assertRaises(ArgumentParserError) as cm:\n-            parser.parse_args(['-v'])\n-        self.assertEqual('PPP 3.5\\n', cm.exception.stdout)\n+            parser.parse_args([\"-v\"])\n+        self.assertEqual(\"PPP 3.5\\n\", cm.exception.stdout)\n \n     def test_version_no_help(self):\n         parser = ErrorRaisingArgumentParser(add_help=False)\n-        parser.add_argument('-v', '--version', action='version', version='1.0')\n-        self.assertArgumentParserError(parser, '-h')\n-        self.assertArgumentParserError(parser, '--help')\n-        self.assertRaises(AttributeError, getattr, parser, 'format_version')\n+        parser.add_argument(\"-v\", \"--version\", action=\"version\", version=\"1.0\")\n+        self.assertArgumentParserError(parser, \"-h\")\n+        self.assertArgumentParserError(parser, \"--help\")\n+        self.assertRaises(AttributeError, getattr, parser, \"format_version\")\n \n     def test_version_action(self):\n-        parser = ErrorRaisingArgumentParser(prog='XXX')\n-        parser.add_argument('-V', action='version', version='%(prog)s 3.7')\n+        parser = ErrorRaisingArgumentParser(prog=\"XXX\")\n+        parser.add_argument(\"-V\", action=\"version\", version=\"%(prog)s 3.7\")\n         with self.assertRaises(ArgumentParserError) as cm:\n-            parser.parse_args(['-V'])\n-        self.assertEqual('XXX 3.7\\n', cm.exception.stdout)\n+            parser.parse_args([\"-V\"])\n+        self.assertEqual(\"XXX 3.7\\n\", cm.exception.stdout)\n \n     def test_no_help(self):\n         parser = ErrorRaisingArgumentParser(add_help=False)\n-        self.assertArgumentParserError(parser, '-h')\n-        self.assertArgumentParserError(parser, '--help')\n-        self.assertArgumentParserError(parser, '-v')\n-        self.assertArgumentParserError(parser, '--version')\n+        self.assertArgumentParserError(parser, \"-h\")\n+        self.assertArgumentParserError(parser, \"--help\")\n+        self.assertArgumentParserError(parser, \"-v\")\n+        self.assertArgumentParserError(parser, \"--version\")\n \n     def test_alternate_help_version(self):\n         parser = ErrorRaisingArgumentParser()\n-        parser.add_argument('-x', action='help')\n-        parser.add_argument('-y', action='version')\n-        self.assertPrintHelpExit(parser, '-x')\n-        self.assertArgumentParserError(parser, '-v')\n-        self.assertArgumentParserError(parser, '--version')\n-        self.assertRaises(AttributeError, getattr, parser, 'format_version')\n+        parser.add_argument(\"-x\", action=\"help\")\n+        parser.add_argument(\"-y\", action=\"version\")\n+        self.assertPrintHelpExit(parser, \"-x\")\n+        self.assertArgumentParserError(parser, \"-v\")\n+        self.assertArgumentParserError(parser, \"--version\")\n+        self.assertRaises(AttributeError, getattr, parser, \"format_version\")\n \n     def test_help_version_extra_arguments(self):\n         parser = ErrorRaisingArgumentParser()\n-        parser.add_argument('--version', action='version', version='1.0')\n-        parser.add_argument('-x', action='store_true')\n-        parser.add_argument('y')\n+        parser.add_argument(\"--version\", action=\"version\", version=\"1.0\")\n+        parser.add_argument(\"-x\", action=\"store_true\")\n+        parser.add_argument(\"y\")\n \n         # try all combinations of valid prefixes and suffixes\n-        valid_prefixes = ['', '-x', 'foo', '-x bar', 'baz -x']\n-        valid_suffixes = valid_prefixes + ['--bad-option', 'foo bar baz']\n+        valid_prefixes = [\"\", \"-x\", \"foo\", \"-x bar\", \"baz -x\"]\n+        valid_suffixes = valid_prefixes + [\"--bad-option\", \"foo bar baz\"]\n         for prefix in valid_prefixes:\n             for suffix in valid_suffixes:\n-                format = '%s %%s %s' % (prefix, suffix)\n-            self.assertPrintHelpExit(parser, format % '-h')\n-            self.assertPrintHelpExit(parser, format % '--help')\n-            self.assertRaises(AttributeError, getattr, parser, 'format_version')\n+                format = \"%s %%s %s\" % (prefix, suffix)\n+            self.assertPrintHelpExit(parser, format % \"-h\")\n+            self.assertPrintHelpExit(parser, format % \"--help\")\n+            self.assertRaises(\n+                AttributeError, getattr, parser, \"format_version\"\n+            )\n \n \n # ======================\n # str() and repr() tests\n # ======================\n \n+\n class TestStrings(TestCase):\n     \"\"\"Test str()  and repr() on Optionals and Positionals\"\"\"\n \n@@ -5915,81 +6524,87 @@ def assertStringEqual(self, obj, result_string):\n \n     def test_optional(self):\n         option = argparse.Action(\n-            option_strings=['--foo', '-a', '-b'],\n-            dest='b',\n-            type='int',\n-            nargs='+',\n+            option_strings=[\"--foo\", \"-a\", \"-b\"],\n+            dest=\"b\",\n+            type=\"int\",\n+            nargs=\"+\",\n             default=42,\n             choices=[1, 2, 3],\n             required=False,\n-            help='HELP',\n-            metavar='METAVAR')\n+            help=\"HELP\",\n+            metavar=\"METAVAR\",\n+        )\n         string = (\n             \"Action(option_strings=['--foo', '-a', '-b'], dest='b', \"\n             \"nargs='+', const=None, default=42, type='int', \"\n             \"choices=[1, 2, 3], required=False, help='HELP', \"\n-            \"metavar='METAVAR', deprecated=False)\")\n+            \"metavar='METAVAR', deprecated=False)\"\n+        )\n         self.assertStringEqual(option, string)\n \n     def test_argument(self):\n         argument = argparse.Action(\n             option_strings=[],\n-            dest='x',\n+            dest=\"x\",\n             type=float,\n-            nargs='?',\n+            nargs=\"?\",\n             default=2.5,\n             choices=[0.5, 1.5, 2.5],\n             required=True,\n-            help='H HH H',\n-            metavar='MV MV MV')\n+            help=\"H HH H\",\n+            metavar=\"MV MV MV\",\n+        )\n         string = (\n             \"Action(option_strings=[], dest='x', nargs='?', \"\n             \"const=None, default=2.5, type=%r, choices=[0.5, 1.5, 2.5], \"\n             \"required=True, help='H HH H', metavar='MV MV MV', \"\n-            \"deprecated=False)\" % float)\n+            \"deprecated=False)\" % float\n+        )\n         self.assertStringEqual(argument, string)\n \n     def test_namespace(self):\n-        ns = argparse.Namespace(foo=42, bar='spam')\n+        ns = argparse.Namespace(foo=42, bar=\"spam\")\n         string = \"Namespace(foo=42, bar='spam')\"\n         self.assertStringEqual(ns, string)\n \n     def test_namespace_starkwargs_notidentifier(self):\n-        ns = argparse.Namespace(**{'\"': 'quote'})\n+        ns = argparse.Namespace(**{'\"': \"quote\"})\n         string = \"\"\"Namespace(**{'\"': 'quote'})\"\"\"\n         self.assertStringEqual(ns, string)\n \n     def test_namespace_kwargs_and_starkwargs_notidentifier(self):\n-        ns = argparse.Namespace(a=1, **{'\"': 'quote'})\n+        ns = argparse.Namespace(a=1, **{'\"': \"quote\"})\n         string = \"\"\"Namespace(a=1, **{'\"': 'quote'})\"\"\"\n         self.assertStringEqual(ns, string)\n \n     def test_namespace_starkwargs_identifier(self):\n-        ns = argparse.Namespace(**{'valid': True})\n+        ns = argparse.Namespace(**{\"valid\": True})\n         string = \"Namespace(valid=True)\"\n         self.assertStringEqual(ns, string)\n \n     def test_parser(self):\n-        parser = argparse.ArgumentParser(prog='PROG')\n+        parser = argparse.ArgumentParser(prog=\"PROG\")\n         string = (\n             \"ArgumentParser(prog='PROG', usage=None, description=None, \"\n             \"formatter_class=%r, conflict_handler='error', \"\n-            \"add_help=True)\" % argparse.HelpFormatter)\n+            \"add_help=True)\" % argparse.HelpFormatter\n+        )\n         self.assertStringEqual(parser, string)\n \n+\n # ===============\n # Namespace tests\n # ===============\n \n-class TestNamespace(TestCase):\n \n+class TestNamespace(TestCase):\n     def test_constructor(self):\n         ns = argparse.Namespace()\n-        self.assertRaises(AttributeError, getattr, ns, 'x')\n+        self.assertRaises(AttributeError, getattr, ns, \"x\")\n \n-        ns = argparse.Namespace(a=42, b='spam')\n+        ns = argparse.Namespace(a=42, b=\"spam\")\n         self.assertEqual(ns.a, 42)\n-        self.assertEqual(ns.b, 'spam')\n+        self.assertEqual(ns.b, \"spam\")\n \n     def test_equality(self):\n         ns1 = argparse.Namespace(a=1, b=2)\n@@ -6018,12 +6633,12 @@ def test_equality_returns_notimplemented(self):\n # File encoding tests\n # ===================\n \n-class TestEncoding(TestCase):\n \n+class TestEncoding(TestCase):\n     def _test_module_encoding(self, path):\n         path, _ = os.path.splitext(path)\n         path += \".py\"\n-        with open(path, 'r', encoding='utf-8') as f:\n+        with open(path, \"r\", encoding=\"utf-8\") as f:\n             f.read()\n \n     def test_argparse_module_encoding(self):\n@@ -6032,301 +6647,311 @@ def test_argparse_module_encoding(self):\n     def test_test_argparse_module_encoding(self):\n         self._test_module_encoding(__file__)\n \n+\n # ===================\n # ArgumentError tests\n # ===================\n \n-class TestArgumentError(TestCase):\n \n+class TestArgumentError(TestCase):\n     def test_argument_error(self):\n         msg = \"my error here\"\n         error = argparse.ArgumentError(None, msg)\n         self.assertEqual(str(error), msg)\n \n+\n # =======================\n # ArgumentTypeError tests\n # =======================\n \n-class TestArgumentTypeError(TestCase):\n \n+class TestArgumentTypeError(TestCase):\n     @force_not_colorized\n     def test_argument_type_error(self):\n-\n         def spam(string):\n-            raise argparse.ArgumentTypeError('spam!')\n+            raise argparse.ArgumentTypeError(\"spam!\")\n \n-        parser = ErrorRaisingArgumentParser(prog='PROG', add_help=False)\n-        parser.add_argument('x', type=spam)\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\", add_help=False)\n+        parser.add_argument(\"x\", type=spam)\n         with self.assertRaises(ArgumentParserError) as cm:\n-            parser.parse_args(['XXX'])\n-        self.assertEqual('usage: PROG x\\nPROG: error: argument x: spam!\\n',\n-                         cm.exception.stderr)\n+            parser.parse_args([\"XXX\"])\n+        self.assertEqual(\n+            \"usage: PROG x\\nPROG: error: argument x: spam!\\n\",\n+            cm.exception.stderr,\n+        )\n+\n \n # =========================\n # MessageContentError tests\n # =========================\n \n-class TestMessageContentError(TestCase):\n \n+class TestMessageContentError(TestCase):\n     def test_missing_argument_name_in_message(self):\n-        parser = ErrorRaisingArgumentParser(prog='PROG', usage='')\n-        parser.add_argument('req_pos', type=str)\n-        parser.add_argument('-req_opt', type=int, required=True)\n-        parser.add_argument('need_one', type=str, nargs='+')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\", usage=\"\")\n+        parser.add_argument(\"req_pos\", type=str)\n+        parser.add_argument(\"-req_opt\", type=int, required=True)\n+        parser.add_argument(\"need_one\", type=str, nargs=\"+\")\n \n         with self.assertRaises(ArgumentParserError) as cm:\n             parser.parse_args([])\n         msg = str(cm.exception)\n-        self.assertRegex(msg, 'req_pos')\n-        self.assertRegex(msg, 'req_opt')\n-        self.assertRegex(msg, 'need_one')\n+        self.assertRegex(msg, \"req_pos\")\n+        self.assertRegex(msg, \"req_opt\")\n+        self.assertRegex(msg, \"need_one\")\n         with self.assertRaises(ArgumentParserError) as cm:\n-            parser.parse_args(['myXargument'])\n+            parser.parse_args([\"myXargument\"])\n         msg = str(cm.exception)\n-        self.assertNotIn(msg, 'req_pos')\n-        self.assertRegex(msg, 'req_opt')\n-        self.assertRegex(msg, 'need_one')\n+        self.assertNotIn(msg, \"req_pos\")\n+        self.assertRegex(msg, \"req_opt\")\n+        self.assertRegex(msg, \"need_one\")\n         with self.assertRaises(ArgumentParserError) as cm:\n-            parser.parse_args(['myXargument', '-req_opt=1'])\n+            parser.parse_args([\"myXargument\", \"-req_opt=1\"])\n         msg = str(cm.exception)\n-        self.assertNotIn(msg, 'req_pos')\n-        self.assertNotIn(msg, 'req_opt')\n-        self.assertRegex(msg, 'need_one')\n+        self.assertNotIn(msg, \"req_pos\")\n+        self.assertNotIn(msg, \"req_opt\")\n+        self.assertRegex(msg, \"need_one\")\n \n     def test_optional_optional_not_in_message(self):\n-        parser = ErrorRaisingArgumentParser(prog='PROG', usage='')\n-        parser.add_argument('req_pos', type=str)\n-        parser.add_argument('--req_opt', type=int, required=True)\n-        parser.add_argument('--opt_opt', type=bool, nargs='?',\n-                            default=True)\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\", usage=\"\")\n+        parser.add_argument(\"req_pos\", type=str)\n+        parser.add_argument(\"--req_opt\", type=int, required=True)\n+        parser.add_argument(\"--opt_opt\", type=bool, nargs=\"?\", default=True)\n         with self.assertRaises(ArgumentParserError) as cm:\n             parser.parse_args([])\n         msg = str(cm.exception)\n-        self.assertRegex(msg, 'req_pos')\n-        self.assertRegex(msg, 'req_opt')\n-        self.assertNotIn(msg, 'opt_opt')\n+        self.assertRegex(msg, \"req_pos\")\n+        self.assertRegex(msg, \"req_opt\")\n+        self.assertNotIn(msg, \"opt_opt\")\n         with self.assertRaises(ArgumentParserError) as cm:\n-            parser.parse_args(['--req_opt=1'])\n+            parser.parse_args([\"--req_opt=1\"])\n         msg = str(cm.exception)\n-        self.assertRegex(msg, 'req_pos')\n-        self.assertNotIn(msg, 'req_opt')\n-        self.assertNotIn(msg, 'opt_opt')\n+        self.assertRegex(msg, \"req_pos\")\n+        self.assertNotIn(msg, \"req_opt\")\n+        self.assertNotIn(msg, \"opt_opt\")\n \n     def test_optional_positional_not_in_message(self):\n-        parser = ErrorRaisingArgumentParser(prog='PROG', usage='')\n-        parser.add_argument('req_pos')\n-        parser.add_argument('optional_positional', nargs='?', default='eggs')\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\", usage=\"\")\n+        parser.add_argument(\"req_pos\")\n+        parser.add_argument(\"optional_positional\", nargs=\"?\", default=\"eggs\")\n         with self.assertRaises(ArgumentParserError) as cm:\n             parser.parse_args([])\n         msg = str(cm.exception)\n-        self.assertRegex(msg, 'req_pos')\n-        self.assertNotIn(msg, 'optional_positional')\n+        self.assertRegex(msg, \"req_pos\")\n+        self.assertNotIn(msg, \"optional_positional\")\n \n \n # ================================================\n # Check that the type function is called only once\n # ================================================\n \n-class TestTypeFunctionCallOnlyOnce(TestCase):\n \n+class TestTypeFunctionCallOnlyOnce(TestCase):\n     def test_type_function_call_only_once(self):\n         def spam(string_to_convert):\n-            self.assertEqual(string_to_convert, 'spam!')\n-            return 'foo_converted'\n+            self.assertEqual(string_to_convert, \"spam!\")\n+            return \"foo_converted\"\n \n         parser = argparse.ArgumentParser()\n-        parser.add_argument('--foo', type=spam, default='bar')\n-        args = parser.parse_args('--foo spam!'.split())\n-        self.assertEqual(NS(foo='foo_converted'), args)\n+        parser.add_argument(\"--foo\", type=spam, default=\"bar\")\n+        args = parser.parse_args(\"--foo spam!\".split())\n+        self.assertEqual(NS(foo=\"foo_converted\"), args)\n \n \n # ==============================================\n # Check that deprecated arguments output warning\n # ==============================================\n \n-class TestDeprecatedArguments(TestCase):\n \n+class TestDeprecatedArguments(TestCase):\n     def test_deprecated_option(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('-f', '--foo', deprecated=True)\n+        parser.add_argument(\"-f\", \"--foo\", deprecated=True)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['--foo', 'spam'])\n+            parser.parse_args([\"--foo\", \"spam\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: option '--foo' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 1)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 1)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['-f', 'spam'])\n+            parser.parse_args([\"-f\", \"spam\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: option '-f' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 1)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 1)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['--foo', 'spam', '-f', 'ham'])\n+            parser.parse_args([\"--foo\", \"spam\", \"-f\", \"ham\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: option '--foo' is deprecated\")\n         self.assertRegex(stderr, \"warning: option '-f' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 2)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 2)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['--foo', 'spam', '--foo', 'ham'])\n+            parser.parse_args([\"--foo\", \"spam\", \"--foo\", \"ham\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: option '--foo' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 1)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 1)\n \n     def test_deprecated_boolean_option(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('-f', '--foo', action=argparse.BooleanOptionalAction, deprecated=True)\n+        parser.add_argument(\n+            \"-f\",\n+            \"--foo\",\n+            action=argparse.BooleanOptionalAction,\n+            deprecated=True,\n+        )\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['--foo'])\n+            parser.parse_args([\"--foo\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: option '--foo' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 1)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 1)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['-f'])\n+            parser.parse_args([\"-f\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: option '-f' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 1)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 1)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['--no-foo'])\n+            parser.parse_args([\"--no-foo\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: option '--no-foo' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 1)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 1)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['--foo', '--no-foo'])\n+            parser.parse_args([\"--foo\", \"--no-foo\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: option '--foo' is deprecated\")\n         self.assertRegex(stderr, \"warning: option '--no-foo' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 2)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 2)\n \n     def test_deprecated_arguments(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('foo', nargs='?', deprecated=True)\n-        parser.add_argument('bar', nargs='?', deprecated=True)\n+        parser.add_argument(\"foo\", nargs=\"?\", deprecated=True)\n+        parser.add_argument(\"bar\", nargs=\"?\", deprecated=True)\n \n         with captured_stderr() as stderr:\n             parser.parse_args([])\n         stderr = stderr.getvalue()\n-        self.assertEqual(stderr.count('is deprecated'), 0)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 0)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['spam'])\n+            parser.parse_args([\"spam\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: argument 'foo' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 1)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 1)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['spam', 'ham'])\n+            parser.parse_args([\"spam\", \"ham\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: argument 'foo' is deprecated\")\n         self.assertRegex(stderr, \"warning: argument 'bar' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 2)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 2)\n \n     def test_deprecated_varargument(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('foo', nargs='*', deprecated=True)\n+        parser.add_argument(\"foo\", nargs=\"*\", deprecated=True)\n \n         with captured_stderr() as stderr:\n             parser.parse_args([])\n         stderr = stderr.getvalue()\n-        self.assertEqual(stderr.count('is deprecated'), 0)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 0)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['spam'])\n+            parser.parse_args([\"spam\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: argument 'foo' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 1)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 1)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['spam', 'ham'])\n+            parser.parse_args([\"spam\", \"ham\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: argument 'foo' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 1)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 1)\n \n     def test_deprecated_subparser(self):\n         parser = argparse.ArgumentParser()\n         subparsers = parser.add_subparsers()\n-        subparsers.add_parser('foo', aliases=['baz'], deprecated=True)\n-        subparsers.add_parser('bar')\n+        subparsers.add_parser(\"foo\", aliases=[\"baz\"], deprecated=True)\n+        subparsers.add_parser(\"bar\")\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['bar'])\n+            parser.parse_args([\"bar\"])\n         stderr = stderr.getvalue()\n-        self.assertEqual(stderr.count('is deprecated'), 0)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 0)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['foo'])\n+            parser.parse_args([\"foo\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: command 'foo' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 1)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 1)\n \n         with captured_stderr() as stderr:\n-            parser.parse_args(['baz'])\n+            parser.parse_args([\"baz\"])\n         stderr = stderr.getvalue()\n         self.assertRegex(stderr, \"warning: command 'baz' is deprecated\")\n-        self.assertEqual(stderr.count('is deprecated'), 1)\n+        self.assertEqual(stderr.count(\"is deprecated\"), 1)\n \n \n # ==================================================================\n # Check semantics regarding the default argument and type conversion\n # ==================================================================\n \n-class TestTypeFunctionCalledOnDefault(TestCase):\n \n+class TestTypeFunctionCalledOnDefault(TestCase):\n     def test_type_function_call_with_non_string_default(self):\n         def spam(int_to_convert):\n             self.assertEqual(int_to_convert, 0)\n-            return 'foo_converted'\n+            return \"foo_converted\"\n \n         parser = argparse.ArgumentParser()\n-        parser.add_argument('--foo', type=spam, default=0)\n+        parser.add_argument(\"--foo\", type=spam, default=0)\n         args = parser.parse_args([])\n         # foo should *not* be converted because its default is not a string.\n         self.assertEqual(NS(foo=0), args)\n \n     def test_type_function_call_with_string_default(self):\n         def spam(int_to_convert):\n-            return 'foo_converted'\n+            return \"foo_converted\"\n \n         parser = argparse.ArgumentParser()\n-        parser.add_argument('--foo', type=spam, default='0')\n+        parser.add_argument(\"--foo\", type=spam, default=\"0\")\n         args = parser.parse_args([])\n         # foo is converted because its default is a string.\n-        self.assertEqual(NS(foo='foo_converted'), args)\n+        self.assertEqual(NS(foo=\"foo_converted\"), args)\n \n     def test_no_double_type_conversion_of_default(self):\n         def extend(str_to_convert):\n-            return str_to_convert + '*'\n+            return str_to_convert + \"*\"\n \n         parser = argparse.ArgumentParser()\n-        parser.add_argument('--test', type=extend, default='*')\n+        parser.add_argument(\"--test\", type=extend, default=\"*\")\n         args = parser.parse_args([])\n         # The test argument will be two stars, one coming from the default\n         # value and one coming from the type conversion being called exactly\n         # once.\n-        self.assertEqual(NS(test='**'), args)\n+        self.assertEqual(NS(test=\"**\"), args)\n \n     def test_issue_15906(self):\n         # Issue #15906: When action='append', type=str, default=[] are\n         # providing, the dest value was the string representation \"[]\" when it\n         # should have been an empty list.\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('--test', dest='test', type=str,\n-                            default=[], action='append')\n+        parser.add_argument(\n+            \"--test\", dest=\"test\", type=str, default=[], action=\"append\"\n+        )\n         args = parser.parse_args([])\n         self.assertEqual(args.test, [])\n \n+\n # ======================\n # parse_known_args tests\n # ======================\n \n-class TestParseKnownArgs(TestCase):\n \n+class TestParseKnownArgs(TestCase):\n     def test_arguments_tuple(self):\n         parser = argparse.ArgumentParser()\n         parser.parse_args(())\n@@ -6337,26 +6962,26 @@ def test_arguments_list(self):\n \n     def test_arguments_tuple_positional(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('x')\n-        parser.parse_args(('x',))\n+        parser.add_argument(\"x\")\n+        parser.parse_args((\"x\",))\n \n     def test_arguments_list_positional(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('x')\n-        parser.parse_args(['x'])\n+        parser.add_argument(\"x\")\n+        parser.parse_args([\"x\"])\n \n     def test_optionals(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('--foo')\n-        args, extras = parser.parse_known_args('--foo F --bar --baz'.split())\n-        self.assertEqual(NS(foo='F'), args)\n-        self.assertEqual(['--bar', '--baz'], extras)\n+        parser.add_argument(\"--foo\")\n+        args, extras = parser.parse_known_args(\"--foo F --bar --baz\".split())\n+        self.assertEqual(NS(foo=\"F\"), args)\n+        self.assertEqual([\"--bar\", \"--baz\"], extras)\n \n     def test_mixed(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('-v', nargs='?', const=1, type=int)\n-        parser.add_argument('--spam', action='store_false')\n-        parser.add_argument('badger')\n+        parser.add_argument(\"-v\", nargs=\"?\", const=1, type=int)\n+        parser.add_argument(\"--spam\", action=\"store_false\")\n+        parser.add_argument(\"badger\")\n \n         argv = [\"B\", \"C\", \"--foo\", \"-v\", \"3\", \"4\"]\n         args, extras = parser.parse_known_args(argv)\n@@ -6365,7 +6990,7 @@ def test_mixed(self):\n \n     def test_zero_or_more_optional(self):\n         parser = argparse.ArgumentParser()\n-        parser.add_argument('x', nargs='*', choices=('x', 'y'))\n+        parser.add_argument(\"x\", nargs=\"*\", choices=(\"x\", \"y\"))\n         args = parser.parse_args([])\n         self.assertEqual(NS(x=[]), args)\n \n@@ -6373,168 +6998,187 @@ def test_zero_or_more_optional(self):\n class TestDoubleDash(TestCase):\n     def test_single_argument_option(self):\n         parser = argparse.ArgumentParser(exit_on_error=False)\n-        parser.add_argument('-f', '--foo')\n-        parser.add_argument('bar', nargs='*')\n-\n-        args = parser.parse_args(['--foo=--'])\n-        self.assertEqual(NS(foo='--', bar=[]), args)\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-            'argument -f/--foo: expected one argument',\n-            parser.parse_args, ['--foo', '--'])\n-        args = parser.parse_args(['-f--'])\n-        self.assertEqual(NS(foo='--', bar=[]), args)\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-            'argument -f/--foo: expected one argument',\n-            parser.parse_args, ['-f', '--'])\n-        args = parser.parse_args(['--foo', 'a', '--', 'b', 'c'])\n-        self.assertEqual(NS(foo='a', bar=['b', 'c']), args)\n-        args = parser.parse_args(['a', 'b', '--foo', 'c'])\n-        self.assertEqual(NS(foo='c', bar=['a', 'b']), args)\n-        args = parser.parse_args(['a', '--', 'b', '--foo', 'c'])\n-        self.assertEqual(NS(foo=None, bar=['a', 'b', '--foo', 'c']), args)\n-        args = parser.parse_args(['a', '--', 'b', '--', 'c', '--foo', 'd'])\n-        self.assertEqual(NS(foo=None, bar=['a', 'b', '--', 'c', '--foo', 'd']), args)\n+        parser.add_argument(\"-f\", \"--foo\")\n+        parser.add_argument(\"bar\", nargs=\"*\")\n+\n+        args = parser.parse_args([\"--foo=--\"])\n+        self.assertEqual(NS(foo=\"--\", bar=[]), args)\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"argument -f/--foo: expected one argument\",\n+            parser.parse_args,\n+            [\"--foo\", \"--\"],\n+        )\n+        args = parser.parse_args([\"-f--\"])\n+        self.assertEqual(NS(foo=\"--\", bar=[]), args)\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"argument -f/--foo: expected one argument\",\n+            parser.parse_args,\n+            [\"-f\", \"--\"],\n+        )\n+        args = parser.parse_args([\"--foo\", \"a\", \"--\", \"b\", \"c\"])\n+        self.assertEqual(NS(foo=\"a\", bar=[\"b\", \"c\"]), args)\n+        args = parser.parse_args([\"a\", \"b\", \"--foo\", \"c\"])\n+        self.assertEqual(NS(foo=\"c\", bar=[\"a\", \"b\"]), args)\n+        args = parser.parse_args([\"a\", \"--\", \"b\", \"--foo\", \"c\"])\n+        self.assertEqual(NS(foo=None, bar=[\"a\", \"b\", \"--foo\", \"c\"]), args)\n+        args = parser.parse_args([\"a\", \"--\", \"b\", \"--\", \"c\", \"--foo\", \"d\"])\n+        self.assertEqual(\n+            NS(foo=None, bar=[\"a\", \"b\", \"--\", \"c\", \"--foo\", \"d\"]), args\n+        )\n \n     def test_multiple_argument_option(self):\n         parser = argparse.ArgumentParser(exit_on_error=False)\n-        parser.add_argument('-f', '--foo', nargs='*')\n-        parser.add_argument('bar', nargs='*')\n+        parser.add_argument(\"-f\", \"--foo\", nargs=\"*\")\n+        parser.add_argument(\"bar\", nargs=\"*\")\n \n-        args = parser.parse_args(['--foo=--'])\n-        self.assertEqual(NS(foo=['--'], bar=[]), args)\n-        args = parser.parse_args(['--foo', '--'])\n+        args = parser.parse_args([\"--foo=--\"])\n+        self.assertEqual(NS(foo=[\"--\"], bar=[]), args)\n+        args = parser.parse_args([\"--foo\", \"--\"])\n         self.assertEqual(NS(foo=[], bar=[]), args)\n-        args = parser.parse_args(['-f--'])\n-        self.assertEqual(NS(foo=['--'], bar=[]), args)\n-        args = parser.parse_args(['-f', '--'])\n+        args = parser.parse_args([\"-f--\"])\n+        self.assertEqual(NS(foo=[\"--\"], bar=[]), args)\n+        args = parser.parse_args([\"-f\", \"--\"])\n         self.assertEqual(NS(foo=[], bar=[]), args)\n-        args = parser.parse_args(['--foo', 'a', 'b', '--', 'c', 'd'])\n-        self.assertEqual(NS(foo=['a', 'b'], bar=['c', 'd']), args)\n-        args = parser.parse_args(['a', 'b', '--foo', 'c', 'd'])\n-        self.assertEqual(NS(foo=['c', 'd'], bar=['a', 'b']), args)\n-        args = parser.parse_args(['a', '--', 'b', '--foo', 'c', 'd'])\n-        self.assertEqual(NS(foo=None, bar=['a', 'b', '--foo', 'c', 'd']), args)\n-        args, argv = parser.parse_known_args(['a', 'b', '--foo', 'c', '--', 'd'])\n-        self.assertEqual(NS(foo=['c'], bar=['a', 'b']), args)\n-        self.assertEqual(argv, ['--', 'd'])\n+        args = parser.parse_args([\"--foo\", \"a\", \"b\", \"--\", \"c\", \"d\"])\n+        self.assertEqual(NS(foo=[\"a\", \"b\"], bar=[\"c\", \"d\"]), args)\n+        args = parser.parse_args([\"a\", \"b\", \"--foo\", \"c\", \"d\"])\n+        self.assertEqual(NS(foo=[\"c\", \"d\"], bar=[\"a\", \"b\"]), args)\n+        args = parser.parse_args([\"a\", \"--\", \"b\", \"--foo\", \"c\", \"d\"])\n+        self.assertEqual(NS(foo=None, bar=[\"a\", \"b\", \"--foo\", \"c\", \"d\"]), args)\n+        args, argv = parser.parse_known_args(\n+            [\"a\", \"b\", \"--foo\", \"c\", \"--\", \"d\"]\n+        )\n+        self.assertEqual(NS(foo=[\"c\"], bar=[\"a\", \"b\"]), args)\n+        self.assertEqual(argv, [\"--\", \"d\"])\n \n     def test_multiple_double_dashes(self):\n         parser = argparse.ArgumentParser(exit_on_error=False)\n-        parser.add_argument('foo')\n-        parser.add_argument('bar', nargs='*')\n-\n-        args = parser.parse_args(['--', 'a', 'b', 'c'])\n-        self.assertEqual(NS(foo='a', bar=['b', 'c']), args)\n-        args = parser.parse_args(['a', '--', 'b', 'c'])\n-        self.assertEqual(NS(foo='a', bar=['b', 'c']), args)\n-        args = parser.parse_args(['a', 'b', '--', 'c'])\n-        self.assertEqual(NS(foo='a', bar=['b', 'c']), args)\n-        args = parser.parse_args(['a', '--', 'b', '--', 'c'])\n-        self.assertEqual(NS(foo='a', bar=['b', '--', 'c']), args)\n-        args = parser.parse_args(['--', '--', 'a', '--', 'b', 'c'])\n-        self.assertEqual(NS(foo='--', bar=['a', '--', 'b', 'c']), args)\n+        parser.add_argument(\"foo\")\n+        parser.add_argument(\"bar\", nargs=\"*\")\n+\n+        args = parser.parse_args([\"--\", \"a\", \"b\", \"c\"])\n+        self.assertEqual(NS(foo=\"a\", bar=[\"b\", \"c\"]), args)\n+        args = parser.parse_args([\"a\", \"--\", \"b\", \"c\"])\n+        self.assertEqual(NS(foo=\"a\", bar=[\"b\", \"c\"]), args)\n+        args = parser.parse_args([\"a\", \"b\", \"--\", \"c\"])\n+        self.assertEqual(NS(foo=\"a\", bar=[\"b\", \"c\"]), args)\n+        args = parser.parse_args([\"a\", \"--\", \"b\", \"--\", \"c\"])\n+        self.assertEqual(NS(foo=\"a\", bar=[\"b\", \"--\", \"c\"]), args)\n+        args = parser.parse_args([\"--\", \"--\", \"a\", \"--\", \"b\", \"c\"])\n+        self.assertEqual(NS(foo=\"--\", bar=[\"a\", \"--\", \"b\", \"c\"]), args)\n \n     def test_remainder(self):\n         parser = argparse.ArgumentParser(exit_on_error=False)\n-        parser.add_argument('foo')\n-        parser.add_argument('bar', nargs='...')\n-\n-        args = parser.parse_args(['--', 'a', 'b', 'c'])\n-        self.assertEqual(NS(foo='a', bar=['b', 'c']), args)\n-        args = parser.parse_args(['a', '--', 'b', 'c'])\n-        self.assertEqual(NS(foo='a', bar=['b', 'c']), args)\n-        args = parser.parse_args(['a', 'b', '--', 'c'])\n-        self.assertEqual(NS(foo='a', bar=['b', '--', 'c']), args)\n-        args = parser.parse_args(['a', '--', 'b', '--', 'c'])\n-        self.assertEqual(NS(foo='a', bar=['b', '--', 'c']), args)\n+        parser.add_argument(\"foo\")\n+        parser.add_argument(\"bar\", nargs=\"...\")\n+\n+        args = parser.parse_args([\"--\", \"a\", \"b\", \"c\"])\n+        self.assertEqual(NS(foo=\"a\", bar=[\"b\", \"c\"]), args)\n+        args = parser.parse_args([\"a\", \"--\", \"b\", \"c\"])\n+        self.assertEqual(NS(foo=\"a\", bar=[\"b\", \"c\"]), args)\n+        args = parser.parse_args([\"a\", \"b\", \"--\", \"c\"])\n+        self.assertEqual(NS(foo=\"a\", bar=[\"b\", \"--\", \"c\"]), args)\n+        args = parser.parse_args([\"a\", \"--\", \"b\", \"--\", \"c\"])\n+        self.assertEqual(NS(foo=\"a\", bar=[\"b\", \"--\", \"c\"]), args)\n \n         parser = argparse.ArgumentParser(exit_on_error=False)\n-        parser.add_argument('--foo')\n-        parser.add_argument('bar', nargs='...')\n-        args = parser.parse_args(['--foo', 'a', '--', 'b', '--', 'c'])\n-        self.assertEqual(NS(foo='a', bar=['--', 'b', '--', 'c']), args)\n+        parser.add_argument(\"--foo\")\n+        parser.add_argument(\"bar\", nargs=\"...\")\n+        args = parser.parse_args([\"--foo\", \"a\", \"--\", \"b\", \"--\", \"c\"])\n+        self.assertEqual(NS(foo=\"a\", bar=[\"--\", \"b\", \"--\", \"c\"]), args)\n \n     def test_subparser(self):\n         parser = argparse.ArgumentParser(exit_on_error=False)\n-        parser.add_argument('foo')\n+        parser.add_argument(\"foo\")\n         subparsers = parser.add_subparsers()\n-        parser1 = subparsers.add_parser('run')\n-        parser1.add_argument('-f')\n-        parser1.add_argument('bar', nargs='*')\n-\n-        args = parser.parse_args(['x', 'run', 'a', 'b', '-f', 'c'])\n-        self.assertEqual(NS(foo='x', f='c', bar=['a', 'b']), args)\n-        args = parser.parse_args(['x', 'run', 'a', 'b', '--', '-f', 'c'])\n-        self.assertEqual(NS(foo='x', f=None, bar=['a', 'b', '-f', 'c']), args)\n-        args = parser.parse_args(['x', 'run', 'a', '--', 'b', '-f', 'c'])\n-        self.assertEqual(NS(foo='x', f=None, bar=['a', 'b', '-f', 'c']), args)\n-        args = parser.parse_args(['x', 'run', '--', 'a', 'b', '-f', 'c'])\n-        self.assertEqual(NS(foo='x', f=None, bar=['a', 'b', '-f', 'c']), args)\n-        args = parser.parse_args(['x', '--', 'run', 'a', 'b', '-f', 'c'])\n-        self.assertEqual(NS(foo='x', f='c', bar=['a', 'b']), args)\n-        args = parser.parse_args(['--', 'x', 'run', 'a', 'b', '-f', 'c'])\n-        self.assertEqual(NS(foo='x', f='c', bar=['a', 'b']), args)\n-        args = parser.parse_args(['x', 'run', '--', 'a', '--', 'b'])\n-        self.assertEqual(NS(foo='x', f=None, bar=['a', '--', 'b']), args)\n-        args = parser.parse_args(['x', '--', 'run', '--', 'a', '--', 'b'])\n-        self.assertEqual(NS(foo='x', f=None, bar=['a', '--', 'b']), args)\n-        self.assertRaisesRegex(argparse.ArgumentError,\n+        parser1 = subparsers.add_parser(\"run\")\n+        parser1.add_argument(\"-f\")\n+        parser1.add_argument(\"bar\", nargs=\"*\")\n+\n+        args = parser.parse_args([\"x\", \"run\", \"a\", \"b\", \"-f\", \"c\"])\n+        self.assertEqual(NS(foo=\"x\", f=\"c\", bar=[\"a\", \"b\"]), args)\n+        args = parser.parse_args([\"x\", \"run\", \"a\", \"b\", \"--\", \"-f\", \"c\"])\n+        self.assertEqual(NS(foo=\"x\", f=None, bar=[\"a\", \"b\", \"-f\", \"c\"]), args)\n+        args = parser.parse_args([\"x\", \"run\", \"a\", \"--\", \"b\", \"-f\", \"c\"])\n+        self.assertEqual(NS(foo=\"x\", f=None, bar=[\"a\", \"b\", \"-f\", \"c\"]), args)\n+        args = parser.parse_args([\"x\", \"run\", \"--\", \"a\", \"b\", \"-f\", \"c\"])\n+        self.assertEqual(NS(foo=\"x\", f=None, bar=[\"a\", \"b\", \"-f\", \"c\"]), args)\n+        args = parser.parse_args([\"x\", \"--\", \"run\", \"a\", \"b\", \"-f\", \"c\"])\n+        self.assertEqual(NS(foo=\"x\", f=\"c\", bar=[\"a\", \"b\"]), args)\n+        args = parser.parse_args([\"--\", \"x\", \"run\", \"a\", \"b\", \"-f\", \"c\"])\n+        self.assertEqual(NS(foo=\"x\", f=\"c\", bar=[\"a\", \"b\"]), args)\n+        args = parser.parse_args([\"x\", \"run\", \"--\", \"a\", \"--\", \"b\"])\n+        self.assertEqual(NS(foo=\"x\", f=None, bar=[\"a\", \"--\", \"b\"]), args)\n+        args = parser.parse_args([\"x\", \"--\", \"run\", \"--\", \"a\", \"--\", \"b\"])\n+        self.assertEqual(NS(foo=\"x\", f=None, bar=[\"a\", \"--\", \"b\"]), args)\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n             \"invalid choice: '--'\",\n-            parser.parse_args, ['--', 'x', '--', 'run', 'a', 'b'])\n+            parser.parse_args,\n+            [\"--\", \"x\", \"--\", \"run\", \"a\", \"b\"],\n+        )\n \n     def test_subparser_after_multiple_argument_option(self):\n         parser = argparse.ArgumentParser(exit_on_error=False)\n-        parser.add_argument('--foo', nargs='*')\n+        parser.add_argument(\"--foo\", nargs=\"*\")\n         subparsers = parser.add_subparsers()\n-        parser1 = subparsers.add_parser('run')\n-        parser1.add_argument('-f')\n-        parser1.add_argument('bar', nargs='*')\n+        parser1 = subparsers.add_parser(\"run\")\n+        parser1.add_argument(\"-f\")\n+        parser1.add_argument(\"bar\", nargs=\"*\")\n \n-        args = parser.parse_args(['--foo', 'x', 'y', '--', 'run', 'a', 'b', '-f', 'c'])\n-        self.assertEqual(NS(foo=['x', 'y'], f='c', bar=['a', 'b']), args)\n-        self.assertRaisesRegex(argparse.ArgumentError,\n+        args = parser.parse_args(\n+            [\"--foo\", \"x\", \"y\", \"--\", \"run\", \"a\", \"b\", \"-f\", \"c\"]\n+        )\n+        self.assertEqual(NS(foo=[\"x\", \"y\"], f=\"c\", bar=[\"a\", \"b\"]), args)\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n             \"invalid choice: '--'\",\n-            parser.parse_args, ['--foo', 'x', '--', '--', 'run', 'a', 'b'])\n+            parser.parse_args,\n+            [\"--foo\", \"x\", \"--\", \"--\", \"run\", \"a\", \"b\"],\n+        )\n \n \n # ===========================\n # parse_intermixed_args tests\n # ===========================\n \n+\n class TestIntermixedArgs(TestCase):\n     def test_basic(self):\n         # test parsing intermixed optionals and positionals\n-        parser = argparse.ArgumentParser(prog='PROG')\n-        parser.add_argument('--foo', dest='foo')\n-        bar = parser.add_argument('--bar', dest='bar', required=True)\n-        parser.add_argument('cmd')\n-        parser.add_argument('rest', nargs='*', type=int)\n-        argv = 'cmd --foo x 1 --bar y 2 3'.split()\n+        parser = argparse.ArgumentParser(prog=\"PROG\")\n+        parser.add_argument(\"--foo\", dest=\"foo\")\n+        bar = parser.add_argument(\"--bar\", dest=\"bar\", required=True)\n+        parser.add_argument(\"cmd\")\n+        parser.add_argument(\"rest\", nargs=\"*\", type=int)\n+        argv = \"cmd --foo x 1 --bar y 2 3\".split()\n         args = parser.parse_intermixed_args(argv)\n         # rest gets [1,2,3] despite the foo and bar strings\n-        self.assertEqual(NS(bar='y', cmd='cmd', foo='x', rest=[1, 2, 3]), args)\n+        self.assertEqual(NS(bar=\"y\", cmd=\"cmd\", foo=\"x\", rest=[1, 2, 3]), args)\n \n         args, extras = parser.parse_known_args(argv)\n         # cannot parse the '1,2,3'\n-        self.assertEqual(NS(bar='y', cmd='cmd', foo='x', rest=[1]), args)\n+        self.assertEqual(NS(bar=\"y\", cmd=\"cmd\", foo=\"x\", rest=[1]), args)\n         self.assertEqual([\"2\", \"3\"], extras)\n         args, extras = parser.parse_known_intermixed_args(argv)\n-        self.assertEqual(NS(bar='y', cmd='cmd', foo='x', rest=[1, 2, 3]), args)\n+        self.assertEqual(NS(bar=\"y\", cmd=\"cmd\", foo=\"x\", rest=[1, 2, 3]), args)\n         self.assertEqual([], extras)\n \n         # unknown optionals go into extras\n-        argv = 'cmd --foo x --error 1 2 --bar y 3'.split()\n+        argv = \"cmd --foo x --error 1 2 --bar y 3\".split()\n         args, extras = parser.parse_known_intermixed_args(argv)\n-        self.assertEqual(NS(bar='y', cmd='cmd', foo='x', rest=[1, 2, 3]), args)\n-        self.assertEqual(['--error'], extras)\n-        argv = 'cmd --foo x 1 --error 2 --bar y 3'.split()\n+        self.assertEqual(NS(bar=\"y\", cmd=\"cmd\", foo=\"x\", rest=[1, 2, 3]), args)\n+        self.assertEqual([\"--error\"], extras)\n+        argv = \"cmd --foo x 1 --error 2 --bar y 3\".split()\n         args, extras = parser.parse_known_intermixed_args(argv)\n-        self.assertEqual(NS(bar='y', cmd='cmd', foo='x', rest=[1, 2, 3]), args)\n-        self.assertEqual(['--error'], extras)\n-        argv = 'cmd --foo x 1 2 --error --bar y 3'.split()\n+        self.assertEqual(NS(bar=\"y\", cmd=\"cmd\", foo=\"x\", rest=[1, 2, 3]), args)\n+        self.assertEqual([\"--error\"], extras)\n+        argv = \"cmd --foo x 1 2 --error --bar y 3\".split()\n         args, extras = parser.parse_known_intermixed_args(argv)\n-        self.assertEqual(NS(bar='y', cmd='cmd', foo='x', rest=[1, 2, 3]), args)\n-        self.assertEqual(['--error'], extras)\n+        self.assertEqual(NS(bar=\"y\", cmd=\"cmd\", foo=\"x\", rest=[1, 2, 3]), args)\n+        self.assertEqual([\"--error\"], extras)\n \n         # restores attributes that were temporarily changed\n         self.assertIsNone(parser.usage)\n@@ -6542,86 +7186,101 @@ def test_basic(self):\n \n     def test_remainder(self):\n         # Intermixed and remainder are incompatible\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n-        parser.add_argument('-z')\n-        parser.add_argument('x')\n-        parser.add_argument('y', nargs='...')\n-        argv = 'X A B -z Z'.split()\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n+        parser.add_argument(\"-z\")\n+        parser.add_argument(\"x\")\n+        parser.add_argument(\"y\", nargs=\"...\")\n+        argv = \"X A B -z Z\".split()\n         # intermixed fails with '...' (also 'A...')\n         # self.assertRaises(TypeError, parser.parse_intermixed_args, argv)\n         with self.assertRaises(TypeError) as cm:\n             parser.parse_intermixed_args(argv)\n-        self.assertRegex(str(cm.exception), r'\\.\\.\\.')\n+        self.assertRegex(str(cm.exception), r\"\\.\\.\\.\")\n \n     def test_required_exclusive(self):\n         # required mutually exclusive group; intermixed works fine\n-        parser = argparse.ArgumentParser(prog='PROG', exit_on_error=False)\n+        parser = argparse.ArgumentParser(prog=\"PROG\", exit_on_error=False)\n         group = parser.add_mutually_exclusive_group(required=True)\n-        group.add_argument('--foo', action='store_true', help='FOO')\n-        group.add_argument('--spam', help='SPAM')\n-        parser.add_argument('badger', nargs='*', default='X', help='BADGER')\n-        args = parser.parse_intermixed_args('--foo 1 2'.split())\n-        self.assertEqual(NS(badger=['1', '2'], foo=True, spam=None), args)\n-        args = parser.parse_intermixed_args('1 --foo 2'.split())\n-        self.assertEqual(NS(badger=['1', '2'], foo=True, spam=None), args)\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                'one of the arguments --foo --spam is required',\n-                parser.parse_intermixed_args, '1 2'.split())\n+        group.add_argument(\"--foo\", action=\"store_true\", help=\"FOO\")\n+        group.add_argument(\"--spam\", help=\"SPAM\")\n+        parser.add_argument(\"badger\", nargs=\"*\", default=\"X\", help=\"BADGER\")\n+        args = parser.parse_intermixed_args(\"--foo 1 2\".split())\n+        self.assertEqual(NS(badger=[\"1\", \"2\"], foo=True, spam=None), args)\n+        args = parser.parse_intermixed_args(\"1 --foo 2\".split())\n+        self.assertEqual(NS(badger=[\"1\", \"2\"], foo=True, spam=None), args)\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"one of the arguments --foo --spam is required\",\n+            parser.parse_intermixed_args,\n+            \"1 2\".split(),\n+        )\n         self.assertEqual(group.required, True)\n \n     def test_required_exclusive_with_positional(self):\n         # required mutually exclusive group with positional argument\n-        parser = argparse.ArgumentParser(prog='PROG', exit_on_error=False)\n+        parser = argparse.ArgumentParser(prog=\"PROG\", exit_on_error=False)\n         group = parser.add_mutually_exclusive_group(required=True)\n-        group.add_argument('--foo', action='store_true', help='FOO')\n-        group.add_argument('--spam', help='SPAM')\n-        group.add_argument('badger', nargs='*', default='X', help='BADGER')\n-        args = parser.parse_intermixed_args(['--foo'])\n-        self.assertEqual(NS(foo=True, spam=None, badger='X'), args)\n-        args = parser.parse_intermixed_args(['a', 'b'])\n-        self.assertEqual(NS(foo=False, spam=None, badger=['a', 'b']), args)\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                'one of the arguments --foo --spam badger is required',\n-                parser.parse_intermixed_args, [])\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                'argument badger: not allowed with argument --foo',\n-                parser.parse_intermixed_args, ['--foo', 'a', 'b'])\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                'argument badger: not allowed with argument --foo',\n-                parser.parse_intermixed_args, ['a', '--foo', 'b'])\n+        group.add_argument(\"--foo\", action=\"store_true\", help=\"FOO\")\n+        group.add_argument(\"--spam\", help=\"SPAM\")\n+        group.add_argument(\"badger\", nargs=\"*\", default=\"X\", help=\"BADGER\")\n+        args = parser.parse_intermixed_args([\"--foo\"])\n+        self.assertEqual(NS(foo=True, spam=None, badger=\"X\"), args)\n+        args = parser.parse_intermixed_args([\"a\", \"b\"])\n+        self.assertEqual(NS(foo=False, spam=None, badger=[\"a\", \"b\"]), args)\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"one of the arguments --foo --spam badger is required\",\n+            parser.parse_intermixed_args,\n+            [],\n+        )\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"argument badger: not allowed with argument --foo\",\n+            parser.parse_intermixed_args,\n+            [\"--foo\", \"a\", \"b\"],\n+        )\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"argument badger: not allowed with argument --foo\",\n+            parser.parse_intermixed_args,\n+            [\"a\", \"--foo\", \"b\"],\n+        )\n         self.assertEqual(group.required, True)\n \n     def test_invalid_args(self):\n-        parser = ErrorRaisingArgumentParser(prog='PROG')\n-        self.assertRaises(ArgumentParserError, parser.parse_intermixed_args, ['a'])\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\")\n+        self.assertRaises(\n+            ArgumentParserError, parser.parse_intermixed_args, [\"a\"]\n+        )\n \n \n class TestIntermixedMessageContentError(TestCase):\n     # case where Intermixed gives different error message\n     # error is raised by 1st parsing step\n     def test_missing_argument_name_in_message(self):\n-        parser = ErrorRaisingArgumentParser(prog='PROG', usage='')\n-        parser.add_argument('req_pos', type=str)\n-        parser.add_argument('-req_opt', type=int, required=True)\n+        parser = ErrorRaisingArgumentParser(prog=\"PROG\", usage=\"\")\n+        parser.add_argument(\"req_pos\", type=str)\n+        parser.add_argument(\"-req_opt\", type=int, required=True)\n \n         with self.assertRaises(ArgumentParserError) as cm:\n             parser.parse_args([])\n         msg = str(cm.exception)\n-        self.assertRegex(msg, 'req_pos')\n-        self.assertRegex(msg, 'req_opt')\n+        self.assertRegex(msg, \"req_pos\")\n+        self.assertRegex(msg, \"req_opt\")\n \n         with self.assertRaises(ArgumentParserError) as cm:\n             parser.parse_intermixed_args([])\n         msg = str(cm.exception)\n-        self.assertRegex(msg, 'req_pos')\n-        self.assertRegex(msg, 'req_opt')\n+        self.assertRegex(msg, \"req_pos\")\n+        self.assertRegex(msg, \"req_opt\")\n+\n \n # ==========================\n # add_argument metavar tests\n # ==========================\n \n-class TestAddArgumentMetavar(TestCase):\n \n+class TestAddArgumentMetavar(TestCase):\n     EXPECTED_MESSAGE = \"length of metavar tuple does not match nargs\"\n \n     def do_test_no_exception(self, nargs, metavar):\n@@ -6789,11 +7448,12 @@ def test_nargs_3_metavar_length3(self):\n \n \n class TestInvalidNargs(TestCase):\n-\n     EXPECTED_INVALID_MESSAGE = \"invalid nargs value\"\n-    EXPECTED_RANGE_MESSAGE = (\"nargs for store actions must be != 0; if you \"\n-                              \"have nothing to store, actions such as store \"\n-                              \"true or store const may be more appropriate\")\n+    EXPECTED_RANGE_MESSAGE = (\n+        \"nargs for store actions must be != 0; if you \"\n+        \"have nothing to store, actions such as store \"\n+        \"true or store const may be more appropriate\"\n+    )\n \n     def do_test_range_exception(self, nargs):\n         parser = argparse.ArgumentParser()\n@@ -6810,18 +7470,19 @@ def do_test_invalid_exception(self, nargs):\n     # Unit tests for different values of nargs\n \n     def test_nargs_alphabetic(self):\n-        self.do_test_invalid_exception(nargs='a')\n+        self.do_test_invalid_exception(nargs=\"a\")\n         self.do_test_invalid_exception(nargs=\"abcd\")\n \n     def test_nargs_zero(self):\n         self.do_test_range_exception(nargs=0)\n \n+\n # ============================\n # from argparse import * tests\n # ============================\n \n-class TestImportStar(TestCase):\n \n+class TestImportStar(TestCase):\n     def test(self):\n         for name in argparse.__all__:\n             self.assertHasAttr(argparse, name)\n@@ -6830,200 +7491,275 @@ def test_all_exports_everything_but_modules(self):\n         items = [\n             name\n             for name, value in vars(argparse).items()\n-            if not (name.startswith(\"_\") or name == 'ngettext')\n+            if not (name.startswith(\"_\") or name == \"ngettext\")\n             if not inspect.ismodule(value)\n         ]\n         self.assertEqual(sorted(items), sorted(argparse.__all__))\n \n \n class TestWrappingMetavar(TestCase):\n-\n     def setUp(self):\n         super().setUp()\n         self.parser = ErrorRaisingArgumentParser(\n-            'this_is_spammy_prog_with_a_long_name_sorry_about_the_name'\n+            \"this_is_spammy_prog_with_a_long_name_sorry_about_the_name\"\n         )\n         # this metavar was triggering library assertion errors due to usage\n         # message formatting incorrectly splitting on the ] chars within\n-        metavar = '<http[s]://example:1234>'\n-        self.parser.add_argument('--proxy', metavar=metavar)\n+        metavar = \"<http[s]://example:1234>\"\n+        self.parser.add_argument(\"--proxy\", metavar=metavar)\n \n     @force_not_colorized\n     def test_help_with_metavar(self):\n         help_text = self.parser.format_help()\n-        self.assertEqual(help_text, textwrap.dedent('''\\\n+        self.assertEqual(\n+            help_text,\n+            textwrap.dedent(\"\"\"\\\n             usage: this_is_spammy_prog_with_a_long_name_sorry_about_the_name\n                    [-h] [--proxy <http[s]://example:1234>]\n \n             options:\n               -h, --help            show this help message and exit\n               --proxy <http[s]://example:1234>\n-            '''))\n+            \"\"\"),\n+        )\n \n \n class TestExitOnError(TestCase):\n-\n     def setUp(self):\n-        self.parser = argparse.ArgumentParser(exit_on_error=False,\n-                                              fromfile_prefix_chars='@')\n-        self.parser.add_argument('--integers', metavar='N', type=int)\n+        self.parser = argparse.ArgumentParser(\n+            exit_on_error=False, fromfile_prefix_chars=\"@\"\n+        )\n+        self.parser.add_argument(\"--integers\", metavar=\"N\", type=int)\n \n     def test_exit_on_error_with_good_args(self):\n-        ns = self.parser.parse_args('--integers 4'.split())\n+        ns = self.parser.parse_args(\"--integers 4\".split())\n         self.assertEqual(ns, argparse.Namespace(integers=4))\n \n     def test_exit_on_error_with_bad_args(self):\n         with self.assertRaises(argparse.ArgumentError):\n-            self.parser.parse_args('--integers a'.split())\n+            self.parser.parse_args(\"--integers a\".split())\n \n     def test_unrecognized_args(self):\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'unrecognized arguments: --foo bar',\n-                               self.parser.parse_args, '--foo bar'.split())\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"unrecognized arguments: --foo bar\",\n+            self.parser.parse_args,\n+            \"--foo bar\".split(),\n+        )\n \n     def test_unrecognized_intermixed_args(self):\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'unrecognized arguments: --foo bar',\n-                               self.parser.parse_intermixed_args, '--foo bar'.split())\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"unrecognized arguments: --foo bar\",\n+            self.parser.parse_intermixed_args,\n+            \"--foo bar\".split(),\n+        )\n \n     def test_required_args(self):\n-        self.parser.add_argument('bar')\n-        self.parser.add_argument('baz')\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'the following arguments are required: bar, baz$',\n-                               self.parser.parse_args, [])\n+        self.parser.add_argument(\"bar\")\n+        self.parser.add_argument(\"baz\")\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"the following arguments are required: bar, baz$\",\n+            self.parser.parse_args,\n+            [],\n+        )\n \n     def test_required_args_with_metavar(self):\n-        self.parser.add_argument('bar')\n-        self.parser.add_argument('baz', metavar='BaZ')\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'the following arguments are required: bar, BaZ$',\n-                               self.parser.parse_args, [])\n+        self.parser.add_argument(\"bar\")\n+        self.parser.add_argument(\"baz\", metavar=\"BaZ\")\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"the following arguments are required: bar, BaZ$\",\n+            self.parser.parse_args,\n+            [],\n+        )\n \n     def test_required_args_n(self):\n-        self.parser.add_argument('bar')\n-        self.parser.add_argument('baz', nargs=3)\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'the following arguments are required: bar, baz$',\n-                               self.parser.parse_args, [])\n+        self.parser.add_argument(\"bar\")\n+        self.parser.add_argument(\"baz\", nargs=3)\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"the following arguments are required: bar, baz$\",\n+            self.parser.parse_args,\n+            [],\n+        )\n \n     def test_required_args_n_with_metavar(self):\n-        self.parser.add_argument('bar')\n-        self.parser.add_argument('baz', nargs=3, metavar=('B', 'A', 'Z'))\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'the following arguments are required: bar, B, A, Z$',\n-                               self.parser.parse_args, [])\n+        self.parser.add_argument(\"bar\")\n+        self.parser.add_argument(\"baz\", nargs=3, metavar=(\"B\", \"A\", \"Z\"))\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"the following arguments are required: bar, B, A, Z$\",\n+            self.parser.parse_args,\n+            [],\n+        )\n \n     def test_required_args_optional(self):\n-        self.parser.add_argument('bar')\n-        self.parser.add_argument('baz', nargs='?')\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'the following arguments are required: bar$',\n-                               self.parser.parse_args, [])\n+        self.parser.add_argument(\"bar\")\n+        self.parser.add_argument(\"baz\", nargs=\"?\")\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"the following arguments are required: bar$\",\n+            self.parser.parse_args,\n+            [],\n+        )\n \n     def test_required_args_zero_or_more(self):\n-        self.parser.add_argument('bar')\n-        self.parser.add_argument('baz', nargs='*')\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'the following arguments are required: bar$',\n-                               self.parser.parse_args, [])\n+        self.parser.add_argument(\"bar\")\n+        self.parser.add_argument(\"baz\", nargs=\"*\")\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"the following arguments are required: bar$\",\n+            self.parser.parse_args,\n+            [],\n+        )\n \n     def test_required_args_one_or_more(self):\n-        self.parser.add_argument('bar')\n-        self.parser.add_argument('baz', nargs='+')\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'the following arguments are required: bar, baz$',\n-                               self.parser.parse_args, [])\n+        self.parser.add_argument(\"bar\")\n+        self.parser.add_argument(\"baz\", nargs=\"+\")\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"the following arguments are required: bar, baz$\",\n+            self.parser.parse_args,\n+            [],\n+        )\n \n     def test_required_args_one_or_more_with_metavar(self):\n-        self.parser.add_argument('bar')\n-        self.parser.add_argument('baz', nargs='+', metavar=('BaZ1', 'BaZ2'))\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               r'the following arguments are required: bar, BaZ1\\[, BaZ2]$',\n-                               self.parser.parse_args, [])\n+        self.parser.add_argument(\"bar\")\n+        self.parser.add_argument(\"baz\", nargs=\"+\", metavar=(\"BaZ1\", \"BaZ2\"))\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            r\"the following arguments are required: bar, BaZ1\\[, BaZ2]$\",\n+            self.parser.parse_args,\n+            [],\n+        )\n \n     def test_required_args_remainder(self):\n-        self.parser.add_argument('bar')\n-        self.parser.add_argument('baz', nargs='...')\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'the following arguments are required: bar$',\n-                               self.parser.parse_args, [])\n+        self.parser.add_argument(\"bar\")\n+        self.parser.add_argument(\"baz\", nargs=\"...\")\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"the following arguments are required: bar$\",\n+            self.parser.parse_args,\n+            [],\n+        )\n \n     def test_required_mutually_exclusive_args(self):\n         group = self.parser.add_mutually_exclusive_group(required=True)\n-        group.add_argument('--bar')\n-        group.add_argument('--baz')\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'one of the arguments --bar --baz is required',\n-                               self.parser.parse_args, [])\n+        group.add_argument(\"--bar\")\n+        group.add_argument(\"--baz\")\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"one of the arguments --bar --baz is required\",\n+            self.parser.parse_args,\n+            [],\n+        )\n \n     def test_conflicting_mutually_exclusive_args_optional_with_metavar(self):\n         group = self.parser.add_mutually_exclusive_group()\n-        group.add_argument('--bar')\n-        group.add_argument('baz', nargs='?', metavar='BaZ')\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'argument BaZ: not allowed with argument --bar$',\n-                               self.parser.parse_args, ['--bar', 'a', 'b'])\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'argument --bar: not allowed with argument BaZ$',\n-                               self.parser.parse_args, ['a', '--bar', 'b'])\n-\n-    def test_conflicting_mutually_exclusive_args_zero_or_more_with_metavar1(self):\n+        group.add_argument(\"--bar\")\n+        group.add_argument(\"baz\", nargs=\"?\", metavar=\"BaZ\")\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"argument BaZ: not allowed with argument --bar$\",\n+            self.parser.parse_args,\n+            [\"--bar\", \"a\", \"b\"],\n+        )\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"argument --bar: not allowed with argument BaZ$\",\n+            self.parser.parse_args,\n+            [\"a\", \"--bar\", \"b\"],\n+        )\n+\n+    def test_conflicting_mutually_exclusive_args_zero_or_more_with_metavar1(\n+        self,\n+    ):\n         group = self.parser.add_mutually_exclusive_group()\n-        group.add_argument('--bar')\n-        group.add_argument('baz', nargs='*', metavar=('BAZ1',))\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'argument BAZ1: not allowed with argument --bar$',\n-                               self.parser.parse_args, ['--bar', 'a', 'b'])\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               'argument --bar: not allowed with argument BAZ1$',\n-                               self.parser.parse_args, ['a', '--bar', 'b'])\n-\n-    def test_conflicting_mutually_exclusive_args_zero_or_more_with_metavar2(self):\n+        group.add_argument(\"--bar\")\n+        group.add_argument(\"baz\", nargs=\"*\", metavar=(\"BAZ1\",))\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"argument BAZ1: not allowed with argument --bar$\",\n+            self.parser.parse_args,\n+            [\"--bar\", \"a\", \"b\"],\n+        )\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"argument --bar: not allowed with argument BAZ1$\",\n+            self.parser.parse_args,\n+            [\"a\", \"--bar\", \"b\"],\n+        )\n+\n+    def test_conflicting_mutually_exclusive_args_zero_or_more_with_metavar2(\n+        self,\n+    ):\n         group = self.parser.add_mutually_exclusive_group()\n-        group.add_argument('--bar')\n-        group.add_argument('baz', nargs='*', metavar=('BAZ1', 'BAZ2'))\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               r'argument BAZ1\\[, BAZ2]: not allowed with argument --bar$',\n-                               self.parser.parse_args, ['--bar', 'a', 'b'])\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               r'argument --bar: not allowed with argument BAZ1\\[, BAZ2]$',\n-                               self.parser.parse_args, ['a', '--bar', 'b'])\n+        group.add_argument(\"--bar\")\n+        group.add_argument(\"baz\", nargs=\"*\", metavar=(\"BAZ1\", \"BAZ2\"))\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            r\"argument BAZ1\\[, BAZ2]: not allowed with argument --bar$\",\n+            self.parser.parse_args,\n+            [\"--bar\", \"a\", \"b\"],\n+        )\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            r\"argument --bar: not allowed with argument BAZ1\\[, BAZ2]$\",\n+            self.parser.parse_args,\n+            [\"a\", \"--bar\", \"b\"],\n+        )\n \n     def test_ambiguous_option(self):\n-        self.parser.add_argument('--foobaz')\n-        self.parser.add_argument('--fooble', action='store_true')\n-        self.parser.add_argument('--foogle')\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                \"ambiguous option: --foob could match --foobaz, --fooble\",\n-            self.parser.parse_args, ['--foob'])\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                \"ambiguous option: --foob=1 could match --foobaz, --fooble$\",\n-            self.parser.parse_args, ['--foob=1'])\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                \"ambiguous option: --foob could match --foobaz, --fooble$\",\n-            self.parser.parse_args, ['--foob', '1', '--foogle', '2'])\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                \"ambiguous option: --foob=1 could match --foobaz, --fooble$\",\n-            self.parser.parse_args, ['--foob=1', '--foogle', '2'])\n+        self.parser.add_argument(\"--foobaz\")\n+        self.parser.add_argument(\"--fooble\", action=\"store_true\")\n+        self.parser.add_argument(\"--foogle\")\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"ambiguous option: --foob could match --foobaz, --fooble\",\n+            self.parser.parse_args,\n+            [\"--foob\"],\n+        )\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"ambiguous option: --foob=1 could match --foobaz, --fooble$\",\n+            self.parser.parse_args,\n+            [\"--foob=1\"],\n+        )\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"ambiguous option: --foob could match --foobaz, --fooble$\",\n+            self.parser.parse_args,\n+            [\"--foob\", \"1\", \"--foogle\", \"2\"],\n+        )\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"ambiguous option: --foob=1 could match --foobaz, --fooble$\",\n+            self.parser.parse_args,\n+            [\"--foob=1\", \"--foogle\", \"2\"],\n+        )\n \n     def test_os_error(self):\n-        self.parser.add_argument('file')\n-        self.assertRaisesRegex(argparse.ArgumentError,\n-                               \"No such file or directory: 'no-such-file'\",\n-                               self.parser.parse_args, ['@no-such-file'])\n+        self.parser.add_argument(\"file\")\n+        self.assertRaisesRegex(\n+            argparse.ArgumentError,\n+            \"No such file or directory: 'no-such-file'\",\n+            self.parser.parse_args,\n+            [\"@no-such-file\"],\n+        )\n \n \n @force_not_colorized_test_class\n class TestProgName(TestCase):\n-    source = textwrap.dedent('''\\\n+    source = textwrap.dedent(\"\"\"\\\n         import argparse\n         parser = argparse.ArgumentParser()\n         parser.parse_args()\n-    ''')\n+    \"\"\")\n \n     def setUp(self):\n-        self.dirname = 'package' + os_helper.FS_NONASCII\n+        self.dirname = \"package\" + os_helper.FS_NONASCII\n         self.addCleanup(os_helper.rmtree, self.dirname)\n         os.mkdir(self.dirname)\n \n@@ -7037,19 +7773,23 @@ def make_script(self, dirname, basename, *, compiled=False):\n         return pyc_file\n \n     def make_zip_script(self, script_name, name_in_zip=None):\n-        zip_name, _ = script_helper.make_zip_script(self.dirname, 'test_zip',\n-                                                    script_name, name_in_zip)\n+        zip_name, _ = script_helper.make_zip_script(\n+            self.dirname, \"test_zip\", script_name, name_in_zip\n+        )\n         return zip_name\n \n     def check_usage(self, expected, *args, **kwargs):\n-        res = script_helper.assert_python_ok('-Xutf8', *args, '-h', **kwargs)\n-        self.assertEqual(os.fsdecode(res.out.splitlines()[0]),\n-                         f'usage: {expected} [-h]')\n+        res = script_helper.assert_python_ok(\"-Xutf8\", *args, \"-h\", **kwargs)\n+        self.assertEqual(\n+            os.fsdecode(res.out.splitlines()[0]), f\"usage: {expected} [-h]\"\n+        )\n \n     def test_script(self, compiled=False):\n         basename = os_helper.TESTFN\n-        script_name = self.make_script(self.dirname, basename, compiled=compiled)\n-        self.check_usage(os.path.basename(script_name), script_name, '-h')\n+        script_name = self.make_script(\n+            self.dirname, basename, compiled=compiled\n+        )\n+        self.check_usage(os.path.basename(script_name), script_name, \"-h\")\n \n     def test_script_compiled(self):\n         self.test_script(compiled=True)\n@@ -7057,62 +7797,73 @@ def test_script_compiled(self):\n     def test_directory(self, compiled=False):\n         dirname = os.path.join(self.dirname, os_helper.TESTFN)\n         os.mkdir(dirname)\n-        self.make_script(dirname, '__main__', compiled=compiled)\n-        self.check_usage(f'{py} {dirname}', dirname)\n+        self.make_script(dirname, \"__main__\", compiled=compiled)\n+        self.check_usage(f\"{py} {dirname}\", dirname)\n         dirname2 = os.path.join(os.curdir, dirname)\n-        self.check_usage(f'{py} {dirname2}', dirname2)\n+        self.check_usage(f\"{py} {dirname2}\", dirname2)\n \n     def test_directory_compiled(self):\n         self.test_directory(compiled=True)\n \n     def test_module(self, compiled=False):\n-        basename = 'module' + os_helper.FS_NONASCII\n-        modulename = f'{self.dirname}.{basename}'\n+        basename = \"module\" + os_helper.FS_NONASCII\n+        modulename = f\"{self.dirname}.{basename}\"\n         self.make_script(self.dirname, basename, compiled=compiled)\n-        self.check_usage(f'{py} -m {modulename}',\n-                         '-m', modulename, PYTHONPATH=os.curdir)\n+        self.check_usage(\n+            f\"{py} -m {modulename}\", \"-m\", modulename, PYTHONPATH=os.curdir\n+        )\n \n     def test_module_compiled(self):\n         self.test_module(compiled=True)\n \n     def test_package(self, compiled=False):\n-        basename = 'subpackage' + os_helper.FS_NONASCII\n-        packagename = f'{self.dirname}.{basename}'\n+        basename = \"subpackage\" + os_helper.FS_NONASCII\n+        packagename = f\"{self.dirname}.{basename}\"\n         subdirname = os.path.join(self.dirname, basename)\n         os.mkdir(subdirname)\n-        self.make_script(subdirname, '__main__', compiled=compiled)\n-        self.check_usage(f'{py} -m {packagename}',\n-                         '-m', packagename, PYTHONPATH=os.curdir)\n-        self.check_usage(f'{py} -m {packagename}',\n-                         '-m', packagename + '.__main__', PYTHONPATH=os.curdir)\n+        self.make_script(subdirname, \"__main__\", compiled=compiled)\n+        self.check_usage(\n+            f\"{py} -m {packagename}\", \"-m\", packagename, PYTHONPATH=os.curdir\n+        )\n+        self.check_usage(\n+            f\"{py} -m {packagename}\",\n+            \"-m\",\n+            packagename + \".__main__\",\n+            PYTHONPATH=os.curdir,\n+        )\n \n     def test_package_compiled(self):\n         self.test_package(compiled=True)\n \n     def test_zipfile(self, compiled=False):\n-        script_name = self.make_script(self.dirname, '__main__', compiled=compiled)\n+        script_name = self.make_script(\n+            self.dirname, \"__main__\", compiled=compiled\n+        )\n         zip_name = self.make_zip_script(script_name)\n-        self.check_usage(f'{py} {zip_name}', zip_name)\n+        self.check_usage(f\"{py} {zip_name}\", zip_name)\n \n     def test_zipfile_compiled(self):\n         self.test_zipfile(compiled=True)\n \n     def test_directory_in_zipfile(self, compiled=False):\n-        script_name = self.make_script(self.dirname, '__main__', compiled=compiled)\n-        name_in_zip = 'package/subpackage/__main__' + ('.py', '.pyc')[compiled]\n+        script_name = self.make_script(\n+            self.dirname, \"__main__\", compiled=compiled\n+        )\n+        name_in_zip = \"package/subpackage/__main__\" + (\".py\", \".pyc\")[compiled]\n         zip_name = self.make_zip_script(script_name, name_in_zip)\n-        dirname = os.path.join(zip_name, 'package', 'subpackage')\n-        self.check_usage(f'{py} {dirname}', dirname)\n+        dirname = os.path.join(zip_name, \"package\", \"subpackage\")\n+        self.check_usage(f\"{py} {dirname}\", dirname)\n \n     def test_directory_in_zipfile_compiled(self):\n         self.test_directory_in_zipfile(compiled=True)\n \n+\n # =================\n # Translation tests\n # =================\n \n-class TestTranslations(TestTranslationsBase):\n \n+class TestTranslations(TestTranslationsBase):\n     def test_translations(self):\n         self.assertMsgidsEqual(argparse)\n \n@@ -7292,8 +8043,8 @@ def custom_formatter(prog):\n             formatter_class=custom_formatter,\n             color=True,\n         )\n-        parser.add_argument('+f', '++foo', help=\"foo help\")\n-        parser.add_argument('spam', help=\"spam help\")\n+        parser.add_argument(\"+f\", \"++foo\", help=\"foo help\")\n+        parser.add_argument(\"spam\", help=\"spam help\")\n \n         prog = self.theme.prog\n         heading = self.theme.heading\n@@ -7307,7 +8058,9 @@ def custom_formatter(prog):\n         reset = self.theme.reset\n \n         parser_help = parser.format_help()\n-        self.assertEqual(parser_help, textwrap.dedent(f'''\\\n+        self.assertEqual(\n+            parser_help,\n+            textwrap.dedent(f\"\"\"\\\n             {heading}usage: {reset}{prog}PROG{reset} [{short}-h{reset}] [{short}+f {label}FOO{reset}] {pos}spam{reset}\n \n             {heading}positional arguments:{reset}\n@@ -7316,7 +8069,8 @@ def custom_formatter(prog):\n             {heading}options:{reset}\n                  {short_b}-h{reset}, {long_b}--help{reset}         show this help message and exit\n                  {short_b}+f{reset}, {long_b}++foo{reset} {label_b}FOO{reset}      foo help\n-        '''))\n+        \"\"\"),\n+        )\n \n     def test_custom_formatter_class(self):\n         class CustomFormatter(argparse.RawTextHelpFormatter):\n@@ -7329,8 +8083,8 @@ def __init__(self, prog):\n             formatter_class=CustomFormatter,\n             color=True,\n         )\n-        parser.add_argument('+f', '++foo', help=\"foo help\")\n-        parser.add_argument('spam', help=\"spam help\")\n+        parser.add_argument(\"+f\", \"++foo\", help=\"foo help\")\n+        parser.add_argument(\"spam\", help=\"spam help\")\n \n         prog = self.theme.prog\n         heading = self.theme.heading\n@@ -7344,7 +8098,9 @@ def __init__(self, prog):\n         reset = self.theme.reset\n \n         parser_help = parser.format_help()\n-        self.assertEqual(parser_help, textwrap.dedent(f'''\\\n+        self.assertEqual(\n+            parser_help,\n+            textwrap.dedent(f\"\"\"\\\n             {heading}usage: {reset}{prog}PROG{reset} [{short}-h{reset}] [{short}+f {label}FOO{reset}] {pos}spam{reset}\n \n             {heading}positional arguments:{reset}\n@@ -7353,7 +8109,8 @@ def __init__(self, prog):\n             {heading}options:{reset}\n                  {short_b}-h{reset}, {long_b}--help{reset}         show this help message and exit\n                  {short_b}+f{reset}, {long_b}++foo{reset} {label_b}FOO{reset}      foo help\n-        '''))\n+        \"\"\"),\n+        )\n \n \n def tearDownModule():\n@@ -7362,9 +8119,9 @@ def tearDownModule():\n     WFile.seen = set()\n \n \n-if __name__ == '__main__':\n+if __name__ == \"__main__\":\n     # To regenerate translation snapshots\n-    if len(sys.argv) > 1 and sys.argv[1] == '--snapshot-update':\n+    if len(sys.argv) > 1 and sys.argv[1] == \"--snapshot-update\":\n         update_translation_snapshots(argparse)\n         sys.exit(0)\n     unittest.main()\ndiff --git a/Lib/test/test_asyncio/test_subprocess.py b/Lib/test/test_asyncio/test_subprocess.py\nindex 3a17c169..46998171 100644\n--- a/Lib/test/test_asyncio/test_subprocess.py\n+++ b/Lib/test/test_asyncio/test_subprocess.py\n@@ -26,14 +26,20 @@\n     raise unittest.SkipTest(\"Exposes ASAN flakiness in GitHub CI\")\n \n # Program blocking\n-PROGRAM_BLOCKED = [sys.executable, '-c', 'import time; time.sleep(3600)']\n+PROGRAM_BLOCKED = [sys.executable, \"-c\", \"import time; time.sleep(3600)\"]\n \n # Program copying input to output\n PROGRAM_CAT = [\n-    sys.executable, '-c',\n-    ';'.join(('import sys',\n-              'data = sys.stdin.buffer.read()',\n-              'sys.stdout.buffer.write(data)'))]\n+    sys.executable,\n+    \"-c\",\n+    \";\".join(\n+        (\n+            \"import sys\",\n+            \"data = sys.stdin.buffer.read()\",\n+            \"sys.stdout.buffer.write(data)\",\n+        )\n+    ),\n+]\n \n \n def tearDownModule():\n@@ -58,8 +64,16 @@ def setUp(self):\n     def create_transport(self, waiter=None):\n         protocol = mock.Mock()\n         transport = TestSubprocessTransport(\n-                        self.loop, protocol, ['test'], False,\n-                        None, None, None, 0, waiter=waiter)\n+            self.loop,\n+            protocol,\n+            [\"test\"],\n+            False,\n+            None,\n+            None,\n+            None,\n+            0,\n+            waiter=waiter,\n+        )\n         return (transport, protocol)\n \n     def test_proc_exited(self):\n@@ -81,8 +95,9 @@ def test_proc_exited(self):\n         self.assertIsNone(transport._protocol)\n \n         # methods must raise ProcessLookupError if the process exited\n-        self.assertRaises(ProcessLookupError,\n-                          transport.send_signal, signal.SIGTERM)\n+        self.assertRaises(\n+            ProcessLookupError, transport.send_signal, signal.SIGTERM\n+        )\n         self.assertRaises(ProcessLookupError, transport.terminate)\n         self.assertRaises(ProcessLookupError, transport.kill)\n \n@@ -95,25 +110,21 @@ def test_subprocess_repr(self):\n         self.loop.run_until_complete(waiter)\n \n         self.assertEqual(\n-            repr(transport),\n-            \"<TestSubprocessTransport pid=-1 returncode=6>\"\n+            repr(transport), \"<TestSubprocessTransport pid=-1 returncode=6>\"\n         )\n         transport._returncode = None\n         self.assertEqual(\n-            repr(transport),\n-            \"<TestSubprocessTransport pid=-1 running>\"\n+            repr(transport), \"<TestSubprocessTransport pid=-1 running>\"\n         )\n         transport._pid = None\n         transport._returncode = None\n         self.assertEqual(\n-            repr(transport),\n-            \"<TestSubprocessTransport not started>\"\n+            repr(transport), \"<TestSubprocessTransport not started>\"\n         )\n         transport.close()\n \n \n class SubprocessMixin:\n-\n     def test_stdin_stdout(self):\n         args = PROGRAM_CAT\n \n@@ -134,11 +145,11 @@ async def run(data):\n             exitcode = await proc.wait()\n             return (exitcode, data)\n \n-        task = run(b'some data')\n+        task = run(b\"some data\")\n         task = asyncio.wait_for(task, 60.0)\n         exitcode, stdout = self.loop.run_until_complete(task)\n         self.assertEqual(exitcode, 0)\n-        self.assertEqual(stdout, b'some data')\n+        self.assertEqual(stdout, b\"some data\")\n \n     def test_communicate(self):\n         args = PROGRAM_CAT\n@@ -152,11 +163,11 @@ async def run(data):\n             stdout, stderr = await proc.communicate(data)\n             return proc.returncode, stdout\n \n-        task = run(b'some data')\n+        task = run(b\"some data\")\n         task = asyncio.wait_for(task, support.LONG_TIMEOUT)\n         exitcode, stdout = self.loop.run_until_complete(task)\n         self.assertEqual(exitcode, 0)\n-        self.assertEqual(stdout, b'some data')\n+        self.assertEqual(stdout, b\"some data\")\n \n     def test_communicate_none_input(self):\n         args = PROGRAM_CAT\n@@ -174,11 +185,11 @@ async def run():\n         task = asyncio.wait_for(task, support.LONG_TIMEOUT)\n         exitcode, stdout = self.loop.run_until_complete(task)\n         self.assertEqual(exitcode, 0)\n-        self.assertEqual(stdout, b'')\n+        self.assertEqual(stdout, b\"\")\n \n     def test_shell(self):\n         proc = self.loop.run_until_complete(\n-            asyncio.create_subprocess_shell('exit 7')\n+            asyncio.create_subprocess_shell(\"exit 7\")\n         )\n         exitcode = self.loop.run_until_complete(proc.wait())\n         self.assertEqual(exitcode, 7)\n@@ -187,7 +198,7 @@ def test_start_new_session(self):\n         # start the new process in a new session\n         proc = self.loop.run_until_complete(\n             asyncio.create_subprocess_shell(\n-                'exit 8',\n+                \"exit 8\",\n                 start_new_session=True,\n             )\n         )\n@@ -201,34 +212,40 @@ def test_kill(self):\n         )\n         proc.kill()\n         returncode = self.loop.run_until_complete(proc.wait())\n-        if sys.platform == 'win32':\n+        if sys.platform == \"win32\":\n             self.assertIsInstance(returncode, int)\n             # expect 1 but sometimes get 0\n         else:\n             self.assertEqual(-signal.SIGKILL, returncode)\n \n     def test_kill_issue43884(self):\n-        if sys.platform == 'win32':\n-            blocking_shell_command = f'\"{sys.executable}\" -c \"import time; time.sleep(2)\"'\n+        if sys.platform == \"win32\":\n+            blocking_shell_command = (\n+                f'\"{sys.executable}\" -c \"import time; time.sleep(2)\"'\n+            )\n         else:\n-            blocking_shell_command = 'sleep 1; sleep 1'\n+            blocking_shell_command = \"sleep 1; sleep 1\"\n         creationflags = 0\n-        if sys.platform == 'win32':\n+        if sys.platform == \"win32\":\n             from subprocess import CREATE_NEW_PROCESS_GROUP\n+\n             # On windows create a new process group so that killing process\n             # kills the process and all its children.\n             creationflags = CREATE_NEW_PROCESS_GROUP\n         proc = self.loop.run_until_complete(\n-            asyncio.create_subprocess_shell(blocking_shell_command, stdout=asyncio.subprocess.PIPE,\n-            creationflags=creationflags)\n+            asyncio.create_subprocess_shell(\n+                blocking_shell_command,\n+                stdout=asyncio.subprocess.PIPE,\n+                creationflags=creationflags,\n+            )\n         )\n         self.loop.run_until_complete(asyncio.sleep(1))\n-        if sys.platform == 'win32':\n+        if sys.platform == \"win32\":\n             proc.send_signal(signal.CTRL_BREAK_EVENT)\n         # On windows it is an alias of terminate which sets the return code\n         proc.kill()\n         returncode = self.loop.run_until_complete(proc.wait())\n-        if sys.platform == 'win32':\n+        if sys.platform == \"win32\":\n             self.assertIsInstance(returncode, int)\n             # expect 1 but sometimes get 0\n         else:\n@@ -241,21 +258,23 @@ def test_terminate(self):\n         )\n         proc.terminate()\n         returncode = self.loop.run_until_complete(proc.wait())\n-        if sys.platform == 'win32':\n+        if sys.platform == \"win32\":\n             self.assertIsInstance(returncode, int)\n             # expect 1 but sometimes get 0\n         else:\n             self.assertEqual(-signal.SIGTERM, returncode)\n \n-    @unittest.skipIf(sys.platform == 'win32', \"Don't have SIGHUP\")\n+    @unittest.skipIf(sys.platform == \"win32\", \"Don't have SIGHUP\")\n     def test_send_signal(self):\n         # bpo-31034: Make sure that we get the default signal handler (killing\n         # the process). The parent process may have decided to ignore SIGHUP,\n         # and signal handlers are inherited.\n         old_handler = signal.signal(signal.SIGHUP, signal.SIG_DFL)\n         try:\n-            code = 'import time; print(\"sleeping\", flush=True); time.sleep(3600)'\n-            args = [sys.executable, '-c', code]\n+            code = (\n+                'import time; print(\"sleeping\", flush=True); time.sleep(3600)'\n+            )\n+            args = [sys.executable, \"-c\", code]\n             proc = self.loop.run_until_complete(\n                 asyncio.create_subprocess_exec(\n                     *args,\n@@ -266,7 +285,7 @@ def test_send_signal(self):\n             async def send_signal(proc):\n                 # basic synchronization to wait until the program is sleeping\n                 line = await proc.stdout.readline()\n-                self.assertEqual(line, b'sleeping\\n')\n+                self.assertEqual(line, b\"sleeping\\n\")\n \n                 proc.send_signal(signal.SIGHUP)\n                 returncode = await proc.wait()\n@@ -279,7 +298,7 @@ async def send_signal(proc):\n \n     def test_stdin_broken_pipe(self):\n         # buffer large enough to feed the whole pipe buffer\n-        large_data = b'x' * support.PIPE_MAX_SIZE\n+        large_data = b\"x\" * support.PIPE_MAX_SIZE\n \n         rfd, wfd = os.pipe()\n         self.addCleanup(os.close, rfd)\n@@ -287,50 +306,54 @@ def test_stdin_broken_pipe(self):\n         if support.MS_WINDOWS:\n             handle = msvcrt.get_osfhandle(rfd)\n             os.set_handle_inheritable(handle, True)\n-            code = textwrap.dedent(f'''\n+            code = textwrap.dedent(f\"\"\"\n                 import os, msvcrt\n                 handle = {handle}\n                 fd = msvcrt.open_osfhandle(handle, os.O_RDONLY)\n                 os.read(fd, 1)\n-            ''')\n+            \"\"\")\n             from subprocess import STARTUPINFO\n+\n             startupinfo = STARTUPINFO()\n             startupinfo.lpAttributeList = {\"handle_list\": [handle]}\n             kwargs = dict(startupinfo=startupinfo)\n         else:\n-            code = f'import os; fd = {rfd}; os.read(fd, 1)'\n+            code = f\"import os; fd = {rfd}; os.read(fd, 1)\"\n             kwargs = dict(pass_fds=(rfd,))\n \n         # the program ends before the stdin can be fed\n         proc = self.loop.run_until_complete(\n             asyncio.create_subprocess_exec(\n-                sys.executable, '-c', code,\n-                stdin=subprocess.PIPE,\n-                **kwargs\n+                sys.executable, \"-c\", code, stdin=subprocess.PIPE, **kwargs\n             )\n         )\n \n         async def write_stdin(proc, data):\n             proc.stdin.write(data)\n             # Only exit the child process once the write buffer is filled\n-            os.write(wfd, b'go')\n+            os.write(wfd, b\"go\")\n             await proc.stdin.drain()\n \n         coro = write_stdin(proc, large_data)\n         # drain() must raise BrokenPipeError or ConnectionResetError\n         with test_utils.disable_logger():\n-            self.assertRaises((BrokenPipeError, ConnectionResetError),\n-                              self.loop.run_until_complete, coro)\n+            self.assertRaises(\n+                (BrokenPipeError, ConnectionResetError),\n+                self.loop.run_until_complete,\n+                coro,\n+            )\n         self.loop.run_until_complete(proc.wait())\n \n     def test_communicate_ignore_broken_pipe(self):\n         # buffer large enough to feed the whole pipe buffer\n-        large_data = b'x' * support.PIPE_MAX_SIZE\n+        large_data = b\"x\" * support.PIPE_MAX_SIZE\n \n         # the program ends before the stdin can be fed\n         proc = self.loop.run_until_complete(\n             asyncio.create_subprocess_exec(\n-                sys.executable, '-c', 'pass',\n+                sys.executable,\n+                \"-c\",\n+                \"pass\",\n                 stdin=subprocess.PIPE,\n             )\n         )\n@@ -342,14 +365,16 @@ def test_communicate_ignore_broken_pipe(self):\n \n     def test_pause_reading(self):\n         limit = 10\n-        size = (limit * 2 + 1)\n+        size = limit * 2 + 1\n \n         async def test_pause_reading():\n-            code = '\\n'.join((\n-                'import sys',\n-                'sys.stdout.write(\"x\" * %s)' % size,\n-                'sys.stdout.flush()',\n-            ))\n+            code = \"\\n\".join(\n+                (\n+                    \"import sys\",\n+                    'sys.stdout.write(\"x\" * %s)' % size,\n+                    \"sys.stdout.flush()\",\n+                )\n+            )\n \n             connect_read_pipe = self.loop.connect_read_pipe\n \n@@ -362,7 +387,9 @@ async def connect_read_pipe_mock(*args, **kw):\n             self.loop.connect_read_pipe = connect_read_pipe_mock\n \n             proc = await asyncio.create_subprocess_exec(\n-                sys.executable, '-c', code,\n+                sys.executable,\n+                \"-c\",\n+                code,\n                 stdin=asyncio.subprocess.PIPE,\n                 stdout=asyncio.subprocess.PIPE,\n                 limit=limit,\n@@ -380,7 +407,7 @@ async def connect_read_pipe_mock(*args, **kw):\n         # when the child process produces too much data\n         stdout, transport = self.loop.run_until_complete(test_pause_reading())\n \n-        self.assertEqual(stdout, b'x' * size)\n+        self.assertEqual(stdout, b\"x\" * size)\n         self.assertTrue(transport.pause_reading.called)\n         self.assertTrue(transport.resume_reading.called)\n \n@@ -388,9 +415,11 @@ def test_stdin_not_inheritable(self):\n         # asyncio issue #209: stdin must not be inheritable, otherwise\n         # the Process.communicate() hangs\n         async def len_message(message):\n-            code = 'import sys; data = sys.stdin.read(); print(len(data))'\n+            code = \"import sys; data = sys.stdin.read(); print(len(data))\"\n             proc = await asyncio.create_subprocess_exec(\n-                sys.executable, '-c', code,\n+                sys.executable,\n+                \"-c\",\n+                code,\n                 stdin=asyncio.subprocess.PIPE,\n                 stdout=asyncio.subprocess.PIPE,\n                 stderr=asyncio.subprocess.PIPE,\n@@ -400,35 +429,37 @@ async def len_message(message):\n             exitcode = await proc.wait()\n             return (stdout, exitcode)\n \n-        output, exitcode = self.loop.run_until_complete(len_message(b'abc'))\n-        self.assertEqual(output.rstrip(), b'3')\n+        output, exitcode = self.loop.run_until_complete(len_message(b\"abc\"))\n+        self.assertEqual(output.rstrip(), b\"3\")\n         self.assertEqual(exitcode, 0)\n \n     def test_empty_input(self):\n-\n         async def empty_input():\n-            code = 'import sys; data = sys.stdin.read(); print(len(data))'\n+            code = \"import sys; data = sys.stdin.read(); print(len(data))\"\n             proc = await asyncio.create_subprocess_exec(\n-                sys.executable, '-c', code,\n+                sys.executable,\n+                \"-c\",\n+                code,\n                 stdin=asyncio.subprocess.PIPE,\n                 stdout=asyncio.subprocess.PIPE,\n                 stderr=asyncio.subprocess.PIPE,\n                 close_fds=False,\n             )\n-            stdout, stderr = await proc.communicate(b'')\n+            stdout, stderr = await proc.communicate(b\"\")\n             exitcode = await proc.wait()\n             return (stdout, exitcode)\n \n         output, exitcode = self.loop.run_until_complete(empty_input())\n-        self.assertEqual(output.rstrip(), b'0')\n+        self.assertEqual(output.rstrip(), b\"0\")\n         self.assertEqual(exitcode, 0)\n \n     def test_devnull_input(self):\n-\n         async def empty_input():\n-            code = 'import sys; data = sys.stdin.read(); print(len(data))'\n+            code = \"import sys; data = sys.stdin.read(); print(len(data))\"\n             proc = await asyncio.create_subprocess_exec(\n-                sys.executable, '-c', code,\n+                sys.executable,\n+                \"-c\",\n+                code,\n                 stdin=asyncio.subprocess.DEVNULL,\n                 stdout=asyncio.subprocess.PIPE,\n                 stderr=asyncio.subprocess.PIPE,\n@@ -439,15 +470,16 @@ async def empty_input():\n             return (stdout, exitcode)\n \n         output, exitcode = self.loop.run_until_complete(empty_input())\n-        self.assertEqual(output.rstrip(), b'0')\n+        self.assertEqual(output.rstrip(), b\"0\")\n         self.assertEqual(exitcode, 0)\n \n     def test_devnull_output(self):\n-\n         async def empty_output():\n-            code = 'import sys; data = sys.stdin.read(); print(len(data))'\n+            code = \"import sys; data = sys.stdin.read(); print(len(data))\"\n             proc = await asyncio.create_subprocess_exec(\n-                sys.executable, '-c', code,\n+                sys.executable,\n+                \"-c\",\n+                code,\n                 stdin=asyncio.subprocess.PIPE,\n                 stdout=asyncio.subprocess.DEVNULL,\n                 stderr=asyncio.subprocess.PIPE,\n@@ -462,11 +494,12 @@ async def empty_output():\n         self.assertEqual(exitcode, 0)\n \n     def test_devnull_error(self):\n-\n         async def empty_error():\n-            code = 'import sys; data = sys.stdin.read(); print(len(data))'\n+            code = \"import sys; data = sys.stdin.read(); print(len(data))\"\n             proc = await asyncio.create_subprocess_exec(\n-                sys.executable, '-c', code,\n+                sys.executable,\n+                \"-c\",\n+                code,\n                 stdin=asyncio.subprocess.PIPE,\n                 stdout=asyncio.subprocess.PIPE,\n                 stderr=asyncio.subprocess.DEVNULL,\n@@ -480,14 +513,16 @@ async def empty_error():\n         self.assertEqual(output, None)\n         self.assertEqual(exitcode, 0)\n \n-    @unittest.skipIf(sys.platform not in ('linux', 'android'),\n-                     \"Don't have /dev/stdin\")\n+    @unittest.skipIf(\n+        sys.platform not in (\"linux\", \"android\"), \"Don't have /dev/stdin\"\n+    )\n     def test_devstdin_input(self):\n-\n         async def devstdin_input(message):\n             code = 'file = open(\"/dev/stdin\"); data = file.read(); print(len(data))'\n             proc = await asyncio.create_subprocess_exec(\n-                sys.executable, '-c', code,\n+                sys.executable,\n+                \"-c\",\n+                code,\n                 stdin=asyncio.subprocess.PIPE,\n                 stdout=asyncio.subprocess.PIPE,\n                 stderr=asyncio.subprocess.PIPE,\n@@ -497,8 +532,8 @@ async def devstdin_input(message):\n             exitcode = await proc.wait()\n             return (stdout, exitcode)\n \n-        output, exitcode = self.loop.run_until_complete(devstdin_input(b'abc'))\n-        self.assertEqual(output.rstrip(), b'3')\n+        output, exitcode = self.loop.run_until_complete(devstdin_input(b\"abc\"))\n+        self.assertEqual(output.rstrip(), b\"3\")\n         self.assertEqual(exitcode, 0)\n \n     def test_cancel_process_wait(self):\n@@ -525,7 +560,6 @@ async def cancel_wait():\n         self.loop.run_until_complete(cancel_wait())\n \n     def test_cancel_make_subprocess_transport_exec(self):\n-\n         async def cancel_make_transport():\n             coro = asyncio.create_subprocess_exec(*PROGRAM_BLOCKED)\n             task = self.loop.create_task(coro)\n@@ -542,10 +576,10 @@ async def cancel_make_transport():\n             self.loop.run_until_complete(cancel_make_transport())\n \n     def test_cancel_post_init(self):\n-\n         async def cancel_make_transport():\n-            coro = self.loop.subprocess_exec(asyncio.SubprocessProtocol,\n-                                             *PROGRAM_BLOCKED)\n+            coro = self.loop.subprocess_exec(\n+                asyncio.SubprocessProtocol, *PROGRAM_BLOCKED\n+            )\n             task = self.loop.create_task(coro)\n \n             self.loop.call_soon(task.cancel)\n@@ -561,19 +595,20 @@ async def cancel_make_transport():\n             test_utils.run_briefly(self.loop)\n \n     def test_close_kill_running(self):\n-\n         async def kill_running():\n-            create = self.loop.subprocess_exec(asyncio.SubprocessProtocol,\n-                                               *PROGRAM_BLOCKED)\n+            create = self.loop.subprocess_exec(\n+                asyncio.SubprocessProtocol, *PROGRAM_BLOCKED\n+            )\n             transport, protocol = await create\n \n             kill_called = False\n+\n             def kill():\n                 nonlocal kill_called\n                 kill_called = True\n                 orig_kill()\n \n-            proc = transport.get_extra_info('subprocess')\n+            proc = transport.get_extra_info(\"subprocess\")\n             orig_kill = proc.kill\n             proc.kill = kill\n             returncode = transport.get_returncode()\n@@ -598,12 +633,12 @@ def kill():\n         test_utils.run_briefly(self.loop)\n \n     def test_close_dont_kill_finished(self):\n-\n         async def kill_running():\n-            create = self.loop.subprocess_exec(asyncio.SubprocessProtocol,\n-                                               *PROGRAM_BLOCKED)\n+            create = self.loop.subprocess_exec(\n+                asyncio.SubprocessProtocol, *PROGRAM_BLOCKED\n+            )\n             transport, protocol = await create\n-            proc = transport.get_extra_info('subprocess')\n+            proc = transport.get_extra_info(\"subprocess\")\n \n             # kill the process (but asyncio is not notified immediately)\n             proc.kill()\n@@ -632,10 +667,10 @@ async def kill_running():\n         self.assertFalse(killed)\n \n     async def _test_popen_error(self, stdin):\n-        if sys.platform == 'win32':\n-            target = 'asyncio.windows_utils.Popen'\n+        if sys.platform == \"win32\":\n+            target = \"asyncio.windows_utils.Popen\"\n         else:\n-            target = 'subprocess.Popen'\n+            target = \"subprocess.Popen\"\n         with mock.patch(target) as popen:\n             exc = ZeroDivisionError\n             popen.side_effect = exc\n@@ -643,10 +678,7 @@ async def _test_popen_error(self, stdin):\n             with warnings.catch_warnings(record=True) as warns:\n                 with self.assertRaises(exc):\n                     await asyncio.create_subprocess_exec(\n-                        sys.executable,\n-                        '-c',\n-                        'pass',\n-                        stdin=stdin\n+                        sys.executable, \"-c\", \"pass\", stdin=stdin\n                     )\n                 self.assertEqual(warns, [])\n \n@@ -659,19 +691,25 @@ def test_popen_error_with_stdin_pipe(self):\n         # Issue #35721: check that newly created socket pair is closed when\n         # Popen fails\n         self.loop.run_until_complete(\n-            self._test_popen_error(stdin=subprocess.PIPE))\n+            self._test_popen_error(stdin=subprocess.PIPE)\n+        )\n \n     def test_read_stdout_after_process_exit(self):\n-\n         async def execute():\n-            code = '\\n'.join(['import sys',\n-                              'for _ in range(64):',\n-                              '    sys.stdout.write(\"x\" * 4096)',\n-                              'sys.stdout.flush()',\n-                              'sys.exit(1)'])\n+            code = \"\\n\".join(\n+                [\n+                    \"import sys\",\n+                    \"for _ in range(64):\",\n+                    '    sys.stdout.write(\"x\" * 4096)',\n+                    \"sys.stdout.flush()\",\n+                    \"sys.exit(1)\",\n+                ]\n+            )\n \n             process = await asyncio.create_subprocess_exec(\n-                sys.executable, '-c', code,\n+                sys.executable,\n+                \"-c\",\n+                code,\n                 stdout=asyncio.subprocess.PIPE,\n             )\n \n@@ -687,43 +725,50 @@ async def execute():\n     def test_create_subprocess_exec_text_mode_fails(self):\n         async def execute():\n             with self.assertRaises(ValueError):\n-                await subprocess.create_subprocess_exec(sys.executable,\n-                                                        text=True)\n+                await subprocess.create_subprocess_exec(\n+                    sys.executable, text=True\n+                )\n \n             with self.assertRaises(ValueError):\n-                await subprocess.create_subprocess_exec(sys.executable,\n-                                                        encoding=\"utf-8\")\n+                await subprocess.create_subprocess_exec(\n+                    sys.executable, encoding=\"utf-8\"\n+                )\n \n             with self.assertRaises(ValueError):\n-                await subprocess.create_subprocess_exec(sys.executable,\n-                                                        errors=\"strict\")\n+                await subprocess.create_subprocess_exec(\n+                    sys.executable, errors=\"strict\"\n+                )\n \n         self.loop.run_until_complete(execute())\n \n     def test_create_subprocess_shell_text_mode_fails(self):\n-\n         async def execute():\n             with self.assertRaises(ValueError):\n-                await subprocess.create_subprocess_shell(sys.executable,\n-                                                         text=True)\n+                await subprocess.create_subprocess_shell(\n+                    sys.executable, text=True\n+                )\n \n             with self.assertRaises(ValueError):\n-                await subprocess.create_subprocess_shell(sys.executable,\n-                                                         encoding=\"utf-8\")\n+                await subprocess.create_subprocess_shell(\n+                    sys.executable, encoding=\"utf-8\"\n+                )\n \n             with self.assertRaises(ValueError):\n-                await subprocess.create_subprocess_shell(sys.executable,\n-                                                         errors=\"strict\")\n+                await subprocess.create_subprocess_shell(\n+                    sys.executable, errors=\"strict\"\n+                )\n \n         self.loop.run_until_complete(execute())\n \n     def test_create_subprocess_exec_with_path(self):\n         async def execute():\n             p = await subprocess.create_subprocess_exec(\n-                os_helper.FakePath(sys.executable), '-c', 'pass')\n+                os_helper.FakePath(sys.executable), \"-c\", \"pass\"\n+            )\n             await p.wait()\n             p = await subprocess.create_subprocess_exec(\n-                sys.executable, '-c', 'pass', os_helper.FakePath('.'))\n+                sys.executable, \"-c\", \"pass\", os_helper.FakePath(\".\")\n+            )\n             await p.wait()\n \n         self.assertIsNone(self.loop.run_until_complete(execute()))\n@@ -750,12 +795,15 @@ async def main() -> None:\n             )\n             return proc\n \n-        self.loop.run_until_complete(self.check_stdout_output(main(), b'bar'))\n+        self.loop.run_until_complete(self.check_stdout_output(main(), b\"bar\"))\n \n     def test_create_subprocess_env_exec(self) -> None:\n         async def main() -> None:\n-            cmd = [sys.executable, \"-c\",\n-                   \"import os, sys; sys.stdout.write(os.getenv('FOO'))\"]\n+            cmd = [\n+                sys.executable,\n+                \"-c\",\n+                \"import os, sys; sys.stdout.write(os.getenv('FOO'))\",\n+            ]\n             env = os.environ.copy()\n             env[\"FOO\"] = \"baz\"\n             proc = await asyncio.create_subprocess_exec(\n@@ -763,8 +811,7 @@ async def main() -> None:\n             )\n             return proc\n \n-        self.loop.run_until_complete(self.check_stdout_output(main(), b'baz'))\n-\n+        self.loop.run_until_complete(self.check_stdout_output(main(), b\"baz\"))\n \n     def test_subprocess_concurrent_wait(self) -> None:\n         async def main() -> None:\n@@ -773,11 +820,13 @@ async def main() -> None:\n                 stdin=subprocess.PIPE,\n                 stdout=subprocess.PIPE,\n             )\n-            stdout, _ = await proc.communicate(b'some data')\n+            stdout, _ = await proc.communicate(b\"some data\")\n             self.assertEqual(stdout, b\"some data\")\n             self.assertEqual(proc.returncode, 0)\n-            self.assertEqual(await asyncio.gather(*[proc.wait() for _ in range(10)]),\n-                             [proc.returncode] * 10)\n+            self.assertEqual(\n+                await asyncio.gather(*[proc.wait() for _ in range(10)]),\n+                [proc.returncode] * 10,\n+            )\n \n         self.loop.run_until_complete(main())\n \n@@ -788,15 +837,15 @@ def test_subprocess_protocol_events(self):\n         events = []\n         fds = [1, 2]\n         expected = [\n-            ('pipe_data_received', 1, b'stdout'),\n-            ('pipe_data_received', 2, b'stderr'),\n-            ('pipe_connection_lost', 1),\n-            ('pipe_connection_lost', 2),\n-            'process_exited',\n+            (\"pipe_data_received\", 1, b\"stdout\"),\n+            (\"pipe_data_received\", 2, b\"stderr\"),\n+            (\"pipe_connection_lost\", 1),\n+            (\"pipe_connection_lost\", 2),\n+            \"process_exited\",\n         ]\n         per_fd_expected = [\n-            'pipe_data_received',\n-            'pipe_connection_lost',\n+            \"pipe_data_received\",\n+            \"pipe_connection_lost\",\n         ]\n \n         class MyProtocol(asyncio.SubprocessProtocol):\n@@ -804,15 +853,15 @@ def __init__(self, exit_future: asyncio.Future) -> None:\n                 self.exit_future = exit_future\n \n             def pipe_data_received(self, fd, data) -> None:\n-                events.append(('pipe_data_received', fd, data))\n+                events.append((\"pipe_data_received\", fd, data))\n                 self.exit_maybe()\n \n             def pipe_connection_lost(self, fd, exc) -> None:\n-                events.append(('pipe_connection_lost', fd))\n+                events.append((\"pipe_connection_lost\", fd))\n                 self.exit_maybe()\n \n             def process_exited(self) -> None:\n-                events.append('process_exited')\n+                events.append(\"process_exited\")\n                 self.exit_maybe()\n \n             def exit_maybe(self):\n@@ -824,8 +873,13 @@ async def main() -> None:\n             loop = asyncio.get_running_loop()\n             exit_future = asyncio.Future()\n             code = 'import sys; sys.stdout.write(\"stdout\"); sys.stderr.write(\"stderr\")'\n-            transport, _ = await loop.subprocess_exec(lambda: MyProtocol(exit_future),\n-                                                      sys.executable, '-c', code, stdin=None)\n+            transport, _ = await loop.subprocess_exec(\n+                lambda: MyProtocol(exit_future),\n+                sys.executable,\n+                \"-c\",\n+                code,\n+                stdin=None,\n+            )\n             await exit_future\n             transport.close()\n \n@@ -839,7 +893,7 @@ async def main() -> None:\n         # Second, check order of pipe events per file descriptor\n         per_fd_events = {fd: [] for fd in fds}\n         for event in events:\n-            if event == 'process_exited':\n+            if event == \"process_exited\":\n                 continue\n             name, fd = event[:2]\n             per_fd_events[fd].append(name)\n@@ -851,25 +905,31 @@ def test_subprocess_communicate_stdout(self):\n         # See https://github.com/python/cpython/issues/100133\n         async def get_command_stdout(cmd, *args):\n             proc = await asyncio.create_subprocess_exec(\n-                cmd, *args, stdout=asyncio.subprocess.PIPE,\n+                cmd,\n+                *args,\n+                stdout=asyncio.subprocess.PIPE,\n             )\n             stdout, _ = await proc.communicate()\n             return stdout.decode().strip()\n \n         async def main():\n-            outputs = [f'foo{i}' for i in range(10)]\n-            res = await asyncio.gather(*[get_command_stdout(sys.executable, '-c',\n-                                        f'print({out!r})') for out in outputs])\n+            outputs = [f\"foo{i}\" for i in range(10)]\n+            res = await asyncio.gather(\n+                *[\n+                    get_command_stdout(sys.executable, \"-c\", f\"print({out!r})\")\n+                    for out in outputs\n+                ]\n+            )\n             self.assertEqual(res, outputs)\n \n         self.loop.run_until_complete(main())\n \n-    @unittest.skipIf(sys.platform != 'linux', \"Linux only\")\n+    @unittest.skipIf(sys.platform != \"linux\", \"Linux only\")\n     def test_subprocess_send_signal_race(self):\n         # See https://github.com/python/cpython/issues/87744\n         async def main():\n             for _ in range(10):\n-                proc = await asyncio.create_subprocess_exec('sleep', '0.1')\n+                proc = await asyncio.create_subprocess_exec(\"sleep\", \"0.1\")\n                 await asyncio.sleep(0.1)\n                 try:\n                     proc.send_signal(signal.SIGUSR1)\n@@ -880,10 +940,9 @@ async def main():\n         self.loop.run_until_complete(main())\n \n \n-if sys.platform != 'win32':\n+if sys.platform != \"win32\":\n     # Unix\n     class SubprocessWatcherMixin(SubprocessMixin):\n-\n         def setUp(self):\n             super().setUp()\n             self.loop = asyncio.new_event_loop()\n@@ -895,11 +954,13 @@ def test_watcher_implementation(self):\n             if unix_events.can_use_pidfd():\n                 self.assertIsInstance(watcher, unix_events._PidfdChildWatcher)\n             else:\n-                self.assertIsInstance(watcher, unix_events._ThreadedChildWatcher)\n-\n+                self.assertIsInstance(\n+                    watcher, unix_events._ThreadedChildWatcher\n+                )\n \n-    class SubprocessThreadedWatcherTests(SubprocessWatcherMixin,\n-                                         test_utils.TestCase):\n+    class SubprocessThreadedWatcherTests(\n+        SubprocessWatcherMixin, test_utils.TestCase\n+    ):\n         def setUp(self):\n             self._original_can_use_pidfd = unix_events.can_use_pidfd\n             # Force the use of the threaded child watcher\n@@ -914,20 +975,19 @@ def tearDown(self):\n         unix_events.can_use_pidfd(),\n         \"operating system does not support pidfds\",\n     )\n-    class SubprocessPidfdWatcherTests(SubprocessWatcherMixin,\n-                                      test_utils.TestCase):\n-\n+    class SubprocessPidfdWatcherTests(\n+        SubprocessWatcherMixin, test_utils.TestCase\n+    ):\n         pass\n \n else:\n     # Windows\n     class SubprocessProactorTests(SubprocessMixin, test_utils.TestCase):\n-\n         def setUp(self):\n             super().setUp()\n             self.loop = asyncio.ProactorEventLoop()\n             self.set_event_loop(self.loop)\n \n \n-if __name__ == '__main__':\n+if __name__ == \"__main__\":\n     unittest.main()\ndiff --git a/Lib/test/test_code_module.py b/Lib/test/test_code_module.py\nindex 3642b47c..4321157c 100644\n--- a/Lib/test/test_code_module.py\n+++ b/Lib/test/test_code_module.py\n@@ -1,4 +1,5 @@\n \"Test InteractiveConsole and InteractiveInterpreter from code module\"\n+\n import sys\n import traceback\n import unittest\n@@ -8,21 +9,21 @@\n from test.support import force_not_colorized_test_class\n from test.support import import_helper\n \n-code = import_helper.import_module('code')\n+code = import_helper.import_module(\"code\")\n \n \n class MockSys:\n-\n     def mock_sys(self):\n         \"Mock system environment for InteractiveConsole\"\n         # use exit stack to match patch context managers to addCleanup\n         stack = ExitStack()\n         self.addCleanup(stack.close)\n-        self.infunc = stack.enter_context(mock.patch('code.input',\n-                                          create=True))\n-        self.stdout = stack.enter_context(mock.patch('code.sys.stdout'))\n-        self.stderr = stack.enter_context(mock.patch('code.sys.stderr'))\n-        prepatch = mock.patch('code.sys', wraps=code.sys, spec=code.sys)\n+        self.infunc = stack.enter_context(\n+            mock.patch(\"code.input\", create=True)\n+        )\n+        self.stdout = stack.enter_context(mock.patch(\"code.sys.stdout\"))\n+        self.stderr = stack.enter_context(mock.patch(\"code.sys.stderr\"))\n+        prepatch = mock.patch(\"code.sys\", wraps=code.sys, spec=code.sys)\n         self.sysmod = stack.enter_context(prepatch)\n         if sys.excepthook is sys.__excepthook__:\n             self.sysmod.excepthook = self.sysmod.__excepthook__\n@@ -42,69 +43,75 @@ def test_ps1(self):\n         self.infunc.side_effect = [\n             \"import code\",\n             \"code.sys.ps1\",\n-            EOFError('Finished')\n+            EOFError(\"Finished\"),\n         ]\n         self.console.interact()\n-        output = ''.join(''.join(call[1]) for call in self.stdout.method_calls)\n-        self.assertIn('>>> ', output)\n-        self.assertNotHasAttr(self.sysmod, 'ps1')\n+        output = \"\".join(\"\".join(call[1]) for call in self.stdout.method_calls)\n+        self.assertIn(\">>> \", output)\n+        self.assertNotHasAttr(self.sysmod, \"ps1\")\n \n         self.infunc.side_effect = [\n             \"import code\",\n             \"code.sys.ps1\",\n-            EOFError('Finished')\n+            EOFError(\"Finished\"),\n         ]\n-        self.sysmod.ps1 = 'custom1> '\n+        self.sysmod.ps1 = \"custom1> \"\n         self.console.interact()\n-        output = ''.join(''.join(call[1]) for call in self.stdout.method_calls)\n-        self.assertIn('custom1> ', output)\n-        self.assertEqual(self.sysmod.ps1, 'custom1> ')\n+        output = \"\".join(\"\".join(call[1]) for call in self.stdout.method_calls)\n+        self.assertIn(\"custom1> \", output)\n+        self.assertEqual(self.sysmod.ps1, \"custom1> \")\n \n     def test_ps2(self):\n         self.infunc.side_effect = [\n             \"import code\",\n             \"code.sys.ps2\",\n-            EOFError('Finished')\n+            EOFError(\"Finished\"),\n         ]\n         self.console.interact()\n-        output = ''.join(''.join(call[1]) for call in self.stdout.method_calls)\n-        self.assertIn('... ', output)\n-        self.assertNotHasAttr(self.sysmod, 'ps2')\n+        output = \"\".join(\"\".join(call[1]) for call in self.stdout.method_calls)\n+        self.assertIn(\"... \", output)\n+        self.assertNotHasAttr(self.sysmod, \"ps2\")\n \n         self.infunc.side_effect = [\n             \"import code\",\n             \"code.sys.ps2\",\n-            EOFError('Finished')\n+            EOFError(\"Finished\"),\n         ]\n-        self.sysmod.ps2 = 'custom2> '\n+        self.sysmod.ps2 = \"custom2> \"\n         self.console.interact()\n-        output = ''.join(''.join(call[1]) for call in self.stdout.method_calls)\n-        self.assertIn('custom2> ', output)\n-        self.assertEqual(self.sysmod.ps2, 'custom2> ')\n+        output = \"\".join(\"\".join(call[1]) for call in self.stdout.method_calls)\n+        self.assertIn(\"custom2> \", output)\n+        self.assertEqual(self.sysmod.ps2, \"custom2> \")\n \n     def test_console_stderr(self):\n-        self.infunc.side_effect = [\"'antioch'\", \"\", EOFError('Finished')]\n+        self.infunc.side_effect = [\"'antioch'\", \"\", EOFError(\"Finished\")]\n         self.console.interact()\n         for call in list(self.stdout.method_calls):\n-            if 'antioch' in ''.join(call[1]):\n+            if \"antioch\" in \"\".join(call[1]):\n                 break\n         else:\n             raise AssertionError(\"no console stdout\")\n \n     def test_syntax_error(self):\n-        self.infunc.side_effect = [\"def f():\",\n-                                   \"    x = ?\",\n-                                   \"\",\n-                                    EOFError('Finished')]\n+        self.infunc.side_effect = [\n+            \"def f():\",\n+            \"    x = ?\",\n+            \"\",\n+            EOFError(\"Finished\"),\n+        ]\n         self.console.interact()\n-        output = ''.join(''.join(call[1]) for call in self.stderr.method_calls)\n-        output = output[output.index('(InteractiveConsole)'):]\n-        output = output[:output.index('\\nnow exiting')]\n-        self.assertEqual(output.splitlines()[1:], [\n-            '  File \"<console>\", line 2',\n-            '    x = ?',\n-            '        ^',\n-            'SyntaxError: invalid syntax'])\n+        output = \"\".join(\"\".join(call[1]) for call in self.stderr.method_calls)\n+        output = output[output.index(\"(InteractiveConsole)\") :]\n+        output = output[: output.index(\"\\nnow exiting\")]\n+        self.assertEqual(\n+            output.splitlines()[1:],\n+            [\n+                '  File \"<console>\", line 2',\n+                \"    x = ?\",\n+                \"        ^\",\n+                \"SyntaxError: invalid syntax\",\n+            ],\n+        )\n         self.assertIs(self.sysmod.last_type, SyntaxError)\n         self.assertIs(type(self.sysmod.last_value), SyntaxError)\n         self.assertIsNone(self.sysmod.last_traceback)\n@@ -112,15 +119,19 @@ def test_syntax_error(self):\n         self.assertIs(self.sysmod.last_exc, self.sysmod.last_value)\n \n     def test_indentation_error(self):\n-        self.infunc.side_effect = [\"  1\", EOFError('Finished')]\n+        self.infunc.side_effect = [\"  1\", EOFError(\"Finished\")]\n         self.console.interact()\n-        output = ''.join(''.join(call[1]) for call in self.stderr.method_calls)\n-        output = output[output.index('(InteractiveConsole)'):]\n-        output = output[:output.index('\\nnow exiting')]\n-        self.assertEqual(output.splitlines()[1:], [\n-            '  File \"<console>\", line 1',\n-            '    1',\n-            'IndentationError: unexpected indent'])\n+        output = \"\".join(\"\".join(call[1]) for call in self.stderr.method_calls)\n+        output = output[output.index(\"(InteractiveConsole)\") :]\n+        output = output[: output.index(\"\\nnow exiting\")]\n+        self.assertEqual(\n+            output.splitlines()[1:],\n+            [\n+                '  File \"<console>\", line 1',\n+                \"    1\",\n+                \"IndentationError: unexpected indent\",\n+            ],\n+        )\n         self.assertIs(self.sysmod.last_type, IndentationError)\n         self.assertIs(type(self.sysmod.last_value), IndentationError)\n         self.assertIsNone(self.sysmod.last_traceback)\n@@ -128,12 +139,12 @@ def test_indentation_error(self):\n         self.assertIs(self.sysmod.last_exc, self.sysmod.last_value)\n \n     def test_unicode_error(self):\n-        self.infunc.side_effect = [\"'\\ud800'\", EOFError('Finished')]\n+        self.infunc.side_effect = [\"'\\ud800'\", EOFError(\"Finished\")]\n         self.console.interact()\n-        output = ''.join(''.join(call[1]) for call in self.stderr.method_calls)\n-        output = output[output.index('(InteractiveConsole)'):]\n-        output = output[output.index('\\n') + 1:]\n-        self.assertStartsWith(output, 'UnicodeEncodeError: ')\n+        output = \"\".join(\"\".join(call[1]) for call in self.stderr.method_calls)\n+        output = output[output.index(\"(InteractiveConsole)\") :]\n+        output = output[output.index(\"\\n\") + 1 :]\n+        self.assertStartsWith(output, \"UnicodeEncodeError: \")\n         self.assertIs(self.sysmod.last_type, UnicodeEncodeError)\n         self.assertIs(type(self.sysmod.last_value), UnicodeEncodeError)\n         self.assertIsNone(self.sysmod.last_traceback)\n@@ -141,90 +152,134 @@ def test_unicode_error(self):\n         self.assertIs(self.sysmod.last_exc, self.sysmod.last_value)\n \n     def test_sysexcepthook(self):\n-        self.infunc.side_effect = [\"def f():\",\n-                                   \"    raise ValueError('BOOM!')\",\n-                                   \"\",\n-                                   \"f()\",\n-                                    EOFError('Finished')]\n+        self.infunc.side_effect = [\n+            \"def f():\",\n+            \"    raise ValueError('BOOM!')\",\n+            \"\",\n+            \"f()\",\n+            EOFError(\"Finished\"),\n+        ]\n         hook = mock.Mock()\n         self.sysmod.excepthook = hook\n         self.console.interact()\n         hook.assert_called()\n-        hook.assert_called_with(self.sysmod.last_type,\n-                                self.sysmod.last_value,\n-                                self.sysmod.last_traceback)\n+        hook.assert_called_with(\n+            self.sysmod.last_type,\n+            self.sysmod.last_value,\n+            self.sysmod.last_traceback,\n+        )\n         self.assertIs(self.sysmod.last_type, ValueError)\n         self.assertIs(type(self.sysmod.last_value), ValueError)\n-        self.assertIs(self.sysmod.last_traceback, self.sysmod.last_value.__traceback__)\n+        self.assertIs(\n+            self.sysmod.last_traceback, self.sysmod.last_value.__traceback__\n+        )\n         self.assertIs(self.sysmod.last_exc, self.sysmod.last_value)\n-        self.assertEqual(traceback.format_exception(self.sysmod.last_exc), [\n-            'Traceback (most recent call last):\\n',\n-            '  File \"<console>\", line 1, in <module>\\n',\n-            '  File \"<console>\", line 2, in f\\n',\n-            'ValueError: BOOM!\\n'])\n+        self.assertEqual(\n+            traceback.format_exception(self.sysmod.last_exc),\n+            [\n+                \"Traceback (most recent call last):\\n\",\n+                '  File \"<console>\", line 1, in <module>\\n',\n+                '  File \"<console>\", line 2, in f\\n',\n+                \"ValueError: BOOM!\\n\",\n+            ],\n+        )\n \n     def test_sysexcepthook_syntax_error(self):\n-        self.infunc.side_effect = [\"def f():\",\n-                                   \"    x = ?\",\n-                                   \"\",\n-                                    EOFError('Finished')]\n+        self.infunc.side_effect = [\n+            \"def f():\",\n+            \"    x = ?\",\n+            \"\",\n+            EOFError(\"Finished\"),\n+        ]\n         hook = mock.Mock()\n         self.sysmod.excepthook = hook\n         self.console.interact()\n         hook.assert_called()\n-        hook.assert_called_with(self.sysmod.last_type,\n-                                self.sysmod.last_value,\n-                                self.sysmod.last_traceback)\n+        hook.assert_called_with(\n+            self.sysmod.last_type,\n+            self.sysmod.last_value,\n+            self.sysmod.last_traceback,\n+        )\n         self.assertIs(self.sysmod.last_type, SyntaxError)\n         self.assertIs(type(self.sysmod.last_value), SyntaxError)\n         self.assertIsNone(self.sysmod.last_traceback)\n         self.assertIsNone(self.sysmod.last_value.__traceback__)\n         self.assertIs(self.sysmod.last_exc, self.sysmod.last_value)\n-        self.assertEqual(traceback.format_exception(self.sysmod.last_exc), [\n-            '  File \"<console>\", line 2\\n',\n-            '    x = ?\\n',\n-            '        ^\\n',\n-            'SyntaxError: invalid syntax\\n'])\n+        self.assertEqual(\n+            traceback.format_exception(self.sysmod.last_exc),\n+            [\n+                '  File \"<console>\", line 2\\n',\n+                \"    x = ?\\n\",\n+                \"        ^\\n\",\n+                \"SyntaxError: invalid syntax\\n\",\n+            ],\n+        )\n \n     def test_sysexcepthook_indentation_error(self):\n-        self.infunc.side_effect = [\"  1\", EOFError('Finished')]\n+        self.infunc.side_effect = [\"  1\", EOFError(\"Finished\")]\n         hook = mock.Mock()\n         self.sysmod.excepthook = hook\n         self.console.interact()\n         hook.assert_called()\n-        hook.assert_called_with(self.sysmod.last_type,\n-                                self.sysmod.last_value,\n-                                self.sysmod.last_traceback)\n+        hook.assert_called_with(\n+            self.sysmod.last_type,\n+            self.sysmod.last_value,\n+            self.sysmod.last_traceback,\n+        )\n         self.assertIs(self.sysmod.last_type, IndentationError)\n         self.assertIs(type(self.sysmod.last_value), IndentationError)\n         self.assertIsNone(self.sysmod.last_traceback)\n         self.assertIsNone(self.sysmod.last_value.__traceback__)\n         self.assertIs(self.sysmod.last_exc, self.sysmod.last_value)\n-        self.assertEqual(traceback.format_exception(self.sysmod.last_exc), [\n-            '  File \"<console>\", line 1\\n',\n-            '    1\\n',\n-            'IndentationError: unexpected indent\\n'])\n+        self.assertEqual(\n+            traceback.format_exception(self.sysmod.last_exc),\n+            [\n+                '  File \"<console>\", line 1\\n',\n+                \"    1\\n\",\n+                \"IndentationError: unexpected indent\\n\",\n+            ],\n+        )\n \n     def test_sysexcepthook_crashing_doesnt_close_repl(self):\n-        self.infunc.side_effect = [\"1/0\", \"a = 123\", \"print(a)\", EOFError('Finished')]\n+        self.infunc.side_effect = [\n+            \"1/0\",\n+            \"a = 123\",\n+            \"print(a)\",\n+            EOFError(\"Finished\"),\n+        ]\n         self.sysmod.excepthook = 1\n         self.console.interact()\n-        self.assertEqual(['write', ('123', ), {}], self.stdout.method_calls[0])\n-        error = \"\".join(call.args[0] for call in self.stderr.method_calls if call[0] == 'write')\n+        self.assertEqual([\"write\", (\"123\",), {}], self.stdout.method_calls[0])\n+        error = \"\".join(\n+            call.args[0]\n+            for call in self.stderr.method_calls\n+            if call[0] == \"write\"\n+        )\n         self.assertIn(\"Error in sys.excepthook:\", error)\n         self.assertEqual(error.count(\"'int' object is not callable\"), 1)\n         self.assertIn(\"Original exception was:\", error)\n         self.assertIn(\"division by zero\", error)\n \n     def test_sysexcepthook_raising_BaseException(self):\n-        self.infunc.side_effect = [\"1/0\", \"a = 123\", \"print(a)\", EOFError('Finished')]\n+        self.infunc.side_effect = [\n+            \"1/0\",\n+            \"a = 123\",\n+            \"print(a)\",\n+            EOFError(\"Finished\"),\n+        ]\n         s = \"not so fast\"\n+\n         def raise_base(*args, **kwargs):\n             raise BaseException(s)\n+\n         self.sysmod.excepthook = raise_base\n         self.console.interact()\n-        self.assertEqual(['write', ('123', ), {}], self.stdout.method_calls[0])\n-        error = \"\".join(call.args[0] for call in self.stderr.method_calls if call[0] == 'write')\n+        self.assertEqual([\"write\", (\"123\",), {}], self.stdout.method_calls[0])\n+        error = \"\".join(\n+            call.args[0]\n+            for call in self.stderr.method_calls\n+            if call[0] == \"write\"\n+        )\n         self.assertIn(\"Error in sys.excepthook:\", error)\n         self.assertEqual(error.count(\"not so fast\"), 1)\n         self.assertIn(\"Original exception was:\", error)\n@@ -232,59 +287,62 @@ def raise_base(*args, **kwargs):\n \n     def test_sysexcepthook_raising_SystemExit_gets_through(self):\n         self.infunc.side_effect = [\"1/0\"]\n+\n         def raise_base(*args, **kwargs):\n             raise SystemExit\n+\n         self.sysmod.excepthook = raise_base\n         with self.assertRaises(SystemExit):\n             self.console.interact()\n \n     def test_banner(self):\n         # with banner\n-        self.infunc.side_effect = EOFError('Finished')\n-        self.console.interact(banner='Foo')\n+        self.infunc.side_effect = EOFError(\"Finished\")\n+        self.console.interact(banner=\"Foo\")\n         self.assertEqual(len(self.stderr.method_calls), 3)\n         banner_call = self.stderr.method_calls[0]\n-        self.assertEqual(banner_call, ['write', ('Foo\\n',), {}])\n+        self.assertEqual(banner_call, [\"write\", (\"Foo\\n\",), {}])\n \n         # no banner\n         self.stderr.reset_mock()\n-        self.infunc.side_effect = EOFError('Finished')\n-        self.console.interact(banner='')\n+        self.infunc.side_effect = EOFError(\"Finished\")\n+        self.console.interact(banner=\"\")\n         self.assertEqual(len(self.stderr.method_calls), 2)\n \n     def test_exit_msg(self):\n         # default exit message\n-        self.infunc.side_effect = EOFError('Finished')\n-        self.console.interact(banner='')\n+        self.infunc.side_effect = EOFError(\"Finished\")\n+        self.console.interact(banner=\"\")\n         self.assertEqual(len(self.stderr.method_calls), 2)\n         err_msg = self.stderr.method_calls[1]\n-        expected = 'now exiting InteractiveConsole...\\n'\n-        self.assertEqual(err_msg, ['write', (expected,), {}])\n+        expected = \"now exiting InteractiveConsole...\\n\"\n+        self.assertEqual(err_msg, [\"write\", (expected,), {}])\n \n         # no exit message\n         self.stderr.reset_mock()\n-        self.infunc.side_effect = EOFError('Finished')\n-        self.console.interact(banner='', exitmsg='')\n+        self.infunc.side_effect = EOFError(\"Finished\")\n+        self.console.interact(banner=\"\", exitmsg=\"\")\n         self.assertEqual(len(self.stderr.method_calls), 1)\n \n         # custom exit message\n         self.stderr.reset_mock()\n         message = (\n-            'bye! \\N{GREEK SMALL LETTER ZETA}\\N{CYRILLIC SMALL LETTER ZHE}'\n-            )\n-        self.infunc.side_effect = EOFError('Finished')\n-        self.console.interact(banner='', exitmsg=message)\n+            \"bye! \\N{GREEK SMALL LETTER ZETA}\\N{CYRILLIC SMALL LETTER ZHE}\"\n+        )\n+        self.infunc.side_effect = EOFError(\"Finished\")\n+        self.console.interact(banner=\"\", exitmsg=message)\n         self.assertEqual(len(self.stderr.method_calls), 2)\n         err_msg = self.stderr.method_calls[1]\n-        expected = message + '\\n'\n-        self.assertEqual(err_msg, ['write', (expected,), {}])\n-\n+        expected = message + \"\\n\"\n+        self.assertEqual(err_msg, [\"write\", (expected,), {}])\n \n     def test_cause_tb(self):\n-        self.infunc.side_effect = [\"raise ValueError('') from AttributeError\",\n-                                    EOFError('Finished')]\n+        self.infunc.side_effect = [\n+            \"raise ValueError('') from AttributeError\",\n+            EOFError(\"Finished\"),\n+        ]\n         self.console.interact()\n-        output = ''.join(''.join(call[1]) for call in self.stderr.method_calls)\n+        output = \"\".join(\"\".join(call[1]) for call in self.stderr.method_calls)\n         expected = dedent(\"\"\"\n         AttributeError\n \n@@ -297,15 +355,19 @@ def test_cause_tb(self):\n         self.assertIn(expected, output)\n         self.assertIs(self.sysmod.last_type, ValueError)\n         self.assertIs(type(self.sysmod.last_value), ValueError)\n-        self.assertIs(self.sysmod.last_traceback, self.sysmod.last_value.__traceback__)\n+        self.assertIs(\n+            self.sysmod.last_traceback, self.sysmod.last_value.__traceback__\n+        )\n         self.assertIsNotNone(self.sysmod.last_traceback)\n         self.assertIs(self.sysmod.last_exc, self.sysmod.last_value)\n \n     def test_context_tb(self):\n-        self.infunc.side_effect = [\"try: ham\\nexcept: eggs\\n\",\n-                                    EOFError('Finished')]\n+        self.infunc.side_effect = [\n+            \"try: ham\\nexcept: eggs\\n\",\n+            EOFError(\"Finished\"),\n+        ]\n         self.console.interact()\n-        output = ''.join(''.join(call[1]) for call in self.stderr.method_calls)\n+        output = \"\".join(\"\".join(call[1]) for call in self.stderr.method_calls)\n         expected = dedent(\"\"\"\n         Traceback (most recent call last):\n           File \"<console>\", line 1, in <module>\n@@ -320,26 +382,29 @@ def test_context_tb(self):\n         self.assertIn(expected, output)\n         self.assertIs(self.sysmod.last_type, NameError)\n         self.assertIs(type(self.sysmod.last_value), NameError)\n-        self.assertIs(self.sysmod.last_traceback, self.sysmod.last_value.__traceback__)\n+        self.assertIs(\n+            self.sysmod.last_traceback, self.sysmod.last_value.__traceback__\n+        )\n         self.assertIsNotNone(self.sysmod.last_traceback)\n         self.assertIs(self.sysmod.last_exc, self.sysmod.last_value)\n \n \n class TestInteractiveConsoleLocalExit(unittest.TestCase, MockSys):\n-\n     def setUp(self):\n         self.console = code.InteractiveConsole(local_exit=True)\n         self.mock_sys()\n \n-    @unittest.skipIf(sys.flags.no_site, \"exit() isn't defined unless there's a site module\")\n+    @unittest.skipIf(\n+        sys.flags.no_site, \"exit() isn't defined unless there's a site module\"\n+    )\n     def test_exit(self):\n         # default exit message\n         self.infunc.side_effect = [\"exit()\"]\n-        self.console.interact(banner='')\n+        self.console.interact(banner=\"\")\n         self.assertEqual(len(self.stderr.method_calls), 2)\n         err_msg = self.stderr.method_calls[1]\n-        expected = 'now exiting InteractiveConsole...\\n'\n-        self.assertEqual(err_msg, ['write', (expected,), {}])\n+        expected = \"now exiting InteractiveConsole...\\n\"\n+        self.assertEqual(err_msg, [\"write\", (expected,), {}])\n \n \n if __name__ == \"__main__\":\ndiff --git a/Lib/test/test_pdb.py b/Lib/test/test_pdb.py\nindex 9a7d8550..0a228ff1 100644\n--- a/Lib/test/test_pdb.py\n+++ b/Lib/test/test_pdb.py\n@@ -38,7 +38,7 @@ def __init__(self, input):\n     def __enter__(self):\n         self.real_stdin = sys.stdin\n         sys.stdin = FakeInput(self.input)\n-        self.orig_trace = sys.gettrace() if hasattr(sys, 'gettrace') else None\n+        self.orig_trace = sys.gettrace() if hasattr(sys, \"gettrace\") else None\n \n     def __exit__(self, *exc):\n         sys.stdin = self.real_stdin\n@@ -227,6 +227,7 @@ def test_pdb_basic_commands():\n     BAZ\n     \"\"\"\n \n+\n def test_pdb_breakpoint_commands():\n     \"\"\"Test basic commands related to breakpoints.\n \n@@ -359,6 +360,7 @@ def test_pdb_breakpoint_commands():\n     4\n     \"\"\"\n \n+\n def test_pdb_breakpoint_ignore_and_condition():\n     \"\"\"\n     >>> def test_function():\n@@ -400,6 +402,7 @@ def test_pdb_breakpoint_ignore_and_condition():\n     4\n     \"\"\"\n \n+\n def test_pdb_breakpoint_on_annotated_function_def():\n     \"\"\"Test breakpoints on function definitions with annotation.\n \n@@ -434,6 +437,7 @@ def test_pdb_breakpoint_on_annotated_function_def():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_commands():\n     \"\"\"Test the commands command of pdb.\n \n@@ -480,6 +484,7 @@ def test_pdb_commands():\n     3\n     \"\"\"\n \n+\n def test_pdb_breakpoint_with_filename():\n     \"\"\"Breakpoints with filename:lineno\n \n@@ -513,6 +518,7 @@ def test_pdb_breakpoint_with_filename():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_breakpoint_on_disabled_line():\n     \"\"\"New breakpoint on once disabled line should work\n \n@@ -554,6 +560,7 @@ def test_pdb_breakpoint_on_disabled_line():\n     4\n     \"\"\"\n \n+\n def test_pdb_breakpoints_preserved_across_interactive_sessions():\n     \"\"\"Breakpoints are remembered between interactive sessions\n \n@@ -620,6 +627,7 @@ def test_pdb_breakpoints_preserved_across_interactive_sessions():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_break_anywhere():\n     \"\"\"Test break_anywhere() method of Pdb.\n \n@@ -656,6 +664,7 @@ def test_pdb_break_anywhere():\n     False\n     \"\"\"\n \n+\n def test_pdb_pp_repr_exc():\n     \"\"\"Test that do_p/do_pp do not swallow exceptions.\n \n@@ -682,6 +691,7 @@ def test_pdb_pp_repr_exc():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_empty_line():\n     \"\"\"Test that empty line repeats the last command.\n \n@@ -714,12 +724,15 @@ def test_pdb_empty_line():\n     (Pdb) continue\n     \"\"\"\n \n+\n def do_nothing():\n     pass\n \n+\n def do_something():\n     print(42)\n \n+\n def test_list_commands():\n     \"\"\"Test the list and source commands of pdb.\n \n@@ -819,6 +832,7 @@ def test_list_commands():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_whatis_command():\n     \"\"\"Test the whatis command\n \n@@ -860,6 +874,7 @@ def test_pdb_whatis_command():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_display_command():\n     \"\"\"Test display command\n \n@@ -923,6 +938,7 @@ def test_pdb_display_command():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_alias_command():\n     \"\"\"Test alias command\n \n@@ -996,6 +1012,7 @@ def test_pdb_alias_command():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_where_command():\n     \"\"\"Test where command\n \n@@ -1087,6 +1104,7 @@ def test_pdb_where_command():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_restart_command():\n     \"\"\"Test restart command\n \n@@ -1108,6 +1126,7 @@ def test_pdb_restart_command():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_commands_with_set_trace():\n     \"\"\"Test that commands can be passed to Pdb.set_trace()\n \n@@ -1123,6 +1142,7 @@ def test_pdb_commands_with_set_trace():\n # skip this test if sys.flags.no_site = True;\n # exit() isn't defined unless there's a site module.\n if not sys.flags.no_site:\n+\n     def test_pdb_interact_command():\n         \"\"\"Test interact command\n \n@@ -1175,6 +1195,7 @@ def test_pdb_interact_command():\n         (Pdb) continue\n         \"\"\"\n \n+\n def test_convenience_variables():\n     \"\"\"Test convenience variables\n \n@@ -1573,6 +1594,7 @@ def test_post_mortem_single_no_stack():\n     A valid traceback must be passed if no exception is being handled\n     \"\"\"\n \n+\n def test_post_mortem_complex():\n     \"\"\"Test post mortem traceback debugging of chained exception\n \n@@ -1817,6 +1839,7 @@ def test_pdb_skip_modules():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_invalid_arg():\n     \"\"\"This tests pdb commands that have invalid arguments\n \n@@ -1854,8 +1877,8 @@ def test_pdb_invalid_arg():\n \n \n # Module for testing skipping of module that makes a callback\n-mod = types.ModuleType('module_to_skip')\n-exec('def foo_pony(callback): x = 1; callback(); return None', mod.__dict__)\n+mod = types.ModuleType(\"module_to_skip\")\n+exec(\"def foo_pony(callback): x = 1; callback(); return None\", mod.__dict__)\n \n \n def test_pdb_skip_modules_with_callback():\n@@ -1994,6 +2017,7 @@ def test_pdb_run_with_code_object():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_next_until_return_at_return_event():\n     \"\"\"Test that pdb stops after a next/until/return issued at a return debug event.\n \n@@ -2057,6 +2081,7 @@ def test_next_until_return_at_return_event():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_next_command_for_generator():\n     \"\"\"Testing skip unwinding stack on yield for generators for \"next\" command\n \n@@ -2120,8 +2145,10 @@ def test_pdb_next_command_for_generator():\n     finished\n     \"\"\"\n \n+\n if not SKIP_CORO_TESTS:\n     if has_socket_support:\n+\n         def test_pdb_asynctask():\n             \"\"\"Testing $_asynctask is accessible in async context\n \n@@ -2437,6 +2464,7 @@ def test_pdb_next_command_for_asyncgen():\n         finished\n         \"\"\"\n \n+\n def test_pdb_return_command_for_generator():\n     \"\"\"Testing no unwinding stack on yield for generators\n        for \"return\" command\n@@ -2496,7 +2524,9 @@ def test_pdb_return_command_for_generator():\n     finished\n     \"\"\"\n \n+\n if not SKIP_CORO_TESTS:\n+\n     def test_pdb_return_command_for_coroutine():\n         \"\"\"Testing no unwinding stack on yield for coroutines for \"return\" command\n \n@@ -2540,6 +2570,7 @@ def test_pdb_return_command_for_coroutine():\n         finished\n         \"\"\"\n \n+\n def test_pdb_until_command_for_generator():\n     \"\"\"Testing no unwinding stack on yield for generators\n        for \"until\" command if target breakpoint is not reached\n@@ -2588,7 +2619,9 @@ def test_pdb_until_command_for_generator():\n     finished\n     \"\"\"\n \n+\n if not SKIP_CORO_TESTS:\n+\n     def test_pdb_until_command_for_coroutine():\n         \"\"\"Testing no unwinding stack for coroutines\n         for \"until\" command if target breakpoint is not reached\n@@ -2637,6 +2670,7 @@ def test_pdb_until_command_for_coroutine():\n         finished\n         \"\"\"\n \n+\n def test_pdb_next_command_in_generator_for_loop():\n     \"\"\"The next command on returning from a generator controlled by a for loop.\n \n@@ -2678,6 +2712,7 @@ def test_pdb_next_command_in_generator_for_loop():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_next_command_subiterator():\n     \"\"\"The next command in a generator with a subiterator.\n \n@@ -2729,6 +2764,7 @@ def test_pdb_next_command_subiterator():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_breakpoint_with_throw():\n     \"\"\"GH-132536: PY_THROW event should not be turned off\n \n@@ -2762,6 +2798,7 @@ def test_pdb_breakpoint_with_throw():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_multiline_statement():\n     \"\"\"Test for multiline statement\n \n@@ -2796,6 +2833,7 @@ def test_pdb_multiline_statement():\n     (Pdb) c\n     \"\"\"\n \n+\n def test_pdb_closure():\n     \"\"\"Test for all expressions/statements that involve closure\n \n@@ -2859,6 +2897,7 @@ def test_pdb_closure():\n     (Pdb) c\n     \"\"\"\n \n+\n def test_pdb_show_attribute_and_item():\n     \"\"\"Test for expressions with command prefix\n \n@@ -2899,10 +2938,12 @@ def test_pdb_show_attribute_and_item():\n     (Pdb) c\n     \"\"\"\n \n+\n # doctest will modify pdb.set_trace during the test, so we need to backup\n # the original function to use it in the test\n original_pdb_settrace = pdb.set_trace\n \n+\n def test_pdb_with_inline_breakpoint():\n     \"\"\"Hard-coded breakpoint() calls should invoke the same debugger instance\n \n@@ -2942,6 +2983,7 @@ def test_pdb_with_inline_breakpoint():\n     (Pdb) c\n     \"\"\"\n \n+\n def test_pdb_issue_20766():\n     \"\"\"Test for reference leaks when the SIGINT handler is set.\n \n@@ -2966,6 +3008,7 @@ def test_pdb_issue_20766():\n     pdb 2: <built-in function default_int_handler>\n     \"\"\"\n \n+\n def test_pdb_issue_43318():\n     \"\"\"echo breakpoints cleared with filename:lineno\n \n@@ -2994,6 +3037,7 @@ def test_pdb_issue_43318():\n     4\n     \"\"\"\n \n+\n def test_pdb_issue_gh_91742():\n     \"\"\"See GH-91742\n \n@@ -3042,6 +3086,7 @@ def test_pdb_issue_gh_91742():\n     Author: 'pi' Version: '3.14'\n     \"\"\"\n \n+\n def test_pdb_issue_gh_94215():\n     \"\"\"See GH-94215\n \n@@ -3111,6 +3156,7 @@ def test_pdb_issue_gh_94215():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_issue_gh_101673():\n     \"\"\"See GH-101673\n \n@@ -3153,6 +3199,7 @@ def test_pdb_issue_gh_101673():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_issue_gh_103225():\n     \"\"\"See GH-103225\n \n@@ -3178,6 +3225,7 @@ def test_pdb_issue_gh_103225():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_issue_gh_101517():\n     \"\"\"See GH-101517\n \n@@ -3198,6 +3246,7 @@ def test_pdb_issue_gh_101517():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_issue_gh_108976():\n     \"\"\"See GH-108976\n     Make sure setting f_trace_opcodes = True won't crash pdb\n@@ -3215,6 +3264,7 @@ def test_pdb_issue_gh_108976():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_issue_gh_127321():\n     \"\"\"See GH-127321\n     breakpoint() should stop at a opcode that has a line number\n@@ -3282,6 +3332,7 @@ def test_pdb_ambiguous_statements():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_f_trace_lines():\n     \"\"\"GH-80675\n \n@@ -3304,6 +3355,7 @@ def test_pdb_f_trace_lines():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_frame_refleak():\n     \"\"\"\n     pdb should not leak reference to frames\n@@ -3355,6 +3407,7 @@ def test_pdb_frame_refleak():\n     1\n     \"\"\"\n \n+\n def test_pdb_function_break():\n     \"\"\"Testing the line number of break on function\n \n@@ -3396,6 +3449,7 @@ def test_pdb_function_break():\n     (Pdb) continue\n     \"\"\"\n \n+\n def test_pdb_issue_gh_65052():\n     \"\"\"See GH-65052\n \n@@ -3454,23 +3508,24 @@ class PdbTestCase(unittest.TestCase):\n     def tearDown(self):\n         os_helper.unlink(os_helper.TESTFN)\n \n-    @unittest.skipIf(sys.flags.safe_path,\n-                     'PYTHONSAFEPATH changes default sys.path')\n-    def _run_pdb(self, pdb_args, commands,\n-                 expected_returncode=0,\n-                 extra_env=None):\n-        self.addCleanup(os_helper.rmtree, '__pycache__')\n-        cmd = [sys.executable, '-m', 'pdb'] + pdb_args\n+    @unittest.skipIf(\n+        sys.flags.safe_path, \"PYTHONSAFEPATH changes default sys.path\"\n+    )\n+    def _run_pdb(\n+        self, pdb_args, commands, expected_returncode=0, extra_env=None\n+    ):\n+        self.addCleanup(os_helper.rmtree, \"__pycache__\")\n+        cmd = [sys.executable, \"-m\", \"pdb\"] + pdb_args\n         if extra_env is not None:\n             env = os.environ | extra_env\n         else:\n             env = os.environ\n         with subprocess.Popen(\n-                cmd,\n-                stdout=subprocess.PIPE,\n-                stdin=subprocess.PIPE,\n-                stderr=subprocess.PIPE,\n-                env = {**env, 'PYTHONIOENCODING': 'utf-8'}\n+            cmd,\n+            stdout=subprocess.PIPE,\n+            stdin=subprocess.PIPE,\n+            stderr=subprocess.PIPE,\n+            env={**env, \"PYTHONIOENCODING\": \"utf-8\"},\n         ) as proc:\n             stdout, stderr = proc.communicate(str.encode(commands))\n         stdout = bytes.decode(stdout) if isinstance(stdout, bytes) else stdout\n@@ -3478,60 +3533,73 @@ def _run_pdb(self, pdb_args, commands,\n         self.assertEqual(\n             proc.returncode,\n             expected_returncode,\n-            f\"Unexpected return code\\nstdout: {stdout}\\nstderr: {stderr}\"\n+            f\"Unexpected return code\\nstdout: {stdout}\\nstderr: {stderr}\",\n         )\n         return stdout, stderr\n \n-    def run_pdb_script(self, script, commands,\n-                       expected_returncode=0,\n-                       extra_env=None,\n-                       script_args=None,\n-                       pdbrc=None,\n-                       remove_home=False):\n+    def run_pdb_script(\n+        self,\n+        script,\n+        commands,\n+        expected_returncode=0,\n+        extra_env=None,\n+        script_args=None,\n+        pdbrc=None,\n+        remove_home=False,\n+    ):\n         \"\"\"Run 'script' lines with pdb and the pdb 'commands'.\"\"\"\n-        filename = 'main.py'\n-        with open(filename, 'w') as f:\n+        filename = \"main.py\"\n+        with open(filename, \"w\") as f:\n             f.write(textwrap.dedent(script))\n \n         if pdbrc is not None:\n-            with open('.pdbrc', 'w') as f:\n+            with open(\".pdbrc\", \"w\") as f:\n                 f.write(textwrap.dedent(pdbrc))\n-            self.addCleanup(os_helper.unlink, '.pdbrc')\n+            self.addCleanup(os_helper.unlink, \".pdbrc\")\n         self.addCleanup(os_helper.unlink, filename)\n \n         with os_helper.EnvironmentVarGuard() as env:\n             if remove_home:\n-                env.unset('HOME')\n+                env.unset(\"HOME\")\n             if script_args is None:\n                 script_args = []\n-            stdout, stderr = self._run_pdb([filename] + script_args, commands, expected_returncode, extra_env)\n+            stdout, stderr = self._run_pdb(\n+                [filename] + script_args,\n+                commands,\n+                expected_returncode,\n+                extra_env,\n+            )\n         return stdout, stderr\n \n     def run_pdb_module(self, script, commands):\n         \"\"\"Runs the script code as part of a module\"\"\"\n-        self.module_name = 't_main'\n+        self.module_name = \"t_main\"\n         os_helper.rmtree(self.module_name)\n-        main_file = self.module_name + '/__main__.py'\n-        init_file = self.module_name + '/__init__.py'\n+        main_file = self.module_name + \"/__main__.py\"\n+        init_file = self.module_name + \"/__init__.py\"\n         os.mkdir(self.module_name)\n-        with open(init_file, 'w') as f:\n+        with open(init_file, \"w\") as f:\n             pass\n-        with open(main_file, 'w') as f:\n+        with open(main_file, \"w\") as f:\n             f.write(textwrap.dedent(script))\n         self.addCleanup(os_helper.rmtree, self.module_name)\n-        return self._run_pdb(['-m', self.module_name], commands)\n+        return self._run_pdb([\"-m\", self.module_name], commands)\n \n     def _assert_find_function(self, file_content, func_name, expected):\n-        with open(os_helper.TESTFN, 'wb') as f:\n+        with open(os_helper.TESTFN, \"wb\") as f:\n             f.write(file_content)\n \n-        expected = None if not expected else (\n-            expected[0], os_helper.TESTFN, expected[1])\n+        expected = (\n+            None\n+            if not expected\n+            else (expected[0], os_helper.TESTFN, expected[1])\n+        )\n         self.assertEqual(\n-            expected, pdb.find_function(func_name, os_helper.TESTFN))\n+            expected, pdb.find_function(func_name, os_helper.TESTFN)\n+        )\n \n     def test_find_function_empty_file(self):\n-        self._assert_find_function(b'', 'foo', None)\n+        self._assert_find_function(b\"\", \"foo\", None)\n \n     def test_find_function_found(self):\n         self._assert_find_function(\n@@ -3545,8 +3613,8 @@ def b\u0153r():\n def quux():\n     pass\n \"\"\".encode(),\n-            'b\u0153r',\n-            ('b\u0153r', 5),\n+            \"b\u0153r\",\n+            (\"b\u0153r\", 5),\n         )\n \n     def test_find_function_found_with_encoding_cookie(self):\n@@ -3561,19 +3629,20 @@ def b\u0153r():\n \n def quux():\n     pass\n-\"\"\".encode('iso-8859-15'),\n-            'b\u0153r',\n-            ('b\u0153r', 6),\n+\"\"\".encode(\"iso-8859-15\"),\n+            \"b\u0153r\",\n+            (\"b\u0153r\", 6),\n         )\n \n     def test_find_function_found_with_bom(self):\n         self._assert_find_function(\n-            codecs.BOM_UTF8 + \"\"\"\\\n+            codecs.BOM_UTF8\n+            + \"\"\"\\\n def b\u0153r():\n     pass\n \"\"\".encode(),\n-            'b\u0153r',\n-            ('b\u0153r', 2),\n+            \"b\u0153r\",\n+            (\"b\u0153r\", 2),\n         )\n \n     def test_spec(self):\n@@ -3586,7 +3655,7 @@ def test_spec(self):\n         commands = \"continue\"\n \n         stdout, _ = self.run_pdb_script(script, commands)\n-        self.assertIn('None', stdout)\n+        self.assertIn(\"None\", stdout)\n \n     def test_find_function_first_executable_line(self):\n         code = textwrap.dedent(\"\"\"\\\n@@ -3608,25 +3677,29 @@ def mul():\n                 )\n         \"\"\").encode()\n \n-        self._assert_find_function(code, 'foo', ('foo', 1))\n-        self._assert_find_function(code, 'bar', ('bar', 4))\n-        self._assert_find_function(code, 'baz', ('baz', 8))\n-        self._assert_find_function(code, 'mul', ('mul', 12))\n+        self._assert_find_function(code, \"foo\", (\"foo\", 1))\n+        self._assert_find_function(code, \"bar\", (\"bar\", 4))\n+        self._assert_find_function(code, \"baz\", (\"baz\", 8))\n+        self._assert_find_function(code, \"mul\", (\"mul\", 12))\n \n     def test_issue7964(self):\n         # open the file as binary so we can force \\r\\n newline\n-        with open(os_helper.TESTFN, 'wb') as f:\n+        with open(os_helper.TESTFN, \"wb\") as f:\n             f.write(b'print(\"testing my pdb\")\\r\\n')\n-        cmd = [sys.executable, '-m', 'pdb', os_helper.TESTFN]\n-        proc = subprocess.Popen(cmd,\n+        cmd = [sys.executable, \"-m\", \"pdb\", os_helper.TESTFN]\n+        proc = subprocess.Popen(\n+            cmd,\n             stdout=subprocess.PIPE,\n             stdin=subprocess.PIPE,\n             stderr=subprocess.PIPE,\n-            )\n+        )\n         self.addCleanup(proc.stdout.close)\n-        stdout, stderr = proc.communicate(b'quit\\n')\n-        self.assertNotIn(b'SyntaxError', stdout,\n-                         \"Got a syntax error running test script under PDB\")\n+        stdout, stderr = proc.communicate(b\"quit\\n\")\n+        self.assertNotIn(\n+            b\"SyntaxError\",\n+            stdout,\n+            \"Got a syntax error running test script under PDB\",\n+        )\n \n     def test_issue46434(self):\n         # Temporarily patch in an extra help command which doesn't have a\n@@ -3643,11 +3716,17 @@ def do_testcmdwithnodocs(self, arg):\n             help testcmdwithnodocs\n         \"\"\"\n         stdout, stderr = self.run_pdb_script(script, commands)\n-        output = (stdout or '') + (stderr or '')\n-        self.assertNotIn('AttributeError', output,\n-                         'Calling help on a command with no docs should be handled gracefully')\n-        self.assertIn(\"*** No help for 'testcmdwithnodocs'; __doc__ string missing\", output,\n-                      'Calling help on a command with no docs should print an error')\n+        output = (stdout or \"\") + (stderr or \"\")\n+        self.assertNotIn(\n+            \"AttributeError\",\n+            output,\n+            \"Calling help on a command with no docs should be handled gracefully\",\n+        )\n+        self.assertIn(\n+            \"*** No help for 'testcmdwithnodocs'; __doc__ string missing\",\n+            output,\n+            \"Calling help on a command with no docs should print an error\",\n+        )\n \n     def test_issue13183(self):\n         script = \"\"\"\n@@ -3677,20 +3756,22 @@ def foobar():\n             def bar():\n                 pass\n         \"\"\"\n-        with open('bar.py', 'w') as f:\n+        with open(\"bar.py\", \"w\") as f:\n             f.write(textwrap.dedent(bar))\n-        self.addCleanup(os_helper.unlink, 'bar.py')\n+        self.addCleanup(os_helper.unlink, \"bar.py\")\n         stdout, stderr = self.run_pdb_script(script, commands)\n         self.assertTrue(\n-            any('main.py(5)foo()->None' in l for l in stdout.splitlines()),\n-            'Fail to step into the caller after a return')\n+            any(\"main.py(5)foo()->None\" in l for l in stdout.splitlines()),\n+            \"Fail to step into the caller after a return\",\n+        )\n \n     def test_issue13120(self):\n         # Invoking \"continue\" on a non-main thread triggered an exception\n         # inside signal.signal.\n \n-        with open(os_helper.TESTFN, 'wb') as f:\n-            f.write(textwrap.dedent(\"\"\"\n+        with open(os_helper.TESTFN, \"wb\") as f:\n+            f.write(\n+                textwrap.dedent(\"\"\"\n                 import threading\n                 import pdb\n \n@@ -3700,23 +3781,26 @@ def start_pdb():\n                     y = 1\n \n                 t = threading.Thread(target=start_pdb)\n-                t.start()\"\"\").encode('ascii'))\n-        cmd = [sys.executable, '-u', os_helper.TESTFN]\n-        proc = subprocess.Popen(cmd,\n+                t.start()\"\"\").encode(\"ascii\")\n+            )\n+        cmd = [sys.executable, \"-u\", os_helper.TESTFN]\n+        proc = subprocess.Popen(\n+            cmd,\n             stdout=subprocess.PIPE,\n             stdin=subprocess.PIPE,\n             stderr=subprocess.PIPE,\n-            env={**os.environ, 'PYTHONIOENCODING': 'utf-8'}\n-            )\n+            env={**os.environ, \"PYTHONIOENCODING\": \"utf-8\"},\n+        )\n         self.addCleanup(proc.stdout.close)\n-        stdout, stderr = proc.communicate(b'cont\\n')\n-        self.assertNotIn(b'Error', stdout,\n-                         \"Got an error running test script under PDB\")\n+        stdout, stderr = proc.communicate(b\"cont\\n\")\n+        self.assertNotIn(\n+            b\"Error\", stdout, \"Got an error running test script under PDB\"\n+        )\n \n     def test_issue36250(self):\n-\n-        with open(os_helper.TESTFN, 'wb') as f:\n-            f.write(textwrap.dedent(\"\"\"\n+        with open(os_helper.TESTFN, \"wb\") as f:\n+            f.write(\n+                textwrap.dedent(\"\"\"\n                 import threading\n                 import pdb\n \n@@ -3730,31 +3814,36 @@ def start_pdb():\n                 t.start()\n                 pdb.Pdb(readrc=False).set_trace()\n                 evt.set()\n-                t.join()\"\"\").encode('ascii'))\n-        cmd = [sys.executable, '-u', os_helper.TESTFN]\n-        proc = subprocess.Popen(cmd,\n+                t.join()\"\"\").encode(\"ascii\")\n+            )\n+        cmd = [sys.executable, \"-u\", os_helper.TESTFN]\n+        proc = subprocess.Popen(\n+            cmd,\n             stdout=subprocess.PIPE,\n             stdin=subprocess.PIPE,\n             stderr=subprocess.PIPE,\n-            env = {**os.environ, 'PYTHONIOENCODING': 'utf-8'}\n-            )\n+            env={**os.environ, \"PYTHONIOENCODING\": \"utf-8\"},\n+        )\n         self.addCleanup(proc.stdout.close)\n-        stdout, stderr = proc.communicate(b'cont\\ncont\\n')\n-        self.assertNotIn(b'Error', stdout,\n-                         \"Got an error running test script under PDB\")\n+        stdout, stderr = proc.communicate(b\"cont\\ncont\\n\")\n+        self.assertNotIn(\n+            b\"Error\", stdout, \"Got an error running test script under PDB\"\n+        )\n \n     def test_issue16180(self):\n         # A syntax error in the debuggee.\n         script = \"def f: pass\\n\"\n-        commands = ''\n+        commands = \"\"\n         expected = \"SyntaxError:\"\n-        stdout, stderr = self.run_pdb_script(\n-            script, commands\n+        stdout, stderr = self.run_pdb_script(script, commands)\n+        self.assertIn(\n+            expected,\n+            stderr,\n+            \"\\n\\nExpected:\\n{}\\nGot:\\n{}\\n\"\n+            \"Fail to handle a syntax error in the debuggee.\".format(\n+                expected, stderr\n+            ),\n         )\n-        self.assertIn(expected, stderr,\n-            '\\n\\nExpected:\\n{}\\nGot:\\n{}\\n'\n-            'Fail to handle a syntax error in the debuggee.'\n-            .format(expected, stderr))\n \n     def test_issue84583(self):\n         # A syntax error from ast.literal_eval should not make pdb exit.\n@@ -3782,7 +3871,7 @@ def test_issue26053(self):\n             quit\n         \"\"\"\n         stdout, stderr = self.run_pdb_script(script, commands)\n-        res = '\\n'.join([x.strip() for x in stdout.splitlines()])\n+        res = \"\\n\".join([x.strip() for x in stdout.splitlines()])\n         self.assertRegex(res, \"Restarting .* with arguments:\\na b c\")\n         self.assertRegex(res, \"Restarting .* with arguments:\\nd e f\")\n \n@@ -3808,13 +3897,13 @@ def foo():\n             def bar():\n                 return 42\n         \"\"\"\n-        with open('bar.py', 'w') as f:\n+        with open(\"bar.py\", \"w\") as f:\n             f.write(textwrap.dedent(bar))\n-        self.addCleanup(os_helper.unlink, 'bar.py')\n+        self.addCleanup(os_helper.unlink, \"bar.py\")\n         stdout, stderr = self.run_pdb_script(script, commands)\n         lines = stdout.splitlines()\n-        self.assertIn('-> pass', lines)\n-        self.assertIn('(Pdb) 42', lines)\n+        self.assertIn(\"-> pass\", lines)\n+        self.assertIn(\"(Pdb) 42\", lines)\n \n     def test_step_into_botframe(self):\n         # gh-125422\n@@ -3842,7 +3931,9 @@ def test_pdbrc_basic(self):\n             p f\"{a+8=}\"\n         \"\"\")\n \n-        stdout, stderr = self.run_pdb_script(script, 'q\\n', pdbrc=pdbrc, remove_home=True)\n+        stdout, stderr = self.run_pdb_script(\n+            script, \"q\\n\", pdbrc=pdbrc, remove_home=True\n+        )\n         self.assertNotIn(\"SyntaxError\", stdout)\n         self.assertIn(\"a+8=9\", stdout)\n         self.assertIn(\"-> b = 2\", stdout)\n@@ -3861,7 +3952,9 @@ def test_pdbrc_empty_line(self):\n \n         \"\"\")\n \n-        stdout, stderr = self.run_pdb_script(script, 'q\\n', pdbrc=pdbrc, remove_home=True)\n+        stdout, stderr = self.run_pdb_script(\n+            script, \"q\\n\", pdbrc=pdbrc, remove_home=True\n+        )\n         self.assertIn(\"b = 2\", stdout)\n         self.assertNotIn(\"c = 3\", stdout)\n \n@@ -3880,7 +3973,9 @@ def __init__(self):\n             pi a\n         \"\"\")\n \n-        stdout, stderr = self.run_pdb_script(script, 'q\\n', pdbrc=pdbrc, remove_home=True)\n+        stdout, stderr = self.run_pdb_script(\n+            script, \"q\\n\", pdbrc=pdbrc, remove_home=True\n+        )\n         self.assertIn(\"a.attr = 1\", stdout)\n \n     def test_pdbrc_semicolon(self):\n@@ -3896,7 +3991,9 @@ def __init__(self):\n             b 5;;c;;n\n         \"\"\")\n \n-        stdout, stderr = self.run_pdb_script(script, 'q\\n', pdbrc=pdbrc, remove_home=True)\n+        stdout, stderr = self.run_pdb_script(\n+            script, \"q\\n\", pdbrc=pdbrc, remove_home=True\n+        )\n         self.assertIn(\"-> b = 2\", stdout)\n \n     def test_pdbrc_commands(self):\n@@ -3914,7 +4011,9 @@ def __init__(self):\n             c\n         \"\"\")\n \n-        stdout, stderr = self.run_pdb_script(script, 'q\\n', pdbrc=pdbrc, remove_home=True)\n+        stdout, stderr = self.run_pdb_script(\n+            script, \"q\\n\", pdbrc=pdbrc, remove_home=True\n+        )\n         self.assertIn(\"<__main__.A object at\", stdout)\n \n     def test_readrc_kwarg(self):\n@@ -3922,7 +4021,9 @@ def test_readrc_kwarg(self):\n             print('hello')\n         \"\"\")\n \n-        stdout, stderr = self.run_pdb_script(script, 'q\\n', pdbrc='invalid', remove_home=True)\n+        stdout, stderr = self.run_pdb_script(\n+            script, \"q\\n\", pdbrc=\"invalid\", remove_home=True\n+        )\n         self.assertIn(\"NameError: name 'invalid' is not defined\", stdout)\n \n     def test_readrc_homedir(self):\n@@ -3937,17 +4038,17 @@ def test_readrc_homedir(self):\n \n     def test_header(self):\n         stdout = StringIO()\n-        header = 'Nobody expects... blah, blah, blah'\n+        header = \"Nobody expects... blah, blah, blah\"\n         with ExitStack() as resources:\n-            resources.enter_context(patch('sys.stdout', stdout))\n+            resources.enter_context(patch(\"sys.stdout\", stdout))\n             # patch pdb.Pdb.set_trace() to avoid entering the debugger\n-            resources.enter_context(patch.object(pdb.Pdb, 'set_trace'))\n+            resources.enter_context(patch.object(pdb.Pdb, \"set_trace\"))\n             # We need to manually clear pdb.Pdb._last_pdb_instance so a\n             # new instance with stdout redirected could be created when\n             # pdb.set_trace() is called.\n             pdb.Pdb._last_pdb_instance = None\n             pdb.set_trace(header=header)\n-        self.assertEqual(stdout.getvalue(), header + '\\n')\n+        self.assertEqual(stdout.getvalue(), header + \"\\n\")\n \n     def test_run_module(self):\n         script = \"\"\"print(\"SUCCESS\")\"\"\"\n@@ -3956,7 +4057,9 @@ def test_run_module(self):\n             quit\n         \"\"\"\n         stdout, stderr = self.run_pdb_module(script, commands)\n-        self.assertTrue(any(\"SUCCESS\" in l for l in stdout.splitlines()), stdout)\n+        self.assertTrue(\n+            any(\"SUCCESS\" in l for l in stdout.splitlines()), stdout\n+        )\n \n     def test_module_is_run_as_main(self):\n         script = \"\"\"\n@@ -3968,7 +4071,9 @@ def test_module_is_run_as_main(self):\n             quit\n         \"\"\"\n         stdout, stderr = self.run_pdb_module(script, commands)\n-        self.assertTrue(any(\"SUCCESS\" in l for l in stdout.splitlines()), stdout)\n+        self.assertTrue(\n+            any(\"SUCCESS\" in l for l in stdout.splitlines()), stdout\n+        )\n \n     def test_run_module_with_args(self):\n         commands = \"\"\"\n@@ -3979,7 +4084,9 @@ def test_run_module_with_args(self):\n         stdout, _ = self._run_pdb([\"-m\", \"calendar\", \"1\"], commands)\n         self.assertIn(\"December\", stdout)\n \n-        stdout, _ = self._run_pdb([\"-m\", \"calendar\", \"--type\", \"text\"], commands)\n+        stdout, _ = self._run_pdb(\n+            [\"-m\", \"calendar\", \"--type\", \"text\"], commands\n+        )\n         self.assertIn(\"December\", stdout)\n \n     def test_run_script_with_args(self):\n@@ -3992,7 +4099,9 @@ def test_run_script_with_args(self):\n             quit\n         \"\"\"\n \n-        stdout, stderr = self.run_pdb_script(script, commands, script_args=[\"--bar\", \"foo\"])\n+        stdout, stderr = self.run_pdb_script(\n+            script, commands, script_args=[\"--bar\", \"foo\"]\n+        )\n         self.assertIn(\"['--bar', 'foo']\", stdout)\n \n     def test_breakpoint(self):\n@@ -4007,8 +4116,12 @@ def test_breakpoint(self):\n             quit\n         \"\"\"\n         stdout, stderr = self.run_pdb_module(script, commands)\n-        self.assertTrue(any(\"Breakpoint 1 at\" in l for l in stdout.splitlines()), stdout)\n-        self.assertTrue(all(\"SUCCESS\" not in l for l in stdout.splitlines()), stdout)\n+        self.assertTrue(\n+            any(\"Breakpoint 1 at\" in l for l in stdout.splitlines()), stdout\n+        )\n+        self.assertTrue(\n+            all(\"SUCCESS\" not in l for l in stdout.splitlines()), stdout\n+        )\n \n     def test_run_pdb_with_pdb(self):\n         commands = \"\"\"\n@@ -4018,53 +4131,68 @@ def test_run_pdb_with_pdb(self):\n         stdout, stderr = self._run_pdb([\"-m\", \"pdb\"], commands)\n         self.assertIn(\n             pdb._usage,\n-            stdout.replace('\\r', '')  # remove \\r for windows\n+            stdout.replace(\"\\r\", \"\"),  # remove \\r for windows\n         )\n \n     def test_module_without_a_main(self):\n-        module_name = 't_main'\n+        module_name = \"t_main\"\n         os_helper.rmtree(module_name)\n-        init_file = module_name + '/__init__.py'\n+        init_file = module_name + \"/__init__.py\"\n         os.mkdir(module_name)\n-        with open(init_file, 'w'):\n+        with open(init_file, \"w\"):\n             pass\n         self.addCleanup(os_helper.rmtree, module_name)\n         stdout, stderr = self._run_pdb(\n-            ['-m', module_name], \"\", expected_returncode=1\n+            [\"-m\", module_name], \"\", expected_returncode=1\n         )\n         self.assertIn(\"ImportError: No module named t_main.__main__;\", stdout)\n \n     def test_package_without_a_main(self):\n-        pkg_name = 't_pkg'\n-        module_name = 't_main'\n+        pkg_name = \"t_pkg\"\n+        module_name = \"t_main\"\n         os_helper.rmtree(pkg_name)\n-        modpath = pkg_name + '/' + module_name\n+        modpath = pkg_name + \"/\" + module_name\n         os.makedirs(modpath)\n-        with open(modpath + '/__init__.py', 'w'):\n+        with open(modpath + \"/__init__.py\", \"w\"):\n             pass\n         self.addCleanup(os_helper.rmtree, pkg_name)\n         stdout, stderr = self._run_pdb(\n-            ['-m', modpath.replace('/', '.')], \"\", expected_returncode=1\n+            [\"-m\", modpath.replace(\"/\", \".\")], \"\", expected_returncode=1\n         )\n         self.assertIn(\n             \"'t_pkg.t_main' is a package and cannot be directly executed\",\n-            stdout)\n+            stdout,\n+        )\n \n     def test_nonexistent_module(self):\n         assert not os.path.exists(os_helper.TESTFN)\n-        stdout, stderr = self._run_pdb([\"-m\", os_helper.TESTFN], \"\", expected_returncode=1)\n-        self.assertIn(f\"ImportError: No module named {os_helper.TESTFN}\", stdout)\n+        stdout, stderr = self._run_pdb(\n+            [\"-m\", os_helper.TESTFN], \"\", expected_returncode=1\n+        )\n+        self.assertIn(\n+            f\"ImportError: No module named {os_helper.TESTFN}\", stdout\n+        )\n \n     def test_dir_as_script(self):\n         with os_helper.temp_dir() as temp_dir:\n-            stdout, stderr = self._run_pdb([temp_dir], \"\", expected_returncode=1)\n+            stdout, stderr = self._run_pdb(\n+                [temp_dir], \"\", expected_returncode=1\n+            )\n             self.assertIn(f\"Error: {temp_dir} is a directory\", stdout)\n \n     def test_invalid_cmd_line_options(self):\n         stdout, stderr = self._run_pdb([\"-c\"], \"\", expected_returncode=2)\n-        self.assertIn(f\"pdb: error: argument -c/--command: expected one argument\", stderr.split('\\n')[1])\n-        stdout, stderr = self._run_pdb([\"--spam\", \"-m\", \"pdb\"], \"\", expected_returncode=2)\n-        self.assertIn(f\"pdb: error: unrecognized arguments: --spam\", stderr.split('\\n')[1])\n+        self.assertIn(\n+            f\"pdb: error: argument -c/--command: expected one argument\",\n+            stderr.split(\"\\n\")[1],\n+        )\n+        stdout, stderr = self._run_pdb(\n+            [\"--spam\", \"-m\", \"pdb\"], \"\", expected_returncode=2\n+        )\n+        self.assertIn(\n+            f\"pdb: error: unrecognized arguments: --spam\",\n+            stderr.split(\"\\n\")[1],\n+        )\n \n     def test_blocks_at_first_code_line(self):\n         script = \"\"\"\n@@ -4076,8 +4204,10 @@ def test_blocks_at_first_code_line(self):\n             quit\n         \"\"\"\n         stdout, stderr = self.run_pdb_module(script, commands)\n-        self.assertTrue(any(\"__main__.py(4)<module>()\"\n-                            in l for l in stdout.splitlines()), stdout)\n+        self.assertTrue(\n+            any(\"__main__.py(4)<module>()\" in l for l in stdout.splitlines()),\n+            stdout,\n+        )\n \n     def test_file_modified_after_execution(self):\n         script = \"\"\"\n@@ -4132,18 +4262,18 @@ def test_file_modified_after_execution_with_multiple_instances(self):\n             continue\n         \"\"\"\n \n-        filename = 'main.py'\n-        with open(filename, 'w') as f:\n+        filename = \"main.py\"\n+        with open(filename, \"w\") as f:\n             f.write(textwrap.dedent(script))\n         self.addCleanup(os_helper.unlink, filename)\n-        self.addCleanup(os_helper.rmtree, '__pycache__')\n+        self.addCleanup(os_helper.rmtree, \"__pycache__\")\n         cmd = [sys.executable, filename]\n         with subprocess.Popen(\n-                cmd,\n-                stdout=subprocess.PIPE,\n-                stdin=subprocess.PIPE,\n-                stderr=subprocess.PIPE,\n-                env = {**os.environ, 'PYTHONIOENCODING': 'utf-8'},\n+            cmd,\n+            stdout=subprocess.PIPE,\n+            stdin=subprocess.PIPE,\n+            stderr=subprocess.PIPE,\n+            env={**os.environ, \"PYTHONIOENCODING\": \"utf-8\"},\n         ) as proc:\n             stdout, _ = proc.communicate(str.encode(commands))\n         stdout = stdout and bytes.decode(stdout)\n@@ -4201,29 +4331,35 @@ def foo():\n         self.assertIn(\"Restarting\", stdout)\n \n     def test_relative_imports(self):\n-        self.module_name = 't_main'\n+        self.module_name = \"t_main\"\n         os_helper.rmtree(self.module_name)\n-        main_file = self.module_name + '/__main__.py'\n-        init_file = self.module_name + '/__init__.py'\n-        module_file = self.module_name + '/module.py'\n+        main_file = self.module_name + \"/__main__.py\"\n+        init_file = self.module_name + \"/__init__.py\"\n+        module_file = self.module_name + \"/module.py\"\n         self.addCleanup(os_helper.rmtree, self.module_name)\n         os.mkdir(self.module_name)\n-        with open(init_file, 'w') as f:\n-            f.write(textwrap.dedent(\"\"\"\n+        with open(init_file, \"w\") as f:\n+            f.write(\n+                textwrap.dedent(\"\"\"\n                 top_var = \"VAR from top\"\n-            \"\"\"))\n-        with open(main_file, 'w') as f:\n-            f.write(textwrap.dedent(\"\"\"\n+            \"\"\")\n+            )\n+        with open(main_file, \"w\") as f:\n+            f.write(\n+                textwrap.dedent(\"\"\"\n                 from . import top_var\n                 from .module import var\n                 from . import module\n                 pass # We'll stop here and print the vars\n-            \"\"\"))\n-        with open(module_file, 'w') as f:\n-            f.write(textwrap.dedent(\"\"\"\n+            \"\"\")\n+            )\n+        with open(module_file, \"w\") as f:\n+            f.write(\n+                textwrap.dedent(\"\"\"\n                 var = \"VAR from module\"\n                 var2 = \"second var\"\n-            \"\"\"))\n+            \"\"\")\n+            )\n         commands = \"\"\"\n             b 5\n             c\n@@ -4232,143 +4368,171 @@ def test_relative_imports(self):\n             p module.var2\n             quit\n         \"\"\"\n-        stdout, _ = self._run_pdb(['-m', self.module_name], commands)\n-        self.assertTrue(any(\"VAR from module\" in l for l in stdout.splitlines()), stdout)\n+        stdout, _ = self._run_pdb([\"-m\", self.module_name], commands)\n+        self.assertTrue(\n+            any(\"VAR from module\" in l for l in stdout.splitlines()), stdout\n+        )\n         self.assertTrue(any(\"VAR from top\" in l for l in stdout.splitlines()))\n         self.assertTrue(any(\"second var\" in l for l in stdout.splitlines()))\n \n     def test_relative_imports_on_plain_module(self):\n         # Validates running a plain module. See bpo32691\n-        self.module_name = 't_main'\n+        self.module_name = \"t_main\"\n         os_helper.rmtree(self.module_name)\n-        main_file = self.module_name + '/runme.py'\n-        init_file = self.module_name + '/__init__.py'\n-        module_file = self.module_name + '/module.py'\n+        main_file = self.module_name + \"/runme.py\"\n+        init_file = self.module_name + \"/__init__.py\"\n+        module_file = self.module_name + \"/module.py\"\n         self.addCleanup(os_helper.rmtree, self.module_name)\n         os.mkdir(self.module_name)\n-        with open(init_file, 'w') as f:\n-            f.write(textwrap.dedent(\"\"\"\n+        with open(init_file, \"w\") as f:\n+            f.write(\n+                textwrap.dedent(\"\"\"\n                 top_var = \"VAR from top\"\n-            \"\"\"))\n-        with open(main_file, 'w') as f:\n-            f.write(textwrap.dedent(\"\"\"\n+            \"\"\")\n+            )\n+        with open(main_file, \"w\") as f:\n+            f.write(\n+                textwrap.dedent(\"\"\"\n                 from . import module\n                 pass # We'll stop here and print the vars\n-            \"\"\"))\n-        with open(module_file, 'w') as f:\n-            f.write(textwrap.dedent(\"\"\"\n+            \"\"\")\n+            )\n+        with open(module_file, \"w\") as f:\n+            f.write(\n+                textwrap.dedent(\"\"\"\n                 var = \"VAR from module\"\n-            \"\"\"))\n+            \"\"\")\n+            )\n         commands = \"\"\"\n             b 3\n             c\n             p module.var\n             quit\n         \"\"\"\n-        stdout, _ = self._run_pdb(['-m', self.module_name + '.runme'], commands)\n-        self.assertTrue(any(\"VAR from module\" in l for l in stdout.splitlines()), stdout)\n+        stdout, _ = self._run_pdb(\n+            [\"-m\", self.module_name + \".runme\"], commands\n+        )\n+        self.assertTrue(\n+            any(\"VAR from module\" in l for l in stdout.splitlines()), stdout\n+        )\n \n     def test_errors_in_command(self):\n-        commands = \"\\n\".join([\n-            'print(]',\n-            'debug print(',\n-            'debug doesnotexist',\n-            'c',\n-        ])\n-        stdout, _ = self.run_pdb_script('pass', commands + '\\n')\n-\n-        self.assertEqual(stdout.splitlines()[1:], [\n-            '-> pass',\n-            \"(Pdb) *** SyntaxError: closing parenthesis ']' does not match opening \"\n-            \"parenthesis '('\",\n-\n-            '(Pdb) ENTERING RECURSIVE DEBUGGER',\n-            '*** SyntaxError: \\'(\\' was never closed',\n-            'LEAVING RECURSIVE DEBUGGER',\n-\n-            '(Pdb) ENTERING RECURSIVE DEBUGGER',\n-            '> <string>(1)<module>()',\n-            \"((Pdb)) *** NameError: name 'doesnotexist' is not defined\",\n-            'LEAVING RECURSIVE DEBUGGER',\n-            '(Pdb) ',\n-        ])\n+        commands = \"\\n\".join(\n+            [\n+                \"print(]\",\n+                \"debug print(\",\n+                \"debug doesnotexist\",\n+                \"c\",\n+            ]\n+        )\n+        stdout, _ = self.run_pdb_script(\"pass\", commands + \"\\n\")\n+\n+        self.assertEqual(\n+            stdout.splitlines()[1:],\n+            [\n+                \"-> pass\",\n+                \"(Pdb) *** SyntaxError: closing parenthesis ']' does not match opening \"\n+                \"parenthesis '('\",\n+                \"(Pdb) ENTERING RECURSIVE DEBUGGER\",\n+                \"*** SyntaxError: '(' was never closed\",\n+                \"LEAVING RECURSIVE DEBUGGER\",\n+                \"(Pdb) ENTERING RECURSIVE DEBUGGER\",\n+                \"> <string>(1)<module>()\",\n+                \"((Pdb)) *** NameError: name 'doesnotexist' is not defined\",\n+                \"LEAVING RECURSIVE DEBUGGER\",\n+                \"(Pdb) \",\n+            ],\n+        )\n \n     def test_issue34266(self):\n-        '''do_run handles exceptions from parsing its arg'''\n+        \"\"\"do_run handles exceptions from parsing its arg\"\"\"\n+\n         def check(bad_arg, msg):\n-            commands = \"\\n\".join([\n-                f'run {bad_arg}',\n-                'q',\n-            ])\n-            stdout, _ = self.run_pdb_script('pass', commands + '\\n')\n-            self.assertEqual(stdout.splitlines()[1:], [\n-                '-> pass',\n-                f'(Pdb) *** Cannot run {bad_arg}: {msg}',\n-                '(Pdb) ',\n-            ])\n-        check('\\\\', 'No escaped character')\n-        check('\"', 'No closing quotation')\n+            commands = \"\\n\".join(\n+                [\n+                    f\"run {bad_arg}\",\n+                    \"q\",\n+                ]\n+            )\n+            stdout, _ = self.run_pdb_script(\"pass\", commands + \"\\n\")\n+            self.assertEqual(\n+                stdout.splitlines()[1:],\n+                [\n+                    \"-> pass\",\n+                    f\"(Pdb) *** Cannot run {bad_arg}: {msg}\",\n+                    \"(Pdb) \",\n+                ],\n+            )\n+\n+        check(\"\\\\\", \"No escaped character\")\n+        check('\"', \"No closing quotation\")\n \n     def test_issue42384(self):\n-        '''When running `python foo.py` sys.path[0] is an absolute path. `python -m pdb foo.py` should behave the same'''\n+        \"\"\"When running `python foo.py` sys.path[0] is an absolute path. `python -m pdb foo.py` should behave the same\"\"\"\n         script = textwrap.dedent(\"\"\"\n             import sys\n             print('sys.path[0] is', sys.path[0])\n         \"\"\")\n-        commands = 'c\\nq'\n+        commands = \"c\\nq\"\n \n         with os_helper.temp_cwd() as cwd:\n-            expected = f'(Pdb) sys.path[0] is {os.path.realpath(cwd)}'\n+            expected = f\"(Pdb) sys.path[0] is {os.path.realpath(cwd)}\"\n \n             stdout, stderr = self.run_pdb_script(script, commands)\n \n-            self.assertEqual(stdout.split('\\n')[2].rstrip('\\r'), expected)\n+            self.assertEqual(stdout.split(\"\\n\")[2].rstrip(\"\\r\"), expected)\n \n     @os_helper.skip_unless_symlink\n     def test_issue42384_symlink(self):\n-        '''When running `python foo.py` sys.path[0] resolves symlinks. `python -m pdb foo.py` should behave the same'''\n+        \"\"\"When running `python foo.py` sys.path[0] resolves symlinks. `python -m pdb foo.py` should behave the same\"\"\"\n         script = textwrap.dedent(\"\"\"\n             import sys\n             print('sys.path[0] is', sys.path[0])\n         \"\"\")\n-        commands = 'c\\nq'\n+        commands = \"c\\nq\"\n \n         with os_helper.temp_cwd() as cwd:\n             cwd = os.path.realpath(cwd)\n-            dir_one = os.path.join(cwd, 'dir_one')\n-            dir_two = os.path.join(cwd, 'dir_two')\n-            expected = f'(Pdb) sys.path[0] is {dir_one}'\n+            dir_one = os.path.join(cwd, \"dir_one\")\n+            dir_two = os.path.join(cwd, \"dir_two\")\n+            expected = f\"(Pdb) sys.path[0] is {dir_one}\"\n \n             os.mkdir(dir_one)\n-            with open(os.path.join(dir_one, 'foo.py'), 'w') as f:\n+            with open(os.path.join(dir_one, \"foo.py\"), \"w\") as f:\n                 f.write(script)\n             os.mkdir(dir_two)\n-            os.symlink(os.path.join(dir_one, 'foo.py'), os.path.join(dir_two, 'foo.py'))\n+            os.symlink(\n+                os.path.join(dir_one, \"foo.py\"),\n+                os.path.join(dir_two, \"foo.py\"),\n+            )\n \n-            stdout, stderr = self._run_pdb([os.path.join('dir_two', 'foo.py')], commands)\n+            stdout, stderr = self._run_pdb(\n+                [os.path.join(\"dir_two\", \"foo.py\")], commands\n+            )\n \n-            self.assertEqual(stdout.split('\\n')[2].rstrip('\\r'), expected)\n+            self.assertEqual(stdout.split(\"\\n\")[2].rstrip(\"\\r\"), expected)\n \n     def test_safe_path(self):\n-        \"\"\" With safe_path set, pdb should not mangle sys.path[0]\"\"\"\n+        \"\"\"With safe_path set, pdb should not mangle sys.path[0]\"\"\"\n \n         script = textwrap.dedent(\"\"\"\n             import sys\n             import random\n             print('sys.path[0] is', sys.path[0])\n         \"\"\")\n-        commands = 'c\\n'\n-\n+        commands = \"c\\n\"\n \n         with os_helper.temp_cwd() as cwd:\n-            stdout, _ = self.run_pdb_script(script, commands, extra_env={'PYTHONSAFEPATH': '1'})\n+            stdout, _ = self.run_pdb_script(\n+                script, commands, extra_env={\"PYTHONSAFEPATH\": \"1\"}\n+            )\n \n-            unexpected = f'sys.path[0] is {os.path.realpath(cwd)}'\n+            unexpected = f\"sys.path[0] is {os.path.realpath(cwd)}\"\n             self.assertNotIn(unexpected, stdout)\n \n     def test_issue42383(self):\n         with os_helper.temp_cwd() as cwd:\n-            with open('foo.py', 'w') as f:\n+            with open(\"foo.py\", \"w\") as f:\n                 s = textwrap.dedent(\"\"\"\n                     print('The correct file was executed')\n \n@@ -4377,17 +4541,17 @@ def test_issue42383(self):\n                 \"\"\")\n                 f.write(s)\n \n-            subdir = os.path.join(cwd, 'subdir')\n+            subdir = os.path.join(cwd, \"subdir\")\n             os.mkdir(subdir)\n-            os.mkdir(os.path.join(subdir, 'subdir'))\n-            wrong_file = os.path.join(subdir, 'foo.py')\n+            os.mkdir(os.path.join(subdir, \"subdir\"))\n+            wrong_file = os.path.join(subdir, \"foo.py\")\n \n-            with open(wrong_file, 'w') as f:\n+            with open(wrong_file, \"w\") as f:\n                 f.write('print(\"The wrong file was executed\")')\n \n-            stdout, stderr = self._run_pdb(['foo.py'], 'c\\nc\\nq')\n-            expected = '(Pdb) The correct file was executed'\n-            self.assertEqual(stdout.split('\\n')[6].rstrip('\\r'), expected)\n+            stdout, stderr = self._run_pdb([\"foo.py\"], \"c\\nc\\nq\")\n+            expected = \"(Pdb) The correct file was executed\"\n+            self.assertEqual(stdout.split(\"\\n\")[6].rstrip(\"\\r\"), expected)\n \n     def test_gh_94215_crash(self):\n         script = \"\"\"\\\n@@ -4451,42 +4615,46 @@ def _create_fake_frozen_module():\n             longlist\n             quit\n         \"\"\"\n-        with open('gh93696.py', 'w') as f:\n+        with open(\"gh93696.py\", \"w\") as f:\n             f.write(textwrap.dedent(frozen_src))\n \n-        with open('gh93696_host.py', 'w') as f:\n+        with open(\"gh93696_host.py\", \"w\") as f:\n             f.write(textwrap.dedent(host_program))\n \n-        self.addCleanup(os_helper.unlink, 'gh93696.py')\n-        self.addCleanup(os_helper.unlink, 'gh93696_host.py')\n+        self.addCleanup(os_helper.unlink, \"gh93696.py\")\n+        self.addCleanup(os_helper.unlink, \"gh93696_host.py\")\n \n         # verify that pdb found the source of the \"frozen\" function and it\n         # shows the breakpoint at the correct line for both list and longlist\n         for commands in (commands_list, commands_longlist):\n             stdout, _ = self._run_pdb([\"gh93696_host.py\"], commands)\n-            self.assertIn('x = \"Sentinel string for gh-93696\"', stdout, \"Sentinel statement not found\")\n-            self.assertIn('4 B', stdout, \"breakpoint not found\")\n-            self.assertIn('-> def func():', stdout, \"stack entry not found\")\n+            self.assertIn(\n+                'x = \"Sentinel string for gh-93696\"',\n+                stdout,\n+                \"Sentinel statement not found\",\n+            )\n+            self.assertIn(\"4 B\", stdout, \"breakpoint not found\")\n+            self.assertIn(\"-> def func():\", stdout, \"stack entry not found\")\n \n     def test_empty_file(self):\n-        script = ''\n-        commands = 'q\\n'\n+        script = \"\"\n+        commands = \"q\\n\"\n         # We check that pdb stopped at line 0, but anything reasonable\n         # is acceptable here, as long as it does not halt\n         stdout, _ = self.run_pdb_script(script, commands)\n-        self.assertIn('main.py(0)', stdout)\n+        self.assertIn(\"main.py(0)\", stdout)\n         stdout, _ = self.run_pdb_module(script, commands)\n-        self.assertIn('__main__.py(0)', stdout)\n+        self.assertIn(\"__main__.py(0)\", stdout)\n \n     def test_non_utf8_encoding(self):\n-        script_dir = os.path.join(os.path.dirname(__file__), 'encoded_modules')\n+        script_dir = os.path.join(os.path.dirname(__file__), \"encoded_modules\")\n         for filename in os.listdir(script_dir):\n             if filename.endswith(\".py\"):\n-                self._run_pdb([os.path.join(script_dir, filename)], 'q')\n+                self._run_pdb([os.path.join(script_dir, filename)], \"q\")\n \n     def test_zipapp(self):\n         with os_helper.temp_dir() as temp_dir:\n-            os.mkdir(os.path.join(temp_dir, 'source'))\n+            os.mkdir(os.path.join(temp_dir, \"source\"))\n             script = textwrap.dedent(\n                 \"\"\"\n                 def f(x):\n@@ -4494,22 +4662,24 @@ def f(x):\n                 f(21 + 21)\n                 \"\"\"\n             )\n-            with open(os.path.join(temp_dir, 'source', '__main__.py'), 'w') as f:\n+            with open(\n+                os.path.join(temp_dir, \"source\", \"__main__.py\"), \"w\"\n+            ) as f:\n                 f.write(script)\n-            zipapp.create_archive(os.path.join(temp_dir, 'source'),\n-                                  os.path.join(temp_dir, 'zipapp.pyz'))\n-            stdout, _ = self._run_pdb([os.path.join(temp_dir, 'zipapp.pyz')], '\\n'.join([\n-                'b f',\n-                'c',\n-                'p x',\n-                'q'\n-            ]))\n-            self.assertIn('42', stdout)\n-            self.assertIn('return x + 1', stdout)\n+            zipapp.create_archive(\n+                os.path.join(temp_dir, \"source\"),\n+                os.path.join(temp_dir, \"zipapp.pyz\"),\n+            )\n+            stdout, _ = self._run_pdb(\n+                [os.path.join(temp_dir, \"zipapp.pyz\")],\n+                \"\\n\".join([\"b f\", \"c\", \"p x\", \"q\"]),\n+            )\n+            self.assertIn(\"42\", stdout)\n+            self.assertIn(\"return x + 1\", stdout)\n \n     def test_zipimport(self):\n         with os_helper.temp_dir() as temp_dir:\n-            os.mkdir(os.path.join(temp_dir, 'source'))\n+            os.mkdir(os.path.join(temp_dir, \"source\"))\n             zipmodule = textwrap.dedent(\n                 \"\"\"\n                 def bar():\n@@ -4518,26 +4688,33 @@ def bar():\n             )\n             script = textwrap.dedent(\n                 f\"\"\"\n-                import sys; sys.path.insert(0, {repr(os.path.join(temp_dir, 'zipmodule.zip'))})\n+                import sys; sys.path.insert(0, {repr(os.path.join(temp_dir, \"zipmodule.zip\"))})\n                 import foo\n                 foo.bar()\n                 \"\"\"\n             )\n \n-            with zipfile.ZipFile(os.path.join(temp_dir, 'zipmodule.zip'), 'w') as zf:\n-                zf.writestr('foo.py', zipmodule)\n-            with open(os.path.join(temp_dir, 'script.py'), 'w') as f:\n+            with zipfile.ZipFile(\n+                os.path.join(temp_dir, \"zipmodule.zip\"), \"w\"\n+            ) as zf:\n+                zf.writestr(\"foo.py\", zipmodule)\n+            with open(os.path.join(temp_dir, \"script.py\"), \"w\") as f:\n                 f.write(script)\n \n-            stdout, _ = self._run_pdb([os.path.join(temp_dir, 'script.py')], '\\n'.join([\n-                'n',\n-                'n',\n-                'b foo.bar',\n-                'c',\n-                'p f\"break in {$_frame.f_code.co_name}\"',\n-                'q'\n-            ]))\n-            self.assertIn('break in bar', stdout)\n+            stdout, _ = self._run_pdb(\n+                [os.path.join(temp_dir, \"script.py\")],\n+                \"\\n\".join(\n+                    [\n+                        \"n\",\n+                        \"n\",\n+                        \"b foo.bar\",\n+                        \"c\",\n+                        'p f\"break in {$_frame.f_code.co_name}\"',\n+                        \"q\",\n+                    ]\n+                ),\n+            )\n+            self.assertIn(\"break in bar\", stdout)\n \n \n class ChecklineTests(unittest.TestCase):\n@@ -4579,30 +4756,31 @@ def test_checkline_is_not_executable(self):\n \n @support.requires_subprocess()\n class PdbTestInline(unittest.TestCase):\n-    @unittest.skipIf(sys.flags.safe_path,\n-                     'PYTHONSAFEPATH changes default sys.path')\n-    def _run_script(self, script, commands,\n-                    expected_returncode=0,\n-                    extra_env=None):\n-        self.addCleanup(os_helper.rmtree, '__pycache__')\n-        filename = 'main.py'\n-        with open(filename, 'w') as f:\n+    @unittest.skipIf(\n+        sys.flags.safe_path, \"PYTHONSAFEPATH changes default sys.path\"\n+    )\n+    def _run_script(\n+        self, script, commands, expected_returncode=0, extra_env=None\n+    ):\n+        self.addCleanup(os_helper.rmtree, \"__pycache__\")\n+        filename = \"main.py\"\n+        with open(filename, \"w\") as f:\n             f.write(textwrap.dedent(script))\n         self.addCleanup(os_helper.unlink, filename)\n \n         commands = textwrap.dedent(commands)\n \n-        cmd = [sys.executable, 'main.py']\n+        cmd = [sys.executable, \"main.py\"]\n         if extra_env is not None:\n             env = os.environ | extra_env\n         else:\n             env = os.environ\n         with subprocess.Popen(\n-                cmd,\n-                stdout=subprocess.PIPE,\n-                stdin=subprocess.PIPE,\n-                stderr=subprocess.PIPE,\n-                env = {**env, 'PYTHONIOENCODING': 'utf-8'}\n+            cmd,\n+            stdout=subprocess.PIPE,\n+            stdin=subprocess.PIPE,\n+            stderr=subprocess.PIPE,\n+            env={**env, \"PYTHONIOENCODING\": \"utf-8\"},\n         ) as proc:\n             stdout, stderr = proc.communicate(str.encode(commands))\n         stdout = bytes.decode(stdout) if isinstance(stdout, bytes) else stdout\n@@ -4610,7 +4788,7 @@ def _run_script(self, script, commands,\n         self.assertEqual(\n             proc.returncode,\n             expected_returncode,\n-            f\"Unexpected return code\\nstdout: {stdout}\\nstderr: {stderr}\"\n+            f\"Unexpected return code\\nstdout: {stdout}\\nstderr: {stderr}\",\n         )\n         return stdout, stderr\n \n@@ -4628,7 +4806,9 @@ def test_quit(self):\n             y\n         \"\"\"\n \n-        stdout, stderr = self._run_script(script, commands, expected_returncode=1)\n+        stdout, stderr = self._run_script(\n+            script, commands, expected_returncode=1\n+        )\n         self.assertIn(\"2\", stdout)\n         self.assertIn(\"Quit anyway\", stdout)\n         # Closing stdin will quit the debugger anyway so we need to confirm\n@@ -4658,7 +4838,9 @@ def test_quit_after_interact(self):\n             y\n         \"\"\"\n \n-        stdout, stderr = self._run_script(script, commands, expected_returncode=1)\n+        stdout, stderr = self._run_script(\n+            script, commands, expected_returncode=1\n+        )\n         # Normal exit should not print anything to stderr\n         self.assertEqual(stderr, \"\")\n         # The quit prompt should be printed exactly once\n@@ -4725,23 +4907,23 @@ def tearDown(self):\n     def test_code_display(self):\n         output = io.StringIO()\n         p = pdb.Pdb(stdout=output, colorize=True)\n-        p.set_trace(commands=['ll', 'c'])\n+        p.set_trace(commands=[\"ll\", \"c\"])\n         self.assertIn(\"\\x1b\", output.getvalue())\n \n         output = io.StringIO()\n         p = pdb.Pdb(stdout=output, colorize=False)\n-        p.set_trace(commands=['ll', 'c'])\n+        p.set_trace(commands=[\"ll\", \"c\"])\n         self.assertNotIn(\"\\x1b\", output.getvalue())\n \n         output = io.StringIO()\n         p = pdb.Pdb(stdout=output)\n-        p.set_trace(commands=['ll', 'c'])\n+        p.set_trace(commands=[\"ll\", \"c\"])\n         self.assertNotIn(\"\\x1b\", output.getvalue())\n \n     def test_stack_entry(self):\n         output = io.StringIO()\n         p = pdb.Pdb(stdout=output, colorize=True)\n-        p.set_trace(commands=['w', 'c'])\n+        p.set_trace(commands=[\"w\", \"c\"])\n         self.assertIn(\"\\x1b\", output.getvalue())\n \n \n@@ -4752,6 +4934,7 @@ def test_return_from_inline_mode_to_REPL(self):\n         # GH-124703: Raise BdbQuit when exiting pdb in REPL session.\n         # This allows the REPL session to continue.\n         from test.test_repl import spawn_repl\n+\n         p = spawn_repl()\n         user_input = \"\"\"\n             x = 'Spam'\n@@ -4761,24 +4944,25 @@ def test_return_from_inline_mode_to_REPL(self):\n         \"\"\"\n         p.stdin.write(textwrap.dedent(user_input))\n         output = kill_python(p)\n-        self.assertIn('SpamDuring', output)\n+        self.assertIn(\"SpamDuring\", output)\n         self.assertNotIn(\"Quit anyway\", output)\n-        self.assertIn('BdbQuit', output)\n-        self.assertIn('SpamAfter', output)\n+        self.assertIn(\"BdbQuit\", output)\n+        self.assertIn(\"SpamAfter\", output)\n         self.assertEqual(p.returncode, 0)\n \n \n @support.force_not_colorized_test_class\n @support.requires_subprocess()\n class PdbTestReadline(unittest.TestCase):\n-\n     @classmethod\n     def setUpClass(cls):\n         # Ensure that the readline module is loaded\n         # If this fails, the test is skipped because SkipTest will be raised\n-        readline = import_module('readline')\n+        readline = import_module(\"readline\")\n         if readline.backend == \"editline\":\n-            raise unittest.SkipTest(\"libedit readline is not supported for pdb\")\n+            raise unittest.SkipTest(\n+                \"libedit readline is not supported for pdb\"\n+            )\n \n     def test_basic_completion(self):\n         script = textwrap.dedent(\"\"\"\n@@ -4793,10 +4977,10 @@ def test_basic_completion(self):\n \n         output = run_pty(script, input)\n \n-        self.assertIn(b'commands', output)\n-        self.assertIn(b'condition', output)\n-        self.assertIn(b'continue', output)\n-        self.assertIn(b'hello!', output)\n+        self.assertIn(b\"commands\", output)\n+        self.assertIn(b\"condition\", output)\n+        self.assertIn(b\"continue\", output)\n+        self.assertIn(b\"hello!\", output)\n \n     def test_expression_completion(self):\n         script = textwrap.dedent(\"\"\"\n@@ -4815,9 +4999,9 @@ def test_expression_completion(self):\n \n         output = run_pty(script, input)\n \n-        self.assertIn(b'special', output)\n-        self.assertIn(b'species', output)\n-        self.assertIn(b'$_frame', output)\n+        self.assertIn(b\"special\", output)\n+        self.assertIn(b\"species\", output)\n+        self.assertIn(b\"$_frame\", output)\n \n     def test_builtin_completion(self):\n         script = textwrap.dedent(\"\"\"\n@@ -4833,7 +5017,7 @@ def test_builtin_completion(self):\n \n         output = run_pty(script, input)\n \n-        self.assertIn(b'special', output)\n+        self.assertIn(b\"special\", output)\n \n     def test_convvar_completion(self):\n         script = textwrap.dedent(\"\"\"\n@@ -4851,8 +5035,8 @@ def test_convvar_completion(self):\n \n         output = run_pty(script, input)\n \n-        self.assertIn(b'<frame at 0x', output)\n-        self.assertIn(b'102', output)\n+        self.assertIn(b\"<frame at 0x\", output)\n+        self.assertIn(b\"102\", output)\n \n     def test_local_namespace(self):\n         script = textwrap.dedent(\"\"\"\n@@ -4870,10 +5054,12 @@ def f():\n \n         output = run_pty(script, input)\n \n-        self.assertIn(b'I love Python', output)\n+        self.assertIn(b\"I love Python\", output)\n \n-    @unittest.skipIf(sys.platform.startswith('freebsd'),\n-                     '\\\\x08 is not interpreted as backspace on FreeBSD')\n+    @unittest.skipIf(\n+        sys.platform.startswith(\"freebsd\"),\n+        \"\\\\x08 is not interpreted as backspace on FreeBSD\",\n+    )\n     def test_multiline_auto_indent(self):\n         script = textwrap.dedent(\"\"\"\n             import pdb; pdb.Pdb().set_trace()\n@@ -4892,7 +5078,7 @@ def test_multiline_auto_indent(self):\n \n         output = run_pty(script, input)\n \n-        self.assertIn(b'42', output)\n+        self.assertIn(b\"42\", output)\n \n     def test_multiline_completion(self):\n         script = textwrap.dedent(\"\"\"\n@@ -4910,10 +5096,12 @@ def test_multiline_completion(self):\n \n         output = run_pty(script, input)\n \n-        self.assertIn(b'42', output)\n+        self.assertIn(b\"42\", output)\n \n-    @unittest.skipIf(sys.platform.startswith('freebsd'),\n-                     '\\\\x08 is not interpreted as backspace on FreeBSD')\n+    @unittest.skipIf(\n+        sys.platform.startswith(\"freebsd\"),\n+        \"\\\\x08 is not interpreted as backspace on FreeBSD\",\n+    )\n     def test_multiline_indent_completion(self):\n         script = textwrap.dedent(\"\"\"\n             import pdb; pdb.Pdb().set_trace()\n@@ -4938,8 +5126,8 @@ def func():\n \n         output = run_pty(script, input)\n \n-        self.assertIn(b'5', output)\n-        self.assertNotIn(b'Error', output)\n+        self.assertIn(b\"5\", output)\n+        self.assertNotIn(b\"Error\", output)\n \n     def test_interact_completion(self):\n         script = textwrap.dedent(\"\"\"\n@@ -4966,8 +5154,8 @@ def test_interact_completion(self):\n         output = run_pty(script, input)\n \n         self.assertIn(b\"'disp' is not defined\", output)\n-        self.assertIn(b'special', output)\n-        self.assertIn(b'84', output)\n+        self.assertIn(b\"special\", output)\n+        self.assertIn(b\"84\", output)\n \n \n def load_tests(loader, tests, pattern):\n@@ -4976,7 +5164,9 @@ def load_tests(loader, tests, pattern):\n     def setUpPdbBackend(backend):\n         def setUp(test):\n             import pdb\n+\n             pdb.set_default_backend(backend)\n+\n         return setUp\n \n     def tearDown(test):\n@@ -4993,6 +5183,7 @@ def tearDown(test):\n \n         # clear all the breakpoints left\n         import bdb\n+\n         bdb.Breakpoint.clearBreakpoints()\n \n         # Stop tracing and clear the pdb instance cache\n@@ -5007,19 +5198,19 @@ def tearDown(test):\n     tests.addTest(\n         doctest.DocTestSuite(\n             test_pdb,\n-            setUp=setUpPdbBackend('monitoring'),\n+            setUp=setUpPdbBackend(\"monitoring\"),\n             tearDown=tearDown,\n         )\n     )\n     tests.addTest(\n         doctest.DocTestSuite(\n             test_pdb,\n-            setUp=setUpPdbBackend('settrace'),\n+            setUp=setUpPdbBackend(\"settrace\"),\n             tearDown=tearDown,\n         )\n     )\n     return tests\n \n \n-if __name__ == '__main__':\n+if __name__ == \"__main__\":\n     unittest.main()\ndiff --git a/Lib/test/test_regrtest.py b/Lib/test/test_regrtest.py\nindex c27b3c86..2ec3b529 100644\n--- a/Lib/test/test_regrtest.py\n+++ b/Lib/test/test_regrtest.py\n@@ -32,27 +32,31 @@\n from test.libregrtest import main\n from test.libregrtest import setup\n from test.libregrtest import utils\n-from test.libregrtest.filter import get_match_tests, set_match_tests, match_test\n+from test.libregrtest.filter import (\n+    get_match_tests,\n+    set_match_tests,\n+    match_test,\n+)\n from test.libregrtest.result import TestStats\n from test.libregrtest.utils import normalize_test_name\n \n if not support.has_subprocess_support:\n     raise unittest.SkipTest(\"test module requires subprocess\")\n \n-ROOT_DIR = os.path.join(os.path.dirname(__file__), '..', '..')\n+ROOT_DIR = os.path.join(os.path.dirname(__file__), \"..\", \"..\")\n ROOT_DIR = os.path.abspath(os.path.normpath(ROOT_DIR))\n-LOG_PREFIX = r'[0-9]+:[0-9]+:[0-9]+ (?:load avg: [0-9]+\\.[0-9]{2} )?'\n+LOG_PREFIX = r\"[0-9]+:[0-9]+:[0-9]+ (?:load avg: [0-9]+\\.[0-9]{2} )?\"\n RESULT_REGEX = (\n-    'passed',\n-    'failed',\n-    'skipped',\n-    'interrupted',\n-    'env changed',\n-    'timed out',\n-    'ran no tests',\n-    'worker non-zero exit code',\n+    \"passed\",\n+    \"failed\",\n+    \"skipped\",\n+    \"interrupted\",\n+    \"env changed\",\n+    \"timed out\",\n+    \"ran no tests\",\n+    \"worker non-zero exit code\",\n )\n-RESULT_REGEX = fr'(?:{\"|\".join(RESULT_REGEX)})'\n+RESULT_REGEX = rf\"(?:{'|'.join(RESULT_REGEX)})\"\n \n EXITCODE_BAD_TEST = 2\n EXITCODE_ENV_CHANGED = 3\n@@ -85,99 +89,101 @@ def checkError(self, args, msg):\n         self.assertIn(msg, err.getvalue())\n \n     def test_help(self):\n-        for opt in '-h', '--help':\n+        for opt in \"-h\", \"--help\":\n             with self.subTest(opt=opt):\n-                with support.captured_stdout() as out, \\\n-                     self.assertRaises(SystemExit):\n+                with (\n+                    support.captured_stdout() as out,\n+                    self.assertRaises(SystemExit),\n+                ):\n                     self.parse_args([opt])\n-                self.assertIn('Run Python regression tests.', out.getvalue())\n+                self.assertIn(\"Run Python regression tests.\", out.getvalue())\n \n     def test_timeout(self):\n-        ns = self.parse_args(['--timeout', '4.2'])\n+        ns = self.parse_args([\"--timeout\", \"4.2\"])\n         self.assertEqual(ns.timeout, 4.2)\n \n         # negative, zero and empty string are treated as \"no timeout\"\n-        for value in ('-1', '0', ''):\n+        for value in (\"-1\", \"0\", \"\"):\n             with self.subTest(value=value):\n-                ns = self.parse_args([f'--timeout={value}'])\n+                ns = self.parse_args([f\"--timeout={value}\"])\n                 self.assertEqual(ns.timeout, None)\n \n-        self.checkError(['--timeout'], 'expected one argument')\n-        self.checkError(['--timeout', 'foo'], 'invalid timeout value:')\n+        self.checkError([\"--timeout\"], \"expected one argument\")\n+        self.checkError([\"--timeout\", \"foo\"], \"invalid timeout value:\")\n \n     def test_wait(self):\n-        ns = self.parse_args(['--wait'])\n+        ns = self.parse_args([\"--wait\"])\n         self.assertTrue(ns.wait)\n \n     def test_start(self):\n-        for opt in '-S', '--start':\n+        for opt in \"-S\", \"--start\":\n             with self.subTest(opt=opt):\n-                ns = self.parse_args([opt, 'foo'])\n-                self.assertEqual(ns.start, 'foo')\n-                self.checkError([opt], 'expected one argument')\n+                ns = self.parse_args([opt, \"foo\"])\n+                self.assertEqual(ns.start, \"foo\")\n+                self.checkError([opt], \"expected one argument\")\n \n     def test_verbose(self):\n-        ns = self.parse_args(['-v'])\n+        ns = self.parse_args([\"-v\"])\n         self.assertEqual(ns.verbose, 1)\n-        ns = self.parse_args(['-vvv'])\n+        ns = self.parse_args([\"-vvv\"])\n         self.assertEqual(ns.verbose, 3)\n-        ns = self.parse_args(['--verbose'])\n+        ns = self.parse_args([\"--verbose\"])\n         self.assertEqual(ns.verbose, 1)\n-        ns = self.parse_args(['--verbose'] * 3)\n+        ns = self.parse_args([\"--verbose\"] * 3)\n         self.assertEqual(ns.verbose, 3)\n         ns = self.parse_args([])\n         self.assertEqual(ns.verbose, 0)\n \n     def test_rerun(self):\n-        for opt in '-w', '--rerun', '--verbose2':\n+        for opt in \"-w\", \"--rerun\", \"--verbose2\":\n             with self.subTest(opt=opt):\n                 ns = self.parse_args([opt])\n                 self.assertTrue(ns.rerun)\n \n     def test_verbose3(self):\n-        for opt in '-W', '--verbose3':\n+        for opt in \"-W\", \"--verbose3\":\n             with self.subTest(opt=opt):\n                 ns = self.parse_args([opt])\n                 self.assertTrue(ns.verbose3)\n \n     def test_quiet(self):\n-        for opt in '-q', '--quiet':\n+        for opt in \"-q\", \"--quiet\":\n             with self.subTest(opt=opt):\n                 ns = self.parse_args([opt])\n                 self.assertTrue(ns.quiet)\n                 self.assertEqual(ns.verbose, 0)\n \n     def test_slowest(self):\n-        for opt in '-o', '--slowest':\n+        for opt in \"-o\", \"--slowest\":\n             with self.subTest(opt=opt):\n                 ns = self.parse_args([opt])\n                 self.assertTrue(ns.print_slow)\n \n     def test_header(self):\n-        ns = self.parse_args(['--header'])\n+        ns = self.parse_args([\"--header\"])\n         self.assertTrue(ns.header)\n \n-        ns = self.parse_args(['--verbose'])\n+        ns = self.parse_args([\"--verbose\"])\n         self.assertTrue(ns.header)\n \n     def test_randomize(self):\n-        for opt in ('-r', '--randomize'):\n+        for opt in (\"-r\", \"--randomize\"):\n             with self.subTest(opt=opt):\n                 ns = self.parse_args([opt])\n                 self.assertTrue(ns.randomize)\n \n         with os_helper.EnvironmentVarGuard() as env:\n             # with SOURCE_DATE_EPOCH\n-            env['SOURCE_DATE_EPOCH'] = '1697839080'\n-            ns = self.parse_args(['--randomize'])\n+            env[\"SOURCE_DATE_EPOCH\"] = \"1697839080\"\n+            ns = self.parse_args([\"--randomize\"])\n             regrtest = main.Regrtest(ns)\n             self.assertFalse(regrtest.randomize)\n             self.assertIsInstance(regrtest.random_seed, str)\n-            self.assertEqual(regrtest.random_seed, '1697839080')\n+            self.assertEqual(regrtest.random_seed, \"1697839080\")\n \n             # without SOURCE_DATE_EPOCH\n-            del env['SOURCE_DATE_EPOCH']\n-            ns = self.parse_args(['--randomize'])\n+            del env[\"SOURCE_DATE_EPOCH\"]\n+            ns = self.parse_args([\"--randomize\"])\n             regrtest = main.Regrtest(ns)\n             self.assertTrue(regrtest.randomize)\n             self.assertIsInstance(regrtest.random_seed, int)\n@@ -199,152 +205,164 @@ def test_no_randomize(self):\n         self.assertIs(ns.randomize, False)\n \n     def test_randseed(self):\n-        ns = self.parse_args(['--randseed', '12345'])\n+        ns = self.parse_args([\"--randseed\", \"12345\"])\n         self.assertEqual(ns.random_seed, 12345)\n         self.assertTrue(ns.randomize)\n-        self.checkError(['--randseed'], 'expected one argument')\n-        self.checkError(['--randseed', 'foo'], 'invalid int value')\n+        self.checkError([\"--randseed\"], \"expected one argument\")\n+        self.checkError([\"--randseed\", \"foo\"], \"invalid int value\")\n \n-        ns = self.parse_args(['--randseed', '12345', '--no-randomize'])\n+        ns = self.parse_args([\"--randseed\", \"12345\", \"--no-randomize\"])\n         self.assertEqual(ns.random_seed, 12345)\n         self.assertFalse(ns.randomize)\n \n     def test_fromfile(self):\n-        for opt in '-f', '--fromfile':\n+        for opt in \"-f\", \"--fromfile\":\n             with self.subTest(opt=opt):\n-                ns = self.parse_args([opt, 'foo'])\n-                self.assertEqual(ns.fromfile, 'foo')\n-                self.checkError([opt], 'expected one argument')\n-                self.checkError([opt, 'foo', '-s'], \"don't go together\")\n+                ns = self.parse_args([opt, \"foo\"])\n+                self.assertEqual(ns.fromfile, \"foo\")\n+                self.checkError([opt], \"expected one argument\")\n+                self.checkError([opt, \"foo\", \"-s\"], \"don't go together\")\n \n     def test_exclude(self):\n-        for opt in '-x', '--exclude':\n+        for opt in \"-x\", \"--exclude\":\n             with self.subTest(opt=opt):\n                 ns = self.parse_args([opt])\n                 self.assertTrue(ns.exclude)\n \n     def test_single(self):\n-        for opt in '-s', '--single':\n+        for opt in \"-s\", \"--single\":\n             with self.subTest(opt=opt):\n                 ns = self.parse_args([opt])\n                 self.assertTrue(ns.single)\n-                self.checkError([opt, '-f', 'foo'], \"don't go together\")\n+                self.checkError([opt, \"-f\", \"foo\"], \"don't go together\")\n \n     def test_match(self):\n-        for opt in '-m', '--match':\n+        for opt in \"-m\", \"--match\":\n             with self.subTest(opt=opt):\n-                ns = self.parse_args([opt, 'pattern'])\n-                self.assertEqual(ns.match_tests, [('pattern', True)])\n-                self.checkError([opt], 'expected one argument')\n+                ns = self.parse_args([opt, \"pattern\"])\n+                self.assertEqual(ns.match_tests, [(\"pattern\", True)])\n+                self.checkError([opt], \"expected one argument\")\n \n-        for opt in '-i', '--ignore':\n+        for opt in \"-i\", \"--ignore\":\n             with self.subTest(opt=opt):\n-                ns = self.parse_args([opt, 'pattern'])\n-                self.assertEqual(ns.match_tests, [('pattern', False)])\n-                self.checkError([opt], 'expected one argument')\n+                ns = self.parse_args([opt, \"pattern\"])\n+                self.assertEqual(ns.match_tests, [(\"pattern\", False)])\n+                self.checkError([opt], \"expected one argument\")\n \n-        ns = self.parse_args(['-m', 'pattern1', '-m', 'pattern2'])\n-        self.assertEqual(ns.match_tests, [('pattern1', True), ('pattern2', True)])\n+        ns = self.parse_args([\"-m\", \"pattern1\", \"-m\", \"pattern2\"])\n+        self.assertEqual(\n+            ns.match_tests, [(\"pattern1\", True), (\"pattern2\", True)]\n+        )\n \n-        ns = self.parse_args(['-m', 'pattern1', '-i', 'pattern2'])\n-        self.assertEqual(ns.match_tests, [('pattern1', True), ('pattern2', False)])\n+        ns = self.parse_args([\"-m\", \"pattern1\", \"-i\", \"pattern2\"])\n+        self.assertEqual(\n+            ns.match_tests, [(\"pattern1\", True), (\"pattern2\", False)]\n+        )\n \n-        ns = self.parse_args(['-i', 'pattern1', '-m', 'pattern2'])\n-        self.assertEqual(ns.match_tests, [('pattern1', False), ('pattern2', True)])\n+        ns = self.parse_args([\"-i\", \"pattern1\", \"-m\", \"pattern2\"])\n+        self.assertEqual(\n+            ns.match_tests, [(\"pattern1\", False), (\"pattern2\", True)]\n+        )\n \n         self.addCleanup(os_helper.unlink, os_helper.TESTFN)\n         with open(os_helper.TESTFN, \"w\") as fp:\n-            print('matchfile1', file=fp)\n-            print('matchfile2', file=fp)\n+            print(\"matchfile1\", file=fp)\n+            print(\"matchfile2\", file=fp)\n \n         filename = os.path.abspath(os_helper.TESTFN)\n-        ns = self.parse_args(['-m', 'match', '--matchfile', filename])\n-        self.assertEqual(ns.match_tests,\n-                         [('match', True), ('matchfile1', True), ('matchfile2', True)])\n+        ns = self.parse_args([\"-m\", \"match\", \"--matchfile\", filename])\n+        self.assertEqual(\n+            ns.match_tests,\n+            [(\"match\", True), (\"matchfile1\", True), (\"matchfile2\", True)],\n+        )\n \n-        ns = self.parse_args(['-i', 'match', '--ignorefile', filename])\n-        self.assertEqual(ns.match_tests,\n-                         [('match', False), ('matchfile1', False), ('matchfile2', False)])\n+        ns = self.parse_args([\"-i\", \"match\", \"--ignorefile\", filename])\n+        self.assertEqual(\n+            ns.match_tests,\n+            [(\"match\", False), (\"matchfile1\", False), (\"matchfile2\", False)],\n+        )\n \n     def test_failfast(self):\n-        for opt in '-G', '--failfast':\n+        for opt in \"-G\", \"--failfast\":\n             with self.subTest(opt=opt):\n-                ns = self.parse_args([opt, '-v'])\n+                ns = self.parse_args([opt, \"-v\"])\n                 self.assertTrue(ns.failfast)\n-                ns = self.parse_args([opt, '-W'])\n+                ns = self.parse_args([opt, \"-W\"])\n                 self.assertTrue(ns.failfast)\n-                self.checkError([opt], '-G/--failfast needs either -v or -W')\n+                self.checkError([opt], \"-G/--failfast needs either -v or -W\")\n \n     def test_use(self):\n-        for opt in '-u', '--use':\n+        for opt in \"-u\", \"--use\":\n             with self.subTest(opt=opt):\n-                ns = self.parse_args([opt, 'gui,network'])\n-                self.assertEqual(ns.use_resources, ['gui', 'network'])\n+                ns = self.parse_args([opt, \"gui,network\"])\n+                self.assertEqual(ns.use_resources, [\"gui\", \"network\"])\n \n-                ns = self.parse_args([opt, 'gui,none,network'])\n-                self.assertEqual(ns.use_resources, ['network'])\n+                ns = self.parse_args([opt, \"gui,none,network\"])\n+                self.assertEqual(ns.use_resources, [\"network\"])\n \n                 expected = list(cmdline.ALL_RESOURCES)\n-                expected.remove('gui')\n-                ns = self.parse_args([opt, 'all,-gui'])\n+                expected.remove(\"gui\")\n+                ns = self.parse_args([opt, \"all,-gui\"])\n                 self.assertEqual(ns.use_resources, expected)\n-                self.checkError([opt], 'expected one argument')\n-                self.checkError([opt, 'foo'], 'invalid resource')\n+                self.checkError([opt], \"expected one argument\")\n+                self.checkError([opt, \"foo\"], \"invalid resource\")\n \n                 # all + a resource not part of \"all\"\n-                ns = self.parse_args([opt, 'all,tzdata'])\n-                self.assertEqual(ns.use_resources,\n-                                 list(cmdline.ALL_RESOURCES) + ['tzdata'])\n+                ns = self.parse_args([opt, \"all,tzdata\"])\n+                self.assertEqual(\n+                    ns.use_resources, list(cmdline.ALL_RESOURCES) + [\"tzdata\"]\n+                )\n \n                 # test another resource which is not part of \"all\"\n-                ns = self.parse_args([opt, 'extralargefile'])\n-                self.assertEqual(ns.use_resources, ['extralargefile'])\n+                ns = self.parse_args([opt, \"extralargefile\"])\n+                self.assertEqual(ns.use_resources, [\"extralargefile\"])\n \n     def test_memlimit(self):\n-        for opt in '-M', '--memlimit':\n+        for opt in \"-M\", \"--memlimit\":\n             with self.subTest(opt=opt):\n-                ns = self.parse_args([opt, '4G'])\n-                self.assertEqual(ns.memlimit, '4G')\n-                self.checkError([opt], 'expected one argument')\n+                ns = self.parse_args([opt, \"4G\"])\n+                self.assertEqual(ns.memlimit, \"4G\")\n+                self.checkError([opt], \"expected one argument\")\n \n     def test_testdir(self):\n-        ns = self.parse_args(['--testdir', 'foo'])\n-        self.assertEqual(ns.testdir, os.path.join(os_helper.SAVEDCWD, 'foo'))\n-        self.checkError(['--testdir'], 'expected one argument')\n+        ns = self.parse_args([\"--testdir\", \"foo\"])\n+        self.assertEqual(ns.testdir, os.path.join(os_helper.SAVEDCWD, \"foo\"))\n+        self.checkError([\"--testdir\"], \"expected one argument\")\n \n     def test_runleaks(self):\n-        for opt in '-L', '--runleaks':\n+        for opt in \"-L\", \"--runleaks\":\n             with self.subTest(opt=opt):\n                 ns = self.parse_args([opt])\n                 self.assertTrue(ns.runleaks)\n \n     def test_huntrleaks(self):\n-        for opt in '-R', '--huntrleaks':\n+        for opt in \"-R\", \"--huntrleaks\":\n             with self.subTest(opt=opt):\n-                ns = self.parse_args([opt, ':'])\n-                self.assertEqual(ns.huntrleaks, (5, 4, 'reflog.txt'))\n-                ns = self.parse_args([opt, '6:'])\n-                self.assertEqual(ns.huntrleaks, (6, 4, 'reflog.txt'))\n-                ns = self.parse_args([opt, ':3'])\n-                self.assertEqual(ns.huntrleaks, (5, 3, 'reflog.txt'))\n-                ns = self.parse_args([opt, '6:3:leaks.log'])\n-                self.assertEqual(ns.huntrleaks, (6, 3, 'leaks.log'))\n-                self.checkError([opt], 'expected one argument')\n-                self.checkError([opt, '6'],\n-                                'needs 2 or 3 colon-separated arguments')\n-                self.checkError([opt, 'foo:'], 'invalid huntrleaks value')\n-                self.checkError([opt, '6:foo'], 'invalid huntrleaks value')\n+                ns = self.parse_args([opt, \":\"])\n+                self.assertEqual(ns.huntrleaks, (5, 4, \"reflog.txt\"))\n+                ns = self.parse_args([opt, \"6:\"])\n+                self.assertEqual(ns.huntrleaks, (6, 4, \"reflog.txt\"))\n+                ns = self.parse_args([opt, \":3\"])\n+                self.assertEqual(ns.huntrleaks, (5, 3, \"reflog.txt\"))\n+                ns = self.parse_args([opt, \"6:3:leaks.log\"])\n+                self.assertEqual(ns.huntrleaks, (6, 3, \"leaks.log\"))\n+                self.checkError([opt], \"expected one argument\")\n+                self.checkError(\n+                    [opt, \"6\"], \"needs 2 or 3 colon-separated arguments\"\n+                )\n+                self.checkError([opt, \"foo:\"], \"invalid huntrleaks value\")\n+                self.checkError([opt, \"6:foo\"], \"invalid huntrleaks value\")\n \n     def test_multiprocess(self):\n-        for opt in '-j', '--multiprocess':\n+        for opt in \"-j\", \"--multiprocess\":\n             with self.subTest(opt=opt):\n-                ns = self.parse_args([opt, '2'])\n+                ns = self.parse_args([opt, \"2\"])\n                 self.assertEqual(ns.use_mp, 2)\n-                self.checkError([opt], 'expected one argument')\n-                self.checkError([opt, 'foo'], 'invalid int value')\n+                self.checkError([opt], \"expected one argument\")\n+                self.checkError([opt, \"foo\"], \"invalid int value\")\n \n     def test_coverage_sequential(self):\n-        for opt in '-T', '--coverage':\n+        for opt in \"-T\", \"--coverage\":\n             with self.subTest(opt=opt):\n                 with support.captured_stderr() as stderr:\n                     ns = self.parse_args([opt])\n@@ -354,86 +372,88 @@ def test_coverage_sequential(self):\n                     stderr.getvalue(),\n                 )\n \n-    @unittest.skipUnless(support.Py_DEBUG, 'need a debug build')\n+    @unittest.skipUnless(support.Py_DEBUG, \"need a debug build\")\n     def test_coverage_mp(self):\n-        for opt in '-T', '--coverage':\n+        for opt in \"-T\", \"--coverage\":\n             with self.subTest(opt=opt):\n-                ns = self.parse_args([opt, '-j1'])\n+                ns = self.parse_args([opt, \"-j1\"])\n                 self.assertTrue(ns.trace)\n \n     def test_coverdir(self):\n-        for opt in '-D', '--coverdir':\n+        for opt in \"-D\", \"--coverdir\":\n             with self.subTest(opt=opt):\n-                ns = self.parse_args([opt, 'foo'])\n-                self.assertEqual(ns.coverdir,\n-                                 os.path.join(os_helper.SAVEDCWD, 'foo'))\n-                self.checkError([opt], 'expected one argument')\n+                ns = self.parse_args([opt, \"foo\"])\n+                self.assertEqual(\n+                    ns.coverdir, os.path.join(os_helper.SAVEDCWD, \"foo\")\n+                )\n+                self.checkError([opt], \"expected one argument\")\n \n     def test_nocoverdir(self):\n-        for opt in '-N', '--nocoverdir':\n+        for opt in \"-N\", \"--nocoverdir\":\n             with self.subTest(opt=opt):\n                 ns = self.parse_args([opt])\n                 self.assertIsNone(ns.coverdir)\n \n     def test_threshold(self):\n-        for opt in '-t', '--threshold':\n+        for opt in \"-t\", \"--threshold\":\n             with self.subTest(opt=opt):\n-                ns = self.parse_args([opt, '1000'])\n+                ns = self.parse_args([opt, \"1000\"])\n                 self.assertEqual(ns.threshold, 1000)\n-                self.checkError([opt], 'expected one argument')\n-                self.checkError([opt, 'foo'], 'invalid int value')\n+                self.checkError([opt], \"expected one argument\")\n+                self.checkError([opt, \"foo\"], \"invalid int value\")\n \n     def test_nowindows(self):\n-        for opt in '-n', '--nowindows':\n+        for opt in \"-n\", \"--nowindows\":\n             with self.subTest(opt=opt):\n                 with contextlib.redirect_stderr(io.StringIO()) as stderr:\n                     ns = self.parse_args([opt])\n                 self.assertTrue(ns.nowindows)\n                 err = stderr.getvalue()\n-                self.assertIn('the --nowindows (-n) option is deprecated', err)\n+                self.assertIn(\"the --nowindows (-n) option is deprecated\", err)\n \n     def test_forever(self):\n-        for opt in '-F', '--forever':\n+        for opt in \"-F\", \"--forever\":\n             with self.subTest(opt=opt):\n                 ns = self.parse_args([opt])\n                 self.assertTrue(ns.forever)\n \n     def test_unrecognized_argument(self):\n-        self.checkError(['--xxx'], 'usage:')\n+        self.checkError([\"--xxx\"], \"usage:\")\n \n     def test_long_option__partial(self):\n-        ns = self.parse_args(['--qui'])\n+        ns = self.parse_args([\"--qui\"])\n         self.assertTrue(ns.quiet)\n         self.assertEqual(ns.verbose, 0)\n \n     def test_two_options(self):\n-        ns = self.parse_args(['--quiet', '--exclude'])\n+        ns = self.parse_args([\"--quiet\", \"--exclude\"])\n         self.assertTrue(ns.quiet)\n         self.assertEqual(ns.verbose, 0)\n         self.assertTrue(ns.exclude)\n \n     def test_option_with_empty_string_value(self):\n-        ns = self.parse_args(['--start', ''])\n-        self.assertEqual(ns.start, '')\n+        ns = self.parse_args([\"--start\", \"\"])\n+        self.assertEqual(ns.start, \"\")\n \n     def test_arg(self):\n-        ns = self.parse_args(['foo'])\n-        self.assertEqual(ns.args, ['foo'])\n+        ns = self.parse_args([\"foo\"])\n+        self.assertEqual(ns.args, [\"foo\"])\n \n     def test_option_and_arg(self):\n-        ns = self.parse_args(['--quiet', 'foo'])\n+        ns = self.parse_args([\"--quiet\", \"foo\"])\n         self.assertTrue(ns.quiet)\n         self.assertEqual(ns.verbose, 0)\n-        self.assertEqual(ns.args, ['foo'])\n+        self.assertEqual(ns.args, [\"foo\"])\n \n     def test_arg_option_arg(self):\n-        ns = self.parse_args(['test_unaryop', '-v', 'test_binop'])\n+        ns = self.parse_args([\"test_unaryop\", \"-v\", \"test_binop\"])\n         self.assertEqual(ns.verbose, 1)\n-        self.assertEqual(ns.args, ['test_unaryop', 'test_binop'])\n+        self.assertEqual(ns.args, [\"test_unaryop\", \"test_binop\"])\n \n     def test_unknown_option(self):\n-        self.checkError(['--unknown-option'],\n-                        'unrecognized arguments: --unknown-option')\n+        self.checkError(\n+            [\"--unknown-option\"], \"unrecognized arguments: --unknown-option\"\n+        )\n \n     def create_regrtest(self, args):\n         ns = cmdline._parse_args(args)\n@@ -442,14 +462,21 @@ def create_regrtest(self, args):\n         # which has an unclear API\n         with os_helper.EnvironmentVarGuard() as env:\n             # Ignore SOURCE_DATE_EPOCH env var if it's set\n-            del env['SOURCE_DATE_EPOCH']\n+            del env[\"SOURCE_DATE_EPOCH\"]\n \n             regrtest = main.Regrtest(ns)\n \n         return regrtest\n \n-    def check_ci_mode(self, args, use_resources,\n-                      *, rerun=True, randomize=True, output_on_failure=True):\n+    def check_ci_mode(\n+        self,\n+        args,\n+        use_resources,\n+        *,\n+        rerun=True,\n+        randomize=True,\n+        output_on_failure=True,\n+    ):\n         regrtest = self.create_regrtest(args)\n         self.assertEqual(regrtest.num_workers, -1)\n         self.assertEqual(regrtest.want_rerun, rerun)\n@@ -463,38 +490,39 @@ def check_ci_mode(self, args, use_resources,\n         return regrtest\n \n     def test_fast_ci(self):\n-        args = ['--fast-ci']\n+        args = [\"--fast-ci\"]\n         use_resources = sorted(cmdline.ALL_RESOURCES)\n-        use_resources.remove('cpu')\n+        use_resources.remove(\"cpu\")\n         regrtest = self.check_ci_mode(args, use_resources)\n         self.assertEqual(regrtest.timeout, 10 * 60)\n \n     def test_fast_ci_python_cmd(self):\n-        args = ['--fast-ci', '--python', 'python -X dev']\n+        args = [\"--fast-ci\", \"--python\", \"python -X dev\"]\n         use_resources = sorted(cmdline.ALL_RESOURCES)\n-        use_resources.remove('cpu')\n+        use_resources.remove(\"cpu\")\n         regrtest = self.check_ci_mode(args, use_resources, rerun=False)\n         self.assertEqual(regrtest.timeout, 10 * 60)\n-        self.assertEqual(regrtest.python_cmd, ('python', '-X', 'dev'))\n+        self.assertEqual(regrtest.python_cmd, (\"python\", \"-X\", \"dev\"))\n \n     def test_fast_ci_resource(self):\n         # it should be possible to override resources individually\n-        args = ['--fast-ci', '-u-network']\n+        args = [\"--fast-ci\", \"-u-network\"]\n         use_resources = sorted(cmdline.ALL_RESOURCES)\n-        use_resources.remove('cpu')\n-        use_resources.remove('network')\n+        use_resources.remove(\"cpu\")\n+        use_resources.remove(\"network\")\n         self.check_ci_mode(args, use_resources)\n \n     def test_fast_ci_verbose(self):\n-        args = ['--fast-ci', '--verbose']\n+        args = [\"--fast-ci\", \"--verbose\"]\n         use_resources = sorted(cmdline.ALL_RESOURCES)\n-        use_resources.remove('cpu')\n-        regrtest = self.check_ci_mode(args, use_resources,\n-                                      output_on_failure=False)\n+        use_resources.remove(\"cpu\")\n+        regrtest = self.check_ci_mode(\n+            args, use_resources, output_on_failure=False\n+        )\n         self.assertEqual(regrtest.verbose, True)\n \n     def test_slow_ci(self):\n-        args = ['--slow-ci']\n+        args = [\"--slow-ci\"]\n         use_resources = sorted(cmdline.ALL_RESOURCES)\n         regrtest = self.check_ci_mode(args, use_resources)\n         self.assertEqual(regrtest.timeout, 20 * 60)\n@@ -505,21 +533,23 @@ def test_ci_no_randomize(self):\n             [\"--slow-ci\", \"--no-randomize\"], all_resources, randomize=False\n         )\n         self.check_ci_mode(\n-            [\"--fast-ci\", \"--no-randomize\"], all_resources - {'cpu'}, randomize=False\n+            [\"--fast-ci\", \"--no-randomize\"],\n+            all_resources - {\"cpu\"},\n+            randomize=False,\n         )\n \n     def test_dont_add_python_opts(self):\n-        args = ['--dont-add-python-opts']\n+        args = [\"--dont-add-python-opts\"]\n         ns = cmdline._parse_args(args)\n         self.assertFalse(ns._add_python_opts)\n \n     def test_bisect(self):\n-        args = ['--bisect']\n+        args = [\"--bisect\"]\n         regrtest = self.create_regrtest(args)\n         self.assertTrue(regrtest.want_bisect)\n \n     def test_verbose3_huntrleaks(self):\n-        args = ['-R', '3:10', '--verbose3']\n+        args = [\"-R\", \"3:10\", \"--verbose3\"]\n         with support.captured_stderr():\n             regrtest = self.create_regrtest(args)\n         self.assertIsNotNone(regrtest.hunt_refleak)\n@@ -528,13 +558,13 @@ def test_verbose3_huntrleaks(self):\n         self.assertFalse(regrtest.output_on_failure)\n \n     def test_single_process(self):\n-        args = ['-j2', '--single-process']\n+        args = [\"-j2\", \"--single-process\"]\n         with support.captured_stderr():\n             regrtest = self.create_regrtest(args)\n         self.assertEqual(regrtest.num_workers, 0)\n         self.assertTrue(regrtest.single_process)\n \n-        args = ['--fast-ci', '--single-process']\n+        args = [\"--fast-ci\", \"--single-process\"]\n         with support.captured_stderr():\n             regrtest = self.create_regrtest(args)\n         self.assertEqual(regrtest.num_workers, 0)\n@@ -550,8 +580,8 @@ class Rerun:\n \n class BaseTestCase(unittest.TestCase):\n     TEST_UNIQUE_ID = 1\n-    TESTNAME_PREFIX = 'test_regrtest_'\n-    TESTNAME_REGEX = r'test_[a-zA-Z0-9_]+'\n+    TESTNAME_PREFIX = \"test_regrtest_\"\n+    TESTNAME_REGEX = r\"test_[a-zA-Z0-9_]+\"\n \n     def setUp(self):\n         self.testdir = os.path.realpath(os.path.dirname(__file__))\n@@ -561,7 +591,7 @@ def setUp(self):\n \n     def create_test(self, name=None, code=None):\n         if not name:\n-            name = 'noop%s' % BaseTestCase.TEST_UNIQUE_ID\n+            name = \"noop%s\" % BaseTestCase.TEST_UNIQUE_ID\n             BaseTestCase.TEST_UNIQUE_ID += 1\n \n         if code is None:\n@@ -576,12 +606,12 @@ def test_empty_test(self):\n         # test_regrtest cannot be run twice in parallel because\n         # of setUp() and create_test()\n         name = self.TESTNAME_PREFIX + name\n-        path = os.path.join(self.tmptestdir, name + '.py')\n+        path = os.path.join(self.tmptestdir, name + \".py\")\n \n         self.addCleanup(os_helper.unlink, path)\n         # Use 'x' mode to ensure that we do not override existing tests\n         try:\n-            with open(path, 'x', encoding='utf-8') as fp:\n+            with open(path, \"x\", encoding=\"utf-8\") as fp:\n                 fp.write(code)\n         except PermissionError as exc:\n             if not sysconfig.is_python_build():\n@@ -599,24 +629,38 @@ def check_line(self, output, pattern, full=False, regex=True):\n         if not regex:\n             pattern = re.escape(pattern)\n         if full:\n-            pattern += '\\n'\n-        regex = re.compile(r'^' + pattern, re.MULTILINE)\n+            pattern += \"\\n\"\n+        regex = re.compile(r\"^\" + pattern, re.MULTILINE)\n         self.assertRegex(output, regex)\n \n     def parse_executed_tests(self, output):\n-        regex = (fr'^{LOG_PREFIX}\\[ *[0-9]+(?:/ *[0-9]+)*\\] '\n-                 fr'({self.TESTNAME_REGEX}) {RESULT_REGEX}')\n+        regex = (\n+            rf\"^{LOG_PREFIX}\\[ *[0-9]+(?:/ *[0-9]+)*\\] \"\n+            rf\"({self.TESTNAME_REGEX}) {RESULT_REGEX}\"\n+        )\n         parser = re.finditer(regex, output, re.MULTILINE)\n         return list(match.group(1) for match in parser)\n \n-    def check_executed_tests(self, output, tests, *, stats,\n-                             skipped=(), failed=(),\n-                             env_changed=(), omitted=(),\n-                             rerun=None, run_no_tests=(),\n-                             resource_denied=(),\n-                             randomize=False, parallel=False, interrupted=False,\n-                             fail_env_changed=False,\n-                             forever=False, filtered=False):\n+    def check_executed_tests(\n+        self,\n+        output,\n+        tests,\n+        *,\n+        stats,\n+        skipped=(),\n+        failed=(),\n+        env_changed=(),\n+        omitted=(),\n+        rerun=None,\n+        run_no_tests=(),\n+        resource_denied=(),\n+        randomize=False,\n+        parallel=False,\n+        interrupted=False,\n+        fail_env_changed=False,\n+        forever=False,\n+        filtered=False,\n+    ):\n         if isinstance(tests, str):\n             tests = [tests]\n         if isinstance(skipped, str):\n@@ -652,72 +696,88 @@ def check_executed_tests(self, output, tests, *, stats,\n             self.assertEqual(executed, total_tests, output)\n \n         def plural(count):\n-            return 's' if count != 1 else ''\n+            return \"s\" if count != 1 else \"\"\n \n         def list_regex(line_format, tests):\n             count = len(tests)\n-            names = ' '.join(sorted(tests))\n+            names = \" \".join(sorted(tests))\n             regex = line_format % (count, plural(count))\n-            regex = r'%s:\\n    %s$' % (regex, names)\n+            regex = r\"%s:\\n    %s$\" % (regex, names)\n             return regex\n \n         if skipped:\n-            regex = list_regex('%s test%s skipped', skipped)\n+            regex = list_regex(\"%s test%s skipped\", skipped)\n             self.check_line(output, regex)\n \n         if resource_denied:\n-            regex = list_regex(r'%s test%s skipped \\(resource denied\\)', resource_denied)\n+            regex = list_regex(\n+                r\"%s test%s skipped \\(resource denied\\)\", resource_denied\n+            )\n             self.check_line(output, regex)\n \n         if failed:\n-            regex = list_regex('%s test%s failed', failed)\n+            regex = list_regex(\"%s test%s failed\", failed)\n             self.check_line(output, regex)\n \n         if env_changed:\n-            regex = list_regex(r'%s test%s altered the execution environment '\n-                               r'\\(env changed\\)',\n-                               env_changed)\n+            regex = list_regex(\n+                r\"%s test%s altered the execution environment \"\n+                r\"\\(env changed\\)\",\n+                env_changed,\n+            )\n             self.check_line(output, regex)\n \n         if omitted:\n-            regex = list_regex('%s test%s omitted', omitted)\n+            regex = list_regex(\"%s test%s omitted\", omitted)\n             self.check_line(output, regex)\n \n         if rerun is not None:\n-            regex = list_regex('%s re-run test%s', [rerun.name])\n+            regex = list_regex(\"%s re-run test%s\", [rerun.name])\n             self.check_line(output, regex)\n             regex = LOG_PREFIX + r\"Re-running 1 failed tests in verbose mode\"\n             self.check_line(output, regex)\n-            regex = fr\"Re-running {rerun.name} in verbose mode\"\n+            regex = rf\"Re-running {rerun.name} in verbose mode\"\n             if rerun.match:\n-                regex = fr\"{regex} \\(matching: {rerun.match}\\)\"\n+                regex = rf\"{regex} \\(matching: {rerun.match}\\)\"\n             self.check_line(output, regex)\n \n         if run_no_tests:\n-            regex = list_regex('%s test%s run no tests', run_no_tests)\n+            regex = list_regex(\"%s test%s run no tests\", run_no_tests)\n             self.check_line(output, regex)\n \n-        good = (len(tests) - len(skipped) - len(resource_denied) - len(failed)\n-                - len(omitted) - len(env_changed) - len(run_no_tests))\n+        good = (\n+            len(tests)\n+            - len(skipped)\n+            - len(resource_denied)\n+            - len(failed)\n+            - len(omitted)\n+            - len(env_changed)\n+            - len(run_no_tests)\n+        )\n         if good:\n-            regex = r'%s test%s OK\\.' % (good, plural(good))\n-            if not skipped and not failed and (rerun is None or rerun.success) and good > 1:\n-                regex = 'All %s' % regex\n+            regex = r\"%s test%s OK\\.\" % (good, plural(good))\n+            if (\n+                not skipped\n+                and not failed\n+                and (rerun is None or rerun.success)\n+                and good > 1\n+            ):\n+                regex = \"All %s\" % regex\n             self.check_line(output, regex, full=True)\n \n         if interrupted:\n-            self.check_line(output, 'Test suite interrupted by signal SIGINT.')\n+            self.check_line(output, \"Test suite interrupted by signal SIGINT.\")\n \n         # Total tests\n-        text = f'run={stats.tests_run:,}'\n+        text = f\"run={stats.tests_run:,}\"\n         if filtered:\n-            text = fr'{text} \\(filtered\\)'\n+            text = rf\"{text} \\(filtered\\)\"\n         parts = [text]\n         if stats.failures:\n-            parts.append(f'failures={stats.failures:,}')\n+            parts.append(f\"failures={stats.failures:,}\")\n         if stats.skipped:\n-            parts.append(f'skipped={stats.skipped:,}')\n-        line = fr'Total tests: {\" \".join(parts)}'\n+            parts.append(f\"skipped={stats.skipped:,}\")\n+        line = rf\"Total tests: {' '.join(parts)}\"\n         self.check_line(output, line, full=True)\n \n         # Total test files\n@@ -730,91 +790,85 @@ def list_regex(line_format, tests):\n             total_rerun = 0\n         if interrupted:\n             run = 0\n-        text = f'run={run}'\n+        text = f\"run={run}\"\n         if not forever:\n-            text = f'{text}/{len(tests)}'\n+            text = f\"{text}/{len(tests)}\"\n         if filtered:\n-            text = fr'{text} \\(filtered\\)'\n+            text = rf\"{text} \\(filtered\\)\"\n         report = [text]\n         for name, ntest in (\n-            ('failed', total_failed),\n-            ('env_changed', len(env_changed)),\n-            ('skipped', len(skipped)),\n-            ('resource_denied', len(resource_denied)),\n-            ('rerun', total_rerun),\n-            ('run_no_tests', len(run_no_tests)),\n+            (\"failed\", total_failed),\n+            (\"env_changed\", len(env_changed)),\n+            (\"skipped\", len(skipped)),\n+            (\"resource_denied\", len(resource_denied)),\n+            (\"rerun\", total_rerun),\n+            (\"run_no_tests\", len(run_no_tests)),\n         ):\n             if ntest:\n-                report.append(f'{name}={ntest}')\n-        line = fr'Total test files: {\" \".join(report)}'\n+                report.append(f\"{name}={ntest}\")\n+        line = rf\"Total test files: {' '.join(report)}\"\n         self.check_line(output, line, full=True)\n \n         # Result\n         state = []\n         if failed:\n-            state.append('FAILURE')\n+            state.append(\"FAILURE\")\n         elif fail_env_changed and env_changed:\n-            state.append('ENV CHANGED')\n+            state.append(\"ENV CHANGED\")\n         if interrupted:\n-            state.append('INTERRUPTED')\n-        if not any((good, failed, interrupted, skipped,\n-                    env_changed, fail_env_changed)):\n+            state.append(\"INTERRUPTED\")\n+        if not any(\n+            (good, failed, interrupted, skipped, env_changed, fail_env_changed)\n+        ):\n             state.append(\"NO TESTS RAN\")\n         elif not state:\n-            state.append('SUCCESS')\n-        state = ', '.join(state)\n+            state.append(\"SUCCESS\")\n+        state = \", \".join(state)\n         if rerun is not None:\n-            new_state = 'SUCCESS' if rerun.success else 'FAILURE'\n-            state = f'{state} then {new_state}'\n-        self.check_line(output, f'Result: {state}', full=True)\n+            new_state = \"SUCCESS\" if rerun.success else \"FAILURE\"\n+            state = f\"{state} then {new_state}\"\n+        self.check_line(output, f\"Result: {state}\", full=True)\n \n     def parse_random_seed(self, output: str) -> str:\n-        match = self.regex_search(r'Using random seed: (.*)', output)\n+        match = self.regex_search(r\"Using random seed: (.*)\", output)\n         return match.group(1)\n \n     def run_command(self, args, input=None, exitcode=0, **kw):\n         if not input:\n-            input = ''\n-        if 'stderr' not in kw:\n-            kw['stderr'] = subprocess.STDOUT\n+            input = \"\"\n+        if \"stderr\" not in kw:\n+            kw[\"stderr\"] = subprocess.STDOUT\n \n-        env = kw.pop('env', None)\n+        env = kw.pop(\"env\", None)\n         if env is None:\n             env = dict(os.environ)\n-            env.pop('SOURCE_DATE_EPOCH', None)\n-\n-        proc = subprocess.run(args,\n-                              text=True,\n-                              input=input,\n-                              stdout=subprocess.PIPE,\n-                              env=env,\n-                              **kw)\n+            env.pop(\"SOURCE_DATE_EPOCH\", None)\n+\n+        proc = subprocess.run(\n+            args, text=True, input=input, stdout=subprocess.PIPE, env=env, **kw\n+        )\n         if proc.returncode != exitcode:\n-            msg = (\"Command %s failed with exit code %s, but exit code %s expected!\\n\"\n-                   \"\\n\"\n-                   \"stdout:\\n\"\n-                   \"---\\n\"\n-                   \"%s\\n\"\n-                   \"---\\n\"\n-                   % (str(args), proc.returncode, exitcode, proc.stdout))\n+            msg = (\n+                \"Command %s failed with exit code %s, but exit code %s expected!\\n\"\n+                \"\\n\"\n+                \"stdout:\\n\"\n+                \"---\\n\"\n+                \"%s\\n\"\n+                \"---\\n\" % (str(args), proc.returncode, exitcode, proc.stdout)\n+            )\n             if proc.stderr:\n-                msg += (\"\\n\"\n-                        \"stderr:\\n\"\n-                        \"---\\n\"\n-                        \"%s\"\n-                        \"---\\n\"\n-                        % proc.stderr)\n+                msg += \"\\nstderr:\\n---\\n%s---\\n\" % proc.stderr\n             self.fail(msg)\n         return proc\n \n     def run_python(self, args, isolated=True, **kw):\n         extraargs = []\n-        if 'uops' in sys._xoptions:\n+        if \"uops\" in sys._xoptions:\n             # Pass -X uops along\n-            extraargs.extend(['-X', 'uops'])\n-        cmd = [sys.executable, *extraargs, '-X', 'faulthandler']\n+            extraargs.extend([\"-X\", \"uops\"])\n+        cmd = [sys.executable, *extraargs, \"-X\", \"faulthandler\"]\n         if isolated:\n-            cmd.append('-I')\n+            cmd.append(\"-I\")\n         cmd.extend(args)\n         proc = self.run_command(cmd, **kw)\n         return proc.stdout\n@@ -825,11 +879,12 @@ def test_finds_expected_number_of_tests(self):\n         \"\"\"\n         Check that regrtest appears to find the expected set of tests.\n         \"\"\"\n-        args = ['-Wd', '-E', '-bb', '-m', 'test.regrtest', '--list-tests']\n+        args = [\"-Wd\", \"-E\", \"-bb\", \"-m\", \"test.regrtest\", \"--list-tests\"]\n         output = self.run_python(args)\n         rough_number_of_tests_found = len(output.splitlines())\n-        actual_testsuite_glob = os.path.join(glob.escape(os.path.dirname(__file__)),\n-                                             'test*.py')\n+        actual_testsuite_glob = os.path.join(\n+            glob.escape(os.path.dirname(__file__)), \"test*.py\"\n+        )\n         rough_counted_test_py_files = len(glob.glob(actual_testsuite_glob))\n         # We're not trying to duplicate test finding logic in here,\n         # just give a rough estimate of how many there should be and\n@@ -838,10 +893,12 @@ def test_finds_expected_number_of_tests(self):\n         # If you need to change the values in here during some\n         # mythical future test suite reorganization, don't go\n         # overboard with logic and keep that goal in mind.\n-        self.assertGreater(rough_number_of_tests_found,\n-                           rough_counted_test_py_files*9//10,\n-                           msg='Unexpectedly low number of tests found in:\\n'\n-                           f'{\", \".join(output.splitlines())}')\n+        self.assertGreater(\n+            rough_number_of_tests_found,\n+            rough_counted_test_py_files * 9 // 10,\n+            msg=\"Unexpectedly low number of tests found in:\\n\"\n+            f\"{', '.join(output.splitlines())}\",\n+        )\n \n \n @support.force_not_colorized_test_class\n@@ -859,19 +916,23 @@ def setUp(self):\n         # Create NTEST tests doing nothing\n         self.tests = [self.create_test() for index in range(self.NTEST)]\n \n-        self.python_args = ['-Wd', '-E', '-bb']\n-        self.regrtest_args = ['-uall', '-rwW',\n-                              '--testdir=%s' % self.tmptestdir]\n-        self.regrtest_args.extend(('--timeout', '3600', '-j4'))\n-        if sys.platform == 'win32':\n-            self.regrtest_args.append('-n')\n+        self.python_args = [\"-Wd\", \"-E\", \"-bb\"]\n+        self.regrtest_args = [\n+            \"-uall\",\n+            \"-rwW\",\n+            \"--testdir=%s\" % self.tmptestdir,\n+        ]\n+        self.regrtest_args.extend((\"--timeout\", \"3600\", \"-j4\"))\n+        if sys.platform == \"win32\":\n+            self.regrtest_args.append(\"-n\")\n \n     def check_output(self, output):\n         randseed = self.parse_random_seed(output)\n         self.assertTrue(randseed.isdigit(), randseed)\n \n-        self.check_executed_tests(output, self.tests,\n-                                  randomize=True, stats=len(self.tests))\n+        self.check_executed_tests(\n+            output, self.tests, randomize=True, stats=len(self.tests)\n+        )\n \n     def run_tests(self, args, env=None, isolated=True):\n         output = self.run_python(args, env=env, isolated=isolated)\n@@ -879,85 +940,108 @@ def run_tests(self, args, env=None, isolated=True):\n \n     def test_script_regrtest(self):\n         # Lib/test/regrtest.py\n-        script = os.path.join(self.testdir, 'regrtest.py')\n+        script = os.path.join(self.testdir, \"regrtest.py\")\n \n         args = [*self.python_args, script, *self.regrtest_args, *self.tests]\n         self.run_tests(args)\n \n     def test_module_test(self):\n         # -m test\n-        args = [*self.python_args, '-m', 'test',\n-                *self.regrtest_args, *self.tests]\n+        args = [\n+            *self.python_args,\n+            \"-m\",\n+            \"test\",\n+            *self.regrtest_args,\n+            *self.tests,\n+        ]\n         self.run_tests(args)\n \n     def test_module_regrtest(self):\n         # -m test.regrtest\n-        args = [*self.python_args, '-m', 'test.regrtest',\n-                *self.regrtest_args, *self.tests]\n+        args = [\n+            *self.python_args,\n+            \"-m\",\n+            \"test.regrtest\",\n+            *self.regrtest_args,\n+            *self.tests,\n+        ]\n         self.run_tests(args)\n \n     def test_module_autotest(self):\n         # -m test.autotest\n-        args = [*self.python_args, '-m', 'test.autotest',\n-                *self.regrtest_args, *self.tests]\n+        args = [\n+            *self.python_args,\n+            \"-m\",\n+            \"test.autotest\",\n+            *self.regrtest_args,\n+            *self.tests,\n+        ]\n         self.run_tests(args)\n \n     def test_module_from_test_autotest(self):\n         # from test import autotest\n-        code = 'from test import autotest'\n-        args = [*self.python_args, '-c', code,\n-                *self.regrtest_args, *self.tests]\n+        code = \"from test import autotest\"\n+        args = [\n+            *self.python_args,\n+            \"-c\",\n+            code,\n+            *self.regrtest_args,\n+            *self.tests,\n+        ]\n         self.run_tests(args)\n \n     def test_script_autotest(self):\n         # Lib/test/autotest.py\n-        script = os.path.join(self.testdir, 'autotest.py')\n+        script = os.path.join(self.testdir, \"autotest.py\")\n         args = [*self.python_args, script, *self.regrtest_args, *self.tests]\n         self.run_tests(args)\n \n     def run_batch(self, *args):\n-        proc = self.run_command(args,\n-                                # gh-133711: cmd.exe uses the OEM code page\n-                                # to display the non-ASCII current directory\n-                                errors=\"backslashreplace\")\n+        proc = self.run_command(\n+            args,\n+            # gh-133711: cmd.exe uses the OEM code page\n+            # to display the non-ASCII current directory\n+            errors=\"backslashreplace\",\n+        )\n         self.check_output(proc.stdout)\n \n-    @unittest.skipUnless(sysconfig.is_python_build(),\n-                         'test.bat script is not installed')\n-    @unittest.skipUnless(sys.platform == 'win32', 'Windows only')\n+    @unittest.skipUnless(\n+        sysconfig.is_python_build(), \"test.bat script is not installed\"\n+    )\n+    @unittest.skipUnless(sys.platform == \"win32\", \"Windows only\")\n     def test_tools_buildbot_test(self):\n         # Tools\\buildbot\\test.bat\n-        script = os.path.join(ROOT_DIR, 'Tools', 'buildbot', 'test.bat')\n-        test_args = ['--testdir=%s' % self.tmptestdir]\n-        if platform.machine() == 'ARM64':\n-            test_args.append('-arm64') # ARM 64-bit build\n-        elif platform.machine() == 'ARM':\n-            test_args.append('-arm32')   # 32-bit ARM build\n-        elif platform.architecture()[0] == '64bit':\n-            test_args.append('-x64')   # 64-bit build\n+        script = os.path.join(ROOT_DIR, \"Tools\", \"buildbot\", \"test.bat\")\n+        test_args = [\"--testdir=%s\" % self.tmptestdir]\n+        if platform.machine() == \"ARM64\":\n+            test_args.append(\"-arm64\")  # ARM 64-bit build\n+        elif platform.machine() == \"ARM\":\n+            test_args.append(\"-arm32\")  # 32-bit ARM build\n+        elif platform.architecture()[0] == \"64bit\":\n+            test_args.append(\"-x64\")  # 64-bit build\n         if not support.Py_DEBUG:\n-            test_args.append('+d')     # Release build, use python.exe\n+            test_args.append(\"+d\")  # Release build, use python.exe\n         if sysconfig.get_config_var(\"Py_GIL_DISABLED\"):\n-            test_args.append('--disable-gil')\n+            test_args.append(\"--disable-gil\")\n         self.run_batch(script, *test_args, *self.tests)\n \n-    @unittest.skipUnless(sys.platform == 'win32', 'Windows only')\n+    @unittest.skipUnless(sys.platform == \"win32\", \"Windows only\")\n     def test_pcbuild_rt(self):\n         # PCbuild\\rt.bat\n-        script = os.path.join(ROOT_DIR, r'PCbuild\\rt.bat')\n+        script = os.path.join(ROOT_DIR, r\"PCbuild\\rt.bat\")\n         if not os.path.isfile(script):\n             self.skipTest(f'File \"{script}\" does not exist')\n-        rt_args = [\"-q\"]             # Quick, don't run tests twice\n-        if platform.machine() == 'ARM64':\n-            rt_args.append('-arm64') # ARM 64-bit build\n-        elif platform.machine() == 'ARM':\n-            rt_args.append('-arm32')   # 32-bit ARM build\n-        elif platform.architecture()[0] == '64bit':\n-            rt_args.append('-x64')   # 64-bit build\n+        rt_args = [\"-q\"]  # Quick, don't run tests twice\n+        if platform.machine() == \"ARM64\":\n+            rt_args.append(\"-arm64\")  # ARM 64-bit build\n+        elif platform.machine() == \"ARM\":\n+            rt_args.append(\"-arm32\")  # 32-bit ARM build\n+        elif platform.architecture()[0] == \"64bit\":\n+            rt_args.append(\"-x64\")  # 64-bit build\n         if support.Py_DEBUG:\n-            rt_args.append('-d')     # Debug build, use python_d.exe\n+            rt_args.append(\"-d\")  # Debug build, use python_d.exe\n         if sysconfig.get_config_var(\"Py_GIL_DISABLED\"):\n-            rt_args.append('--disable-gil')\n+            rt_args.append(\"--disable-gil\")\n         self.run_batch(script, *rt_args, *self.regrtest_args, *self.tests)\n \n \n@@ -968,7 +1052,7 @@ class ArgsTestCase(BaseTestCase):\n     \"\"\"\n \n     def run_tests(self, *testargs, **kw):\n-        cmdargs = ['-m', 'test', '--testdir=%s' % self.tmptestdir, *testargs]\n+        cmdargs = [\"-m\", \"test\", \"--testdir=%s\" % self.tmptestdir, *testargs]\n         return self.run_python(cmdargs, **kw)\n \n     def test_success(self):\n@@ -985,25 +1069,22 @@ def test_test2(self):\n                 def test_test3(self):\n                     pass\n         \"\"\")\n-        tests = [self.create_test(f'ok{i}', code=code) for i in range(1, 6)]\n+        tests = [self.create_test(f\"ok{i}\", code=code) for i in range(1, 6)]\n \n         output = self.run_tests(*tests)\n-        self.check_executed_tests(output, tests,\n-                                  stats=3 * len(tests))\n+        self.check_executed_tests(output, tests, stats=3 * len(tests))\n \n     def test_skip(self):\n         code = textwrap.dedent(\"\"\"\n             import unittest\n             raise unittest.SkipTest(\"nope\")\n         \"\"\")\n-        test_ok = self.create_test('ok')\n-        test_skip = self.create_test('skip', code=code)\n+        test_ok = self.create_test(\"ok\")\n+        test_skip = self.create_test(\"skip\", code=code)\n         tests = [test_ok, test_skip]\n \n         output = self.run_tests(*tests)\n-        self.check_executed_tests(output, tests,\n-                                  skipped=[test_skip],\n-                                  stats=1)\n+        self.check_executed_tests(output, tests, skipped=[test_skip], stats=1)\n \n     def test_failing_test(self):\n         # test a failing test\n@@ -1014,44 +1095,48 @@ class FailingTest(unittest.TestCase):\n                 def test_failing(self):\n                     self.fail(\"bug\")\n         \"\"\")\n-        test_ok = self.create_test('ok')\n-        test_failing = self.create_test('failing', code=code)\n+        test_ok = self.create_test(\"ok\")\n+        test_failing = self.create_test(\"failing\", code=code)\n         tests = [test_ok, test_failing]\n \n         output = self.run_tests(*tests, exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, tests, failed=test_failing,\n-                                  stats=TestStats(2, 1))\n+        self.check_executed_tests(\n+            output, tests, failed=test_failing, stats=TestStats(2, 1)\n+        )\n \n     def test_resources(self):\n         # test -u command line option\n         tests = {}\n-        for resource in ('audio', 'network'):\n-            code = textwrap.dedent(\"\"\"\n+        for resource in (\"audio\", \"network\"):\n+            code = textwrap.dedent(\n+                \"\"\"\n                         from test import support; support.requires(%r)\n                         import unittest\n                         class PassingTest(unittest.TestCase):\n                             def test_pass(self):\n                                 pass\n-                    \"\"\" % resource)\n+                    \"\"\"\n+                % resource\n+            )\n \n             tests[resource] = self.create_test(resource, code)\n         test_names = sorted(tests.values())\n \n         # -u all: 2 resources enabled\n-        output = self.run_tests('-u', 'all', *test_names)\n+        output = self.run_tests(\"-u\", \"all\", *test_names)\n         self.check_executed_tests(output, test_names, stats=2)\n \n         # -u audio: 1 resource enabled\n-        output = self.run_tests('-uaudio', *test_names)\n-        self.check_executed_tests(output, test_names,\n-                                  resource_denied=tests['network'],\n-                                  stats=1)\n+        output = self.run_tests(\"-uaudio\", *test_names)\n+        self.check_executed_tests(\n+            output, test_names, resource_denied=tests[\"network\"], stats=1\n+        )\n \n         # no option: 0 resources enabled\n         output = self.run_tests(*test_names, exitcode=EXITCODE_NO_TESTS_RAN)\n-        self.check_executed_tests(output, test_names,\n-                                  resource_denied=test_names,\n-                                  stats=0)\n+        self.check_executed_tests(\n+            output, test_names, resource_denied=test_names, stats=0\n+        )\n \n     def test_random(self):\n         # test -r and --randseed command line option\n@@ -1059,21 +1144,25 @@ def test_random(self):\n             import random\n             print(\"TESTRANDOM: %s\" % random.randint(1, 1000))\n         \"\"\")\n-        test = self.create_test('random', code)\n+        test = self.create_test(\"random\", code)\n \n         # first run to get the output with the random seed\n-        output = self.run_tests('-r', test, exitcode=EXITCODE_NO_TESTS_RAN)\n+        output = self.run_tests(\"-r\", test, exitcode=EXITCODE_NO_TESTS_RAN)\n         randseed = self.parse_random_seed(output)\n-        match = self.regex_search(r'TESTRANDOM: ([0-9]+)', output)\n+        match = self.regex_search(r\"TESTRANDOM: ([0-9]+)\", output)\n         test_random = int(match.group(1))\n \n         # try to reproduce with the random seed\n-        output = self.run_tests('-r', f'--randseed={randseed}', test,\n-                                exitcode=EXITCODE_NO_TESTS_RAN)\n+        output = self.run_tests(\n+            \"-r\",\n+            f\"--randseed={randseed}\",\n+            test,\n+            exitcode=EXITCODE_NO_TESTS_RAN,\n+        )\n         randseed2 = self.parse_random_seed(output)\n         self.assertEqual(randseed2, randseed)\n \n-        match = self.regex_search(r'TESTRANDOM: ([0-9]+)', output)\n+        match = self.regex_search(r\"TESTRANDOM: ([0-9]+)\", output)\n         test_random2 = int(match.group(1))\n         self.assertEqual(test_random2, test_random)\n \n@@ -1083,26 +1172,29 @@ def test_random(self):\n         self.assertTrue(randseed.isdigit(), randseed)\n \n         # check SOURCE_DATE_EPOCH (integer)\n-        timestamp = '1697839080'\n+        timestamp = \"1697839080\"\n         env = dict(os.environ, SOURCE_DATE_EPOCH=timestamp)\n-        output = self.run_tests('-r', test, exitcode=EXITCODE_NO_TESTS_RAN,\n-                                env=env)\n+        output = self.run_tests(\n+            \"-r\", test, exitcode=EXITCODE_NO_TESTS_RAN, env=env\n+        )\n         randseed = self.parse_random_seed(output)\n         self.assertEqual(randseed, timestamp)\n-        self.check_line(output, 'TESTRANDOM: 520')\n+        self.check_line(output, \"TESTRANDOM: 520\")\n \n         # check SOURCE_DATE_EPOCH (string)\n-        env = dict(os.environ, SOURCE_DATE_EPOCH='XYZ')\n-        output = self.run_tests('-r', test, exitcode=EXITCODE_NO_TESTS_RAN,\n-                                env=env)\n+        env = dict(os.environ, SOURCE_DATE_EPOCH=\"XYZ\")\n+        output = self.run_tests(\n+            \"-r\", test, exitcode=EXITCODE_NO_TESTS_RAN, env=env\n+        )\n         randseed = self.parse_random_seed(output)\n-        self.assertEqual(randseed, 'XYZ')\n-        self.check_line(output, 'TESTRANDOM: 22')\n+        self.assertEqual(randseed, \"XYZ\")\n+        self.check_line(output, \"TESTRANDOM: 22\")\n \n         # check SOURCE_DATE_EPOCH (empty string): ignore the env var\n-        env = dict(os.environ, SOURCE_DATE_EPOCH='')\n-        output = self.run_tests('-r', test, exitcode=EXITCODE_NO_TESTS_RAN,\n-                                env=env)\n+        env = dict(os.environ, SOURCE_DATE_EPOCH=\"\")\n+        output = self.run_tests(\n+            \"-r\", test, exitcode=EXITCODE_NO_TESTS_RAN, env=env\n+        )\n         randseed = self.parse_random_seed(output)\n         self.assertTrue(randseed.isdigit(), randseed)\n \n@@ -1120,14 +1212,18 @@ def test_fromfile(self):\n         with open(filename, \"w\") as fp:\n             previous = None\n             for index, name in enumerate(tests, 1):\n-                line = (\"00:00:%02i [%s/%s] %s\"\n-                        % (index, index, len(tests), name))\n+                line = \"00:00:%02i [%s/%s] %s\" % (\n+                    index,\n+                    index,\n+                    len(tests),\n+                    name,\n+                )\n                 if previous:\n                     line += \" -- %s took 0 sec\" % previous\n                 print(line, file=fp)\n                 previous = name\n \n-        output = self.run_tests('--fromfile', filename)\n+        output = self.run_tests(\"--fromfile\", filename)\n         stats = len(tests)\n         self.check_executed_tests(output, tests, stats=stats)\n \n@@ -1136,7 +1232,7 @@ def test_fromfile(self):\n             for index, name in enumerate(tests, 1):\n                 print(\"[%s/%s] %s\" % (index, len(tests), name), file=fp)\n \n-        output = self.run_tests('--fromfile', filename)\n+        output = self.run_tests(\"--fromfile\", filename)\n         self.check_executed_tests(output, tests, stats=stats)\n \n         # test format 'test_opcodes'\n@@ -1144,32 +1240,34 @@ def test_fromfile(self):\n             for name in tests:\n                 print(name, file=fp)\n \n-        output = self.run_tests('--fromfile', filename)\n+        output = self.run_tests(\"--fromfile\", filename)\n         self.check_executed_tests(output, tests, stats=stats)\n \n         # test format 'Lib/test/test_opcodes.py'\n         with open(filename, \"w\") as fp:\n             for name in tests:\n-                print('Lib/test/%s.py' % name, file=fp)\n+                print(\"Lib/test/%s.py\" % name, file=fp)\n \n-        output = self.run_tests('--fromfile', filename)\n+        output = self.run_tests(\"--fromfile\", filename)\n         self.check_executed_tests(output, tests, stats=stats)\n \n     def test_interrupted(self):\n         code = TEST_INTERRUPTED\n-        test = self.create_test('sigint', code=code)\n+        test = self.create_test(\"sigint\", code=code)\n         output = self.run_tests(test, exitcode=EXITCODE_INTERRUPTED)\n-        self.check_executed_tests(output, test, omitted=test,\n-                                  interrupted=True, stats=0)\n+        self.check_executed_tests(\n+            output, test, omitted=test, interrupted=True, stats=0\n+        )\n \n     def test_slowest(self):\n         # test --slowest\n         tests = [self.create_test() for index in range(3)]\n         output = self.run_tests(\"--slowest\", *tests)\n         self.check_executed_tests(output, tests, stats=len(tests))\n-        regex = ('10 slowest tests:\\n'\n-                 '(?:- %s: .*\\n){%s}'\n-                 % (self.TESTNAME_REGEX, len(tests)))\n+        regex = \"10 slowest tests:\\n(?:- %s: .*\\n){%s}\" % (\n+            self.TESTNAME_REGEX,\n+            len(tests),\n+        )\n         self.check_line(output, regex)\n \n     def test_slowest_interrupted(self):\n@@ -1184,27 +1282,29 @@ def test_slowest_interrupted(self):\n                 else:\n                     args = (\"--slowest\", test)\n                 output = self.run_tests(*args, exitcode=EXITCODE_INTERRUPTED)\n-                self.check_executed_tests(output, test,\n-                                          omitted=test, interrupted=True,\n-                                          stats=0)\n+                self.check_executed_tests(\n+                    output, test, omitted=test, interrupted=True, stats=0\n+                )\n \n-                regex = ('10 slowest tests:\\n')\n+                regex = \"10 slowest tests:\\n\"\n                 self.check_line(output, regex)\n \n     def test_coverage(self):\n         # test --coverage\n-        test = self.create_test('coverage')\n+        test = self.create_test(\"coverage\")\n         output = self.run_tests(\"--coverage\", test)\n         self.check_executed_tests(output, [test], stats=1)\n-        regex = (r'lines +cov% +module +\\(path\\)\\n'\n-                 r'(?: *[0-9]+ *[0-9]{1,2}\\.[0-9]% *[^ ]+ +\\([^)]+\\)+)+')\n+        regex = (\n+            r\"lines +cov% +module +\\(path\\)\\n\"\n+            r\"(?: *[0-9]+ *[0-9]{1,2}\\.[0-9]% *[^ ]+ +\\([^)]+\\)+)+\"\n+        )\n         self.check_line(output, regex)\n \n     def test_wait(self):\n         # test --wait\n-        test = self.create_test('wait')\n-        output = self.run_tests(\"--wait\", test, input='key')\n-        self.check_line(output, 'Press any key to continue')\n+        test = self.create_test(\"wait\")\n+        output = self.run_tests(\"--wait\", test, input=\"key\")\n+        self.check_line(output, \"Press any key to continue\")\n \n     def test_forever(self):\n         # test --forever\n@@ -1223,49 +1323,54 @@ def test_run(self):\n                     else:\n                         builtins.__dict__['RUN'] = 1\n         \"\"\")\n-        test = self.create_test('forever', code=code)\n+        test = self.create_test(\"forever\", code=code)\n \n         # --forever\n-        output = self.run_tests('--forever', test, exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, [test]*3, failed=test,\n-                                  stats=TestStats(3, 1),\n-                                  forever=True)\n+        output = self.run_tests(\"--forever\", test, exitcode=EXITCODE_BAD_TEST)\n+        self.check_executed_tests(\n+            output,\n+            [test] * 3,\n+            failed=test,\n+            stats=TestStats(3, 1),\n+            forever=True,\n+        )\n \n         # --forever --rerun\n-        output = self.run_tests('--forever', '--rerun', test, exitcode=0)\n-        self.check_executed_tests(output, [test]*3,\n-                                  rerun=Rerun(test,\n-                                              match='test_run',\n-                                              success=True),\n-                                  stats=TestStats(4, 1),\n-                                  forever=True)\n+        output = self.run_tests(\"--forever\", \"--rerun\", test, exitcode=0)\n+        self.check_executed_tests(\n+            output,\n+            [test] * 3,\n+            rerun=Rerun(test, match=\"test_run\", success=True),\n+            stats=TestStats(4, 1),\n+            forever=True,\n+        )\n \n     @support.requires_jit_disabled\n     def check_leak(self, code, what, *, run_workers=False):\n-        test = self.create_test('huntrleaks', code=code)\n+        test = self.create_test(\"huntrleaks\", code=code)\n \n-        filename = 'reflog.txt'\n+        filename = \"reflog.txt\"\n         self.addCleanup(os_helper.unlink, filename)\n-        cmd = ['--huntrleaks', '3:3:']\n+        cmd = [\"--huntrleaks\", \"3:3:\"]\n         if run_workers:\n-            cmd.append('-j1')\n+            cmd.append(\"-j1\")\n         cmd.append(test)\n-        output = self.run_tests(*cmd,\n-                                exitcode=EXITCODE_BAD_TEST,\n-                                stderr=subprocess.STDOUT)\n+        output = self.run_tests(\n+            *cmd, exitcode=EXITCODE_BAD_TEST, stderr=subprocess.STDOUT\n+        )\n         self.check_executed_tests(output, [test], failed=test, stats=1)\n \n-        line = r'beginning 6 repetitions. .*\\n123:456\\n[.0-9X]{3} 111\\n'\n+        line = r\"beginning 6 repetitions. .*\\n123:456\\n[.0-9X]{3} 111\\n\"\n         self.check_line(output, line)\n \n-        line2 = '%s leaked [1, 1, 1] %s, sum=3\\n' % (test, what)\n+        line2 = \"%s leaked [1, 1, 1] %s, sum=3\\n\" % (test, what)\n         self.assertIn(line2, output)\n \n         with open(filename) as fp:\n             reflog = fp.read()\n             self.assertIn(line2, reflog)\n \n-    @unittest.skipUnless(support.Py_DEBUG, 'need a debug build')\n+    @unittest.skipUnless(support.Py_DEBUG, \"need a debug build\")\n     def check_huntrleaks(self, *, run_workers: bool):\n         # test --huntrleaks\n         code = textwrap.dedent(\"\"\"\n@@ -1277,7 +1382,7 @@ class RefLeakTest(unittest.TestCase):\n                 def test_leak(self):\n                     GLOBAL_LIST.append(object())\n         \"\"\")\n-        self.check_leak(code, 'references', run_workers=run_workers)\n+        self.check_leak(code, \"references\", run_workers=run_workers)\n \n     def test_huntrleaks(self):\n         self.check_huntrleaks(run_workers=False)\n@@ -1285,7 +1390,7 @@ def test_huntrleaks(self):\n     def test_huntrleaks_mp(self):\n         self.check_huntrleaks(run_workers=True)\n \n-    @unittest.skipUnless(support.Py_DEBUG, 'need a debug build')\n+    @unittest.skipUnless(support.Py_DEBUG, \"need a debug build\")\n     def test_huntrleaks_bisect(self):\n         # test --huntrleaks --bisect\n         code = textwrap.dedent(\"\"\"\n@@ -1307,26 +1412,23 @@ def test4(self):\n                     pass\n         \"\"\")\n \n-        test = self.create_test('huntrleaks', code=code)\n+        test = self.create_test(\"huntrleaks\", code=code)\n \n-        filename = 'reflog.txt'\n+        filename = \"reflog.txt\"\n         self.addCleanup(os_helper.unlink, filename)\n-        cmd = ['--huntrleaks', '3:3:', '--bisect', test]\n-        output = self.run_tests(*cmd,\n-                                exitcode=EXITCODE_BAD_TEST,\n-                                stderr=subprocess.STDOUT)\n+        cmd = [\"--huntrleaks\", \"3:3:\", \"--bisect\", test]\n+        output = self.run_tests(\n+            *cmd, exitcode=EXITCODE_BAD_TEST, stderr=subprocess.STDOUT\n+        )\n \n         self.assertIn(f\"Bisect {test}\", output)\n         self.assertIn(f\"Bisect {test}: exit code 0\", output)\n \n         # test3 is the one which leaks\n         self.assertIn(\"Bisection completed in\", output)\n-        self.assertIn(\n-            \"Tests (1):\\n\"\n-            f\"* {test}.RefLeakTest.test3\\n\",\n-            output)\n+        self.assertIn(f\"Tests (1):\\n* {test}.RefLeakTest.test3\\n\", output)\n \n-    @unittest.skipUnless(support.Py_DEBUG, 'need a debug build')\n+    @unittest.skipUnless(support.Py_DEBUG, \"need a debug build\")\n     def test_huntrleaks_fd_leak(self):\n         # test --huntrleaks for file descriptor leak\n         code = textwrap.dedent(\"\"\"\n@@ -1338,14 +1440,13 @@ def test_leak(self):\n                     fd = os.open(__file__, os.O_RDONLY)\n                     # bug: never close the file descriptor\n         \"\"\")\n-        self.check_leak(code, 'file descriptors')\n+        self.check_leak(code, \"file descriptors\")\n \n     def test_list_tests(self):\n         # test --list-tests\n         tests = [self.create_test() for i in range(5)]\n-        output = self.run_tests('--list-tests', *tests)\n-        self.assertEqual(output.rstrip().splitlines(),\n-                         tests)\n+        output = self.run_tests(\"--list-tests\", *tests)\n+        self.assertEqual(output.rstrip().splitlines(), tests)\n \n     def test_list_cases(self):\n         # test --list-cases\n@@ -1361,28 +1462,29 @@ def test_method2(self):\n         testname = self.create_test(code=code)\n \n         # Test --list-cases\n-        all_methods = ['%s.Tests.test_method1' % testname,\n-                       '%s.Tests.test_method2' % testname]\n-        output = self.run_tests('--list-cases', testname)\n+        all_methods = [\n+            \"%s.Tests.test_method1\" % testname,\n+            \"%s.Tests.test_method2\" % testname,\n+        ]\n+        output = self.run_tests(\"--list-cases\", testname)\n         self.assertEqual(output.splitlines(), all_methods)\n \n         # Test --list-cases with --match\n-        all_methods = ['%s.Tests.test_method1' % testname]\n-        output = self.run_tests('--list-cases',\n-                                '-m', 'test_method1',\n-                                testname)\n+        all_methods = [\"%s.Tests.test_method1\" % testname]\n+        output = self.run_tests(\"--list-cases\", \"-m\", \"test_method1\", testname)\n         self.assertEqual(output.splitlines(), all_methods)\n \n     @support.cpython_only\n     def test_crashed(self):\n         # Any code which causes a crash\n-        code = 'import faulthandler; faulthandler._sigsegv()'\n+        code = \"import faulthandler; faulthandler._sigsegv()\"\n         crash_test = self.create_test(name=\"crash\", code=code)\n \n         tests = [crash_test]\n         output = self.run_tests(\"-j2\", *tests, exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, tests, failed=crash_test,\n-                                  parallel=True, stats=0)\n+        self.check_executed_tests(\n+            output, tests, failed=crash_test, parallel=True, stats=0\n+        )\n \n     def parse_methods(self, output):\n         regex = re.compile(\"^(test[^ ]+).*ok$\", flags=re.MULTILINE)\n@@ -1410,16 +1512,17 @@ def test_method4(self):\n \n         subset = [\n             # only ignore the method name\n-            'test_method1',\n+            \"test_method1\",\n             # ignore the full identifier\n-            '%s.Tests.test_method3' % testname]\n+            \"%s.Tests.test_method3\" % testname,\n+        ]\n         with open(filename, \"w\") as fp:\n             for name in subset:\n                 print(name, file=fp)\n \n         output = self.run_tests(\"-v\", \"--ignorefile\", filename, testname)\n         methods = self.parse_methods(output)\n-        subset = ['test_method2', 'test_method4']\n+        subset = [\"test_method2\", \"test_method4\"]\n         self.assertEqual(methods, subset)\n \n     def test_matchfile(self):\n@@ -1436,8 +1539,12 @@ def test_method3(self):\n                 def test_method4(self):\n                     pass\n         \"\"\")\n-        all_methods = ['test_method1', 'test_method2',\n-                       'test_method3', 'test_method4']\n+        all_methods = [\n+            \"test_method1\",\n+            \"test_method2\",\n+            \"test_method3\",\n+            \"test_method4\",\n+        ]\n         testname = self.create_test(code=code)\n \n         # by default, all methods should be run\n@@ -1451,16 +1558,17 @@ def test_method4(self):\n \n         subset = [\n             # only match the method name\n-            'test_method1',\n+            \"test_method1\",\n             # match the full identifier\n-            '%s.Tests.test_method3' % testname]\n+            \"%s.Tests.test_method3\" % testname,\n+        ]\n         with open(filename, \"w\") as fp:\n             for name in subset:\n                 print(name, file=fp)\n \n         output = self.run_tests(\"-v\", \"--matchfile\", filename, testname)\n         methods = self.parse_methods(output)\n-        subset = ['test_method1', 'test_method3']\n+        subset = [\"test_method1\", \"test_method3\"]\n         self.assertEqual(methods, subset)\n \n     def test_env_changed(self):\n@@ -1475,23 +1583,31 @@ def test_env_changed(self):\n \n         # don't fail by default\n         output = self.run_tests(testname)\n-        self.check_executed_tests(output, [testname],\n-                                  env_changed=testname, stats=1)\n+        self.check_executed_tests(\n+            output, [testname], env_changed=testname, stats=1\n+        )\n \n         # fail with --fail-env-changed\n-        output = self.run_tests(\"--fail-env-changed\", testname,\n-                                exitcode=EXITCODE_ENV_CHANGED)\n-        self.check_executed_tests(output, [testname], env_changed=testname,\n-                                  fail_env_changed=True, stats=1)\n+        output = self.run_tests(\n+            \"--fail-env-changed\", testname, exitcode=EXITCODE_ENV_CHANGED\n+        )\n+        self.check_executed_tests(\n+            output,\n+            [testname],\n+            env_changed=testname,\n+            fail_env_changed=True,\n+            stats=1,\n+        )\n \n         # rerun\n         output = self.run_tests(\"--rerun\", testname)\n-        self.check_executed_tests(output, [testname],\n-                                  env_changed=testname,\n-                                  rerun=Rerun(testname,\n-                                              match=None,\n-                                              success=True),\n-                                  stats=2)\n+        self.check_executed_tests(\n+            output,\n+            [testname],\n+            env_changed=testname,\n+            rerun=Rerun(testname, match=None, success=True),\n+            stats=2,\n+        )\n \n     def test_rerun_fail(self):\n         # FAILURE then FAILURE\n@@ -1508,12 +1624,15 @@ def test_fail_always(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--rerun\", testname, exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, [testname],\n-                                  rerun=Rerun(testname,\n-                                              \"test_fail_always\",\n-                                              success=False),\n-                                  stats=TestStats(3, 2))\n+        output = self.run_tests(\n+            \"--rerun\", testname, exitcode=EXITCODE_BAD_TEST\n+        )\n+        self.check_executed_tests(\n+            output,\n+            [testname],\n+            rerun=Rerun(testname, \"test_fail_always\", success=False),\n+            stats=TestStats(3, 2),\n+        )\n \n     def test_rerun_success(self):\n         # FAILURE then SUCCESS\n@@ -1540,22 +1659,25 @@ def test_fail_once(self):\n \n         # FAILURE then SUCCESS => exit code 0\n         output = self.run_tests(\"--rerun\", testname, exitcode=0)\n-        self.check_executed_tests(output, [testname],\n-                                  rerun=Rerun(testname,\n-                                              match=\"test_fail_once\",\n-                                              success=True),\n-                                  stats=TestStats(3, 1))\n+        self.check_executed_tests(\n+            output,\n+            [testname],\n+            rerun=Rerun(testname, match=\"test_fail_once\", success=True),\n+            stats=TestStats(3, 1),\n+        )\n         os_helper.unlink(marker_filename)\n \n         # with --fail-rerun, exit code EXITCODE_RERUN_FAIL\n         # on \"FAILURE then SUCCESS\" state.\n-        output = self.run_tests(\"--rerun\", \"--fail-rerun\", testname,\n-                                exitcode=EXITCODE_RERUN_FAIL)\n-        self.check_executed_tests(output, [testname],\n-                                  rerun=Rerun(testname,\n-                                              match=\"test_fail_once\",\n-                                              success=True),\n-                                  stats=TestStats(3, 1))\n+        output = self.run_tests(\n+            \"--rerun\", \"--fail-rerun\", testname, exitcode=EXITCODE_RERUN_FAIL\n+        )\n+        self.check_executed_tests(\n+            output,\n+            [testname],\n+            rerun=Rerun(testname, match=\"test_fail_once\", success=True),\n+            stats=TestStats(3, 1),\n+        )\n         os_helper.unlink(marker_filename)\n \n     def test_rerun_setup_class_hook_failure(self):\n@@ -1573,13 +1695,16 @@ def test_success(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--rerun\", testname, exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, testname,\n-                                  failed=[testname],\n-                                  rerun=Rerun(testname,\n-                                              match=\"ExampleTests\",\n-                                              success=False),\n-                                  stats=0)\n+        output = self.run_tests(\n+            \"--rerun\", testname, exitcode=EXITCODE_BAD_TEST\n+        )\n+        self.check_executed_tests(\n+            output,\n+            testname,\n+            failed=[testname],\n+            rerun=Rerun(testname, match=\"ExampleTests\", success=False),\n+            stats=0,\n+        )\n \n     def test_rerun_teardown_class_hook_failure(self):\n         # FAILURE then FAILURE\n@@ -1596,13 +1721,16 @@ def test_success(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--rerun\", testname, exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, testname,\n-                                  failed=[testname],\n-                                  rerun=Rerun(testname,\n-                                              match=\"ExampleTests\",\n-                                              success=False),\n-                                  stats=2)\n+        output = self.run_tests(\n+            \"--rerun\", testname, exitcode=EXITCODE_BAD_TEST\n+        )\n+        self.check_executed_tests(\n+            output,\n+            testname,\n+            failed=[testname],\n+            rerun=Rerun(testname, match=\"ExampleTests\", success=False),\n+            stats=2,\n+        )\n \n     def test_rerun_setup_module_hook_failure(self):\n         # FAILURE then FAILURE\n@@ -1618,13 +1746,16 @@ def test_success(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--rerun\", testname, exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, testname,\n-                                  failed=[testname],\n-                                  rerun=Rerun(testname,\n-                                              match=None,\n-                                              success=False),\n-                                  stats=0)\n+        output = self.run_tests(\n+            \"--rerun\", testname, exitcode=EXITCODE_BAD_TEST\n+        )\n+        self.check_executed_tests(\n+            output,\n+            testname,\n+            failed=[testname],\n+            rerun=Rerun(testname, match=None, success=False),\n+            stats=0,\n+        )\n \n     def test_rerun_teardown_module_hook_failure(self):\n         # FAILURE then FAILURE\n@@ -1640,13 +1771,16 @@ def test_success(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--rerun\", testname, exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, [testname],\n-                                  failed=[testname],\n-                                  rerun=Rerun(testname,\n-                                              match=None,\n-                                              success=False),\n-                                  stats=2)\n+        output = self.run_tests(\n+            \"--rerun\", testname, exitcode=EXITCODE_BAD_TEST\n+        )\n+        self.check_executed_tests(\n+            output,\n+            [testname],\n+            failed=[testname],\n+            rerun=Rerun(testname, match=None, success=False),\n+            stats=2,\n+        )\n \n     def test_rerun_setup_hook_failure(self):\n         # FAILURE then FAILURE\n@@ -1662,13 +1796,16 @@ def test_success(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--rerun\", testname, exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, testname,\n-                                  failed=[testname],\n-                                  rerun=Rerun(testname,\n-                                              match=\"test_success\",\n-                                              success=False),\n-                                  stats=2)\n+        output = self.run_tests(\n+            \"--rerun\", testname, exitcode=EXITCODE_BAD_TEST\n+        )\n+        self.check_executed_tests(\n+            output,\n+            testname,\n+            failed=[testname],\n+            rerun=Rerun(testname, match=\"test_success\", success=False),\n+            stats=2,\n+        )\n \n     def test_rerun_teardown_hook_failure(self):\n         # FAILURE then FAILURE\n@@ -1684,13 +1821,16 @@ def test_success(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--rerun\", testname, exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, testname,\n-                                  failed=[testname],\n-                                  rerun=Rerun(testname,\n-                                              match=\"test_success\",\n-                                              success=False),\n-                                  stats=2)\n+        output = self.run_tests(\n+            \"--rerun\", testname, exitcode=EXITCODE_BAD_TEST\n+        )\n+        self.check_executed_tests(\n+            output,\n+            testname,\n+            failed=[testname],\n+            rerun=Rerun(testname, match=\"test_success\", success=False),\n+            stats=2,\n+        )\n \n     def test_rerun_async_setup_hook_failure(self):\n         # FAILURE then FAILURE\n@@ -1706,12 +1846,15 @@ async def test_success(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--rerun\", testname, exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, testname,\n-                                  rerun=Rerun(testname,\n-                                              match=\"test_success\",\n-                                              success=False),\n-                                  stats=2)\n+        output = self.run_tests(\n+            \"--rerun\", testname, exitcode=EXITCODE_BAD_TEST\n+        )\n+        self.check_executed_tests(\n+            output,\n+            testname,\n+            rerun=Rerun(testname, match=\"test_success\", success=False),\n+            stats=2,\n+        )\n \n     def test_rerun_async_teardown_hook_failure(self):\n         # FAILURE then FAILURE\n@@ -1727,13 +1870,16 @@ async def test_success(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--rerun\", testname, exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, testname,\n-                                  failed=[testname],\n-                                  rerun=Rerun(testname,\n-                                              match=\"test_success\",\n-                                              success=False),\n-                                  stats=2)\n+        output = self.run_tests(\n+            \"--rerun\", testname, exitcode=EXITCODE_BAD_TEST\n+        )\n+        self.check_executed_tests(\n+            output,\n+            testname,\n+            failed=[testname],\n+            rerun=Rerun(testname, match=\"test_success\", success=False),\n+            stats=2,\n+        )\n \n     def test_no_tests_ran(self):\n         code = textwrap.dedent(\"\"\"\n@@ -1745,11 +1891,12 @@ def test_bug(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(testname, \"-m\", \"nosuchtest\",\n-                                exitcode=EXITCODE_NO_TESTS_RAN)\n-        self.check_executed_tests(output, [testname],\n-                                  run_no_tests=testname,\n-                                  stats=0, filtered=True)\n+        output = self.run_tests(\n+            testname, \"-m\", \"nosuchtest\", exitcode=EXITCODE_NO_TESTS_RAN\n+        )\n+        self.check_executed_tests(\n+            output, [testname], run_no_tests=testname, stats=0, filtered=True\n+        )\n \n     def test_no_tests_ran_skip(self):\n         code = textwrap.dedent(\"\"\"\n@@ -1762,8 +1909,9 @@ def test_skipped(self):\n         testname = self.create_test(code=code)\n \n         output = self.run_tests(testname)\n-        self.check_executed_tests(output, [testname],\n-                                  stats=TestStats(1, skipped=1))\n+        self.check_executed_tests(\n+            output, [testname], stats=TestStats(1, skipped=1)\n+        )\n \n     def test_no_tests_ran_multiple_tests_nonexistent(self):\n         code = textwrap.dedent(\"\"\"\n@@ -1776,11 +1924,20 @@ def test_bug(self):\n         testname = self.create_test(code=code)\n         testname2 = self.create_test(code=code)\n \n-        output = self.run_tests(testname, testname2, \"-m\", \"nosuchtest\",\n-                                exitcode=EXITCODE_NO_TESTS_RAN)\n-        self.check_executed_tests(output, [testname, testname2],\n-                                  run_no_tests=[testname, testname2],\n-                                  stats=0, filtered=True)\n+        output = self.run_tests(\n+            testname,\n+            testname2,\n+            \"-m\",\n+            \"nosuchtest\",\n+            exitcode=EXITCODE_NO_TESTS_RAN,\n+        )\n+        self.check_executed_tests(\n+            output,\n+            [testname, testname2],\n+            run_no_tests=[testname, testname2],\n+            stats=0,\n+            filtered=True,\n+        )\n \n     def test_no_test_ran_some_test_exist_some_not(self):\n         code = textwrap.dedent(\"\"\"\n@@ -1800,16 +1957,27 @@ def test_other_bug(self):\n         \"\"\")\n         testname2 = self.create_test(code=other_code)\n \n-        output = self.run_tests(testname, testname2, \"-m\", \"nosuchtest\",\n-                                \"-m\", \"test_other_bug\", exitcode=0)\n-        self.check_executed_tests(output, [testname, testname2],\n-                                  run_no_tests=[testname],\n-                                  stats=1, filtered=True)\n+        output = self.run_tests(\n+            testname,\n+            testname2,\n+            \"-m\",\n+            \"nosuchtest\",\n+            \"-m\",\n+            \"test_other_bug\",\n+            exitcode=0,\n+        )\n+        self.check_executed_tests(\n+            output,\n+            [testname, testname2],\n+            run_no_tests=[testname],\n+            stats=1,\n+            filtered=True,\n+        )\n \n     @support.cpython_only\n     def test_uncollectable(self):\n         # Skip test if _testcapi is missing\n-        import_helper.import_module('_testcapi')\n+        import_helper.import_module(\"_testcapi\")\n \n         code = textwrap.dedent(r\"\"\"\n             import _testcapi\n@@ -1830,12 +1998,16 @@ def test_garbage(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--fail-env-changed\", testname,\n-                                exitcode=EXITCODE_ENV_CHANGED)\n-        self.check_executed_tests(output, [testname],\n-                                  env_changed=[testname],\n-                                  fail_env_changed=True,\n-                                  stats=1)\n+        output = self.run_tests(\n+            \"--fail-env-changed\", testname, exitcode=EXITCODE_ENV_CHANGED\n+        )\n+        self.check_executed_tests(\n+            output,\n+            [testname],\n+            env_changed=[testname],\n+            fail_env_changed=True,\n+            stats=1,\n+        )\n \n     def test_multiprocessing_timeout(self):\n         code = textwrap.dedent(r\"\"\"\n@@ -1858,12 +2030,13 @@ def test_sleep(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"-j2\", \"--timeout=1.0\", testname,\n-                                exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, [testname],\n-                                  failed=testname, stats=0)\n-        self.assertRegex(output,\n-                         re.compile('%s timed out' % testname, re.MULTILINE))\n+        output = self.run_tests(\n+            \"-j2\", \"--timeout=1.0\", testname, exitcode=EXITCODE_BAD_TEST\n+        )\n+        self.check_executed_tests(output, [testname], failed=testname, stats=0)\n+        self.assertRegex(\n+            output, re.compile(\"%s timed out\" % testname, re.MULTILINE)\n+        )\n \n     def test_unraisable_exc(self):\n         # --fail-env-changed must catch unraisable exception.\n@@ -1891,12 +2064,16 @@ def test_unraisable_exc(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--fail-env-changed\", \"-v\", testname,\n-                                exitcode=EXITCODE_ENV_CHANGED)\n-        self.check_executed_tests(output, [testname],\n-                                  env_changed=[testname],\n-                                  fail_env_changed=True,\n-                                  stats=1)\n+        output = self.run_tests(\n+            \"--fail-env-changed\", \"-v\", testname, exitcode=EXITCODE_ENV_CHANGED\n+        )\n+        self.check_executed_tests(\n+            output,\n+            [testname],\n+            env_changed=[testname],\n+            fail_env_changed=True,\n+            stats=1,\n+        )\n         self.assertIn(\"Warning -- Unraisable exception\", output)\n         self.assertIn(\"Exception: weakref callback bug\", output)\n \n@@ -1924,12 +2101,16 @@ def test_threading_excepthook(self):\n         \"\"\")\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--fail-env-changed\", \"-v\", testname,\n-                                exitcode=EXITCODE_ENV_CHANGED)\n-        self.check_executed_tests(output, [testname],\n-                                  env_changed=[testname],\n-                                  fail_env_changed=True,\n-                                  stats=1)\n+        output = self.run_tests(\n+            \"--fail-env-changed\", \"-v\", testname, exitcode=EXITCODE_ENV_CHANGED\n+        )\n+        self.check_executed_tests(\n+            output,\n+            [testname],\n+            env_changed=[testname],\n+            fail_env_changed=True,\n+            stats=1,\n+        )\n         self.assertIn(\"Warning -- Uncaught thread exception\", output)\n         self.assertIn(\"Exception: bug in thread\", output)\n \n@@ -1961,17 +2142,22 @@ def test_print_warning(self):\n         #   test_threading_excepthook (test.test_x.Tests) ... msg1: stdout\n         #   Warning -- msg2: print_warning\n         #   ok\n-        regex = (r\"test_print_warning.*msg1: stdout\\n\"\n-                 r\"Warning -- msg2: print_warning\\n\"\n-                 r\"ok\\n\")\n+        regex = (\n+            r\"test_print_warning.*msg1: stdout\\n\"\n+            r\"Warning -- msg2: print_warning\\n\"\n+            r\"ok\\n\"\n+        )\n         for option in (\"-v\", \"-W\"):\n             with self.subTest(option=option):\n                 cmd = [\"--fail-env-changed\", option, testname]\n                 output = self.run_tests(*cmd, exitcode=EXITCODE_ENV_CHANGED)\n-                self.check_executed_tests(output, [testname],\n-                                          env_changed=[testname],\n-                                          fail_env_changed=True,\n-                                          stats=1)\n+                self.check_executed_tests(\n+                    output,\n+                    [testname],\n+                    env_changed=[testname],\n+                    fail_env_changed=True,\n+                    stats=1,\n+                )\n                 self.assertRegex(output, regex)\n \n     def test_unicode_guard_env(self):\n@@ -1989,16 +2175,15 @@ def test_cleanup(self):\n         open(filename, \"wb\").close()\n         names = [dirname, filename]\n \n-        cmdargs = ['-m', 'test',\n-                   '--tempdir=%s' % self.tmptestdir,\n-                   '--cleanup']\n+        cmdargs = [\"-m\", \"test\", \"--tempdir=%s\" % self.tmptestdir, \"--cleanup\"]\n         self.run_python(cmdargs)\n \n         for name in names:\n             self.assertFalse(os.path.exists(name), name)\n \n-    @unittest.skipIf(support.is_wasi,\n-                     'checking temp files is not implemented on WASI')\n+    @unittest.skipIf(\n+        support.is_wasi, \"checking temp files is not implemented on WASI\"\n+    )\n     def test_leak_tmp_file(self):\n         code = textwrap.dedent(r\"\"\"\n             import os.path\n@@ -2013,21 +2198,30 @@ def test_leak_tmp_file(self):\n         \"\"\")\n         testnames = [self.create_test(code=code) for _ in range(3)]\n \n-        output = self.run_tests(\"--fail-env-changed\", \"-v\", \"-j2\", *testnames,\n-                                exitcode=EXITCODE_ENV_CHANGED)\n-        self.check_executed_tests(output, testnames,\n-                                  env_changed=testnames,\n-                                  fail_env_changed=True,\n-                                  parallel=True,\n-                                  stats=len(testnames))\n+        output = self.run_tests(\n+            \"--fail-env-changed\",\n+            \"-v\",\n+            \"-j2\",\n+            *testnames,\n+            exitcode=EXITCODE_ENV_CHANGED,\n+        )\n+        self.check_executed_tests(\n+            output,\n+            testnames,\n+            env_changed=testnames,\n+            fail_env_changed=True,\n+            parallel=True,\n+            stats=len(testnames),\n+        )\n         for testname in testnames:\n-            self.assertIn(f\"Warning -- {testname} leaked temporary \"\n-                          f\"files (1): mytmpfile\",\n-                          output)\n+            self.assertIn(\n+                f\"Warning -- {testname} leaked temporary files (1): mytmpfile\",\n+                output,\n+            )\n \n     def test_worker_decode_error(self):\n         # gh-109425: Use \"backslashreplace\" error handler to decode stdout.\n-        if sys.platform == 'win32':\n+        if sys.platform == \"win32\":\n             encoding = locale.getencoding()\n         else:\n             encoding = sys.stdout.encoding\n@@ -2040,8 +2234,8 @@ def test_worker_decode_error(self):\n         corrupted_output = b\"nonascii:%s\\n\" % (nonascii,)\n         # gh-108989: On Windows, assertion errors are written in UTF-16: when\n         # decoded each letter is follow by a NUL character.\n-        assertion_failed = 'Assertion failed: tstate_is_alive(tstate)\\n'\n-        corrupted_output += assertion_failed.encode('utf-16-le')\n+        assertion_failed = \"Assertion failed: tstate_is_alive(tstate)\\n\"\n+        corrupted_output += assertion_failed.encode(\"utf-16-le\")\n         try:\n             corrupted_output.decode(encoding)\n         except UnicodeDecodeError:\n@@ -2049,9 +2243,9 @@ def test_worker_decode_error(self):\n         else:\n             self.skipTest(f\"{encoding} can decode non-ASCII bytes\")\n \n-        expected_line = corrupted_output.decode(encoding, 'backslashreplace')\n+        expected_line = corrupted_output.decode(encoding, \"backslashreplace\")\n \n-        code = textwrap.dedent(fr\"\"\"\n+        code = textwrap.dedent(rf\"\"\"\n             import sys\n             import unittest\n \n@@ -2067,9 +2261,7 @@ def test_pass(self):\n         testname = self.create_test(code=code)\n \n         output = self.run_tests(\"--fail-env-changed\", \"-v\", \"-j1\", testname)\n-        self.check_executed_tests(output, [testname],\n-                                  parallel=True,\n-                                  stats=1)\n+        self.check_executed_tests(output, [testname], parallel=True, stats=1)\n         self.check_line(output, expected_line, regex=False)\n \n     def test_doctest(self):\n@@ -2104,17 +2296,25 @@ def load_tests(loader, tests, pattern):\n         ''')\n         testname = self.create_test(code=code)\n \n-        output = self.run_tests(\"--fail-env-changed\", \"-v\", \"-j1\", testname,\n-                                exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, [testname],\n-                                  failed=[testname],\n-                                  parallel=True,\n-                                  stats=TestStats(1, 2, 1))\n+        output = self.run_tests(\n+            \"--fail-env-changed\",\n+            \"-v\",\n+            \"-j1\",\n+            testname,\n+            exitcode=EXITCODE_BAD_TEST,\n+        )\n+        self.check_executed_tests(\n+            output,\n+            [testname],\n+            failed=[testname],\n+            parallel=True,\n+            stats=TestStats(1, 2, 1),\n+        )\n \n     def _check_random_seed(self, run_workers: bool):\n         # gh-109276: When -r/--randomize is used, random.seed() is called\n         # with the same random seed before running each test file.\n-        code = textwrap.dedent(r'''\n+        code = textwrap.dedent(r\"\"\"\n             import random\n             import unittest\n \n@@ -2122,15 +2322,17 @@ class RandomSeedTest(unittest.TestCase):\n                 def test_randint(self):\n                     numbers = [random.randint(0, 1000) for _ in range(10)]\n                     print(f\"Random numbers: {numbers}\")\n-        ''')\n-        tests = [self.create_test(name=f'test_random{i}', code=code)\n-                 for i in range(1, 3+1)]\n+        \"\"\")\n+        tests = [\n+            self.create_test(name=f\"test_random{i}\", code=code)\n+            for i in range(1, 3 + 1)\n+        ]\n \n         random_seed = 856_656_202\n         cmd = [\"--randomize\", f\"--randseed={random_seed}\"]\n         if run_workers:\n             # run as many worker processes than the number of tests\n-            cmd.append(f'-j{len(tests)}')\n+            cmd.append(f\"-j{len(tests)}\")\n         cmd.extend(tests)\n         output = self.run_tests(*cmd)\n \n@@ -2141,7 +2343,7 @@ def test_randint(self):\n         numbers = [random.randint(0, 1000) for _ in range(10)]\n         expected = f\"Random numbers: {numbers}\"\n \n-        regex = r'^Random numbers: .*$'\n+        regex = r\"^Random numbers: .*$\"\n         matches = re.findall(regex, output, flags=re.MULTILINE)\n         self.assertEqual(matches, [expected] * len(tests))\n \n@@ -2163,14 +2365,15 @@ def test_dev_mode(self):\n         tests = [self.create_test(code=code) for _ in range(3)]\n \n         # Custom Python command: \"python -X dev\"\n-        python_cmd = [sys.executable, '-X', 'dev']\n+        python_cmd = [sys.executable, \"-X\", \"dev\"]\n         # test.libregrtest.cmdline uses shlex.split() to parse the Python\n         # command line string\n         python_cmd = shlex.join(python_cmd)\n \n         output = self.run_tests(\"--python\", python_cmd, \"-j0\", *tests)\n-        self.check_executed_tests(output, tests,\n-                                  stats=len(tests), parallel=True)\n+        self.check_executed_tests(\n+            output, tests, stats=len(tests), parallel=True\n+        )\n \n     def test_unload_tests(self):\n         # Test that unloading test modules does not break tests\n@@ -2184,10 +2387,19 @@ def test_unload_tests(self):\n         # sys.modules was left after test_regrtest_a (making the import\n         # statement no-op), but new test_regrtest_b without the util attribute\n         # was imported for test_regrtest_b.\n-        testdir = os.path.join(os.path.dirname(__file__),\n-                               'regrtestdata', 'import_from_tests')\n-        tests = [f'test_regrtest_{name}' for name in ('a', 'b', 'c')]\n-        args = ['-Wd', '-E', '-bb', '-m', 'test', '--testdir=%s' % testdir, *tests]\n+        testdir = os.path.join(\n+            os.path.dirname(__file__), \"regrtestdata\", \"import_from_tests\"\n+        )\n+        tests = [f\"test_regrtest_{name}\" for name in (\"a\", \"b\", \"c\")]\n+        args = [\n+            \"-Wd\",\n+            \"-E\",\n+            \"-bb\",\n+            \"-m\",\n+            \"test\",\n+            \"--testdir=%s\" % testdir,\n+            *tests,\n+        ]\n         output = self.run_python(args)\n         self.check_executed_tests(output, tests, stats=3)\n \n@@ -2195,7 +2407,7 @@ def check_add_python_opts(self, option):\n         # --fast-ci and --slow-ci add \"-u -W default -bb -E\" options to Python\n \n         # Skip test if _testinternalcapi is missing\n-        import_helper.import_module('_testinternalcapi')\n+        import_helper.import_module(\"_testinternalcapi\")\n \n         code = textwrap.dedent(r\"\"\"\n             import sys\n@@ -2240,14 +2452,17 @@ def test_python_opts(self):\n         testname = self.create_test(code=code)\n \n         # Use directly subprocess to control the exact command line\n-        cmd = [sys.executable,\n-               \"-m\", \"test\", option,\n-               f'--testdir={self.tmptestdir}',\n-               testname]\n-        proc = subprocess.run(cmd,\n-                              stdout=subprocess.PIPE,\n-                              stderr=subprocess.STDOUT,\n-                              text=True)\n+        cmd = [\n+            sys.executable,\n+            \"-m\",\n+            \"test\",\n+            option,\n+            f\"--testdir={self.tmptestdir}\",\n+            testname,\n+        ]\n+        proc = subprocess.run(\n+            cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True\n+        )\n         self.assertEqual(proc.returncode, 0, proc)\n \n     def test_add_python_opts(self):\n@@ -2256,11 +2471,12 @@ def test_add_python_opts(self):\n                 self.check_add_python_opts(opt)\n \n     # gh-76319: Raising SIGSEGV on Android may not cause a crash.\n-    @unittest.skipIf(support.is_android,\n-                     'raising SIGSEGV on Android is unreliable')\n+    @unittest.skipIf(\n+        support.is_android, \"raising SIGSEGV on Android is unreliable\"\n+    )\n     def test_worker_output_on_failure(self):\n         # Skip test if faulthandler is missing\n-        import_helper.import_module('faulthandler')\n+        import_helper.import_module(\"faulthandler\")\n \n         code = textwrap.dedent(r\"\"\"\n             import faulthandler\n@@ -2278,15 +2494,15 @@ def test_crash(self):\n \n         # Sanitizers must not handle SIGSEGV (ex: for test_enable_fd())\n         env = dict(os.environ)\n-        option = 'handle_segv=0'\n+        option = \"handle_segv=0\"\n         support.set_sanitizer_env_var(env, option)\n \n-        output = self.run_tests(\"-j1\", testname,\n-                                exitcode=EXITCODE_BAD_TEST,\n-                                env=env)\n-        self.check_executed_tests(output, testname,\n-                                  failed=[testname],\n-                                  stats=0, parallel=True)\n+        output = self.run_tests(\n+            \"-j1\", testname, exitcode=EXITCODE_BAD_TEST, env=env\n+        )\n+        self.check_executed_tests(\n+            output, testname, failed=[testname], stats=0, parallel=True\n+        )\n         if not support.MS_WINDOWS:\n             exitcode = -int(signal.SIGSEGV)\n             self.assertIn(f\"Exit code {exitcode} (SIGSEGV)\", output)\n@@ -2306,14 +2522,14 @@ def test_pass(self):\n         # Run sequentially\n         output = self.run_tests(\"--verbose3\", testname)\n         self.check_executed_tests(output, testname, stats=1)\n-        self.assertNotIn('SPAM SPAM SPAM', output)\n+        self.assertNotIn(\"SPAM SPAM SPAM\", output)\n \n         # -R option needs a debug build\n         if support.Py_DEBUG:\n             # Check for reference leaks, run in parallel\n             output = self.run_tests(\"-R\", \"3:3\", \"-j1\", \"--verbose3\", testname)\n             self.check_executed_tests(output, testname, stats=1, parallel=True)\n-            self.assertNotIn('SPAM SPAM SPAM', output)\n+            self.assertNotIn(\"SPAM SPAM SPAM\", output)\n \n     def test_xml(self):\n         code = textwrap.dedent(r\"\"\"\n@@ -2330,26 +2546,27 @@ def test_failed(self):\n         filename = os_helper.TESTFN\n         self.addCleanup(os_helper.unlink, filename)\n \n-        output = self.run_tests(testname, \"--junit-xml\", filename,\n-                                exitcode=EXITCODE_BAD_TEST)\n-        self.check_executed_tests(output, testname,\n-                                  failed=testname,\n-                                  stats=TestStats(1, 1, 0))\n+        output = self.run_tests(\n+            testname, \"--junit-xml\", filename, exitcode=EXITCODE_BAD_TEST\n+        )\n+        self.check_executed_tests(\n+            output, testname, failed=testname, stats=TestStats(1, 1, 0)\n+        )\n \n         # Test generated XML\n         with open(filename, encoding=\"utf8\") as fp:\n             content = fp.read()\n \n         testsuite = ElementTree.fromstring(content)\n-        self.assertEqual(int(testsuite.get('tests')), 1)\n-        self.assertEqual(int(testsuite.get('errors')), 0)\n-        self.assertEqual(int(testsuite.get('failures')), 1)\n+        self.assertEqual(int(testsuite.get(\"tests\")), 1)\n+        self.assertEqual(int(testsuite.get(\"errors\")), 0)\n+        self.assertEqual(int(testsuite.get(\"failures\")), 1)\n \n         testcase = testsuite[0][0]\n-        self.assertEqual(testcase.get('status'), 'run')\n-        self.assertEqual(testcase.get('result'), 'completed')\n-        self.assertGreater(float(testcase.get('time')), 0)\n-        for out in testcase.iter('system-out'):\n+        self.assertEqual(testcase.get(\"status\"), \"run\")\n+        self.assertEqual(testcase.get(\"result\"), \"completed\")\n+        self.assertGreater(float(testcase.get(\"time\")), 0)\n+        for out in testcase.iter(\"system-out\"):\n             self.assertEqual(out.text, r\"abc \\x1b def\")\n \n     def test_nonascii(self):\n@@ -2370,86 +2587,97 @@ def test_skip(self):\n         testname = self.create_test(code=code)\n \n         env = dict(os.environ)\n-        env['PYTHONIOENCODING'] = 'ascii'\n+        env[\"PYTHONIOENCODING\"] = \"ascii\"\n \n         def check(output):\n-            self.check_executed_tests(output, testname, stats=TestStats(3, 0, 1))\n-            self.assertIn(r'docstring:\\u20ac', output)\n-            self.assertIn(r'skipped:\\u20ac', output)\n+            self.check_executed_tests(\n+                output, testname, stats=TestStats(3, 0, 1)\n+            )\n+            self.assertIn(r\"docstring:\\u20ac\", output)\n+            self.assertIn(r\"skipped:\\u20ac\", output)\n \n         # Run sequentially\n-        output = self.run_tests('-v', testname, env=env, isolated=False)\n+        output = self.run_tests(\"-v\", testname, env=env, isolated=False)\n         check(output)\n \n         # Run in parallel\n-        output = self.run_tests('-j1', '-v', testname, env=env, isolated=False)\n+        output = self.run_tests(\"-j1\", \"-v\", testname, env=env, isolated=False)\n         check(output)\n \n     def test_pgo_exclude(self):\n         # Get PGO tests\n-        output = self.run_tests('--pgo', '--list-tests')\n+        output = self.run_tests(\"--pgo\", \"--list-tests\")\n         pgo_tests = output.strip().split()\n \n         # Exclude test_re\n-        output = self.run_tests('--pgo', '--list-tests', '-x', 'test_re')\n+        output = self.run_tests(\"--pgo\", \"--list-tests\", \"-x\", \"test_re\")\n         tests = output.strip().split()\n-        self.assertNotIn('test_re', tests)\n+        self.assertNotIn(\"test_re\", tests)\n         self.assertEqual(len(tests), len(pgo_tests) - 1)\n \n \n class TestUtils(unittest.TestCase):\n     def test_format_duration(self):\n-        self.assertEqual(utils.format_duration(0),\n-                         '0 ms')\n-        self.assertEqual(utils.format_duration(1e-9),\n-                         '1 ms')\n-        self.assertEqual(utils.format_duration(10e-3),\n-                         '10 ms')\n-        self.assertEqual(utils.format_duration(1.5),\n-                         '1.5 sec')\n-        self.assertEqual(utils.format_duration(1),\n-                         '1.0 sec')\n-        self.assertEqual(utils.format_duration(2 * 60),\n-                         '2 min')\n-        self.assertEqual(utils.format_duration(2 * 60 + 1),\n-                         '2 min 1 sec')\n-        self.assertEqual(utils.format_duration(3 * 3600),\n-                         '3 hour')\n-        self.assertEqual(utils.format_duration(3 * 3600  + 2 * 60 + 1),\n-                         '3 hour 2 min')\n-        self.assertEqual(utils.format_duration(3 * 3600 + 1),\n-                         '3 hour 1 sec')\n+        self.assertEqual(utils.format_duration(0), \"0 ms\")\n+        self.assertEqual(utils.format_duration(1e-9), \"1 ms\")\n+        self.assertEqual(utils.format_duration(10e-3), \"10 ms\")\n+        self.assertEqual(utils.format_duration(1.5), \"1.5 sec\")\n+        self.assertEqual(utils.format_duration(1), \"1.0 sec\")\n+        self.assertEqual(utils.format_duration(2 * 60), \"2 min\")\n+        self.assertEqual(utils.format_duration(2 * 60 + 1), \"2 min 1 sec\")\n+        self.assertEqual(utils.format_duration(3 * 3600), \"3 hour\")\n+        self.assertEqual(\n+            utils.format_duration(3 * 3600 + 2 * 60 + 1), \"3 hour 2 min\"\n+        )\n+        self.assertEqual(utils.format_duration(3 * 3600 + 1), \"3 hour 1 sec\")\n \n     def test_normalize_test_name(self):\n         normalize = normalize_test_name\n-        self.assertEqual(normalize('test_access (test.test_os.FileTests.test_access)'),\n-                         'test_access')\n-        self.assertEqual(normalize('setUpClass (test.test_os.ChownFileTests)', is_error=True),\n-                         'ChownFileTests')\n-        self.assertEqual(normalize('test_success (test.test_bug.ExampleTests.test_success)', is_error=True),\n-                         'test_success')\n-        self.assertIsNone(normalize('setUpModule (test.test_x)', is_error=True))\n-        self.assertIsNone(normalize('tearDownModule (test.test_module)', is_error=True))\n+        self.assertEqual(\n+            normalize(\"test_access (test.test_os.FileTests.test_access)\"),\n+            \"test_access\",\n+        )\n+        self.assertEqual(\n+            normalize(\n+                \"setUpClass (test.test_os.ChownFileTests)\", is_error=True\n+            ),\n+            \"ChownFileTests\",\n+        )\n+        self.assertEqual(\n+            normalize(\n+                \"test_success (test.test_bug.ExampleTests.test_success)\",\n+                is_error=True,\n+            ),\n+            \"test_success\",\n+        )\n+        self.assertIsNone(\n+            normalize(\"setUpModule (test.test_x)\", is_error=True)\n+        )\n+        self.assertIsNone(\n+            normalize(\"tearDownModule (test.test_module)\", is_error=True)\n+        )\n \n     def test_format_resources(self):\n         format_resources = utils.format_resources\n         ALL_RESOURCES = utils.ALL_RESOURCES\n         self.assertEqual(\n-            format_resources((\"network\",)),\n-            'resources (1): network')\n+            format_resources((\"network\",)), \"resources (1): network\"\n+        )\n         self.assertEqual(\n             format_resources((\"audio\", \"decimal\", \"network\")),\n-            'resources (3): audio,decimal,network')\n-        self.assertEqual(\n-            format_resources(ALL_RESOURCES),\n-            'resources: all')\n+            \"resources (3): audio,decimal,network\",\n+        )\n+        self.assertEqual(format_resources(ALL_RESOURCES), \"resources: all\")\n         self.assertEqual(\n-            format_resources(tuple(name for name in ALL_RESOURCES\n-                                   if name != \"cpu\")),\n-            'resources: all,-cpu')\n+            format_resources(\n+                tuple(name for name in ALL_RESOURCES if name != \"cpu\")\n+            ),\n+            \"resources: all,-cpu\",\n+        )\n         self.assertEqual(\n             format_resources((*ALL_RESOURCES, \"tzdata\")),\n-            'resources: all,tzdata')\n+            \"resources: all,tzdata\",\n+        )\n \n     def test_match_test(self):\n         class Test:\n@@ -2463,12 +2691,12 @@ def id(self):\n         patterns = get_match_tests()\n         self.addCleanup(set_match_tests, patterns)\n \n-        test_access = Test('test.test_os.FileTests.test_access')\n-        test_chdir = Test('test.test_os.Win32ErrorTests.test_chdir')\n-        test_copy = Test('test.test_shutil.TestCopy.test_copy')\n+        test_access = Test(\"test.test_os.FileTests.test_access\")\n+        test_chdir = Test(\"test.test_os.Win32ErrorTests.test_chdir\")\n+        test_copy = Test(\"test.test_shutil.TestCopy.test_copy\")\n \n         # Test acceptance\n-        with support.swap_attr(support, '_test_matchers', ()):\n+        with support.swap_attr(support, \"_test_matchers\", ()):\n             # match all\n             set_match_tests([])\n             self.assertTrue(match_test(test_access))\n@@ -2485,86 +2713,90 @@ def id(self):\n             self.assertFalse(match_test(test_chdir))\n \n             # match the module name\n-            set_match_tests([('test_os', True)])\n+            set_match_tests([(\"test_os\", True)])\n             self.assertTrue(match_test(test_access))\n             self.assertTrue(match_test(test_chdir))\n             self.assertFalse(match_test(test_copy))\n \n             # Test '*' pattern\n-            set_match_tests([('test_*', True)])\n+            set_match_tests([(\"test_*\", True)])\n             self.assertTrue(match_test(test_access))\n             self.assertTrue(match_test(test_chdir))\n \n             # Test case sensitivity\n-            set_match_tests([('filetests', True)])\n+            set_match_tests([(\"filetests\", True)])\n             self.assertFalse(match_test(test_access))\n-            set_match_tests([('FileTests', True)])\n+            set_match_tests([(\"FileTests\", True)])\n             self.assertTrue(match_test(test_access))\n \n             # Test pattern containing '.' and a '*' metacharacter\n-            set_match_tests([('*test_os.*.test_*', True)])\n+            set_match_tests([(\"*test_os.*.test_*\", True)])\n             self.assertTrue(match_test(test_access))\n             self.assertTrue(match_test(test_chdir))\n             self.assertFalse(match_test(test_copy))\n \n             # Multiple patterns\n-            set_match_tests([(test_access.id(), True), (test_chdir.id(), True)])\n+            set_match_tests(\n+                [(test_access.id(), True), (test_chdir.id(), True)]\n+            )\n             self.assertTrue(match_test(test_access))\n             self.assertTrue(match_test(test_chdir))\n             self.assertFalse(match_test(test_copy))\n \n-            set_match_tests([('test_access', True), ('DONTMATCH', True)])\n+            set_match_tests([(\"test_access\", True), (\"DONTMATCH\", True)])\n             self.assertTrue(match_test(test_access))\n             self.assertFalse(match_test(test_chdir))\n \n         # Test rejection\n-        with support.swap_attr(support, '_test_matchers', ()):\n+        with support.swap_attr(support, \"_test_matchers\", ()):\n             # match the full test identifier\n             set_match_tests([(test_access.id(), False)])\n             self.assertFalse(match_test(test_access))\n             self.assertTrue(match_test(test_chdir))\n \n             # match the module name\n-            set_match_tests([('test_os', False)])\n+            set_match_tests([(\"test_os\", False)])\n             self.assertFalse(match_test(test_access))\n             self.assertFalse(match_test(test_chdir))\n             self.assertTrue(match_test(test_copy))\n \n             # Test '*' pattern\n-            set_match_tests([('test_*', False)])\n+            set_match_tests([(\"test_*\", False)])\n             self.assertFalse(match_test(test_access))\n             self.assertFalse(match_test(test_chdir))\n \n             # Test case sensitivity\n-            set_match_tests([('filetests', False)])\n+            set_match_tests([(\"filetests\", False)])\n             self.assertTrue(match_test(test_access))\n-            set_match_tests([('FileTests', False)])\n+            set_match_tests([(\"FileTests\", False)])\n             self.assertFalse(match_test(test_access))\n \n             # Test pattern containing '.' and a '*' metacharacter\n-            set_match_tests([('*test_os.*.test_*', False)])\n+            set_match_tests([(\"*test_os.*.test_*\", False)])\n             self.assertFalse(match_test(test_access))\n             self.assertFalse(match_test(test_chdir))\n             self.assertTrue(match_test(test_copy))\n \n             # Multiple patterns\n-            set_match_tests([(test_access.id(), False), (test_chdir.id(), False)])\n+            set_match_tests(\n+                [(test_access.id(), False), (test_chdir.id(), False)]\n+            )\n             self.assertFalse(match_test(test_access))\n             self.assertFalse(match_test(test_chdir))\n             self.assertTrue(match_test(test_copy))\n \n-            set_match_tests([('test_access', False), ('DONTMATCH', False)])\n+            set_match_tests([(\"test_access\", False), (\"DONTMATCH\", False)])\n             self.assertFalse(match_test(test_access))\n             self.assertTrue(match_test(test_chdir))\n \n         # Test mixed filters\n-        with support.swap_attr(support, '_test_matchers', ()):\n-            set_match_tests([('*test_os', False), ('test_access', True)])\n+        with support.swap_attr(support, \"_test_matchers\", ()):\n+            set_match_tests([(\"*test_os\", False), (\"test_access\", True)])\n             self.assertTrue(match_test(test_access))\n             self.assertFalse(match_test(test_chdir))\n             self.assertTrue(match_test(test_copy))\n \n-            set_match_tests([('*test_os', True), ('test_access', False)])\n+            set_match_tests([(\"*test_os\", True), (\"test_access\", False)])\n             self.assertFalse(match_test(test_access))\n             self.assertTrue(match_test(test_chdir))\n             self.assertFalse(match_test(test_copy))\n@@ -2573,20 +2805,21 @@ def test_sanitize_xml(self):\n         sanitize_xml = utils.sanitize_xml\n \n         # escape invalid XML characters\n-        self.assertEqual(sanitize_xml('abc \\x1b\\x1f def'),\n-                         r'abc \\x1b\\x1f def')\n-        self.assertEqual(sanitize_xml('nul:\\x00, bell:\\x07'),\n-                         r'nul:\\x00, bell:\\x07')\n-        self.assertEqual(sanitize_xml('surrogate:\\uDC80'),\n-                         r'surrogate:\\udc80')\n-        self.assertEqual(sanitize_xml('illegal \\uFFFE and \\uFFFF'),\n-                         r'illegal \\ufffe and \\uffff')\n+        self.assertEqual(sanitize_xml(\"abc \\x1b\\x1f def\"), r\"abc \\x1b\\x1f def\")\n+        self.assertEqual(\n+            sanitize_xml(\"nul:\\x00, bell:\\x07\"), r\"nul:\\x00, bell:\\x07\"\n+        )\n+        self.assertEqual(sanitize_xml(\"surrogate:\\udc80\"), r\"surrogate:\\udc80\")\n+        self.assertEqual(\n+            sanitize_xml(\"illegal \\ufffe and \\uffff\"),\n+            r\"illegal \\ufffe and \\uffff\",\n+        )\n \n         # no escape for valid XML characters\n-        self.assertEqual(sanitize_xml('a\\n\\tb'),\n-                         'a\\n\\tb')\n-        self.assertEqual(sanitize_xml('valid t\\xe9xt \\u20ac'),\n-                         'valid t\\xe9xt \\u20ac')\n+        self.assertEqual(sanitize_xml(\"a\\n\\tb\"), \"a\\n\\tb\")\n+        self.assertEqual(\n+            sanitize_xml(\"valid t\\xe9xt \\u20ac\"), \"valid t\\xe9xt \\u20ac\"\n+        )\n \n \n from test.libregrtest.results import TestResults\n@@ -2633,6 +2866,6 @@ def test_test_result_get_state(self):\n                 self.assertEqual(result, expected)\n \n \n-if __name__ == '__main__':\n+if __name__ == \"__main__\":\n     setup.setup_process()\n     unittest.main()\ndiff --git a/Lib/test/test_sys.py b/Lib/test/test_sys.py\nindex 1198c6d3..dd98f9cf 100644\n--- a/Lib/test/test_sys.py\n+++ b/Lib/test/test_sys.py\n@@ -23,6 +23,7 @@\n from test.support import import_helper\n from test.support import force_not_colorized\n from test.support import SHORT_TIMEOUT\n+\n try:\n     from concurrent import interpreters\n except ImportError:\n@@ -34,14 +35,15 @@\n \n def requires_subinterpreters(meth):\n     \"\"\"Decorator to skip a test if subinterpreters are not supported.\"\"\"\n-    return unittest.skipIf(interpreters is None,\n-                           'subinterpreters required')(meth)\n+    return unittest.skipIf(interpreters is None, \"subinterpreters required\")(\n+        meth\n+    )\n \n \n-DICT_KEY_STRUCT_FORMAT = 'n2BI2n'\n+DICT_KEY_STRUCT_FORMAT = \"n2BI2n\"\n \n-class DisplayHookTest(unittest.TestCase):\n \n+class DisplayHookTest(unittest.TestCase):\n     def test_original_displayhook(self):\n         dh = sys.__displayhook__\n \n@@ -82,7 +84,7 @@ def test_custom_displayhook(self):\n         def baddisplayhook(obj):\n             raise ValueError\n \n-        with support.swap_attr(sys, 'displayhook', baddisplayhook):\n+        with support.swap_attr(sys, \"displayhook\", baddisplayhook):\n             code = compile(\"42\", \"<string>\", \"single\")\n             self.assertRaises(ValueError, eval, code)\n \n@@ -91,9 +93,9 @@ class X:\n             def __repr__(self):\n                 sys.stdout = io.StringIO()\n                 support.gc_collect()\n-                return 'foo'\n+                return \"foo\"\n \n-        with support.swap_attr(sys, 'stdout', None):\n+        with support.swap_attr(sys, \"stdout\", None):\n             sys.stdout = io.StringIO()  # the only reference\n             sys.displayhook(X())  # should not crash\n \n@@ -163,7 +165,6 @@ def f():\n \n \n class ExceptHookTest(unittest.TestCase):\n-\n     @force_not_colorized\n     def test_original_excepthook(self):\n         try:\n@@ -181,7 +182,7 @@ def test_excepthook_bytes_filename(self):\n         # bpo-37467: sys.excepthook() must not crash if a filename\n         # is a bytes string\n         with warnings.catch_warnings():\n-            warnings.simplefilter('ignore', BytesWarning)\n+            warnings.simplefilter(\"ignore\", BytesWarning)\n \n             try:\n                 raise SyntaxError(\"msg\", (b\"bytes_filename\", 123, 0, \"text\"))\n@@ -197,16 +198,17 @@ def test_excepthook_bytes_filename(self):\n     def test_excepthook(self):\n         with test.support.captured_output(\"stderr\") as stderr:\n             with test.support.catch_unraisable_exception():\n-                sys.excepthook(1, '1', 1)\n-        self.assertTrue(\"TypeError: print_exception(): Exception expected for \" \\\n-                         \"value, str found\" in stderr.getvalue())\n+                sys.excepthook(1, \"1\", 1)\n+        self.assertTrue(\n+            \"TypeError: print_exception(): Exception expected for \"\n+            \"value, str found\" in stderr.getvalue()\n+        )\n \n     # FIXME: testing the code for a lost or replaced excepthook in\n     # Python/pythonrun.c::PyErr_PrintEx() is tricky.\n \n \n class SysModuleTest(unittest.TestCase):\n-\n     def tearDown(self):\n         test.support.reap_children()\n \n@@ -219,24 +221,28 @@ def test_exit(self):\n             sys.exit()\n         self.assertIsNone(cm.exception.code)\n \n-        rc, out, err = assert_python_ok('-c', 'import sys; sys.exit()')\n+        rc, out, err = assert_python_ok(\"-c\", \"import sys; sys.exit()\")\n         self.assertEqual(rc, 0)\n-        self.assertEqual(out, b'')\n-        self.assertEqual(err, b'')\n+        self.assertEqual(out, b\"\")\n+        self.assertEqual(err, b\"\")\n \n         # gh-125842: Windows uses 32-bit unsigned integers for exit codes\n         # so a -1 exit code is sometimes interpreted as 0xffff_ffff.\n-        rc, out, err = assert_python_failure('-c', 'import sys; sys.exit(0xffff_ffff)')\n-        self.assertIn(rc, (-1, 0xff, 0xffff_ffff))\n-        self.assertEqual(out, b'')\n-        self.assertEqual(err, b'')\n+        rc, out, err = assert_python_failure(\n+            \"-c\", \"import sys; sys.exit(0xffff_ffff)\"\n+        )\n+        self.assertIn(rc, (-1, 0xFF, 0xFFFF_FFFF))\n+        self.assertEqual(out, b\"\")\n+        self.assertEqual(err, b\"\")\n \n         # Overflow results in a -1 exit code, which may be converted to 0xff\n         # or 0xffff_ffff.\n-        rc, out, err = assert_python_failure('-c', 'import sys; sys.exit(2**128)')\n-        self.assertIn(rc, (-1, 0xff, 0xffff_ffff))\n-        self.assertEqual(out, b'')\n-        self.assertEqual(err, b'')\n+        rc, out, err = assert_python_failure(\n+            \"-c\", \"import sys; sys.exit(2**128)\"\n+        )\n+        self.assertIn(rc, (-1, 0xFF, 0xFFFF_FFFF))\n+        self.assertEqual(out, b\"\")\n+        self.assertEqual(err, b\"\")\n \n         # call with integer argument\n         with self.assertRaises(SystemExit) as cm:\n@@ -260,34 +266,37 @@ def test_exit(self):\n         self.assertEqual(cm.exception.code, (17, 23))\n \n         # test that the exit machinery handles SystemExits properly\n-        rc, out, err = assert_python_failure('-c', 'raise SystemExit(47)')\n+        rc, out, err = assert_python_failure(\"-c\", \"raise SystemExit(47)\")\n         self.assertEqual(rc, 47)\n-        self.assertEqual(out, b'')\n-        self.assertEqual(err, b'')\n+        self.assertEqual(out, b\"\")\n+        self.assertEqual(err, b\"\")\n \n         def check_exit_message(code, expected, **env_vars):\n-            rc, out, err = assert_python_failure('-c', code, **env_vars)\n+            rc, out, err = assert_python_failure(\"-c\", code, **env_vars)\n             self.assertEqual(rc, 1)\n-            self.assertEqual(out, b'')\n+            self.assertEqual(out, b\"\")\n             self.assertStartsWith(err, expected)\n \n         # test that stderr buffer is flushed before the exit message is written\n         # into stderr\n         check_exit_message(\n             r'import sys; sys.stderr.write(\"unflushed,\"); sys.exit(\"message\")',\n-            b\"unflushed,message\")\n+            b\"unflushed,message\",\n+        )\n \n         # test that the exit message is written with backslashreplace error\n         # handler to stderr\n         check_exit_message(\n-            r'import sys; sys.exit(\"surrogates:\\uDCFF\")',\n-            b\"surrogates:\\\\udcff\")\n+            r'import sys; sys.exit(\"surrogates:\\uDCFF\")', b\"surrogates:\\\\udcff\"\n+        )\n \n         # test that the unicode message is encoded to the stderr encoding\n         # instead of the default encoding (utf8)\n         check_exit_message(\n             r'import sys; sys.exit(\"h\\xe9\")',\n-            b\"h\\xe9\", PYTHONIOENCODING='latin-1')\n+            b\"h\\xe9\",\n+            PYTHONIOENCODING=\"latin-1\",\n+        )\n \n     @support.requires_subprocess()\n     def test_exit_codes_under_repl(self):\n@@ -295,11 +304,7 @@ def test_exit_codes_under_repl(self):\n         # get their return code propagated by the REPL\n         import tempfile\n \n-        exit_ways = [\n-            \"exit\",\n-            \"__import__('sys').exit\",\n-            \"raise SystemExit\"\n-        ]\n+        exit_ways = [\"exit\", \"__import__('sys').exit\", \"raise SystemExit\"]\n \n         for exitfunc in exit_ways:\n             for return_code in (0, 123):\n@@ -352,12 +357,14 @@ def test_setrecursionlimit(self):\n             sys.setrecursionlimit(old_limit)\n \n     def test_recursionlimit_recovery(self):\n-        if hasattr(sys, 'gettrace') and sys.gettrace():\n-            self.skipTest('fatal error if run with a trace function')\n+        if hasattr(sys, \"gettrace\") and sys.gettrace():\n+            self.skipTest(\"fatal error if run with a trace function\")\n \n         old_limit = sys.getrecursionlimit()\n+\n         def f():\n             f()\n+\n         try:\n             for depth in (50, 75, 100, 250, 1000):\n                 try:\n@@ -393,10 +400,12 @@ def test_setrecursionlimit_to_depth(self):\n                 sys.setrecursionlimit(old_limit)\n                 with self.assertRaises(RecursionError) as cm:\n                     sys.setrecursionlimit(depth)\n-            self.assertRegex(str(cm.exception),\n-                             \"cannot set the recursion limit to [0-9]+ \"\n-                             \"at the recursion depth [0-9]+: \"\n-                             \"the limit is too low\")\n+            self.assertRegex(\n+                str(cm.exception),\n+                \"cannot set the recursion limit to [0-9]+ \"\n+                \"at the recursion depth [0-9]+: \"\n+                \"the limit is too low\",\n+            )\n         finally:\n             sys.setrecursionlimit(old_limit)\n \n@@ -433,15 +442,16 @@ def test_getwindowsversion(self):\n     def test_call_tracing(self):\n         self.assertRaises(TypeError, sys.call_tracing, type, 2)\n \n-    @unittest.skipUnless(hasattr(sys, \"setdlopenflags\"),\n-                         'test needs sys.setdlopenflags()')\n+    @unittest.skipUnless(\n+        hasattr(sys, \"setdlopenflags\"), \"test needs sys.setdlopenflags()\"\n+    )\n     def test_dlopenflags(self):\n         self.assertHasAttr(sys, \"getdlopenflags\")\n         self.assertRaises(TypeError, sys.getdlopenflags, 42)\n         oldflags = sys.getdlopenflags()\n         self.assertRaises(TypeError, sys.setdlopenflags)\n-        sys.setdlopenflags(oldflags+1)\n-        self.assertEqual(sys.getdlopenflags(), oldflags+1)\n+        sys.setdlopenflags(oldflags + 1)\n+        self.assertEqual(sys.getdlopenflags(), oldflags + 1)\n         sys.setdlopenflags(oldflags)\n \n     @test.support.refcount_test\n@@ -470,8 +480,7 @@ def test_getframe(self):\n         self.assertRaises(TypeError, sys._getframe, 42, 42)\n         self.assertRaises(ValueError, sys._getframe, 2000000000)\n         self.assertTrue(\n-            SysModuleTest.test_getframe.__code__ \\\n-            is sys._getframe().f_code\n+            SysModuleTest.test_getframe.__code__ is sys._getframe().f_code\n         )\n \n     def test_getframemodulename(self):\n@@ -482,8 +491,8 @@ def test_getframemodulename(self):\n         f = sys._getframe(i)\n         while f:\n             self.assertEqual(\n-                f.f_globals['__name__'],\n-                sys._getframemodulename(i) or '__main__'\n+                f.f_globals[\"__name__\"],\n+                sys._getframemodulename(i) or \"__main__\",\n             )\n             i += 1\n             f2 = f.f_back\n@@ -545,7 +554,9 @@ def g456():\n             # threading.py are also in the thread's call stack.\n             frame = d.pop(thread_id)\n             stack = traceback.extract_stack(frame)\n-            for i, (filename, lineno, funcname, sourceline) in enumerate(stack):\n+            for i, (filename, lineno, funcname, sourceline) in enumerate(\n+                stack\n+            ):\n                 if funcname == \"f123\":\n                     break\n             else:\n@@ -554,7 +565,7 @@ def g456():\n             self.assertEqual(sourceline, \"g456()\")\n \n             # And the next record must be for g456().\n-            filename, lineno, funcname, sourceline = stack[i+1]\n+            filename, lineno, funcname, sourceline = stack[i + 1]\n             self.assertEqual(funcname, \"g456\")\n             self.assertIn(sourceline, [\"leave_g.wait()\", \"entered_g.set()\"])\n         finally:\n@@ -611,7 +622,9 @@ def g456():\n             # threading.py are also in the thread's call stack.\n             exc_value = d.pop(thread_id)\n             stack = traceback.extract_stack(exc_value.__traceback__.tb_frame)\n-            for i, (filename, lineno, funcname, sourceline) in enumerate(stack):\n+            for i, (filename, lineno, funcname, sourceline) in enumerate(\n+                stack\n+            ):\n                 if funcname == \"f123\":\n                     break\n             else:\n@@ -620,9 +633,11 @@ def g456():\n             self.assertEqual(sourceline, \"g456()\")\n \n             # And the next record must be for g456().\n-            filename, lineno, funcname, sourceline = stack[i+1]\n+            filename, lineno, funcname, sourceline = stack[i + 1]\n             self.assertEqual(funcname, \"g456\")\n-            self.assertStartsWith(sourceline, (\"if leave_g.wait(\", \"g_raised.set()\"))\n+            self.assertStartsWith(\n+                sourceline, (\"if leave_g.wait(\", \"g_raised.set()\")\n+            )\n         finally:\n             # Reap the spawned thread.\n             leave_g.set()\n@@ -649,8 +664,10 @@ def test_attributes(self):\n         self.assertTrue(sys.int_info.sizeof_digit >= 1)\n         self.assertGreaterEqual(sys.int_info.default_max_str_digits, 500)\n         self.assertGreaterEqual(sys.int_info.str_digits_check_threshold, 100)\n-        self.assertGreater(sys.int_info.default_max_str_digits,\n-                           sys.int_info.str_digits_check_threshold)\n+        self.assertGreater(\n+            sys.int_info.default_max_str_digits,\n+            sys.int_info.str_digits_check_threshold,\n+        )\n         self.assertEqual(type(sys.int_info.bits_per_digit), int)\n         self.assertEqual(type(sys.int_info.sizeof_digit), int)\n         self.assertIsInstance(sys.int_info.default_max_str_digits, int)\n@@ -664,11 +681,12 @@ def test_attributes(self):\n         # a Carmichael number)\n         for x in range(1, 100):\n             self.assertEqual(\n-                pow(x, sys.hash_info.modulus-1, sys.hash_info.modulus),\n+                pow(x, sys.hash_info.modulus - 1, sys.hash_info.modulus),\n                 1,\n                 \"sys.hash_info.modulus {} is a non-prime\".format(\n-                    sys.hash_info.modulus)\n-                )\n+                    sys.hash_info.modulus\n+                ),\n+            )\n         self.assertIsInstance(sys.hash_info.inf, int)\n         self.assertIsInstance(sys.hash_info.nan, int)\n         self.assertIsInstance(sys.hash_info.imag, int)\n@@ -684,7 +702,9 @@ def test_attributes(self):\n             elif algo == 3:\n                 self.assertEqual(sys.hash_info.algorithm, \"siphash13\")\n             else:\n-                self.assertIn(sys.hash_info.algorithm, {\"fnv\", \"siphash13\", \"siphash24\"})\n+                self.assertIn(\n+                    sys.hash_info.algorithm, {\"fnv\", \"siphash13\", \"siphash24\"}\n+                )\n         else:\n             # PY_HASH_EXTERNAL\n             self.assertEqual(algo, 0)\n@@ -717,19 +737,21 @@ def test_attributes(self):\n         self.assertEqual(vi[2], vi.micro)\n         self.assertEqual(vi[3], vi.releaselevel)\n         self.assertEqual(vi[4], vi.serial)\n-        self.assertTrue(vi > (1,0,0))\n+        self.assertTrue(vi > (1, 0, 0))\n         self.assertIsInstance(sys.float_repr_style, str)\n-        self.assertIn(sys.float_repr_style, ('short', 'legacy'))\n-        if not sys.platform.startswith('win'):\n+        self.assertIn(sys.float_repr_style, (\"short\", \"legacy\"))\n+        if not sys.platform.startswith(\"win\"):\n             self.assertIsInstance(sys.abiflags, str)\n         else:\n-            self.assertFalse(hasattr(sys, 'abiflags'))\n+            self.assertFalse(hasattr(sys, \"abiflags\"))\n \n     def test_thread_info(self):\n         info = sys.thread_info\n         self.assertEqual(len(info), 3)\n-        self.assertIn(info.name, ('nt', 'pthread', 'pthread-stubs', 'solaris', None))\n-        self.assertIn(info.lock, ('pymutex', None))\n+        self.assertIn(\n+            info.name, (\"nt\", \"pthread\", \"pthread-stubs\", \"solaris\", None)\n+        )\n+        self.assertIn(info.lock, (\"pymutex\", None))\n         if sys.platform.startswith((\"linux\", \"android\", \"freebsd\")):\n             self.assertEqual(info.name, \"pthread\")\n         elif sys.platform == \"win32\":\n@@ -741,14 +763,17 @@ def test_thread_info(self):\n \n     def test_abi_info(self):\n         info = sys.abi_info\n-        info_keys = {'pointer_bits', 'free_threaded', 'debug', 'byteorder'}\n+        info_keys = {\"pointer_bits\", \"free_threaded\", \"debug\", \"byteorder\"}\n         self.assertEqual(set(vars(info)), info_keys)\n         pointer_bits = 64 if sys.maxsize > 2**32 else 32\n         self.assertEqual(info.pointer_bits, pointer_bits)\n-        self.assertEqual(info.free_threaded,\n-                         bool(sysconfig.get_config_var('Py_GIL_DISABLED')))\n-        self.assertEqual(info.debug,\n-                         bool(sysconfig.get_config_var('Py_DEBUG')))\n+        self.assertEqual(\n+            info.free_threaded,\n+            bool(sysconfig.get_config_var(\"Py_GIL_DISABLED\")),\n+        )\n+        self.assertEqual(\n+            info.debug, bool(sysconfig.get_config_var(\"Py_DEBUG\"))\n+        )\n         self.assertEqual(info.byteorder, sys.byteorder)\n \n     @unittest.skipUnless(support.is_emscripten, \"only available on Emscripten\")\n@@ -765,13 +790,14 @@ def test_43581(self):\n         self.assertEqual(sys.__stdout__.encoding, sys.__stderr__.encoding)\n \n     def test_intern(self):\n-        has_is_interned = (test.support.check_impl_detail(cpython=True)\n-                           or hasattr(sys, '_is_interned'))\n+        has_is_interned = test.support.check_impl_detail(\n+            cpython=True\n+        ) or hasattr(sys, \"_is_interned\")\n         self.assertRaises(TypeError, sys.intern)\n-        self.assertRaises(TypeError, sys.intern, b'abc')\n+        self.assertRaises(TypeError, sys.intern, b\"abc\")\n         if has_is_interned:\n             self.assertRaises(TypeError, sys._is_interned)\n-            self.assertRaises(TypeError, sys._is_interned, b'abc')\n+            self.assertRaises(TypeError, sys._is_interned, b\"abc\")\n         s = \"never interned before\" + str(random.randrange(0, 10**9))\n         self.assertTrue(sys.intern(s) is s)\n         if has_is_interned:\n@@ -806,7 +832,8 @@ def test_subinterp_intern_dynamically_allocated(self):\n         self.assertIs(t, s)\n \n         interp = interpreters.create()\n-        interp.exec(textwrap.dedent(f'''\n+        interp.exec(\n+            textwrap.dedent(f\"\"\"\n             import sys\n \n             # set `s`, avoid parser interning & constant folding\n@@ -816,7 +843,8 @@ def test_subinterp_intern_dynamically_allocated(self):\n \n             assert id(t) != {id(s)}, (id(t), {id(s)})\n             assert id(t) != {id(t)}, (id(t), {id(t)})\n-            '''))\n+            \"\"\")\n+        )\n \n     @support.cpython_only\n     @requires_subinterpreters\n@@ -825,14 +853,26 @@ def test_subinterp_intern_statically_allocated(self):\n         # between interpreters.\n         # See Tools/build/generate_global_objects.py for the list\n         # of strings that are always statically allocated.\n-        for s in ('__init__', 'CANCELLED', '<module>', 'utf-8',\n-                  '{{', '', '\\n', '_', 'x', '\\0', '\\N{CEDILLA}', '\\xff',\n-                  ):\n+        for s in (\n+            \"__init__\",\n+            \"CANCELLED\",\n+            \"<module>\",\n+            \"utf-8\",\n+            \"{{\",\n+            \"\",\n+            \"\\n\",\n+            \"_\",\n+            \"x\",\n+            \"\\0\",\n+            \"\\N{CEDILLA}\",\n+            \"\\xff\",\n+        ):\n             with self.subTest(s=s):\n                 t = sys.intern(s)\n \n                 interp = interpreters.create()\n-                interp.exec(textwrap.dedent(f'''\n+                interp.exec(\n+                    textwrap.dedent(f\"\"\"\n                     import sys\n \n                     # set `s`, avoid parser interning & constant folding\n@@ -840,17 +880,19 @@ def test_subinterp_intern_statically_allocated(self):\n \n                     t = sys.intern(s)\n                     assert id(t) == {id(t)}, (id(t), {id(t)})\n-                    '''))\n+                    \"\"\")\n+                )\n \n     @support.cpython_only\n     @requires_subinterpreters\n     def test_subinterp_intern_singleton(self):\n         # Implementation detail: singletons are used for 0- and 1-character\n         # latin1 strings.\n-        for s in '', '\\n', '_', 'x', '\\0', '\\N{CEDILLA}', '\\xff':\n+        for s in \"\", \"\\n\", \"_\", \"x\", \"\\0\", \"\\N{CEDILLA}\", \"\\xff\":\n             with self.subTest(s=s):\n                 interp = interpreters.create()\n-                interp.exec(textwrap.dedent(f'''\n+                interp.exec(\n+                    textwrap.dedent(f\"\"\"\n                     import sys\n \n                     # set `s`, avoid parser interning & constant folding\n@@ -858,17 +900,32 @@ def test_subinterp_intern_singleton(self):\n \n                     assert id(s) == {id(s)}\n                     t = sys.intern(s)\n-                    '''))\n+                    \"\"\")\n+                )\n                 self.assertTrue(sys._is_interned(s))\n \n     def test_sys_flags(self):\n         self.assertTrue(sys.flags)\n-        attrs = (\"debug\",\n-                 \"inspect\", \"interactive\", \"optimize\",\n-                 \"dont_write_bytecode\", \"no_user_site\", \"no_site\",\n-                 \"ignore_environment\", \"verbose\", \"bytes_warning\", \"quiet\",\n-                 \"hash_randomization\", \"isolated\", \"dev_mode\", \"utf8_mode\",\n-                 \"warn_default_encoding\", \"safe_path\", \"int_max_str_digits\")\n+        attrs = (\n+            \"debug\",\n+            \"inspect\",\n+            \"interactive\",\n+            \"optimize\",\n+            \"dont_write_bytecode\",\n+            \"no_user_site\",\n+            \"no_site\",\n+            \"ignore_environment\",\n+            \"verbose\",\n+            \"bytes_warning\",\n+            \"quiet\",\n+            \"hash_randomization\",\n+            \"isolated\",\n+            \"dev_mode\",\n+            \"utf8_mode\",\n+            \"warn_default_encoding\",\n+            \"safe_path\",\n+            \"int_max_str_digits\",\n+        )\n         for attr in attrs:\n             self.assertHasAttr(sys.flags, attr)\n             attr_type = bool if attr in (\"dev_mode\", \"safe_path\") else int\n@@ -896,8 +953,9 @@ def test_sys_getwindowsversion_no_instantiation(self):\n \n     @test.support.cpython_only\n     def test_clear_type_cache(self):\n-        with self.assertWarnsRegex(DeprecationWarning,\n-                                   r\"sys\\._clear_type_cache\\(\\) is deprecated.*\"):\n+        with self.assertWarnsRegex(\n+            DeprecationWarning, r\"sys\\._clear_type_cache\\(\\) is deprecated.*\"\n+        ):\n             sys._clear_type_cache()\n \n     @force_not_colorized\n@@ -909,59 +967,80 @@ def test_ioencoding(self):\n         # not representable in ASCII.\n \n         env[\"PYTHONIOENCODING\"] = \"cp424\"\n-        p = subprocess.Popen([sys.executable, \"-c\", 'print(chr(0xa2))'],\n-                             stdout = subprocess.PIPE, env=env)\n+        p = subprocess.Popen(\n+            [sys.executable, \"-c\", \"print(chr(0xa2))\"],\n+            stdout=subprocess.PIPE,\n+            env=env,\n+        )\n         out = p.communicate()[0].strip()\n         expected = (\"\\xa2\" + os.linesep).encode(\"cp424\")\n         self.assertEqual(out, expected)\n \n         env[\"PYTHONIOENCODING\"] = \"ascii:replace\"\n-        p = subprocess.Popen([sys.executable, \"-c\", 'print(chr(0xa2))'],\n-                             stdout = subprocess.PIPE, env=env)\n+        p = subprocess.Popen(\n+            [sys.executable, \"-c\", \"print(chr(0xa2))\"],\n+            stdout=subprocess.PIPE,\n+            env=env,\n+        )\n         out = p.communicate()[0].strip()\n-        self.assertEqual(out, b'?')\n+        self.assertEqual(out, b\"?\")\n \n         env[\"PYTHONIOENCODING\"] = \"ascii\"\n-        p = subprocess.Popen([sys.executable, \"-c\", 'print(chr(0xa2))'],\n-                             stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n-                             env=env)\n+        p = subprocess.Popen(\n+            [sys.executable, \"-c\", \"print(chr(0xa2))\"],\n+            stdout=subprocess.PIPE,\n+            stderr=subprocess.PIPE,\n+            env=env,\n+        )\n         out, err = p.communicate()\n-        self.assertEqual(out, b'')\n-        self.assertIn(b'UnicodeEncodeError:', err)\n+        self.assertEqual(out, b\"\")\n+        self.assertIn(b\"UnicodeEncodeError:\", err)\n         self.assertIn(rb\"'\\xa2'\", err)\n \n         env[\"PYTHONIOENCODING\"] = \"ascii:\"\n-        p = subprocess.Popen([sys.executable, \"-c\", 'print(chr(0xa2))'],\n-                             stdout=subprocess.PIPE, stderr=subprocess.PIPE,\n-                             env=env)\n+        p = subprocess.Popen(\n+            [sys.executable, \"-c\", \"print(chr(0xa2))\"],\n+            stdout=subprocess.PIPE,\n+            stderr=subprocess.PIPE,\n+            env=env,\n+        )\n         out, err = p.communicate()\n-        self.assertEqual(out, b'')\n-        self.assertIn(b'UnicodeEncodeError:', err)\n+        self.assertEqual(out, b\"\")\n+        self.assertIn(b\"UnicodeEncodeError:\", err)\n         self.assertIn(rb\"'\\xa2'\", err)\n \n         env[\"PYTHONIOENCODING\"] = \":surrogateescape\"\n-        p = subprocess.Popen([sys.executable, \"-c\", 'print(chr(0xdcbd))'],\n-                             stdout=subprocess.PIPE, env=env)\n+        p = subprocess.Popen(\n+            [sys.executable, \"-c\", \"print(chr(0xdcbd))\"],\n+            stdout=subprocess.PIPE,\n+            env=env,\n+        )\n         out = p.communicate()[0].strip()\n-        self.assertEqual(out, b'\\xbd')\n-\n-    @unittest.skipUnless(os_helper.FS_NONASCII,\n-                         'requires OS support of non-ASCII encodings')\n-    @unittest.skipUnless(sys.getfilesystemencoding() == locale.getpreferredencoding(False),\n-                         'requires FS encoding to match locale')\n+        self.assertEqual(out, b\"\\xbd\")\n+\n+    @unittest.skipUnless(\n+        os_helper.FS_NONASCII, \"requires OS support of non-ASCII encodings\"\n+    )\n+    @unittest.skipUnless(\n+        sys.getfilesystemencoding() == locale.getpreferredencoding(False),\n+        \"requires FS encoding to match locale\",\n+    )\n     @support.requires_subprocess()\n     def test_ioencoding_nonascii(self):\n         env = dict(os.environ)\n \n         env[\"PYTHONIOENCODING\"] = \"\"\n-        p = subprocess.Popen([sys.executable, \"-c\",\n-                                'print(%a)' % os_helper.FS_NONASCII],\n-                                stdout=subprocess.PIPE, env=env)\n+        p = subprocess.Popen(\n+            [sys.executable, \"-c\", \"print(%a)\" % os_helper.FS_NONASCII],\n+            stdout=subprocess.PIPE,\n+            env=env,\n+        )\n         out = p.communicate()[0].strip()\n         self.assertEqual(out, os.fsencode(os_helper.FS_NONASCII))\n \n-    @unittest.skipIf(sys.base_prefix != sys.prefix,\n-                     'Test is not venv-compatible')\n+    @unittest.skipIf(\n+        sys.base_prefix != sys.prefix, \"Test is not venv-compatible\"\n+    )\n     @support.requires_subprocess()\n     def test_executable(self):\n         # sys.executable should be absolute\n@@ -975,13 +1054,22 @@ def test_executable(self):\n         # argument. For test runs in the build directory, see #7774.\n         python_dir = os.path.dirname(os.path.realpath(sys.executable))\n         p = subprocess.Popen(\n-            [\"nonexistent\", \"-c\",\n-             'import sys; print(sys.executable.encode(\"ascii\", \"backslashreplace\"))'],\n-            executable=sys.executable, stdout=subprocess.PIPE, cwd=python_dir)\n+            [\n+                \"nonexistent\",\n+                \"-c\",\n+                'import sys; print(sys.executable.encode(\"ascii\", \"backslashreplace\"))',\n+            ],\n+            executable=sys.executable,\n+            stdout=subprocess.PIPE,\n+            cwd=python_dir,\n+        )\n         stdout = p.communicate()[0]\n         executable = stdout.strip().decode(\"ASCII\")\n         p.wait()\n-        self.assertIn(executable, [\"b''\", repr(sys.executable.encode(\"ascii\", \"backslashreplace\"))])\n+        self.assertIn(\n+            executable,\n+            [\"b''\", repr(sys.executable.encode(\"ascii\", \"backslashreplace\"))],\n+        )\n \n     def check_fsencoding(self, fs_encoding, expected=None):\n         self.assertIsNotNone(fs_encoding)\n@@ -991,109 +1079,125 @@ def check_fsencoding(self, fs_encoding, expected=None):\n \n     def test_getfilesystemencoding(self):\n         fs_encoding = sys.getfilesystemencoding()\n-        if sys.platform == 'darwin':\n-            expected = 'utf-8'\n+        if sys.platform == \"darwin\":\n+            expected = \"utf-8\"\n         else:\n             expected = None\n         self.check_fsencoding(fs_encoding, expected)\n \n-    def c_locale_get_error_handler(self, locale, isolated=False, encoding=None):\n+    def c_locale_get_error_handler(\n+        self, locale, isolated=False, encoding=None\n+    ):\n         # Force the POSIX locale\n         env = os.environ.copy()\n         env[\"LC_ALL\"] = locale\n         env[\"PYTHONCOERCECLOCALE\"] = \"0\"\n-        code = '\\n'.join((\n-            'import sys',\n-            'def dump(name):',\n-            '    std = getattr(sys, name)',\n-            '    print(\"%s: %s\" % (name, std.errors))',\n-            'dump(\"stdin\")',\n-            'dump(\"stdout\")',\n-            'dump(\"stderr\")',\n-        ))\n+        code = \"\\n\".join(\n+            (\n+                \"import sys\",\n+                \"def dump(name):\",\n+                \"    std = getattr(sys, name)\",\n+                '    print(\"%s: %s\" % (name, std.errors))',\n+                'dump(\"stdin\")',\n+                'dump(\"stdout\")',\n+                'dump(\"stderr\")',\n+            )\n+        )\n         args = [sys.executable, \"-X\", \"utf8=0\", \"-c\", code]\n         if isolated:\n             args.append(\"-I\")\n         if encoding is not None:\n-            env['PYTHONIOENCODING'] = encoding\n+            env[\"PYTHONIOENCODING\"] = encoding\n         else:\n-            env.pop('PYTHONIOENCODING', None)\n-        p = subprocess.Popen(args,\n-                              stdout=subprocess.PIPE,\n-                              stderr=subprocess.STDOUT,\n-                              env=env,\n-                              universal_newlines=True)\n+            env.pop(\"PYTHONIOENCODING\", None)\n+        p = subprocess.Popen(\n+            args,\n+            stdout=subprocess.PIPE,\n+            stderr=subprocess.STDOUT,\n+            env=env,\n+            universal_newlines=True,\n+        )\n         stdout, stderr = p.communicate()\n         return stdout\n \n     def check_locale_surrogateescape(self, locale):\n         out = self.c_locale_get_error_handler(locale, isolated=True)\n-        self.assertEqual(out,\n-                         'stdin: surrogateescape\\n'\n-                         'stdout: surrogateescape\\n'\n-                         'stderr: backslashreplace\\n')\n+        self.assertEqual(\n+            out,\n+            \"stdin: surrogateescape\\n\"\n+            \"stdout: surrogateescape\\n\"\n+            \"stderr: backslashreplace\\n\",\n+        )\n \n         # replace the default error handler\n-        out = self.c_locale_get_error_handler(locale, encoding=':ignore')\n-        self.assertEqual(out,\n-                         'stdin: ignore\\n'\n-                         'stdout: ignore\\n'\n-                         'stderr: backslashreplace\\n')\n+        out = self.c_locale_get_error_handler(locale, encoding=\":ignore\")\n+        self.assertEqual(\n+            out, \"stdin: ignore\\nstdout: ignore\\nstderr: backslashreplace\\n\"\n+        )\n \n         # force the encoding\n-        out = self.c_locale_get_error_handler(locale, encoding='iso8859-1')\n-        self.assertEqual(out,\n-                         'stdin: strict\\n'\n-                         'stdout: strict\\n'\n-                         'stderr: backslashreplace\\n')\n-        out = self.c_locale_get_error_handler(locale, encoding='iso8859-1:')\n-        self.assertEqual(out,\n-                         'stdin: strict\\n'\n-                         'stdout: strict\\n'\n-                         'stderr: backslashreplace\\n')\n+        out = self.c_locale_get_error_handler(locale, encoding=\"iso8859-1\")\n+        self.assertEqual(\n+            out, \"stdin: strict\\nstdout: strict\\nstderr: backslashreplace\\n\"\n+        )\n+        out = self.c_locale_get_error_handler(locale, encoding=\"iso8859-1:\")\n+        self.assertEqual(\n+            out, \"stdin: strict\\nstdout: strict\\nstderr: backslashreplace\\n\"\n+        )\n \n         # have no any effect\n-        out = self.c_locale_get_error_handler(locale, encoding=':')\n-        self.assertEqual(out,\n-                         'stdin: surrogateescape\\n'\n-                         'stdout: surrogateescape\\n'\n-                         'stderr: backslashreplace\\n')\n-        out = self.c_locale_get_error_handler(locale, encoding='')\n-        self.assertEqual(out,\n-                         'stdin: surrogateescape\\n'\n-                         'stdout: surrogateescape\\n'\n-                         'stderr: backslashreplace\\n')\n+        out = self.c_locale_get_error_handler(locale, encoding=\":\")\n+        self.assertEqual(\n+            out,\n+            \"stdin: surrogateescape\\n\"\n+            \"stdout: surrogateescape\\n\"\n+            \"stderr: backslashreplace\\n\",\n+        )\n+        out = self.c_locale_get_error_handler(locale, encoding=\"\")\n+        self.assertEqual(\n+            out,\n+            \"stdin: surrogateescape\\n\"\n+            \"stdout: surrogateescape\\n\"\n+            \"stderr: backslashreplace\\n\",\n+        )\n \n     @support.requires_subprocess()\n     def test_c_locale_surrogateescape(self):\n-        self.check_locale_surrogateescape('C')\n+        self.check_locale_surrogateescape(\"C\")\n \n     @support.requires_subprocess()\n     def test_posix_locale_surrogateescape(self):\n-        self.check_locale_surrogateescape('POSIX')\n+        self.check_locale_surrogateescape(\"POSIX\")\n \n     def test_implementation(self):\n         # This test applies to all implementations equally.\n \n-        levels = {'alpha': 0xA, 'beta': 0xB, 'candidate': 0xC, 'final': 0xF}\n+        levels = {\"alpha\": 0xA, \"beta\": 0xB, \"candidate\": 0xC, \"final\": 0xF}\n \n-        self.assertHasAttr(sys.implementation, 'name')\n-        self.assertHasAttr(sys.implementation, 'version')\n-        self.assertHasAttr(sys.implementation, 'hexversion')\n-        self.assertHasAttr(sys.implementation, 'cache_tag')\n-        self.assertHasAttr(sys.implementation, 'supports_isolated_interpreters')\n+        self.assertHasAttr(sys.implementation, \"name\")\n+        self.assertHasAttr(sys.implementation, \"version\")\n+        self.assertHasAttr(sys.implementation, \"hexversion\")\n+        self.assertHasAttr(sys.implementation, \"cache_tag\")\n+        self.assertHasAttr(\n+            sys.implementation, \"supports_isolated_interpreters\"\n+        )\n \n         version = sys.implementation.version\n         self.assertEqual(version[:2], (version.major, version.minor))\n \n-        hexversion = (version.major << 24 | version.minor << 16 |\n-                      version.micro << 8 | levels[version.releaselevel] << 4 |\n-                      version.serial << 0)\n+        hexversion = (\n+            version.major << 24\n+            | version.minor << 16\n+            | version.micro << 8\n+            | levels[version.releaselevel] << 4\n+            | version.serial << 0\n+        )\n         self.assertEqual(sys.implementation.hexversion, hexversion)\n \n         # PEP 421 requires that .name be lower case.\n-        self.assertEqual(sys.implementation.name,\n-                         sys.implementation.name.lower())\n+        self.assertEqual(\n+            sys.implementation.name, sys.implementation.name.lower()\n+        )\n \n         # https://peps.python.org/pep-0734\n         sii = sys.implementation.supports_isolated_interpreters\n@@ -1108,7 +1212,8 @@ def test_implementation(self):\n     def test_debugmallocstats(self):\n         # Test sys._debugmallocstats()\n         from test.support.script_helper import assert_python_ok\n-        args = ['-c', 'import sys; sys._debugmallocstats()']\n+\n+        args = [\"-c\", \"import sys; sys._debugmallocstats()\"]\n         ret, out, err = assert_python_ok(*args)\n \n         # Output of sys._debugmallocstats() depends on configure flags.\n@@ -1117,13 +1222,15 @@ def test_debugmallocstats(self):\n             with_pymalloc = sysconfig.get_config_var(\"WITH_PYMALLOC\")\n             self.assertIn(b\"free PyDictObjects\", err)\n             if with_pymalloc:\n-                self.assertIn(b'Small block threshold', err)\n+                self.assertIn(b\"Small block threshold\", err)\n \n         # The function has no parameter\n         self.assertRaises(TypeError, sys._debugmallocstats, True)\n \n-    @unittest.skipUnless(hasattr(sys, \"getallocatedblocks\"),\n-                         \"sys.getallocatedblocks unavailable on this build\")\n+    @unittest.skipUnless(\n+        hasattr(sys, \"getallocatedblocks\"),\n+        \"sys.getallocatedblocks unavailable on this build\",\n+    )\n     def test_getallocatedblocks(self):\n         try:\n             import _testinternalcapi\n@@ -1136,7 +1243,7 @@ def test_getallocatedblocks(self):\n                 # \"cannot get allocators name\" (ex: tracemalloc is used)\n                 with_pymalloc = True\n             else:\n-                with_pymalloc = (alloc_name in ('pymalloc', 'pymalloc_debug'))\n+                with_pymalloc = alloc_name in (\"pymalloc\", \"pymalloc_debug\")\n \n         # Some sanity checks\n         a = sys.getallocatedblocks()\n@@ -1189,8 +1296,8 @@ def __del__(self):\n             # AtExit destructor will be called at Python exit\n             ref = AtExit()\n         \"\"\"\n-        rc, stdout, stderr = assert_python_ok('-c', code)\n-        self.assertEqual(stdout.rstrip(), b'True')\n+        rc, stdout, stderr = assert_python_ok(\"-c\", code)\n+        self.assertEqual(stdout.rstrip(), b\"True\")\n \n     def test_issue20602(self):\n         # sys.flags and sys.float_info were wiped during shutdown.\n@@ -1202,10 +1309,10 @@ def __del__(self, sys=sys):\n                     print(sys.float_info)\n             a = A()\n             \"\"\"\n-        rc, out, err = assert_python_ok('-c', code)\n+        rc, out, err = assert_python_ok(\"-c\", code)\n         out = out.splitlines()\n-        self.assertIn(b'sys.flags', out[0])\n-        self.assertIn(b'sys.float_info', out[1])\n+        self.assertIn(b\"sys.flags\", out[0])\n+        self.assertIn(b\"sys.float_info\", out[1])\n \n     def test_sys_ignores_cleaning_up_user_data(self):\n         code = \"\"\"if 1:\n@@ -1219,7 +1326,7 @@ def __del__(self):\n \n             sys.x = C()\n             \"\"\"\n-        rc, stdout, stderr = assert_python_ok('-c', code)\n+        rc, stdout, stderr = assert_python_ok(\"-c\", code)\n         self.assertEqual(rc, 0)\n         self.assertEqual(stdout.rstrip(), b\"\")\n         self.assertEqual(stderr.rstrip(), b\"\")\n@@ -1242,24 +1349,27 @@ def f2():\n             sys.tracebacklimit = %r\n             f2()\n         \"\"\"\n+\n         def check(tracebacklimit, expected):\n-            p = subprocess.Popen([sys.executable, '-c', code % tracebacklimit],\n-                                 stderr=subprocess.PIPE)\n+            p = subprocess.Popen(\n+                [sys.executable, \"-c\", code % tracebacklimit],\n+                stderr=subprocess.PIPE,\n+            )\n             out = p.communicate()[1]\n             self.assertEqual(out.splitlines(), expected)\n \n         traceback = [\n-            b'Traceback (most recent call last):',\n+            b\"Traceback (most recent call last):\",\n             b'  File \"<string>\", line 8, in <module>',\n-            b'    f2()',\n-            b'    ~~^^',\n+            b\"    f2()\",\n+            b\"    ~~^^\",\n             b'  File \"<string>\", line 6, in f2',\n-            b'    f1()',\n-            b'    ~~^^',\n+            b\"    f1()\",\n+            b\"    ~~^^\",\n             b'  File \"<string>\", line 4, in f1',\n-            b'    1 / 0',\n-            b'    ~~^~~',\n-            b'ZeroDivisionError: division by zero'\n+            b\"    1 / 0\",\n+            b\"    ~~^~~\",\n+            b\"ZeroDivisionError: division by zero\",\n         ]\n         check(10, traceback)\n         check(3, traceback)\n@@ -1267,55 +1377,59 @@ def check(tracebacklimit, expected):\n         check(1, traceback[:1] + traceback[7:])\n         check(0, [traceback[-1]])\n         check(-1, [traceback[-1]])\n-        check(1<<1000, traceback)\n-        check(-1<<1000, [traceback[-1]])\n+        check(1 << 1000, traceback)\n+        check(-1 << 1000, [traceback[-1]])\n         check(None, traceback)\n \n     def test_no_duplicates_in_meta_path(self):\n         self.assertEqual(len(sys.meta_path), len(set(sys.meta_path)))\n \n-    @unittest.skipUnless(hasattr(sys, \"_enablelegacywindowsfsencoding\"),\n-                         'needs sys._enablelegacywindowsfsencoding()')\n+    @unittest.skipUnless(\n+        hasattr(sys, \"_enablelegacywindowsfsencoding\"),\n+        \"needs sys._enablelegacywindowsfsencoding()\",\n+    )\n     def test__enablelegacywindowsfsencoding(self):\n-        code = ('import sys',\n-                'sys._enablelegacywindowsfsencoding()',\n-                'print(sys.getfilesystemencoding(), sys.getfilesystemencodeerrors())')\n-        rc, out, err = assert_python_ok('-c', '; '.join(code))\n-        out = out.decode('ascii', 'replace').rstrip()\n-        self.assertEqual(out, 'mbcs replace')\n+        code = (\n+            \"import sys\",\n+            \"sys._enablelegacywindowsfsencoding()\",\n+            \"print(sys.getfilesystemencoding(), sys.getfilesystemencodeerrors())\",\n+        )\n+        rc, out, err = assert_python_ok(\"-c\", \"; \".join(code))\n+        out = out.decode(\"ascii\", \"replace\").rstrip()\n+        self.assertEqual(out, \"mbcs replace\")\n \n     @support.requires_subprocess()\n     def test_orig_argv(self):\n-        code = textwrap.dedent('''\n+        code = textwrap.dedent(\"\"\"\n             import sys\n             print(sys.argv)\n             print(sys.orig_argv)\n-        ''')\n-        args = [sys.executable, '-I', '-X', 'utf8', '-c', code, 'arg']\n+        \"\"\")\n+        args = [sys.executable, \"-I\", \"-X\", \"utf8\", \"-c\", code, \"arg\"]\n         proc = subprocess.run(args, check=True, capture_output=True, text=True)\n         expected = [\n-            repr(['-c', 'arg']),  # sys.argv\n+            repr([\"-c\", \"arg\"]),  # sys.argv\n             repr(args),  # sys.orig_argv\n         ]\n-        self.assertEqual(proc.stdout.rstrip().splitlines(), expected,\n-                         proc)\n+        self.assertEqual(proc.stdout.rstrip().splitlines(), expected, proc)\n \n     def test_module_names(self):\n         self.assertIsInstance(sys.stdlib_module_names, frozenset)\n         for name in sys.stdlib_module_names:\n             self.assertIsInstance(name, str)\n \n-    @unittest.skipUnless(hasattr(sys, '_stdlib_dir'), 'need sys._stdlib_dir')\n+    @unittest.skipUnless(hasattr(sys, \"_stdlib_dir\"), \"need sys._stdlib_dir\")\n     def test_stdlib_dir(self):\n-        os = import_helper.import_fresh_module('os')\n-        marker = getattr(os, '__file__', None)\n+        os = import_helper.import_fresh_module(\"os\")\n+        marker = getattr(os, \"__file__\", None)\n         if marker and not os.path.exists(marker):\n             marker = None\n         expected = os.path.dirname(marker) if marker else None\n-        self.assertEqual(os.path.normpath(sys._stdlib_dir),\n-                         os.path.normpath(expected))\n+        self.assertEqual(\n+            os.path.normpath(sys._stdlib_dir), os.path.normpath(expected)\n+        )\n \n-    @unittest.skipUnless(hasattr(sys, 'getobjects'), 'need sys.getobjects()')\n+    @unittest.skipUnless(hasattr(sys, \"getobjects\"), \"need sys.getobjects()\")\n     def test_getobjects(self):\n         # sys.getobjects(0)\n         all_objects = sys.getobjects(0)\n@@ -1325,6 +1439,7 @@ def test_getobjects(self):\n         # sys.getobjects(0, MyType)\n         class MyType:\n             pass\n+\n         size = 100\n         my_objects = [MyType() for _ in range(size)]\n         get_objects = sys.getobjects(0, MyType)\n@@ -1336,7 +1451,7 @@ class MyType:\n         get_objects = sys.getobjects(3, MyType)\n         self.assertEqual(len(get_objects), 3)\n \n-    @unittest.skipUnless(hasattr(sys, '_stats_on'), 'need Py_STATS build')\n+    @unittest.skipUnless(hasattr(sys, \"_stats_on\"), \"need Py_STATS build\")\n     def test_pystats(self):\n         # Call the functions, just check that they don't crash\n         # Cannot save/restore state.\n@@ -1346,46 +1461,46 @@ def test_pystats(self):\n         sys._stats_dump()\n \n     @test.support.cpython_only\n-    @unittest.skipUnless(hasattr(sys, 'abiflags'), 'need sys.abiflags')\n+    @unittest.skipUnless(hasattr(sys, \"abiflags\"), \"need sys.abiflags\")\n     def test_disable_gil_abi(self):\n-        self.assertEqual('t' in sys.abiflags, support.Py_GIL_DISABLED)\n+        self.assertEqual(\"t\" in sys.abiflags, support.Py_GIL_DISABLED)\n \n \n @test.support.cpython_only\n @force_not_colorized\n class UnraisableHookTest(unittest.TestCase):\n     def test_original_unraisablehook(self):\n-        _testcapi = import_helper.import_module('_testcapi')\n+        _testcapi = import_helper.import_module(\"_testcapi\")\n         from _testcapi import err_writeunraisable, err_formatunraisable\n+\n         obj = hex\n \n-        with support.swap_attr(sys, 'unraisablehook',\n-                                    sys.__unraisablehook__):\n+        with support.swap_attr(sys, \"unraisablehook\", sys.__unraisablehook__):\n             with support.captured_stderr() as stderr:\n                 err_writeunraisable(ValueError(42), obj)\n             lines = stderr.getvalue().splitlines()\n-            self.assertEqual(lines[0], f'Exception ignored in: {obj!r}')\n-            self.assertEqual(lines[1], 'Traceback (most recent call last):')\n-            self.assertEqual(lines[-1], 'ValueError: 42')\n+            self.assertEqual(lines[0], f\"Exception ignored in: {obj!r}\")\n+            self.assertEqual(lines[1], \"Traceback (most recent call last):\")\n+            self.assertEqual(lines[-1], \"ValueError: 42\")\n \n             with support.captured_stderr() as stderr:\n                 err_writeunraisable(ValueError(42), None)\n             lines = stderr.getvalue().splitlines()\n-            self.assertEqual(lines[0], 'Traceback (most recent call last):')\n-            self.assertEqual(lines[-1], 'ValueError: 42')\n+            self.assertEqual(lines[0], \"Traceback (most recent call last):\")\n+            self.assertEqual(lines[-1], \"ValueError: 42\")\n \n             with support.captured_stderr() as stderr:\n-                err_formatunraisable(ValueError(42), 'Error in %R', obj)\n+                err_formatunraisable(ValueError(42), \"Error in %R\", obj)\n             lines = stderr.getvalue().splitlines()\n-            self.assertEqual(lines[0], f'Error in {obj!r}:')\n-            self.assertEqual(lines[1], 'Traceback (most recent call last):')\n-            self.assertEqual(lines[-1], 'ValueError: 42')\n+            self.assertEqual(lines[0], f\"Error in {obj!r}:\")\n+            self.assertEqual(lines[1], \"Traceback (most recent call last):\")\n+            self.assertEqual(lines[-1], \"ValueError: 42\")\n \n             with support.captured_stderr() as stderr:\n                 err_formatunraisable(ValueError(42), None)\n             lines = stderr.getvalue().splitlines()\n-            self.assertEqual(lines[0], 'Traceback (most recent call last):')\n-            self.assertEqual(lines[-1], 'ValueError: 42')\n+            self.assertEqual(lines[0], \"Traceback (most recent call last):\")\n+            self.assertEqual(lines[-1], \"ValueError: 42\")\n \n     def test_original_unraisablehook_err(self):\n         # bpo-22836: PyErr_WriteUnraisable() should give sensible reports\n@@ -1408,9 +1523,12 @@ def __del__(self):\n         for test_class in (BrokenDel, BrokenExceptionDel):\n             with self.subTest(test_class):\n                 obj = test_class()\n-                with test.support.captured_stderr() as stderr, \\\n-                     test.support.swap_attr(sys, 'unraisablehook',\n-                                            sys.__unraisablehook__):\n+                with (\n+                    test.support.captured_stderr() as stderr,\n+                    test.support.swap_attr(\n+                        sys, \"unraisablehook\", sys.__unraisablehook__\n+                    ),\n+                ):\n                     # Trigger obj.__del__()\n                     del obj\n \n@@ -1432,37 +1550,43 @@ def test_original_unraisablehook_exception_qualname(self):\n         # Check that the exception is printed with its qualified name\n         # rather than just classname, and the module names appears\n         # unless it is one of the hard-coded exclusions.\n-        _testcapi = import_helper.import_module('_testcapi')\n+        _testcapi = import_helper.import_module(\"_testcapi\")\n         from _testcapi import err_writeunraisable\n+\n         class A:\n             class B:\n                 class X(Exception):\n                     pass\n \n-        for moduleName in 'builtins', '__main__', 'some_module':\n+        for moduleName in \"builtins\", \"__main__\", \"some_module\":\n             with self.subTest(moduleName=moduleName):\n                 A.B.X.__module__ = moduleName\n-                with test.support.captured_stderr() as stderr, test.support.swap_attr(\n-                    sys, 'unraisablehook', sys.__unraisablehook__\n+                with (\n+                    test.support.captured_stderr() as stderr,\n+                    test.support.swap_attr(\n+                        sys, \"unraisablehook\", sys.__unraisablehook__\n+                    ),\n                 ):\n                     err_writeunraisable(A.B.X(), \"obj\")\n                 report = stderr.getvalue()\n                 self.assertIn(A.B.X.__qualname__, report)\n-                if moduleName in ['builtins', '__main__']:\n-                    self.assertNotIn(moduleName + '.', report)\n+                if moduleName in [\"builtins\", \"__main__\"]:\n+                    self.assertNotIn(moduleName + \".\", report)\n                 else:\n-                    self.assertIn(moduleName + '.', report)\n+                    self.assertIn(moduleName + \".\", report)\n \n     def test_original_unraisablehook_wrong_type(self):\n         exc = ValueError(42)\n-        with test.support.swap_attr(sys, 'unraisablehook',\n-                                    sys.__unraisablehook__):\n+        with test.support.swap_attr(\n+            sys, \"unraisablehook\", sys.__unraisablehook__\n+        ):\n             with self.assertRaises(TypeError):\n                 sys.unraisablehook(exc)\n \n     def test_custom_unraisablehook(self):\n-        _testcapi = import_helper.import_module('_testcapi')\n+        _testcapi = import_helper.import_module(\"_testcapi\")\n         from _testcapi import err_writeunraisable, err_formatunraisable\n+\n         hook_args = None\n \n         def hook_func(args):\n@@ -1471,7 +1595,7 @@ def hook_func(args):\n \n         obj = hex\n         try:\n-            with test.support.swap_attr(sys, 'unraisablehook', hook_func):\n+            with test.support.swap_attr(sys, \"unraisablehook\", hook_func):\n                 exc = ValueError(42)\n                 err_writeunraisable(exc, obj)\n                 self.assertIs(hook_args.exc_type, type(exc))\n@@ -1484,7 +1608,7 @@ def hook_func(args):\n                 self.assertIs(hook_args.exc_type, type(exc))\n                 self.assertIs(hook_args.exc_value, exc)\n                 self.assertIs(hook_args.exc_traceback, exc.__traceback__)\n-                self.assertEqual(hook_args.err_msg, f'custom hook {obj!r}')\n+                self.assertEqual(hook_args.err_msg, f\"custom hook {obj!r}\")\n                 self.assertIsNone(hook_args.object)\n         finally:\n             # expected and hook_args contain an exception: break reference cycle\n@@ -1492,32 +1616,34 @@ def hook_func(args):\n             hook_args = None\n \n     def test_custom_unraisablehook_fail(self):\n-        _testcapi = import_helper.import_module('_testcapi')\n+        _testcapi = import_helper.import_module(\"_testcapi\")\n         from _testcapi import err_writeunraisable\n+\n         def hook_func(*args):\n             raise Exception(\"hook_func failed\")\n \n         with test.support.captured_output(\"stderr\") as stderr:\n-            with test.support.swap_attr(sys, 'unraisablehook', hook_func):\n+            with test.support.swap_attr(sys, \"unraisablehook\", hook_func):\n                 err_writeunraisable(ValueError(42), \"custom hook fail\")\n \n         err = stderr.getvalue()\n-        self.assertIn(f'Exception ignored in sys.unraisablehook: '\n-                      f'{hook_func!r}\\n',\n-                      err)\n-        self.assertIn('Traceback (most recent call last):\\n', err)\n-        self.assertIn('Exception: hook_func failed\\n', err)\n+        self.assertIn(\n+            f\"Exception ignored in sys.unraisablehook: {hook_func!r}\\n\", err\n+        )\n+        self.assertIn(\"Traceback (most recent call last):\\n\", err)\n+        self.assertIn(\"Exception: hook_func failed\\n\", err)\n \n \n @test.support.cpython_only\n class SizeofTest(unittest.TestCase):\n-\n     def setUp(self):\n-        self.P = struct.calcsize('P')\n+        self.P = struct.calcsize(\"P\")\n         self.longdigit = sys.int_info.sizeof_digit\n         _testinternalcapi = import_helper.import_module(\"_testinternalcapi\")\n         self.gc_headsize = _testinternalcapi.SIZEOF_PYGC_HEAD\n-        self.managed_pre_header_size = _testinternalcapi.SIZEOF_MANAGED_PRE_HEADER\n+        self.managed_pre_header_size = (\n+            _testinternalcapi.SIZEOF_MANAGED_PRE_HEADER\n+        )\n \n     check_sizeof = test.support.check_sizeof\n \n@@ -1526,19 +1652,21 @@ def test_gc_head_size(self):\n         vsize = test.support.calcvobjsize\n         gc_header_size = self.gc_headsize\n         # bool objects are not gc tracked\n-        self.assertEqual(sys.getsizeof(True), vsize('') + self.longdigit)\n+        self.assertEqual(sys.getsizeof(True), vsize(\"\") + self.longdigit)\n         # but lists are\n-        self.assertEqual(sys.getsizeof([]), vsize('Pn') + gc_header_size)\n+        self.assertEqual(sys.getsizeof([]), vsize(\"Pn\") + gc_header_size)\n \n     def test_errors(self):\n         class BadSizeof:\n             def __sizeof__(self):\n                 raise ValueError\n+\n         self.assertRaises(ValueError, sys.getsizeof, BadSizeof())\n \n         class InvalidSizeof:\n             def __sizeof__(self):\n                 return None\n+\n         self.assertRaises(TypeError, sys.getsizeof, InvalidSizeof())\n         sentinel = [\"sentinel\"]\n         self.assertIs(sys.getsizeof(InvalidSizeof(), sentinel), sentinel)\n@@ -1546,14 +1674,18 @@ def __sizeof__(self):\n         class FloatSizeof:\n             def __sizeof__(self):\n                 return 4.5\n+\n         self.assertRaises(TypeError, sys.getsizeof, FloatSizeof())\n         self.assertIs(sys.getsizeof(FloatSizeof(), sentinel), sentinel)\n \n         class OverflowSizeof(int):\n             def __sizeof__(self):\n                 return int(self)\n-        self.assertEqual(sys.getsizeof(OverflowSizeof(sys.maxsize)),\n-                         sys.maxsize + self.gc_headsize + self.managed_pre_header_size)\n+\n+        self.assertEqual(\n+            sys.getsizeof(OverflowSizeof(sys.maxsize)),\n+            sys.maxsize + self.gc_headsize + self.managed_pre_header_size,\n+        )\n         with self.assertRaises(OverflowError):\n             sys.getsizeof(OverflowSizeof(sys.maxsize + 1))\n         with self.assertRaises(ValueError):\n@@ -1563,8 +1695,8 @@ def __sizeof__(self):\n \n     def test_default(self):\n         size = test.support.calcvobjsize\n-        self.assertEqual(sys.getsizeof(True), size('') + self.longdigit)\n-        self.assertEqual(sys.getsizeof(True, -1), size('') + self.longdigit)\n+        self.assertEqual(sys.getsizeof(True), size(\"\") + self.longdigit)\n+        self.assertEqual(sys.getsizeof(True, -1), size(\"\") + self.longdigit)\n \n     def test_objecttypes(self):\n         # check all types defined in Objects/\n@@ -1573,195 +1705,257 @@ def test_objecttypes(self):\n         vsize = test.support.calcvobjsize\n         check = self.check_sizeof\n         # bool\n-        check(True, vsize('') + self.longdigit)\n-        check(False, vsize('') + self.longdigit)\n+        check(True, vsize(\"\") + self.longdigit)\n+        check(False, vsize(\"\") + self.longdigit)\n         # buffer\n         # XXX\n         # builtin_function_or_method\n-        check(len, size('5P'))\n+        check(len, size(\"5P\"))\n         # bytearray\n-        samples = [b'', b'u'*100000]\n+        samples = [b\"\", b\"u\" * 100000]\n         for sample in samples:\n             x = bytearray(sample)\n-            check(x, vsize('n2Pi') + x.__alloc__())\n+            check(x, vsize(\"n2Pi\") + x.__alloc__())\n         # bytearray_iterator\n-        check(iter(bytearray()), size('nP'))\n+        check(iter(bytearray()), size(\"nP\"))\n         # bytes\n-        check(b'', vsize('n') + 1)\n-        check(b'x' * 10, vsize('n') + 11)\n+        check(b\"\", vsize(\"n\") + 1)\n+        check(b\"x\" * 10, vsize(\"n\") + 11)\n+\n         # cell\n         def get_cell():\n             x = 42\n+\n             def inner():\n                 return x\n+\n             return inner\n-        check(get_cell().__closure__[0], size('P'))\n+\n+        check(get_cell().__closure__[0], size(\"P\"))\n+\n         # code\n         def check_code_size(a, expected_size):\n             self.assertGreaterEqual(sys.getsizeof(a), expected_size)\n-        check_code_size(get_cell().__code__, size('6i13P'))\n-        check_code_size(get_cell.__code__, size('6i13P'))\n+\n+        check_code_size(get_cell().__code__, size(\"6i13P\"))\n+        check_code_size(get_cell.__code__, size(\"6i13P\"))\n+\n         def get_cell2(x):\n             def inner():\n                 return x\n+\n             return inner\n-        check_code_size(get_cell2.__code__, size('6i13P') + calcsize('n'))\n+\n+        check_code_size(get_cell2.__code__, size(\"6i13P\") + calcsize(\"n\"))\n         # complex\n-        check(complex(0,1), size('2d'))\n+        check(complex(0, 1), size(\"2d\"))\n         # method_descriptor (descriptor object)\n-        check(str.lower, size('3PPP'))\n+        check(str.lower, size(\"3PPP\"))\n         # classmethod_descriptor (descriptor object)\n         # XXX\n         # member_descriptor (descriptor object)\n         import datetime\n-        check(datetime.timedelta.days, size('3PP'))\n+\n+        check(datetime.timedelta.days, size(\"3PP\"))\n         # getset_descriptor (descriptor object)\n         import collections\n-        check(collections.defaultdict.default_factory, size('3PP'))\n+\n+        check(collections.defaultdict.default_factory, size(\"3PP\"))\n         # wrapper_descriptor (descriptor object)\n-        check(int.__add__, size('3P2P'))\n+        check(int.__add__, size(\"3P2P\"))\n         # method-wrapper (descriptor object)\n-        check({}.__iter__, size('2P'))\n+        check({}.__iter__, size(\"2P\"))\n         # empty dict\n-        check({}, size('nQ2P'))\n+        check({}, size(\"nQ2P\"))\n         # dict (string key)\n-        check({\"a\": 1}, size('nQ2P') + calcsize(DICT_KEY_STRUCT_FORMAT) + 8 + (8*2//3)*calcsize('2P'))\n+        check(\n+            {\"a\": 1},\n+            size(\"nQ2P\")\n+            + calcsize(DICT_KEY_STRUCT_FORMAT)\n+            + 8\n+            + (8 * 2 // 3) * calcsize(\"2P\"),\n+        )\n         longdict = {str(i): i for i in range(8)}\n-        check(longdict, size('nQ2P') + calcsize(DICT_KEY_STRUCT_FORMAT) + 16 + (16*2//3)*calcsize('2P'))\n+        check(\n+            longdict,\n+            size(\"nQ2P\")\n+            + calcsize(DICT_KEY_STRUCT_FORMAT)\n+            + 16\n+            + (16 * 2 // 3) * calcsize(\"2P\"),\n+        )\n         # dict (non-string key)\n-        check({1: 1}, size('nQ2P') + calcsize(DICT_KEY_STRUCT_FORMAT) + 8 + (8*2//3)*calcsize('n2P'))\n-        longdict = {1:1, 2:2, 3:3, 4:4, 5:5, 6:6, 7:7, 8:8}\n-        check(longdict, size('nQ2P') + calcsize(DICT_KEY_STRUCT_FORMAT) + 16 + (16*2//3)*calcsize('n2P'))\n+        check(\n+            {1: 1},\n+            size(\"nQ2P\")\n+            + calcsize(DICT_KEY_STRUCT_FORMAT)\n+            + 8\n+            + (8 * 2 // 3) * calcsize(\"n2P\"),\n+        )\n+        longdict = {1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8}\n+        check(\n+            longdict,\n+            size(\"nQ2P\")\n+            + calcsize(DICT_KEY_STRUCT_FORMAT)\n+            + 16\n+            + (16 * 2 // 3) * calcsize(\"n2P\"),\n+        )\n         # dictionary-keyview\n-        check({}.keys(), size('P'))\n+        check({}.keys(), size(\"P\"))\n         # dictionary-valueview\n-        check({}.values(), size('P'))\n+        check({}.values(), size(\"P\"))\n         # dictionary-itemview\n-        check({}.items(), size('P'))\n+        check({}.items(), size(\"P\"))\n         # dictionary iterator\n-        check(iter({}), size('P2nPn'))\n+        check(iter({}), size(\"P2nPn\"))\n         # dictionary-keyiterator\n-        check(iter({}.keys()), size('P2nPn'))\n+        check(iter({}.keys()), size(\"P2nPn\"))\n         # dictionary-valueiterator\n-        check(iter({}.values()), size('P2nPn'))\n+        check(iter({}.values()), size(\"P2nPn\"))\n         # dictionary-itemiterator\n-        check(iter({}.items()), size('P2nPn'))\n+        check(iter({}.items()), size(\"P2nPn\"))\n+\n         # dictproxy\n-        class C(object): pass\n-        check(C.__dict__, size('P'))\n+        class C(object):\n+            pass\n+\n+        check(C.__dict__, size(\"P\"))\n         # BaseException\n-        check(BaseException(), size('6Pb'))\n+        check(BaseException(), size(\"6Pb\"))\n         # UnicodeEncodeError\n-        check(UnicodeEncodeError(\"\", \"\", 0, 0, \"\"), size('6Pb 2P2nP'))\n+        check(UnicodeEncodeError(\"\", \"\", 0, 0, \"\"), size(\"6Pb 2P2nP\"))\n         # UnicodeDecodeError\n-        check(UnicodeDecodeError(\"\", b\"\", 0, 0, \"\"), size('6Pb 2P2nP'))\n+        check(UnicodeDecodeError(\"\", b\"\", 0, 0, \"\"), size(\"6Pb 2P2nP\"))\n         # UnicodeTranslateError\n-        check(UnicodeTranslateError(\"\", 0, 1, \"\"), size('6Pb 2P2nP'))\n+        check(UnicodeTranslateError(\"\", 0, 1, \"\"), size(\"6Pb 2P2nP\"))\n         # ellipses\n-        check(Ellipsis, size(''))\n+        check(Ellipsis, size(\"\"))\n         # EncodingMap\n         import codecs, encodings.iso8859_3\n+\n         x = codecs.charmap_build(encodings.iso8859_3.decoding_table)\n-        check(x, size('32B2iB'))\n+        check(x, size(\"32B2iB\"))\n         # enumerate\n-        check(enumerate([]), size('n4P'))\n+        check(enumerate([]), size(\"n4P\"))\n         # reverse\n-        check(reversed(''), size('nP'))\n+        check(reversed(\"\"), size(\"nP\"))\n         # float\n-        check(float(0), size('d'))\n+        check(float(0), size(\"d\"))\n         # sys.floatinfo\n-        check(sys.float_info, self.P + vsize('') + self.P * len(sys.float_info))\n+        check(\n+            sys.float_info, self.P + vsize(\"\") + self.P * len(sys.float_info)\n+        )\n+\n         # frame\n         def func():\n             return sys._getframe()\n+\n         x = func()\n         if support.Py_GIL_DISABLED:\n-            INTERPRETER_FRAME = '9PihcP'\n+            INTERPRETER_FRAME = \"9PihcP\"\n         else:\n-            INTERPRETER_FRAME = '9PhcP'\n-        check(x, size('3PiccPPP' + INTERPRETER_FRAME + 'P'))\n+            INTERPRETER_FRAME = \"9PhcP\"\n+        check(x, size(\"3PiccPPP\" + INTERPRETER_FRAME + \"P\"))\n+\n         # function\n-        def func(): pass\n-        check(func, size('16Pi'))\n-        class c():\n+        def func():\n+            pass\n+\n+        check(func, size(\"16Pi\"))\n+\n+        class c:\n             @staticmethod\n             def foo():\n                 pass\n+\n             @classmethod\n             def bar(cls):\n                 pass\n+\n             # staticmethod\n-            check(foo, size('PP'))\n+            check(foo, size(\"PP\"))\n             # classmethod\n-            check(bar, size('PP'))\n+            check(bar, size(\"PP\"))\n+\n         # generator\n-        def get_gen(): yield 1\n-        check(get_gen(), size('6P4c' + INTERPRETER_FRAME + 'P'))\n+        def get_gen():\n+            yield 1\n+\n+        check(get_gen(), size(\"6P4c\" + INTERPRETER_FRAME + \"P\"))\n         # iterator\n-        check(iter('abc'), size('lP'))\n+        check(iter(\"abc\"), size(\"lP\"))\n         # callable-iterator\n         import re\n-        check(re.finditer('',''), size('2P'))\n+\n+        check(re.finditer(\"\", \"\"), size(\"2P\"))\n         # list\n-        check(list([]), vsize('Pn'))\n-        check(list([1]), vsize('Pn') + 2*self.P)\n-        check(list([1, 2]), vsize('Pn') + 2*self.P)\n-        check(list([1, 2, 3]), vsize('Pn') + 4*self.P)\n+        check(list([]), vsize(\"Pn\"))\n+        check(list([1]), vsize(\"Pn\") + 2 * self.P)\n+        check(list([1, 2]), vsize(\"Pn\") + 2 * self.P)\n+        check(list([1, 2, 3]), vsize(\"Pn\") + 4 * self.P)\n         # sortwrapper (list)\n         # XXX\n         # cmpwrapper (list)\n         # XXX\n         # listiterator (list)\n-        check(iter([]), size('lP'))\n+        check(iter([]), size(\"lP\"))\n         # listreverseiterator (list)\n-        check(reversed([]), size('nP'))\n+        check(reversed([]), size(\"nP\"))\n         # int\n-        check(0, vsize('') + self.longdigit)\n-        check(1, vsize('') + self.longdigit)\n-        check(-1, vsize('') + self.longdigit)\n+        check(0, vsize(\"\") + self.longdigit)\n+        check(1, vsize(\"\") + self.longdigit)\n+        check(-1, vsize(\"\") + self.longdigit)\n         PyLong_BASE = 2**sys.int_info.bits_per_digit\n-        check(int(PyLong_BASE), vsize('') + 2*self.longdigit)\n-        check(int(PyLong_BASE**2-1), vsize('') + 2*self.longdigit)\n-        check(int(PyLong_BASE**2), vsize('') + 3*self.longdigit)\n+        check(int(PyLong_BASE), vsize(\"\") + 2 * self.longdigit)\n+        check(int(PyLong_BASE**2 - 1), vsize(\"\") + 2 * self.longdigit)\n+        check(int(PyLong_BASE**2), vsize(\"\") + 3 * self.longdigit)\n         # module\n         if support.Py_GIL_DISABLED:\n-            check(unittest, size('PPPPPP'))\n+            check(unittest, size(\"PPPPPP\"))\n         else:\n-            check(unittest, size('PPPPP'))\n+            check(unittest, size(\"PPPPP\"))\n         # None\n-        check(None, size(''))\n+        check(None, size(\"\"))\n         # NotImplementedType\n-        check(NotImplemented, size(''))\n+        check(NotImplemented, size(\"\"))\n         # object\n-        check(object(), size(''))\n+        check(object(), size(\"\"))\n+\n         # property (descriptor object)\n         class C(object):\n-            def getx(self): return self.__x\n-            def setx(self, value): self.__x = value\n-            def delx(self): del self.__x\n+            def getx(self):\n+                return self.__x\n+\n+            def setx(self, value):\n+                self.__x = value\n+\n+            def delx(self):\n+                del self.__x\n+\n             x = property(getx, setx, delx, \"\")\n-            check(x, size('5Pi'))\n+            check(x, size(\"5Pi\"))\n+\n         # PyCapsule\n-        check(_datetime.datetime_CAPI, size('6P'))\n+        check(_datetime.datetime_CAPI, size(\"6P\"))\n         # rangeiterator\n-        check(iter(range(1)), size('3l'))\n-        check(iter(range(2**65)), size('3P'))\n+        check(iter(range(1)), size(\"3l\"))\n+        check(iter(range(2**65)), size(\"3P\"))\n         # reverse\n-        check(reversed(''), size('nP'))\n+        check(reversed(\"\"), size(\"nP\"))\n         # range\n-        check(range(1), size('4P'))\n-        check(range(66000), size('4P'))\n+        check(range(1), size(\"4P\"))\n+        check(range(66000), size(\"4P\"))\n         # set\n         # frozenset\n         PySet_MINSIZE = 8\n         samples = [[], range(10), range(50)]\n-        s = size('3nP' + PySet_MINSIZE*'nP' + '2nP')\n+        s = size(\"3nP\" + PySet_MINSIZE * \"nP\" + \"2nP\")\n         for sample in samples:\n             minused = len(sample)\n-            if minused == 0: tmp = 1\n+            if minused == 0:\n+                tmp = 1\n             # the computation of minused is actually a bit more complicated\n             # but this suffices for the sizeof test\n-            minused = minused*2\n+            minused = minused * 2\n             newsize = PySet_MINSIZE\n             while newsize <= minused:\n                 newsize = newsize << 1\n@@ -1769,53 +1963,68 @@ def delx(self): del self.__x\n                 check(set(sample), s)\n                 check(frozenset(sample), s)\n             else:\n-                check(set(sample), s + newsize*calcsize('nP'))\n-                check(frozenset(sample), s + newsize*calcsize('nP'))\n+                check(set(sample), s + newsize * calcsize(\"nP\"))\n+                check(frozenset(sample), s + newsize * calcsize(\"nP\"))\n         # setiterator\n-        check(iter(set()), size('P3n'))\n+        check(iter(set()), size(\"P3n\"))\n         # slice\n-        check(slice(0), size('3P'))\n+        check(slice(0), size(\"3P\"))\n         # super\n-        check(super(int), size('3P'))\n+        check(super(int), size(\"3P\"))\n         # tuple\n-        check((), vsize('') + self.P)\n-        check((1,2,3), vsize('') + self.P + 3*self.P)\n+        check((), vsize(\"\") + self.P)\n+        check((1, 2, 3), vsize(\"\") + self.P + 3 * self.P)\n         # type\n         # static type: PyTypeObject\n-        fmt = 'P2nPI13Pl4Pn9Pn12PIPc'\n+        fmt = \"P2nPI13Pl4Pn9Pn12PIPc\"\n         s = vsize(fmt)\n         check(int, s)\n-        typeid = 'n' if support.Py_GIL_DISABLED else ''\n+        typeid = \"n\" if support.Py_GIL_DISABLED else \"\"\n         # class\n-        s = vsize(fmt +                 # PyTypeObject\n-                  '4P'                  # PyAsyncMethods\n-                  '36P'                 # PyNumberMethods\n-                  '3P'                  # PyMappingMethods\n-                  '10P'                 # PySequenceMethods\n-                  '2P'                  # PyBufferProcs\n-                  '7P'\n-                  '1PIP'                # Specializer cache\n-                  + typeid              # heap type id (free-threaded only)\n-                  )\n-        class newstyleclass(object): pass\n+        s = vsize(\n+            fmt  # PyTypeObject\n+            + \"4P\"  # PyAsyncMethods\n+            \"36P\"  # PyNumberMethods\n+            \"3P\"  # PyMappingMethods\n+            \"10P\"  # PySequenceMethods\n+            \"2P\"  # PyBufferProcs\n+            \"7P\"\n+            \"1PIP\"  # Specializer cache\n+             + typeid  # heap type id (free-threaded only)\n+        )\n+\n+        class newstyleclass(object):\n+            pass\n+\n         # Separate block for PyDictKeysObject with 8 keys and 5 entries\n-        check(newstyleclass, s + calcsize(DICT_KEY_STRUCT_FORMAT) + 64 + 42*calcsize(\"2P\"))\n+        check(\n+            newstyleclass,\n+            s + calcsize(DICT_KEY_STRUCT_FORMAT) + 64 + 42 * calcsize(\"2P\"),\n+        )\n         # dict with shared keys\n         [newstyleclass() for _ in range(100)]\n-        check(newstyleclass().__dict__, size('nQ2P') + self.P)\n+        check(newstyleclass().__dict__, size(\"nQ2P\") + self.P)\n         o = newstyleclass()\n         o.a = o.b = o.c = o.d = o.e = o.f = o.g = o.h = 1\n         # Separate block for PyDictKeysObject with 16 keys and 10 entries\n-        check(newstyleclass, s + calcsize(DICT_KEY_STRUCT_FORMAT) + 64 + 42*calcsize(\"2P\"))\n+        check(\n+            newstyleclass,\n+            s + calcsize(DICT_KEY_STRUCT_FORMAT) + 64 + 42 * calcsize(\"2P\"),\n+        )\n         # dict with shared keys\n-        check(newstyleclass().__dict__, size('nQ2P') + self.P)\n+        check(newstyleclass().__dict__, size(\"nQ2P\") + self.P)\n         # unicode\n         # each tuple contains a string and its expected character size\n         # don't put any static strings here, as they may contain\n         # wchar_t or UTF-8 representations\n-        samples = ['1'*100, '\\xff'*50,\n-                   '\\u0100'*40, '\\uffff'*100,\n-                   '\\U00010000'*30, '\\U0010ffff'*100]\n+        samples = [\n+            \"1\" * 100,\n+            \"\\xff\" * 50,\n+            \"\\u0100\" * 40,\n+            \"\\uffff\" * 100,\n+            \"\\U00010000\" * 30,\n+            \"\\U0010ffff\" * 100,\n+        ]\n         # also update field definitions in test_unicode.test_raiseMemError\n         asciifields = \"nnb\"\n         compactfields = asciifields + \"nP\"\n@@ -1827,12 +2036,12 @@ class newstyleclass(object): pass\n             elif maxchar < 256:\n                 L = size(compactfields) + len(s) + 1\n             elif maxchar < 65536:\n-                L = size(compactfields) + 2*(len(s) + 1)\n+                L = size(compactfields) + 2 * (len(s) + 1)\n             else:\n-                L = size(compactfields) + 4*(len(s) + 1)\n+                L = size(compactfields) + 4 * (len(s) + 1)\n             check(s, L)\n         # verify that the UTF-8 size is accounted for\n-        s = chr(0x4000)   # 4 bytes canonical representation\n+        s = chr(0x4000)  # 4 bytes canonical representation\n         check(s, size(compactfields) + 4)\n         # compile() will trigger the generation of the UTF-8\n         # representation as a side effect\n@@ -1842,10 +2051,11 @@ class newstyleclass(object): pass\n         # TODO: add check that forces layout of unicodefields\n         # weakref\n         import weakref\n+\n         if support.Py_GIL_DISABLED:\n-            expected = size('2Pn4P')\n+            expected = size(\"2Pn4P\")\n         else:\n-            expected = size('2Pn3P')\n+            expected = size(\"2Pn3P\")\n         check(weakref.ref(int), expected)\n         # weakproxy\n         # XXX\n@@ -1862,25 +2072,37 @@ def test_slots(self):\n         # check all subclassable types defined in Objects/ that allow\n         # non-empty __slots__\n         check = self.check_slots\n+\n         class BA(bytearray):\n-            __slots__ = 'a', 'b', 'c'\n-        check(BA(), bytearray(), '3P')\n+            __slots__ = \"a\", \"b\", \"c\"\n+\n+        check(BA(), bytearray(), \"3P\")\n+\n         class D(dict):\n-            __slots__ = 'a', 'b', 'c'\n-        check(D(x=[]), {'x': []}, '3P')\n+            __slots__ = \"a\", \"b\", \"c\"\n+\n+        check(D(x=[]), {\"x\": []}, \"3P\")\n+\n         class L(list):\n-            __slots__ = 'a', 'b', 'c'\n-        check(L(), [], '3P')\n+            __slots__ = \"a\", \"b\", \"c\"\n+\n+        check(L(), [], \"3P\")\n+\n         class S(set):\n-            __slots__ = 'a', 'b', 'c'\n-        check(S(), set(), '3P')\n+            __slots__ = \"a\", \"b\", \"c\"\n+\n+        check(S(), set(), \"3P\")\n+\n         class FS(frozenset):\n-            __slots__ = 'a', 'b', 'c'\n-        check(FS(), frozenset(), '3P')\n+            __slots__ = \"a\", \"b\", \"c\"\n+\n+        check(FS(), frozenset(), \"3P\")\n         from collections import OrderedDict\n+\n         class OD(OrderedDict):\n-            __slots__ = 'a', 'b', 'c'\n-        check(OD(x=[]), OrderedDict(x=[]), '3P')\n+            __slots__ = \"a\", \"b\", \"c\"\n+\n+        check(OD(x=[]), OrderedDict(x=[]), \"3P\")\n \n     def test_pythontypes(self):\n         # check all types defined in Python/\n@@ -1889,21 +2111,22 @@ def test_pythontypes(self):\n         check = self.check_sizeof\n         # _ast.AST\n         import _ast\n-        check(_ast.AST(), size('P'))\n+\n+        check(_ast.AST(), size(\"P\"))\n         try:\n             raise TypeError\n         except TypeError as e:\n             tb = e.__traceback__\n             # traceback\n             if tb is not None:\n-                check(tb, size('2P2i'))\n+                check(tb, size(\"2P2i\"))\n         # symtable entry\n         # XXX\n         # sys.flags\n         # FIXME: The +3 is for the 'gil', 'thread_inherit_context' and\n         # 'context_aware_warnings' flags and will not be necessary once\n         # gh-122575 is fixed\n-        check(sys.flags, vsize('') + self.P + self.P * (3 + len(sys.flags)))\n+        check(sys.flags, vsize(\"\") + self.P + self.P * (3 + len(sys.flags)))\n \n     def test_asyncgen_hooks(self):\n         old = sys.get_asyncgen_hooks()\n@@ -1949,41 +2172,47 @@ def test_changing_sys_stderr_and_removing_reference(self):\n         # If the default displayhook doesn't take a strong reference\n         # to sys.stderr the following code can crash. See bpo-43660\n         # for more details.\n-        code = textwrap.dedent('''\n+        code = textwrap.dedent(\"\"\"\n             import sys\n             class MyStderr:\n                 def write(self, s):\n                     sys.stderr = None\n             sys.stderr = MyStderr()\n             1/0\n-        ''')\n-        rc, out, err = assert_python_failure('-c', code)\n+        \"\"\")\n+        rc, out, err = assert_python_failure(\"-c\", code)\n         self.assertEqual(out, b\"\")\n         self.assertEqual(err, b\"\")\n \n+\n @test.support.support_remote_exec_only\n @test.support.cpython_only\n class TestRemoteExec(unittest.TestCase):\n     def tearDown(self):\n         test.support.reap_children()\n \n-    def _run_remote_exec_test(self, script_code, python_args=None, env=None,\n-                              prologue='',\n-                              script_path=os_helper.TESTFN + '_remote.py'):\n+    def _run_remote_exec_test(\n+        self,\n+        script_code,\n+        python_args=None,\n+        env=None,\n+        prologue=\"\",\n+        script_path=os_helper.TESTFN + \"_remote.py\",\n+    ):\n         # Create the script that will be remotely executed\n         self.addCleanup(os_helper.unlink, script_path)\n \n-        with open(script_path, 'w') as f:\n+        with open(script_path, \"w\") as f:\n             f.write(script_code)\n \n         # Create and run the target process\n-        target = os_helper.TESTFN + '_target.py'\n+        target = os_helper.TESTFN + \"_target.py\"\n         self.addCleanup(os_helper.unlink, target)\n \n         port = find_unused_port()\n \n-        with open(target, 'w') as f:\n-            f.write(f'''\n+        with open(target, \"w\") as f:\n+            f.write(f\"\"\"\n import sys\n import time\n import socket\n@@ -2013,7 +2242,7 @@ def _run_remote_exec_test(self, script_code, python_args=None, env=None,\n # Write confirmation back\n sock.sendall(b\"executed\")\n sock.close()\n-''')\n+\"\"\")\n \n         # Start the target process and capture its output\n         cmd = [sys.executable]\n@@ -2023,15 +2252,16 @@ def _run_remote_exec_test(self, script_code, python_args=None, env=None,\n \n         # Create a socket server to communicate with the target process\n         server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n-        server_socket.bind(('localhost', port))\n+        server_socket.bind((\"localhost\", port))\n         server_socket.settimeout(SHORT_TIMEOUT)\n         server_socket.listen(1)\n \n-        with subprocess.Popen(cmd,\n-                              stdout=subprocess.PIPE,\n-                              stderr=subprocess.PIPE,\n-                              env=env,\n-                              ) as proc:\n+        with subprocess.Popen(\n+            cmd,\n+            stdout=subprocess.PIPE,\n+            stderr=subprocess.PIPE,\n+            env=env,\n+        ) as proc:\n             client_socket = None\n             try:\n                 # Accept connection from target process\n@@ -2055,7 +2285,9 @@ def _run_remote_exec_test(self, script_code, python_args=None, env=None,\n                 stdout, stderr = proc.communicate(timeout=10.0)\n                 return proc.returncode, stdout, stderr\n             except PermissionError:\n-                self.skipTest(\"Insufficient permissions to execute code in remote process\")\n+                self.skipTest(\n+                    \"Insufficient permissions to execute code in remote process\"\n+                )\n             finally:\n                 if client_socket is not None:\n                     client_socket.close()\n@@ -2073,21 +2305,27 @@ def test_remote_exec(self):\n \n     def test_remote_exec_bytes(self):\n         script = 'print(\"Remote script executed successfully!\")'\n-        script_path = os.fsencode(os_helper.TESTFN) + b'_bytes_remote.py'\n-        returncode, stdout, stderr = self._run_remote_exec_test(script,\n-                                                    script_path=script_path)\n+        script_path = os.fsencode(os_helper.TESTFN) + b\"_bytes_remote.py\"\n+        returncode, stdout, stderr = self._run_remote_exec_test(\n+            script, script_path=script_path\n+        )\n         self.assertIn(b\"Remote script executed successfully!\", stdout)\n         self.assertEqual(stderr, b\"\")\n \n-    @unittest.skipUnless(os_helper.TESTFN_UNDECODABLE, 'requires undecodable path')\n-    @unittest.skipIf(sys.platform == 'darwin',\n-                     'undecodable paths are not supported on macOS')\n+    @unittest.skipUnless(\n+        os_helper.TESTFN_UNDECODABLE, \"requires undecodable path\"\n+    )\n+    @unittest.skipIf(\n+        sys.platform == \"darwin\",\n+        \"undecodable paths are not supported on macOS\",\n+    )\n     def test_remote_exec_undecodable(self):\n         script = 'print(\"Remote script executed successfully!\")'\n-        script_path = os_helper.TESTFN_UNDECODABLE + b'_undecodable_remote.py'\n+        script_path = os_helper.TESTFN_UNDECODABLE + b\"_undecodable_remote.py\"\n         for script_path in [script_path, os.fsdecode(script_path)]:\n-            returncode, stdout, stderr = self._run_remote_exec_test(script,\n-                                                        script_path=script_path)\n+            returncode, stdout, stderr = self._run_remote_exec_test(\n+                script, script_path=script_path\n+            )\n             self.assertIn(b\"Remote script executed successfully!\", stdout)\n             self.assertEqual(stderr, b\"\")\n \n@@ -2095,32 +2333,41 @@ def test_remote_exec_with_self_process(self):\n         \"\"\"Test remote exec with the target process being the same as the test process\"\"\"\n \n         code = 'import sys;print(\"Remote script executed successfully!\", file=sys.stderr)'\n-        file = os_helper.TESTFN + '_remote_self.py'\n-        with open(file, 'w') as f:\n+        file = os_helper.TESTFN + \"_remote_self.py\"\n+        with open(file, \"w\") as f:\n             f.write(code)\n         self.addCleanup(os_helper.unlink, file)\n-        with mock.patch('sys.stderr', new_callable=StringIO) as mock_stderr:\n-            with mock.patch('sys.stdout', new_callable=StringIO) as mock_stdout:\n+        with mock.patch(\"sys.stderr\", new_callable=StringIO) as mock_stderr:\n+            with mock.patch(\n+                \"sys.stdout\", new_callable=StringIO\n+            ) as mock_stdout:\n                 sys.remote_exec(os.getpid(), os.path.abspath(file))\n                 print(\"Done\")\n-                self.assertEqual(mock_stderr.getvalue(), \"Remote script executed successfully!\\n\")\n+                self.assertEqual(\n+                    mock_stderr.getvalue(),\n+                    \"Remote script executed successfully!\\n\",\n+                )\n                 self.assertEqual(mock_stdout.getvalue(), \"Done\\n\")\n \n     def test_remote_exec_raises_audit_event(self):\n         \"\"\"Test remote exec raises an audit event\"\"\"\n-        prologue = '''\\\n+        prologue = \"\"\"\\\n import sys\n def audit_hook(event, arg):\n     print(f\"Audit event: {event}, arg: {arg}\".encode(\"ascii\", errors=\"replace\"))\n sys.addaudithook(audit_hook)\n-'''\n-        script = '''\n+\"\"\"\n+        script = \"\"\"\n print(\"Remote script executed successfully!\")\n-'''\n-        returncode, stdout, stderr = self._run_remote_exec_test(script, prologue=prologue)\n+\"\"\"\n+        returncode, stdout, stderr = self._run_remote_exec_test(\n+            script, prologue=prologue\n+        )\n         self.assertEqual(returncode, 0)\n         self.assertIn(b\"Remote script executed successfully!\", stdout)\n-        self.assertIn(b\"Audit event: cpython.remote_debugger_script, arg: \", stdout)\n+        self.assertIn(\n+            b\"Audit event: cpython.remote_debugger_script, arg: \", stdout\n+        )\n         self.assertEqual(stderr, b\"\")\n \n     def test_remote_exec_with_exception(self):\n@@ -2129,9 +2376,9 @@ def test_remote_exec_with_exception(self):\n         The exception should be raised in the main thread of the target process\n         but not crash the target process.\n         \"\"\"\n-        script = '''\n+        script = \"\"\"\n raise Exception(\"Remote script exception\")\n-'''\n+\"\"\"\n         returncode, stdout, stderr = self._run_remote_exec_test(script)\n         self.assertEqual(returncode, 0)\n         self.assertIn(b\"Remote script exception\", stderr)\n@@ -2153,14 +2400,23 @@ def test_new_namespace_for_each_remote_exec(self):\n     def test_remote_exec_disabled_by_env(self):\n         \"\"\"Test remote exec is disabled when PYTHON_DISABLE_REMOTE_DEBUG is set\"\"\"\n         env = os.environ.copy()\n-        env['PYTHON_DISABLE_REMOTE_DEBUG'] = '1'\n-        with self.assertRaisesRegex(RuntimeError, \"Remote debugging is not enabled in the remote process\"):\n+        env[\"PYTHON_DISABLE_REMOTE_DEBUG\"] = \"1\"\n+        with self.assertRaisesRegex(\n+            RuntimeError,\n+            \"Remote debugging is not enabled in the remote process\",\n+        ):\n             self._run_remote_exec_test(\"print('should not run')\", env=env)\n \n     def test_remote_exec_disabled_by_xoption(self):\n         \"\"\"Test remote exec is disabled with -Xdisable-remote-debug\"\"\"\n-        with self.assertRaisesRegex(RuntimeError, \"Remote debugging is not enabled in the remote process\"):\n-            self._run_remote_exec_test(\"print('should not run')\", python_args=['-Xdisable-remote-debug'])\n+        with self.assertRaisesRegex(\n+            RuntimeError,\n+            \"Remote debugging is not enabled in the remote process\",\n+        ):\n+            self._run_remote_exec_test(\n+                \"print('should not run')\",\n+                python_args=[\"-Xdisable-remote-debug\"],\n+            )\n \n     def test_remote_exec_invalid_pid(self):\n         \"\"\"Test remote exec with invalid process ID\"\"\"\n@@ -2176,9 +2432,9 @@ def test_remote_exec_invalid_script(self):\n \n     def test_remote_exec_syntax_error(self):\n         \"\"\"Test remote exec with syntax error in script\"\"\"\n-        script = '''\n+        script = \"\"\"\n this is invalid python code\n-'''\n+\"\"\"\n         returncode, stdout, stderr = self._run_remote_exec_test(script)\n         self.assertEqual(returncode, 0)\n         self.assertIn(b\"SyntaxError\", stderr)\n@@ -2191,30 +2447,38 @@ def test_remote_exec_invalid_script_path(self):\n \n     def test_remote_exec_in_process_without_debug_fails_envvar(self):\n         \"\"\"Test remote exec in a process without remote debugging enabled\"\"\"\n-        script = os_helper.TESTFN + '_remote.py'\n+        script = os_helper.TESTFN + \"_remote.py\"\n         self.addCleanup(os_helper.unlink, script)\n-        with open(script, 'w') as f:\n+        with open(script, \"w\") as f:\n             f.write('print(\"Remote script executed successfully!\")')\n         env = os.environ.copy()\n-        env['PYTHON_DISABLE_REMOTE_DEBUG'] = '1'\n+        env[\"PYTHON_DISABLE_REMOTE_DEBUG\"] = \"1\"\n \n-        _, out, err = assert_python_failure('-c', f'import os, sys; sys.remote_exec(os.getpid(), \"{script}\")', **env)\n+        _, out, err = assert_python_failure(\n+            \"-c\",\n+            f'import os, sys; sys.remote_exec(os.getpid(), \"{script}\")',\n+            **env,\n+        )\n         self.assertIn(b\"Remote debugging is not enabled\", err)\n         self.assertEqual(out, b\"\")\n \n     def test_remote_exec_in_process_without_debug_fails_xoption(self):\n         \"\"\"Test remote exec in a process without remote debugging enabled\"\"\"\n-        script = os_helper.TESTFN + '_remote.py'\n+        script = os_helper.TESTFN + \"_remote.py\"\n         self.addCleanup(os_helper.unlink, script)\n-        with open(script, 'w') as f:\n+        with open(script, \"w\") as f:\n             f.write('print(\"Remote script executed successfully!\")')\n \n-        _, out, err = assert_python_failure('-Xdisable-remote-debug', '-c', f'import os, sys; sys.remote_exec(os.getpid(), \"{script}\")')\n+        _, out, err = assert_python_failure(\n+            \"-Xdisable-remote-debug\",\n+            \"-c\",\n+            f'import os, sys; sys.remote_exec(os.getpid(), \"{script}\")',\n+        )\n         self.assertIn(b\"Remote debugging is not enabled\", err)\n         self.assertEqual(out, b\"\")\n \n-class TestSysJIT(unittest.TestCase):\n \n+class TestSysJIT(unittest.TestCase):\n     def test_jit_is_available(self):\n         available = sys._jit.is_available()\n         script = f\"import sys; assert sys._jit.is_available() is {available}\"\n@@ -2225,7 +2489,9 @@ def test_jit_is_enabled(self):\n         available = sys._jit.is_available()\n         script = \"import sys; assert sys._jit.is_enabled() is {enabled}\"\n         assert_python_ok(\"-c\", script.format(enabled=False), PYTHON_JIT=\"0\")\n-        assert_python_ok(\"-c\", script.format(enabled=available), PYTHON_JIT=\"1\")\n+        assert_python_ok(\n+            \"-c\", script.format(enabled=available), PYTHON_JIT=\"1\"\n+        )\n \n     def test_jit_is_active(self):\n         available = sys._jit.is_available()\n@@ -2270,7 +2536,9 @@ def frame_4_interpreter() -> None:\n             \"\"\"\n         )\n         assert_python_ok(\"-c\", script.format(enabled=False), PYTHON_JIT=\"0\")\n-        assert_python_ok(\"-c\", script.format(enabled=available), PYTHON_JIT=\"1\")\n+        assert_python_ok(\n+            \"-c\", script.format(enabled=available), PYTHON_JIT=\"1\"\n+        )\n \n \n if __name__ == \"__main__\":\ndiff --git a/Lib/timeit.py b/Lib/timeit.py\nindex e767f018..480db985 100644\n--- a/Lib/timeit.py\n+++ b/Lib/timeit.py\n@@ -98,23 +98,24 @@ class Timer:\n     multi-line string literals.\n     \"\"\"\n \n-    def __init__(self, stmt=\"pass\", setup=\"pass\", timer=default_timer,\n-                 globals=None):\n+    def __init__(\n+        self, stmt=\"pass\", setup=\"pass\", timer=default_timer, globals=None\n+    ):\n         \"\"\"Constructor.  See class doc string.\"\"\"\n         self.timer = timer\n         local_ns = {}\n         global_ns = _globals() if globals is None else globals\n-        init = ''\n+        init = \"\"\n         if isinstance(setup, str):\n             # Check that the code can be compiled outside a function\n             compile(setup, dummy_src_name, \"exec\")\n-            stmtprefix = setup + '\\n'\n+            stmtprefix = setup + \"\\n\"\n             setup = reindent(setup, 4)\n         elif callable(setup):\n-            local_ns['_setup'] = setup\n-            init += ', _setup=_setup'\n-            stmtprefix = ''\n-            setup = '_setup()'\n+            local_ns[\"_setup\"] = setup\n+            init += \", _setup=_setup\"\n+            stmtprefix = \"\"\n+            setup = \"_setup()\"\n         else:\n             raise ValueError(\"setup is neither a string nor callable\")\n         if isinstance(stmt, str):\n@@ -122,9 +123,9 @@ def __init__(self, stmt=\"pass\", setup=\"pass\", timer=default_timer,\n             compile(stmtprefix + stmt, dummy_src_name, \"exec\")\n             stmt = reindent(stmt, 8)\n         elif callable(stmt):\n-            local_ns['_stmt'] = stmt\n-            init += ', _stmt=_stmt'\n-            stmt = '_stmt()'\n+            local_ns[\"_stmt\"] = stmt\n+            init += \", _stmt=_stmt\"\n+            stmt = \"_stmt()\"\n         else:\n             raise ValueError(\"stmt is neither a string nor callable\")\n         src = template.format(stmt=stmt, setup=setup, init=init)\n@@ -150,12 +151,16 @@ def print_exc(self, file=None):\n         The optional file argument directs where the traceback is\n         sent; it defaults to sys.stderr.\n         \"\"\"\n-        import linecache, traceback\n+        import linecache\n+        import traceback\n+\n         if self.src is not None:\n-            linecache.cache[dummy_src_name] = (len(self.src),\n-                                               None,\n-                                               self.src.split(\"\\n\"),\n-                                               dummy_src_name)\n+            linecache.cache[dummy_src_name] = (\n+                len(self.src),\n+                None,\n+                self.src.split(\"\\n\"),\n+                dummy_src_name,\n+            )\n         # else the source is already stored somewhere else\n \n         traceback.print_exc(file=file)\n@@ -228,14 +233,25 @@ def autorange(self, callback=None):\n             i *= 10\n \n \n-def timeit(stmt=\"pass\", setup=\"pass\", timer=default_timer,\n-           number=default_number, globals=None):\n+def timeit(\n+    stmt=\"pass\",\n+    setup=\"pass\",\n+    timer=default_timer,\n+    number=default_number,\n+    globals=None,\n+):\n     \"\"\"Convenience function to create Timer object and call timeit method.\"\"\"\n     return Timer(stmt, setup, timer, globals).timeit(number)\n \n \n-def repeat(stmt=\"pass\", setup=\"pass\", timer=default_timer,\n-           repeat=default_repeat, number=default_number, globals=None):\n+def repeat(\n+    stmt=\"pass\",\n+    setup=\"pass\",\n+    timer=default_timer,\n+    repeat=default_repeat,\n+    number=default_number,\n+    globals=None,\n+):\n     \"\"\"Convenience function to create Timer object and call repeat method.\"\"\"\n     return Timer(stmt, setup, timer, globals).repeat(repeat, number)\n \n@@ -260,10 +276,21 @@ def main(args=None, *, _wrap_timer=None):\n     if args is None:\n         args = sys.argv[1:]\n     import getopt\n+\n     try:\n-        opts, args = getopt.getopt(args, \"n:u:s:r:pvh\",\n-                                   [\"number=\", \"setup=\", \"repeat=\",\n-                                    \"process\", \"verbose\", \"unit=\", \"help\"])\n+        opts, args = getopt.getopt(\n+            args,\n+            \"n:u:s:r:pvh\",\n+            [\n+                \"number=\",\n+                \"setup=\",\n+                \"repeat=\",\n+                \"process\",\n+                \"verbose\",\n+                \"unit=\",\n+                \"help\",\n+            ],\n+        )\n     except getopt.error as err:\n         print(err)\n         print(\"use -h/--help for command line help\")\n@@ -287,8 +314,10 @@ def main(args=None, *, _wrap_timer=None):\n             if a in units:\n                 time_unit = a\n             else:\n-                print(\"Unrecognized unit. Please select nsec, usec, msec, or sec.\",\n-                      file=sys.stderr)\n+                print(\n+                    \"Unrecognized unit. Please select nsec, usec, msec, or sec.\",\n+                    file=sys.stderr,\n+                )\n                 return 2\n         if o in (\"-r\", \"--repeat\"):\n             repeat = int(a)\n@@ -309,6 +338,7 @@ def main(args=None, *, _wrap_timer=None):\n     # contains the directory of this script, rather than the current\n     # directory)\n     import os\n+\n     sys.path.insert(0, os.curdir)\n     if _wrap_timer is not None:\n         timer = _wrap_timer(timer)\n@@ -318,11 +348,19 @@ def main(args=None, *, _wrap_timer=None):\n         # determine number so that 0.2 <= total time < 2.0\n         callback = None\n         if verbose:\n+\n             def callback(number, time_taken):\n                 msg = \"{num} loop{s} -> {secs:.{prec}g} secs\"\n-                plural = (number != 1)\n-                print(msg.format(num=number, s='s' if plural else '',\n-                                 secs=time_taken, prec=precision))\n+                plural = number != 1\n+                print(\n+                    msg.format(\n+                        num=number,\n+                        s=\"s\" if plural else \"\",\n+                        secs=time_taken,\n+                        prec=precision,\n+                    )\n+                )\n+\n         try:\n             number, _ = t.autorange(callback)\n         except:\n@@ -358,19 +396,25 @@ def format_time(dt):\n     timings = [dt / number for dt in raw_timings]\n \n     best = min(timings)\n-    print(\"%d loop%s, best of %d: %s per loop\"\n-          % (number, 's' if number != 1 else '',\n-             repeat, format_time(best)))\n+    print(\n+        \"%d loop%s, best of %d: %s per loop\"\n+        % (number, \"s\" if number != 1 else \"\", repeat, format_time(best))\n+    )\n \n     best = min(timings)\n     worst = max(timings)\n     if worst >= best * 4:\n         import warnings\n-        warnings.warn_explicit(\"The test results are likely unreliable. \"\n-                               \"The worst time (%s) was more than four times \"\n-                               \"slower than the best time (%s).\"\n-                               % (format_time(worst), format_time(best)),\n-                               UserWarning, '', 0)\n+\n+        warnings.warn_explicit(\n+            \"The test results are likely unreliable. \"\n+            \"The worst time (%s) was more than four times \"\n+            \"slower than the best time (%s).\"\n+            % (format_time(worst), format_time(best)),\n+            UserWarning,\n+            \"\",\n+            0,\n+        )\n     return None\n \n \n"
    },
    {
        "id": 329,
        "sha_fail": "d01a6ec49f1aac932816c81c0354de64c0183373",
        "diff": "diff --git a/lib/core/ncgui.py b/lib/core/ncgui.py\nindex 708f021..440cedb 100644\n--- a/lib/core/ncgui.py\n+++ b/lib/core/ncgui.py\n@@ -5,7 +5,7 @@ Copyright (c) 2006-2025 sqlmap developers (https://sqlmap.org)\n See the file 'LICENSE' for copying permission\n \"\"\"\n \n-import curses\n+# import curses\n import os\n import subprocess\n import sys\n@@ -19,9 +19,9 @@ from lib.core.enums import MKSTEMP_PREFIX\n from lib.core.exception import SqlmapMissingDependence\n from lib.core.exception import SqlmapSystemException\n from lib.core.settings import IS_WIN\n-from thirdparty.six.moves import queue as _queue\n from thirdparty.six.moves import configparser as _configparser\n \n+\n class NcursesUI:\n     def __init__(self, stdscr, parser):\n         self.stdscr = stdscr\n@@ -37,13 +37,13 @@ class NcursesUI:\n \n         # Initialize colors\n         curses.start_color()\n-        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_CYAN)    # Header\n-        curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLUE)    # Active tab\n-        curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_WHITE)   # Inactive tab\n+        curses.init_pair(1, curses.COLOR_BLACK, curses.COLOR_CYAN)  # Header\n+        curses.init_pair(2, curses.COLOR_WHITE, curses.COLOR_BLUE)  # Active tab\n+        curses.init_pair(3, curses.COLOR_BLACK, curses.COLOR_WHITE)  # Inactive tab\n         curses.init_pair(4, curses.COLOR_YELLOW, curses.COLOR_BLACK)  # Selected field\n-        curses.init_pair(5, curses.COLOR_GREEN, curses.COLOR_BLACK)   # Help text\n-        curses.init_pair(6, curses.COLOR_RED, curses.COLOR_BLACK)     # Error/Important\n-        curses.init_pair(7, curses.COLOR_CYAN, curses.COLOR_BLACK)    # Label\n+        curses.init_pair(5, curses.COLOR_GREEN, curses.COLOR_BLACK)  # Help text\n+        curses.init_pair(6, curses.COLOR_RED, curses.COLOR_BLACK)  # Error/Important\n+        curses.init_pair(7, curses.COLOR_CYAN, curses.COLOR_BLACK)  # Label\n \n         # Setup curses\n         curses.curs_set(1)\n@@ -56,21 +56,27 @@ class NcursesUI:\n         \"\"\"Parse command line options into tabs and fields\"\"\"\n         for group in self.parser.option_groups:\n             tab_data = {\n-                'title': group.title,\n-                'description': group.get_description() if hasattr(group, 'get_description') and group.get_description() else \"\",\n-                'options': []\n+                \"title\": group.title,\n+                \"description\": group.get_description()\n+                if hasattr(group, \"get_description\") and group.get_description()\n+                else \"\",\n+                \"options\": [],\n             }\n \n             for option in group.option_list:\n                 field_data = {\n-                    'dest': option.dest,\n-                    'label': self._format_option_strings(option),\n-                    'help': option.help if option.help else \"\",\n-                    'type': option.type if hasattr(option, 'type') and option.type else 'bool',\n-                    'value': '',\n-                    'default': defaults.get(option.dest) if defaults.get(option.dest) else None\n+                    \"dest\": option.dest,\n+                    \"label\": self._format_option_strings(option),\n+                    \"help\": option.help if option.help else \"\",\n+                    \"type\": option.type\n+                    if hasattr(option, \"type\") and option.type\n+                    else \"bool\",\n+                    \"value\": \"\",\n+                    \"default\": defaults.get(option.dest)\n+                    if defaults.get(option.dest)\n+                    else None,\n                 }\n-                tab_data['options'].append(field_data)\n+                tab_data[\"options\"].append(field_data)\n                 self.fields[(group.title, option.dest)] = field_data\n \n             self.tabs.append(tab_data)\n@@ -78,11 +84,11 @@ class NcursesUI:\n     def _format_option_strings(self, option):\n         \"\"\"Format option strings for display\"\"\"\n         parts = []\n-        if hasattr(option, '_short_opts') and option._short_opts:\n+        if hasattr(option, \"_short_opts\") and option._short_opts:\n             parts.extend(option._short_opts)\n-        if hasattr(option, '_long_opts') and option._long_opts:\n+        if hasattr(option, \"_long_opts\") and option._long_opts:\n             parts.extend(option._long_opts)\n-        return ', '.join(parts)\n+        return \", \".join(parts)\n \n     def _draw_header(self):\n         \"\"\"Draw the header bar\"\"\"\n@@ -99,7 +105,7 @@ class NcursesUI:\n         x = 0\n \n         for i, tab in enumerate(self.tabs):\n-            tab_text = \" %s \" % tab['title']\n+            tab_text = \" %s \" % tab[\"title\"]\n \n             # Check if tab exceeds width, wrap to next line\n             if x + len(tab_text) >= width:\n@@ -120,7 +126,7 @@ class NcursesUI:\n         x = 0\n \n         for i, tab in enumerate(self.tabs):\n-            tab_text = \" %s \" % tab['title']\n+            tab_text = \" %s \" % tab[\"title\"]\n \n             # Check if tab exceeds width, wrap to next line\n             if x + len(tab_text) >= width:\n@@ -178,8 +184,8 @@ class NcursesUI:\n         y = start_y\n \n         # Draw description if exists\n-        if tab['description']:\n-            desc_lines = self._wrap_text(tab['description'], width - 4)\n+        if tab[\"description\"]:\n+            desc_lines = self._wrap_text(tab[\"description\"], width - 4)\n             for line in desc_lines[:2]:  # Limit to 2 lines\n                 try:\n                     self.stdscr.attron(curses.color_pair(5))\n@@ -194,14 +200,16 @@ class NcursesUI:\n         visible_start = self.scroll_offset\n         visible_end = visible_start + (height - y - 2)\n \n-        for i, option in enumerate(tab['options'][visible_start:visible_end], visible_start):\n+        for i, option in enumerate(\n+            tab[\"options\"][visible_start:visible_end], visible_start\n+        ):\n             if y >= height - 2:\n                 break\n \n-            is_selected = (i == self.current_field)\n+            is_selected = i == self.current_field\n \n             # Draw label\n-            label = option['label'][:25].ljust(25)\n+            label = option[\"label\"][:25].ljust(25)\n             try:\n                 if is_selected:\n                     self.stdscr.attron(curses.color_pair(4) | curses.A_BOLD)\n@@ -219,12 +227,12 @@ class NcursesUI:\n \n             # Draw value\n             value_str = \"\"\n-            if option['type'] == 'bool':\n-                value_str = \"[X]\" if option['value'] else \"[ ]\"\n+            if option[\"type\"] == \"bool\":\n+                value_str = \"[X]\" if option[\"value\"] else \"[ ]\"\n             else:\n-                value_str = str(option['value']) if option['value'] else \"\"\n-                if option['default'] and not option['value']:\n-                    value_str = \"(%s)\" % str(option['default'])\n+                value_str = str(option[\"value\"]) if option[\"value\"] else \"\"\n+                if option[\"default\"] and not option[\"value\"]:\n+                    value_str = \"(%s)\" % str(option[\"default\"])\n \n             value_str = value_str[:30]\n \n@@ -239,7 +247,7 @@ class NcursesUI:\n \n             # Draw help text\n             if width > 65:\n-                help_text = option['help'][:width-62] if option['help'] else \"\"\n+                help_text = option[\"help\"][: width - 62] if option[\"help\"] else \"\"\n                 try:\n                     self.stdscr.attron(curses.color_pair(5))\n                     self.stdscr.addstr(y, 60, help_text)\n@@ -250,7 +258,7 @@ class NcursesUI:\n             y += 1\n \n         # Draw scroll indicator\n-        if len(tab['options']) > visible_end - visible_start:\n+        if len(tab[\"options\"]) > visible_end - visible_start:\n             try:\n                 self.stdscr.attron(curses.color_pair(6))\n                 self.stdscr.addstr(height - 2, width - 10, \"[More...]\")\n@@ -280,14 +288,14 @@ class NcursesUI:\n     def _edit_field(self):\n         \"\"\"Edit the current field\"\"\"\n         tab = self.tabs[self.current_tab]\n-        if self.current_field >= len(tab['options']):\n+        if self.current_field >= len(tab[\"options\"]):\n             return\n \n-        option = tab['options'][self.current_field]\n+        option = tab[\"options\"][self.current_field]\n \n-        if option['type'] == 'bool':\n+        if option[\"type\"] == \"bool\":\n             # Toggle boolean\n-            option['value'] = not option['value']\n+            option[\"value\"] = not option[\"value\"]\n         else:\n             # Text input\n             height, width = self.stdscr.getmaxyx()\n@@ -296,7 +304,7 @@ class NcursesUI:\n             input_win = curses.newwin(5, width - 20, height // 2 - 2, 10)\n             input_win.box()\n             input_win.attron(curses.color_pair(2))\n-            input_win.addstr(0, 2, \" Edit %s \" % option['label'][:20])\n+            input_win.addstr(0, 2, \" Edit %s \" % option[\"label\"][:20])\n             input_win.attroff(curses.color_pair(2))\n             input_win.addstr(2, 2, \"Value:\")\n             input_win.refresh()\n@@ -306,26 +314,26 @@ class NcursesUI:\n             curses.curs_set(1)\n \n             # Pre-fill with existing value\n-            current_value = str(option['value']) if option['value'] else \"\"\n+            current_value = str(option[\"value\"]) if option[\"value\"] else \"\"\n             input_win.addstr(2, 9, current_value)\n             input_win.move(2, 9)\n \n             try:\n-                new_value = input_win.getstr(2, 9, width - 32).decode('utf-8')\n+                new_value = input_win.getstr(2, 9, width - 32).decode(\"utf-8\")\n \n                 # Validate and convert based on type\n-                if option['type'] == 'int':\n+                if option[\"type\"] == \"int\":\n                     try:\n-                        option['value'] = int(new_value) if new_value else None\n+                        option[\"value\"] = int(new_value) if new_value else None\n                     except ValueError:\n-                        option['value'] = None\n-                elif option['type'] == 'float':\n+                        option[\"value\"] = None\n+                elif option[\"type\"] == \"float\":\n                     try:\n-                        option['value'] = float(new_value) if new_value else None\n+                        option[\"value\"] = float(new_value) if new_value else None\n                     except ValueError:\n-                        option['value'] = None\n+                        option[\"value\"] = None\n                 else:\n-                    option['value'] = new_value if new_value else None\n+                    option[\"value\"] = new_value if new_value else None\n             except:\n                 pass\n \n@@ -355,21 +363,25 @@ class NcursesUI:\n         curses.curs_set(1)\n \n         try:\n-            filename = input_win.getstr(2, 8, width - 32).decode('utf-8').strip()\n+            filename = input_win.getstr(2, 8, width - 32).decode(\"utf-8\").strip()\n \n             if filename:\n                 # Collect all field values\n                 config = {}\n                 for tab in self.tabs:\n-                    for option in tab['options']:\n-                        dest = option['dest']\n-                        value = option['value'] if option['value'] else option.get('default')\n-\n-                        if option['type'] == 'bool':\n+                    for option in tab[\"options\"]:\n+                        dest = option[\"dest\"]\n+                        value = (\n+                            option[\"value\"]\n+                            if option[\"value\"]\n+                            else option.get(\"default\")\n+                        )\n+\n+                        if option[\"type\"] == \"bool\":\n                             config[dest] = bool(value)\n-                        elif option['type'] == 'int':\n+                        elif option[\"type\"] == \"int\":\n                             config[dest] = int(value) if value else None\n-                        elif option['type'] == 'float':\n+                        elif option[\"type\"] == \"float\":\n                             config[dest] = float(value) if value else None\n                         else:\n                             config[dest] = value\n@@ -390,7 +402,7 @@ class NcursesUI:\n                     input_win.addstr(0, 2, \" Export Successful \")\n                     input_win.attroff(curses.color_pair(5))\n                     input_win.addstr(2, 2, \"Configuration exported to:\")\n-                    input_win.addstr(3, 2, filename[:width - 26])\n+                    input_win.addstr(3, 2, filename[: width - 26])\n                     input_win.refresh()\n                     curses.napms(2000)\n                 except Exception as ex:\n@@ -400,7 +412,7 @@ class NcursesUI:\n                     input_win.attron(curses.color_pair(6))\n                     input_win.addstr(0, 2, \" Export Failed \")\n                     input_win.attroff(curses.color_pair(6))\n-                    input_win.addstr(2, 2, str(getSafeExString(ex))[:width - 26])\n+                    input_win.addstr(2, 2, str(getSafeExString(ex))[: width - 26])\n                     input_win.refresh()\n                     curses.napms(2000)\n         except:\n@@ -432,7 +444,7 @@ class NcursesUI:\n         curses.curs_set(1)\n \n         try:\n-            filename = input_win.getstr(2, 8, width - 32).decode('utf-8').strip()\n+            filename = input_win.getstr(2, 8, width - 32).decode(\"utf-8\").strip()\n \n             if filename and os.path.isfile(filename):\n                 try:\n@@ -444,8 +456,8 @@ class NcursesUI:\n \n                     # Load values into fields\n                     for tab in self.tabs:\n-                        for option in tab['options']:\n-                            dest = option['dest']\n+                        for option in tab[\"options\"]:\n+                            dest = option[\"dest\"]\n \n                             # Search for option in all sections\n                             for section in config.sections():\n@@ -453,20 +465,29 @@ class NcursesUI:\n                                     value = config.get(section, dest)\n \n                                     # Convert based on type\n-                                    if option['type'] == 'bool':\n-                                        option['value'] = value.lower() in ('true', '1', 'yes', 'on')\n-                                    elif option['type'] == 'int':\n+                                    if option[\"type\"] == \"bool\":\n+                                        option[\"value\"] = value.lower() in (\n+                                            \"true\",\n+                                            \"1\",\n+                                            \"yes\",\n+                                            \"on\",\n+                                        )\n+                                    elif option[\"type\"] == \"int\":\n                                         try:\n-                                            option['value'] = int(value) if value else None\n+                                            option[\"value\"] = (\n+                                                int(value) if value else None\n+                                            )\n                                         except ValueError:\n-                                            option['value'] = None\n-                                    elif option['type'] == 'float':\n+                                            option[\"value\"] = None\n+                                    elif option[\"type\"] == \"float\":\n                                         try:\n-                                            option['value'] = float(value) if value else None\n+                                            option[\"value\"] = (\n+                                                float(value) if value else None\n+                                            )\n                                         except ValueError:\n-                                            option['value'] = None\n+                                            option[\"value\"] = None\n                                     else:\n-                                        option['value'] = value if value else None\n+                                        option[\"value\"] = value if value else None\n \n                                     imported_count += 1\n                                     break\n@@ -478,7 +499,7 @@ class NcursesUI:\n                     input_win.addstr(0, 2, \" Import Successful \")\n                     input_win.attroff(curses.color_pair(5))\n                     input_win.addstr(2, 2, \"Imported %d options from:\" % imported_count)\n-                    input_win.addstr(3, 2, filename[:width - 26])\n+                    input_win.addstr(3, 2, filename[: width - 26])\n                     input_win.refresh()\n                     curses.napms(2000)\n \n@@ -489,7 +510,7 @@ class NcursesUI:\n                     input_win.attron(curses.color_pair(6))\n                     input_win.addstr(0, 2, \" Import Failed \")\n                     input_win.attroff(curses.color_pair(6))\n-                    input_win.addstr(2, 2, str(getSafeExString(ex))[:width - 26])\n+                    input_win.addstr(2, 2, str(getSafeExString(ex))[: width - 26])\n                     input_win.refresh()\n                     curses.napms(2000)\n             elif filename:\n@@ -500,7 +521,7 @@ class NcursesUI:\n                 input_win.addstr(0, 2, \" File Not Found \")\n                 input_win.attroff(curses.color_pair(6))\n                 input_win.addstr(2, 2, \"File does not exist:\")\n-                input_win.addstr(3, 2, filename[:width - 26])\n+                input_win.addstr(3, 2, filename[: width - 26])\n                 input_win.refresh()\n                 curses.napms(2000)\n         except:\n@@ -520,15 +541,15 @@ class NcursesUI:\n \n         # Collect all field values\n         for tab in self.tabs:\n-            for option in tab['options']:\n-                dest = option['dest']\n-                value = option['value'] if option['value'] else option.get('default')\n+            for option in tab[\"options\"]:\n+                dest = option[\"dest\"]\n+                value = option[\"value\"] if option[\"value\"] else option.get(\"default\")\n \n-                if option['type'] == 'bool':\n+                if option[\"type\"] == \"bool\":\n                     config[dest] = bool(value)\n-                elif option['type'] == 'int':\n+                elif option[\"type\"] == \"int\":\n                     config[dest] = int(value) if value else None\n-                elif option['type'] == 'float':\n+                elif option[\"type\"] == \"float\":\n                     config[dest] = float(value) if value else None\n                 else:\n                     config[dest] = value\n@@ -567,17 +588,23 @@ class NcursesUI:\n         # Start sqlmap process\n         try:\n             process = subprocess.Popen(\n-                [sys.executable or \"python\", os.path.join(paths.SQLMAP_ROOT_PATH, \"sqlmap.py\"), \"-c\", configFile],\n+                [\n+                    sys.executable or \"python\",\n+                    os.path.join(paths.SQLMAP_ROOT_PATH, \"sqlmap.py\"),\n+                    \"-c\",\n+                    configFile,\n+                ],\n                 shell=False,\n                 stdout=subprocess.PIPE,\n                 stderr=subprocess.STDOUT,\n                 stdin=subprocess.PIPE,\n                 bufsize=1,\n-                close_fds=not IS_WIN\n+                close_fds=not IS_WIN,\n             )\n \n             # Make it non-blocking\n             import fcntl\n+\n             flags = fcntl.fcntl(process.stdout, fcntl.F_GETFL)\n             fcntl.fcntl(process.stdout, fcntl.F_SETFL, flags | os.O_NONBLOCK)\n \n@@ -591,7 +618,7 @@ class NcursesUI:\n                 # Check for user input\n                 try:\n                     key = console_win.getch()\n-                    if key in (ord('q'), ord('Q')):\n+                    if key in (ord(\"q\"), ord(\"Q\")):\n                         # Kill process\n                         process.terminate()\n                         break\n@@ -599,7 +626,7 @@ class NcursesUI:\n                         # Send newline to process\n                         if process.poll() is None:\n                             try:\n-                                process.stdin.write(b'\\n')\n+                                process.stdin.write(b\"\\n\")\n                                 process.stdin.flush()\n                             except:\n                                 pass\n@@ -610,11 +637,11 @@ class NcursesUI:\n                 try:\n                     chunk = process.stdout.read(1024)\n                     if chunk:\n-                        current_line += chunk.decode('utf-8', errors='ignore')\n+                        current_line += chunk.decode(\"utf-8\", errors=\"ignore\")\n \n                         # Split into lines\n-                        while '\\n' in current_line:\n-                            line, current_line = current_line.split('\\n', 1)\n+                        while \"\\n\" in current_line:\n+                            line, current_line = current_line.split(\"\\n\", 1)\n                             lines.append(line)\n \n                             # Keep only last N lines\n@@ -626,7 +653,7 @@ class NcursesUI:\n                             start_line = max(0, len(lines) - (height - 10))\n                             for i, l in enumerate(lines[start_line:]):\n                                 try:\n-                                    output_win.addstr(i, 0, l[:width-10])\n+                                    output_win.addstr(i, 0, l[: width - 10])\n                                 except:\n                                     pass\n                             output_win.refresh()\n@@ -640,8 +667,8 @@ class NcursesUI:\n                     try:\n                         remaining = process.stdout.read()\n                         if remaining:\n-                            current_line += remaining.decode('utf-8', errors='ignore')\n-                            for line in current_line.split('\\n'):\n+                            current_line += remaining.decode(\"utf-8\", errors=\"ignore\")\n+                            for line in current_line.split(\"\\n\"):\n                                 if line:\n                                     lines.append(line)\n                     except:\n@@ -652,11 +679,13 @@ class NcursesUI:\n                     start_line = max(0, len(lines) - (height - 10))\n                     for i, l in enumerate(lines[start_line:]):\n                         try:\n-                            output_win.addstr(i, 0, l[:width-10])\n+                            output_win.addstr(i, 0, l[: width - 10])\n                         except:\n                             pass\n \n-                    output_win.addstr(height - 9, 0, \"--- Process finished. Press Q to close ---\")\n+                    output_win.addstr(\n+                        height - 9, 0, \"--- Process finished. Press Q to close ---\"\n+                    )\n                     output_win.refresh()\n                     console_win.refresh()\n \n@@ -664,7 +693,7 @@ class NcursesUI:\n                     console_win.nodelay(False)\n                     while True:\n                         key = console_win.getch()\n-                        if key in (ord('q'), ord('Q')):\n+                        if key in (ord(\"q\"), ord(\"Q\")):\n                             break\n \n                     break\n@@ -711,7 +740,7 @@ class NcursesUI:\n             # Handle input\n             if key == curses.KEY_F10 or key == 27:  # F10 or ESC\n                 break\n-            elif key == ord('\\t') or key == curses.KEY_RIGHT:  # Tab or Right arrow\n+            elif key == ord(\"\\t\") or key == curses.KEY_RIGHT:  # Tab or Right arrow\n                 self.current_tab = (self.current_tab + 1) % len(self.tabs)\n                 self.current_field = 0\n                 self.scroll_offset = 0\n@@ -726,7 +755,7 @@ class NcursesUI:\n                     if self.current_field < self.scroll_offset:\n                         self.scroll_offset = self.current_field\n             elif key == curses.KEY_DOWN:  # Down arrow\n-                if self.current_field < len(tab['options']) - 1:\n+                if self.current_field < len(tab[\"options\"]) - 1:\n                     self.current_field += 1\n                     # Adjust scroll if needed\n                     height, width = self.stdscr.getmaxyx()\n@@ -741,10 +770,11 @@ class NcursesUI:\n                 self._export_config()\n             elif key == curses.KEY_F4:  # F4 to import\n                 self._import_config()\n-            elif key == ord(' '):  # Space for boolean toggle\n-                option = tab['options'][self.current_field]\n-                if option['type'] == 'bool':\n-                    option['value'] = not option['value']\n+            elif key == ord(\" \"):  # Space for boolean toggle\n+                option = tab[\"options\"][self.current_field]\n+                if option[\"type\"] == \"bool\":\n+                    option[\"value\"] = not option[\"value\"]\n+\n \n def runNcGui(parser):\n     \"\"\"Main entry point for ncurses GUI\"\"\"\n@@ -752,7 +782,9 @@ def runNcGui(parser):\n         # Check if ncurses is available\n         import curses\n     except ImportError:\n-        raise SqlmapMissingDependence(\"missing 'curses' module (try installing 'windows-curses' on Windows)\")\n+        raise SqlmapMissingDependence(\n+            \"missing 'curses' module (try installing 'windows-curses' on Windows)\"\n+        )\n \n     try:\n         # Initialize and run\ndiff --git a/lib/core/testing.py b/lib/core/testing.py\nindex 1e0e343..84a502b 100644\n--- a/lib/core/testing.py\n+++ b/lib/core/testing.py\n@@ -32,6 +32,7 @@ from lib.core.data import queries\n from lib.core.patch import unisonRandom\n from lib.core.settings import IS_WIN\n \n+\n def vulnTest():\n     \"\"\"\n     Runs the testing against 'vulnserver'\n@@ -40,41 +41,267 @@ def vulnTest():\n     TESTS = (\n         (\"-h\", (\"to see full list of options run with '-hh'\",)),\n         (\"--dependencies\", (\"sqlmap requires\", \"third-party library\")),\n-        (\"-u <url> --data=\\\"reflect=1\\\" --flush-session --wizard --disable-coloring\", (\"Please choose:\", \"back-end DBMS: SQLite\", \"current user is DBA: True\", \"banner: '3.\")),\n-        (\"-u <url> --data=\\\"code=1\\\" --code=200 --technique=B --banner --no-cast --flush-session\", (\"back-end DBMS: SQLite\", \"banner: '3.\", \"~COALESCE(CAST(\")),\n-        (u\"-c <config> --flush-session --output-dir=\\\"<tmpdir>\\\" --smart --roles --statements --hostname --privileges --sql-query=\\\"SELECT '\\u0161u\\u0107uraj'\\\" --technique=U\", (u\": '\\u0161u\\u0107uraj'\", \"on SQLite it is not possible\", \"as the output directory\")),\n-        (u\"-u <url> --flush-session --sql-query=\\\"SELECT '\\u0161u\\u0107uraj'\\\" --technique=B --no-escape --string=luther --unstable\", (u\": '\\u0161u\\u0107uraj'\",)),\n-        (\"-m <multiple> --flush-session --technique=B --banner\", (\"/3] URL:\", \"back-end DBMS: SQLite\", \"banner: '3.\")),\n-        (\"--dummy\", (\"all tested parameters do not appear to be injectable\", \"does not seem to be injectable\", \"there is not at least one\", \"~might be injectable\")),\n-        (\"-u \\\"<url>&id2=1\\\" -p id2 -v 5 --flush-session --level=5 --text-only --test-filter=\\\"AND boolean-based blind - WHERE or HAVING clause (MySQL comment)\\\"\", (\"~1AND\",)),\n+        (\n+            '-u <url> --data=\"reflect=1\" --flush-session --wizard --disable-coloring',\n+            (\n+                \"Please choose:\",\n+                \"back-end DBMS: SQLite\",\n+                \"current user is DBA: True\",\n+                \"banner: '3.\",\n+            ),\n+        ),\n+        (\n+            '-u <url> --data=\"code=1\" --code=200 --technique=B --banner --no-cast --flush-session',\n+            (\"back-end DBMS: SQLite\", \"banner: '3.\", \"~COALESCE(CAST(\"),\n+        ),\n+        (\n+            '-c <config> --flush-session --output-dir=\"<tmpdir>\" --smart --roles --statements --hostname --privileges --sql-query=\"SELECT \\'\\u0161u\\u0107uraj\\'\" --technique=U',\n+            (\n+                \": '\\u0161u\\u0107uraj'\",\n+                \"on SQLite it is not possible\",\n+                \"as the output directory\",\n+            ),\n+        ),\n+        (\n+            \"-u <url> --flush-session --sql-query=\\\"SELECT '\\u0161u\\u0107uraj'\\\" --technique=B --no-escape --string=luther --unstable\",\n+            (\": '\\u0161u\\u0107uraj'\",),\n+        ),\n+        (\n+            \"-m <multiple> --flush-session --technique=B --banner\",\n+            (\"/3] URL:\", \"back-end DBMS: SQLite\", \"banner: '3.\"),\n+        ),\n+        (\n+            \"--dummy\",\n+            (\n+                \"all tested parameters do not appear to be injectable\",\n+                \"does not seem to be injectable\",\n+                \"there is not at least one\",\n+                \"~might be injectable\",\n+            ),\n+        ),\n+        (\n+            '-u \"<url>&id2=1\" -p id2 -v 5 --flush-session --level=5 --text-only --test-filter=\"AND boolean-based blind - WHERE or HAVING clause (MySQL comment)\"',\n+            (\"~1AND\",),\n+        ),\n         (\"--list-tampers\", (\"between\", \"MySQL\", \"xforwardedfor\")),\n-        (\"-r <request> --flush-session -v 5 --test-skip=\\\"heavy\\\" --save=<config>\", (\"CloudFlare\", \"web application technology: Express\", \"possible DBMS: 'SQLite'\", \"User-Agent: foobar\", \"~Type: time-based blind\", \"saved command line options to the configuration file\")),\n-        (\"-c <config>\", (\"CloudFlare\", \"possible DBMS: 'SQLite'\", \"User-Agent: foobar\", \"~Type: time-based blind\")),\n-        (\"-l <log> --flush-session --keep-alive --skip-waf -vvvvv --technique=U --union-from=users --banner --parse-errors\", (\"banner: '3.\", \"ORDER BY term out of range\", \"~xp_cmdshell\", \"Connection: keep-alive\")),\n+        (\n+            '-r <request> --flush-session -v 5 --test-skip=\"heavy\" --save=<config>',\n+            (\n+                \"CloudFlare\",\n+                \"web application technology: Express\",\n+                \"possible DBMS: 'SQLite'\",\n+                \"User-Agent: foobar\",\n+                \"~Type: time-based blind\",\n+                \"saved command line options to the configuration file\",\n+            ),\n+        ),\n+        (\n+            \"-c <config>\",\n+            (\n+                \"CloudFlare\",\n+                \"possible DBMS: 'SQLite'\",\n+                \"User-Agent: foobar\",\n+                \"~Type: time-based blind\",\n+            ),\n+        ),\n+        (\n+            \"-l <log> --flush-session --keep-alive --skip-waf -vvvvv --technique=U --union-from=users --banner --parse-errors\",\n+            (\n+                \"banner: '3.\",\n+                \"ORDER BY term out of range\",\n+                \"~xp_cmdshell\",\n+                \"Connection: keep-alive\",\n+            ),\n+        ),\n         (\"-l <log> --offline --banner -v 5\", (\"banner: '3.\", \"~[TRAFFIC OUT]\")),\n-        (\"-u <base> --flush-session --data=\\\"id=1&_=Eewef6oh\\\" --chunked --randomize=_ --random-agent --banner\", (\"fetched random HTTP User-Agent header value\", \"Parameter: id (POST)\", \"Type: boolean-based blind\", \"Type: time-based blind\", \"Type: UNION query\", \"banner: '3.\")),\n-        (\"-u <base64> -p id --base64=id --data=\\\"base64=true\\\" --flush-session --banner --technique=B\", (\"banner: '3.\",)),\n-        (\"-u <base64> -p id --base64=id --data=\\\"base64=true\\\" --flush-session --tables --technique=U\", (\" users \",)),\n-        (\"-u <url> --flush-session --banner --technique=B --disable-precon --not-string \\\"no results\\\"\", (\"banner: '3.\",)),\n-        (\"-u <url> --flush-session --encoding=gbk --banner --technique=B --first=1 --last=2\", (\"banner: '3.'\",)),\n-        (\"-u <url> --flush-session --encoding=ascii --forms --crawl=2 --threads=2 --banner\", (\"total of 2 targets\", \"might be injectable\", \"Type: UNION query\", \"banner: '3.\")),\n-        (\"-u <base> --flush-session --technique=BU --data=\\\"{\\\\\\\"id\\\\\\\": 1}\\\" --banner\", (\"might be injectable\", \"3 columns\", \"Payload: {\\\"id\\\"\", \"Type: boolean-based blind\", \"Type: UNION query\", \"banner: '3.\")),\n-        (\"-u <base> --flush-session -H \\\"Foo: Bar\\\" -H \\\"Sna: Fu\\\" --data=\\\"<root><param name=\\\\\\\"id\\\\\\\" value=\\\\\\\"1*\\\\\\\"/></root>\\\" --union-char=1 --mobile --answers=\\\"smartphone=3\\\" --banner --smart -v 5\", (\"might be injectable\", \"Payload: <root><param name=\\\"id\\\" value=\\\"1\", \"Type: boolean-based blind\", \"Type: time-based blind\", \"Type: UNION query\", \"banner: '3.\", \"Nexus\", \"Sna: Fu\", \"Foo: Bar\")),\n-        (\"-u <base> --flush-session --technique=BU --method=PUT --data=\\\"a=1;id=1;b=2\\\" --param-del=\\\";\\\" --skip-static --har=<tmpfile> --dump -T users --start=1 --stop=2\", (\"might be injectable\", \"Parameter: id (PUT)\", \"Type: boolean-based blind\", \"Type: UNION query\", \"2 entries\")),\n-        (\"-u <url> --flush-session -H \\\"id: 1*\\\" --tables -t <tmpfile>\", (\"might be injectable\", \"Parameter: id #1* ((custom) HEADER)\", \"Type: boolean-based blind\", \"Type: time-based blind\", \"Type: UNION query\", \" users \")),\n-        (\"-u <url> --flush-session --banner --invalid-logical --technique=B --predict-output --test-filter=\\\"OR boolean\\\" --tamper=space2dash\", (\"banner: '3.\", \" LIKE \")),\n-        (\"-u <url> --flush-session --cookie=\\\"PHPSESSID=d41d8cd98f00b204e9800998ecf8427e; id=1*; id2=2\\\" --tables --union-cols=3\", (\"might be injectable\", \"Cookie #1* ((custom) HEADER)\", \"Type: boolean-based blind\", \"Type: time-based blind\", \"Type: UNION query\", \" users \")),\n-        (\"-u <url> --flush-session --null-connection --technique=B --tamper=between,randomcase --banner --count -T users\", (\"NULL connection is supported with HEAD method\", \"banner: '3.\", \"users | 5\")),\n-        (\"-u <base> --data=\\\"aWQ9MQ==\\\" --flush-session --base64=POST -v 6\", (\"aWQ9MTtXQUlURk9SIERFTEFZICcwOjA\",)),\n-        (\"-u <url> --flush-session --parse-errors --test-filter=\\\"subquery\\\" --eval=\\\"import hashlib; id2=2; id3=hashlib.md5(id.encode()).hexdigest()\\\" --referer=\\\"localhost\\\"\", (\"might be injectable\", \": syntax error\", \"back-end DBMS: SQLite\", \"WHERE or HAVING clause (subquery\")),\n-        (\"-u <url> --banner --schema --dump -T users --binary-fields=surname --where \\\"id>3\\\"\", (\"banner: '3.\", \"INTEGER\", \"TEXT\", \"id\", \"name\", \"surname\", \"2 entries\", \"6E616D6569736E756C6C\")),\n-        (\"-u <url> --technique=U --fresh-queries --force-partial --dump -T users --dump-format=HTML --answers=\\\"crack=n\\\" -v 3\", (\"performed 6 queries\", \"nameisnull\", \"~using default dictionary\", \"dumped to HTML file\")),\n-        (\"-u <url> --flush-session --technique=BU --all\", (\"5 entries\", \"Type: boolean-based blind\", \"Type: UNION query\", \"luther\", \"blisset\", \"fluffy\", \"179ad45c6ce2cb97cf1029e212046e81\", \"NULL\", \"nameisnull\", \"testpass\")),\n-        (\"-u <url> -z \\\"tec=B\\\" --hex --fresh-queries --threads=4 --sql-query=\\\"SELECT * FROM users\\\"\", (\"SELECT * FROM users [5]\", \"nameisnull\")),\n-        (\"-u \\\"<url>&echo=foobar*\\\" --flush-session\", (\"might be vulnerable to cross-site scripting\",)),\n-        (\"-u \\\"<url>&query=*\\\" --flush-session --technique=Q --banner\", (\"Title: SQLite inline queries\", \"banner: '3.\")),\n-        (\"-d \\\"<direct>\\\" --flush-session --dump -T users --dump-format=SQLITE --binary-fields=name --where \\\"id=3\\\"\", (\"7775\", \"179ad45c6ce2cb97cf1029e212046e81 (testpass)\", \"dumped to SQLITE database\")),\n-        (\"-d \\\"<direct>\\\" --flush-session --banner --schema --sql-query=\\\"UPDATE users SET name='foobar' WHERE id=5; SELECT * FROM users; SELECT 987654321\\\"\", (\"banner: '3.\", \"INTEGER\", \"TEXT\", \"id\", \"name\", \"surname\", \"5,foobar,nameisnull\", \"'987654321'\",)),\n+        (\n+            '-u <base> --flush-session --data=\"id=1&_=Eewef6oh\" --chunked --randomize=_ --random-agent --banner',\n+            (\n+                \"fetched random HTTP User-Agent header value\",\n+                \"Parameter: id (POST)\",\n+                \"Type: boolean-based blind\",\n+                \"Type: time-based blind\",\n+                \"Type: UNION query\",\n+                \"banner: '3.\",\n+            ),\n+        ),\n+        (\n+            '-u <base64> -p id --base64=id --data=\"base64=true\" --flush-session --banner --technique=B',\n+            (\"banner: '3.\",),\n+        ),\n+        (\n+            '-u <base64> -p id --base64=id --data=\"base64=true\" --flush-session --tables --technique=U',\n+            (\" users \",),\n+        ),\n+        (\n+            '-u <url> --flush-session --banner --technique=B --disable-precon --not-string \"no results\"',\n+            (\"banner: '3.\",),\n+        ),\n+        (\n+            \"-u <url> --flush-session --encoding=gbk --banner --technique=B --first=1 --last=2\",\n+            (\"banner: '3.'\",),\n+        ),\n+        (\n+            \"-u <url> --flush-session --encoding=ascii --forms --crawl=2 --threads=2 --banner\",\n+            (\n+                \"total of 2 targets\",\n+                \"might be injectable\",\n+                \"Type: UNION query\",\n+                \"banner: '3.\",\n+            ),\n+        ),\n+        (\n+            '-u <base> --flush-session --technique=BU --data=\"{\\\\\"id\\\\\": 1}\" --banner',\n+            (\n+                \"might be injectable\",\n+                \"3 columns\",\n+                'Payload: {\"id\"',\n+                \"Type: boolean-based blind\",\n+                \"Type: UNION query\",\n+                \"banner: '3.\",\n+            ),\n+        ),\n+        (\n+            '-u <base> --flush-session -H \"Foo: Bar\" -H \"Sna: Fu\" --data=\"<root><param name=\\\\\"id\\\\\" value=\\\\\"1*\\\\\"/></root>\" --union-char=1 --mobile --answers=\"smartphone=3\" --banner --smart -v 5',\n+            (\n+                \"might be injectable\",\n+                'Payload: <root><param name=\"id\" value=\"1',\n+                \"Type: boolean-based blind\",\n+                \"Type: time-based blind\",\n+                \"Type: UNION query\",\n+                \"banner: '3.\",\n+                \"Nexus\",\n+                \"Sna: Fu\",\n+                \"Foo: Bar\",\n+            ),\n+        ),\n+        (\n+            '-u <base> --flush-session --technique=BU --method=PUT --data=\"a=1;id=1;b=2\" --param-del=\";\" --skip-static --har=<tmpfile> --dump -T users --start=1 --stop=2',\n+            (\n+                \"might be injectable\",\n+                \"Parameter: id (PUT)\",\n+                \"Type: boolean-based blind\",\n+                \"Type: UNION query\",\n+                \"2 entries\",\n+            ),\n+        ),\n+        (\n+            '-u <url> --flush-session -H \"id: 1*\" --tables -t <tmpfile>',\n+            (\n+                \"might be injectable\",\n+                \"Parameter: id #1* ((custom) HEADER)\",\n+                \"Type: boolean-based blind\",\n+                \"Type: time-based blind\",\n+                \"Type: UNION query\",\n+                \" users \",\n+            ),\n+        ),\n+        (\n+            '-u <url> --flush-session --banner --invalid-logical --technique=B --predict-output --test-filter=\"OR boolean\" --tamper=space2dash',\n+            (\"banner: '3.\", \" LIKE \"),\n+        ),\n+        (\n+            '-u <url> --flush-session --cookie=\"PHPSESSID=d41d8cd98f00b204e9800998ecf8427e; id=1*; id2=2\" --tables --union-cols=3',\n+            (\n+                \"might be injectable\",\n+                \"Cookie #1* ((custom) HEADER)\",\n+                \"Type: boolean-based blind\",\n+                \"Type: time-based blind\",\n+                \"Type: UNION query\",\n+                \" users \",\n+            ),\n+        ),\n+        (\n+            \"-u <url> --flush-session --null-connection --technique=B --tamper=between,randomcase --banner --count -T users\",\n+            (\n+                \"NULL connection is supported with HEAD method\",\n+                \"banner: '3.\",\n+                \"users | 5\",\n+            ),\n+        ),\n+        (\n+            '-u <base> --data=\"aWQ9MQ==\" --flush-session --base64=POST -v 6',\n+            (\"aWQ9MTtXQUlURk9SIERFTEFZICcwOjA\",),\n+        ),\n+        (\n+            '-u <url> --flush-session --parse-errors --test-filter=\"subquery\" --eval=\"import hashlib; id2=2; id3=hashlib.md5(id.encode()).hexdigest()\" --referer=\"localhost\"',\n+            (\n+                \"might be injectable\",\n+                \": syntax error\",\n+                \"back-end DBMS: SQLite\",\n+                \"WHERE or HAVING clause (subquery\",\n+            ),\n+        ),\n+        (\n+            '-u <url> --banner --schema --dump -T users --binary-fields=surname --where \"id>3\"',\n+            (\n+                \"banner: '3.\",\n+                \"INTEGER\",\n+                \"TEXT\",\n+                \"id\",\n+                \"name\",\n+                \"surname\",\n+                \"2 entries\",\n+                \"6E616D6569736E756C6C\",\n+            ),\n+        ),\n+        (\n+            '-u <url> --technique=U --fresh-queries --force-partial --dump -T users --dump-format=HTML --answers=\"crack=n\" -v 3',\n+            (\n+                \"performed 6 queries\",\n+                \"nameisnull\",\n+                \"~using default dictionary\",\n+                \"dumped to HTML file\",\n+            ),\n+        ),\n+        (\n+            \"-u <url> --flush-session --technique=BU --all\",\n+            (\n+                \"5 entries\",\n+                \"Type: boolean-based blind\",\n+                \"Type: UNION query\",\n+                \"luther\",\n+                \"blisset\",\n+                \"fluffy\",\n+                \"179ad45c6ce2cb97cf1029e212046e81\",\n+                \"NULL\",\n+                \"nameisnull\",\n+                \"testpass\",\n+            ),\n+        ),\n+        (\n+            '-u <url> -z \"tec=B\" --hex --fresh-queries --threads=4 --sql-query=\"SELECT * FROM users\"',\n+            (\"SELECT * FROM users [5]\", \"nameisnull\"),\n+        ),\n+        (\n+            '-u \"<url>&echo=foobar*\" --flush-session',\n+            (\"might be vulnerable to cross-site scripting\",),\n+        ),\n+        (\n+            '-u \"<url>&query=*\" --flush-session --technique=Q --banner',\n+            (\"Title: SQLite inline queries\", \"banner: '3.\"),\n+        ),\n+        (\n+            '-d \"<direct>\" --flush-session --dump -T users --dump-format=SQLITE --binary-fields=name --where \"id=3\"',\n+            (\n+                \"7775\",\n+                \"179ad45c6ce2cb97cf1029e212046e81 (testpass)\",\n+                \"dumped to SQLITE database\",\n+            ),\n+        ),\n+        (\n+            '-d \"<direct>\" --flush-session --banner --schema --sql-query=\"UPDATE users SET name=\\'foobar\\' WHERE id=5; SELECT * FROM users; SELECT 987654321\"',\n+            (\n+                \"banner: '3.\",\n+                \"INTEGER\",\n+                \"TEXT\",\n+                \"id\",\n+                \"name\",\n+                \"surname\",\n+                \"5,foobar,nameisnull\",\n+                \"'987654321'\",\n+            ),\n+        ),\n         (\"--purge -v 3\", (\"~ERROR\", \"~CRITICAL\", \"deleting the whole directory tree\")),\n     )\n \n@@ -123,7 +350,10 @@ def vulnTest():\n         time.sleep(1)\n \n     if not vulnserver._alive:\n-        logger.error(\"problem occurred in vulnserver instantiation (address: 'http://%s:%s')\" % (address, port))\n+        logger.error(\n+            \"problem occurred in vulnserver instantiation (address: 'http://%s:%s')\"\n+            % (address, port)\n+        )\n         return False\n     else:\n         logger.info(\"vulnserver running at 'http://%s:%s'...\" % (address, port))\n@@ -147,12 +377,18 @@ def vulnTest():\n     handle, multiple = tempfile.mkstemp(suffix=\".lst\")\n     os.close(handle)\n \n-    content = \"POST / HTTP/1.0\\nUser-Agent: foobar\\nHost: %s:%s\\n\\nid=1\\n\" % (address, port)\n+    content = \"POST / HTTP/1.0\\nUser-Agent: foobar\\nHost: %s:%s\\n\\nid=1\\n\" % (\n+        address,\n+        port,\n+    )\n     with open(request, \"w+\") as f:\n         f.write(content)\n         f.flush()\n \n-    content = '<port>%d</port><request base64=\"true\"><![CDATA[%s]]></request>' % (port, encodeBase64(content, binary=False))\n+    content = '<port>%d</port><request base64=\"true\"><![CDATA[%s]]></request>' % (\n+        port,\n+        encodeBase64(content, binary=False),\n+    )\n     with open(log, \"w+\") as f:\n         f.write(content)\n         f.flush()\n@@ -162,30 +398,63 @@ def vulnTest():\n     direct = \"sqlite3://%s\" % database\n     tmpdir = tempfile.mkdtemp()\n \n-    with open(os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"..\", \"sqlmap.conf\"))) as f:\n+    with open(\n+        os.path.abspath(\n+            os.path.join(os.path.dirname(__file__), \"..\", \"..\", \"sqlmap.conf\")\n+        )\n+    ) as f:\n         content = f.read().replace(\"url =\", \"url = %s\" % url)\n \n     with open(config, \"w+\") as f:\n         f.write(content)\n         f.flush()\n \n-    content = \"%s?%s=%d\\n%s?%s=%d\\n%s&%s=1\" % (base, randomStr(), randomInt(), base, randomStr(), randomInt(), url, randomStr())\n+    content = \"%s?%s=%d\\n%s?%s=%d\\n%s&%s=1\" % (\n+        base,\n+        randomStr(),\n+        randomInt(),\n+        base,\n+        randomStr(),\n+        randomInt(),\n+        url,\n+        randomStr(),\n+    )\n     with open(multiple, \"w+\") as f:\n         f.write(content)\n         f.flush()\n \n     for options, checks in TESTS:\n-        status = '%d/%d (%d%%) ' % (count, len(TESTS), round(100.0 * count / len(TESTS)))\n+        status = \"%d/%d (%d%%) \" % (\n+            count,\n+            len(TESTS),\n+            round(100.0 * count / len(TESTS)),\n+        )\n         dataToStdout(\"\\r[%s] [INFO] complete: %s\" % (time.strftime(\"%X\"), status))\n \n         if IS_WIN and \"uraj\" in options:\n-            options = options.replace(u\"\\u0161u\\u0107uraj\", \"sucuraj\")\n-            checks = [check.replace(u\"\\u0161u\\u0107uraj\", \"sucuraj\") for check in checks]\n-\n-        for tag, value in ((\"<url>\", url), (\"<base>\", base), (\"<direct>\", direct), (\"<tmpdir>\", tmpdir), (\"<request>\", request), (\"<log>\", log), (\"<multiple>\", multiple), (\"<config>\", config), (\"<base64>\", url.replace(\"id=1\", \"id=MZ=%3d\"))):\n+            options = options.replace(\"\\u0161u\\u0107uraj\", \"sucuraj\")\n+            checks = [check.replace(\"\\u0161u\\u0107uraj\", \"sucuraj\") for check in checks]\n+\n+        for tag, value in (\n+            (\"<url>\", url),\n+            (\"<base>\", base),\n+            (\"<direct>\", direct),\n+            (\"<tmpdir>\", tmpdir),\n+            (\"<request>\", request),\n+            (\"<log>\", log),\n+            (\"<multiple>\", multiple),\n+            (\"<config>\", config),\n+            (\"<base64>\", url.replace(\"id=1\", \"id=MZ=%3d\")),\n+        ):\n             options = options.replace(tag, value)\n \n-        cmd = \"%s \\\"%s\\\" %s --batch --non-interactive --debug --time-sec=1\" % (sys.executable if ' ' not in sys.executable else '\"%s\"' % sys.executable, os.path.abspath(os.path.join(os.path.dirname(__file__), \"..\", \"..\", \"sqlmap.py\")), options)\n+        cmd = '%s \"%s\" %s --batch --non-interactive --debug --time-sec=1' % (\n+            sys.executable if \" \" not in sys.executable else '\"%s\"' % sys.executable,\n+            os.path.abspath(\n+                os.path.join(os.path.dirname(__file__), \"..\", \"..\", \"sqlmap.py\")\n+            ),\n+            options,\n+        )\n \n         if \"<tmpfile>\" in cmd:\n             handle, tmp = tempfile.mkstemp()\n@@ -194,7 +463,17 @@ def vulnTest():\n \n         output = shellExec(cmd)\n \n-        if not all((check in output if not check.startswith('~') else check[1:] not in output) for check in checks) or \"unhandled exception\" in output:\n+        if (\n+            not all(\n+                (\n+                    check in output\n+                    if not check.startswith(\"~\")\n+                    else check[1:] not in output\n+                )\n+                for check in checks\n+            )\n+            or \"unhandled exception\" in output\n+        ):\n             dataToStdout(\"---\\n\\n$ %s\\n\" % cmd)\n             dataToStdout(\"%s---\\n\" % output, coloring=False)\n             retVal = False\n@@ -209,6 +488,7 @@ def vulnTest():\n \n     return retVal\n \n+\n def smokeTest():\n     \"\"\"\n     Runs the basic smoke testing of a program\n@@ -235,7 +515,10 @@ def smokeTest():\n             continue\n \n         for filename in files:\n-            if os.path.splitext(filename)[1].lower() == \".py\" and filename != \"__init__.py\":\n+            if (\n+                os.path.splitext(filename)[1].lower() == \".py\"\n+                and filename != \"__init__.py\"\n+            ):\n                 length += 1\n \n     for root, _, files in os.walk(paths.SQLMAP_ROOT_PATH):\n@@ -243,17 +526,24 @@ def smokeTest():\n             continue\n \n         for filename in files:\n-            if os.path.splitext(filename)[1].lower() == \".py\" and filename not in (\"__init__.py\", \"gui.py\"):\n+            if os.path.splitext(filename)[1].lower() == \".py\" and filename not in (\n+                \"__init__.py\",\n+                \"gui.py\",\n+            ):\n                 path = os.path.join(root, os.path.splitext(filename)[0])\n-                path = path.replace(paths.SQLMAP_ROOT_PATH, '.')\n-                path = path.replace(os.sep, '.').lstrip('.')\n+                path = path.replace(paths.SQLMAP_ROOT_PATH, \".\")\n+                path = path.replace(os.sep, \".\").lstrip(\".\")\n                 try:\n                     __import__(path)\n                     module = sys.modules[path]\n                 except Exception as ex:\n                     retVal = False\n                     dataToStdout(\"\\r\")\n-                    errMsg = \"smoke test failed at importing module '%s' (%s):\\n%s\" % (path, os.path.join(root, filename), ex)\n+                    errMsg = \"smoke test failed at importing module '%s' (%s):\\n%s\" % (\n+                        path,\n+                        os.path.join(root, filename),\n+                        ex,\n+                    )\n                     logger.error(errMsg)\n                 else:\n                     logger.setLevel(logging.CRITICAL)\n@@ -268,15 +558,21 @@ def smokeTest():\n                         retVal = False\n \n                 count += 1\n-                status = '%d/%d (%d%%) ' % (count, length, round(100.0 * count / length))\n-                dataToStdout(\"\\r[%s] [INFO] complete: %s\" % (time.strftime(\"%X\"), status))\n+                status = \"%d/%d (%d%%) \" % (\n+                    count,\n+                    length,\n+                    round(100.0 * count / length),\n+                )\n+                dataToStdout(\n+                    \"\\r[%s] [INFO] complete: %s\" % (time.strftime(\"%X\"), status)\n+                )\n \n     def _(node):\n         for __ in dir(node):\n-            if not __.startswith('_'):\n+            if not __.startswith(\"_\"):\n                 candidate = getattr(node, __)\n                 if isinstance(candidate, str):\n-                    if '\\\\' in candidate:\n+                    if \"\\\\\" in candidate:\n                         try:\n                             re.compile(candidate)\n                         except:\n"
    },
    {
        "id": 330,
        "sha_fail": "71b7fd4a926acb2c018af855f325502bfe03d417",
        "diff": "diff --git a/dspy/utils/annotation.py b/dspy/utils/annotation.py\nindex 4b12c14..3d9cf3e 100644\n--- a/dspy/utils/annotation.py\n+++ b/dspy/utils/annotation.py\n@@ -6,9 +6,11 @@ from typing import Callable, ParamSpec, TypeVar, overload\n P = ParamSpec(\"P\")\n R = TypeVar(\"R\")\n \n+\n @overload\n def experimental(f: Callable[P, R], version: str | None = None) -> Callable[P, R]: ...\n \n+\n @overload\n def experimental(f: None = None, version: str | None = None) -> Callable[[Callable[P, R]], Callable[P, R]]: ...\n \n@@ -31,8 +33,10 @@ def experimental(\n     if f:\n         return _experimental(f, version)\n     else:\n+\n         def decorator(f: Callable[P, R]) -> Callable[P, R]:\n             return _experimental(f, version)\n+\n         return decorator\n \n \ndiff --git a/dspy/utils/hasher.py b/dspy/utils/hasher.py\nindex f842600..5343f9a 100644\n--- a/dspy/utils/hasher.py\n+++ b/dspy/utils/hasher.py\n@@ -13,6 +13,8 @@ Author: Hugging Face Inc.\n URL: https://github.com/huggingface/datasets/blob/fa73ab472eecf9136a3daf7a0fbff16a3dffa7a6/src/datasets/fingerprint.py#L170\n Changes: 2025-08-10 - Ran ruff to format the code to DSPy styles.\n \"\"\"\n+\n+\n class Hasher:\n     \"\"\"Hasher that accepts python objects as inputs.\"\"\"\n \ndiff --git a/tests/primitives/test_python_interpreter.py b/tests/primitives/test_python_interpreter.py\nindex b61cf29..652820d 100644\n--- a/tests/primitives/test_python_interpreter.py\n+++ b/tests/primitives/test_python_interpreter.py\n@@ -63,6 +63,7 @@ def test_final_answer_trick():\n         # They should maintain the same order\n         assert result == [\"The result is\", token], \"The returned results are differ, `final_answer` trick doesn't work\"\n \n+\n def test_enable_env_vars_flag():\n     os.environ[\"FOO_TEST_ENV\"] = \"test_value\"\n \n@@ -77,7 +78,6 @@ def test_enable_env_vars_flag():\n         assert result == \"test_value\", \"Environment variables should be accessible with allow-env\"\n \n \n-\n def test_read_file_access_control(tmp_path):\n     testfile_path = tmp_path / \"test_temp_file.txt\"\n     virtual_path = f\"/sandbox/{testfile_path.name}\"\n@@ -85,11 +85,7 @@ def test_read_file_access_control(tmp_path):\n         f.write(\"test content\")\n \n     with PythonInterpreter(enable_read_paths=[str(testfile_path)]) as interpreter:\n-        code = (\n-            f\"with open({virtual_path!r}, 'r') as f:\\n\"\n-            f\"    data = f.read()\\n\"\n-            f\"data\"\n-        )\n+        code = f\"with open({virtual_path!r}, 'r') as f:\\n    data = f.read()\\ndata\"\n         result = interpreter.execute(code)\n         assert result == \"test content\", \"Test file should be accessible with enable_read_paths and specified file\"\n \n@@ -103,7 +99,10 @@ def test_read_file_access_control(tmp_path):\n             f\"data\"\n         )\n         result = interpreter.execute(code)\n-        assert (\"PermissionDenied\" in result or \"denied\" in result.lower() or \"no such file\" in result.lower()), \"Test file should not be accessible without enable_read_paths\"\n+        assert \"PermissionDenied\" in result or \"denied\" in result.lower() or \"no such file\" in result.lower(), (\n+            \"Test file should not be accessible without enable_read_paths\"\n+        )\n+\n \n def test_enable_write_flag(tmp_path):\n     testfile_path = tmp_path / \"test_temp_output.txt\"\n@@ -120,14 +119,12 @@ def test_enable_write_flag(tmp_path):\n             f\"result\"\n         )\n         result = interpreter.execute(code)\n-        assert (\"PermissionDenied\" in result or \"denied\" in result.lower() or \"no such file\" in result.lower()), \"Test file should not be writable without enable_write_paths\"\n+        assert \"PermissionDenied\" in result or \"denied\" in result.lower() or \"no such file\" in result.lower(), (\n+            \"Test file should not be writable without enable_write_paths\"\n+        )\n \n     with PythonInterpreter(enable_write_paths=[str(testfile_path)]) as interpreter:\n-        code = (\n-            f\"with open({virtual_path!r}, 'w') as f:\\n\"\n-            f\"    f.write('allowed')\\n\"\n-            f\"'ok'\"\n-        )\n+        code = f\"with open({virtual_path!r}, 'w') as f:\\n    f.write('allowed')\\n'ok'\"\n         result = interpreter.execute(code)\n         assert result == \"ok\", \"Test file should be writable with enable_write_paths\"\n     assert testfile_path.exists()\n@@ -137,35 +134,22 @@ def test_enable_write_flag(tmp_path):\n     with open(testfile_path, \"w\") as f:\n         f.write(\"original_content\")\n     with PythonInterpreter(enable_write_paths=[str(testfile_path)], sync_files=False) as interpreter:\n-        code = (\n-            f\"with open({virtual_path!r}, 'w') as f:\\n\"\n-            f\"    f.write('should_not_sync')\\n\"\n-            f\"'done_no_sync'\"\n-        )\n+        code = f\"with open({virtual_path!r}, 'w') as f:\\n    f.write('should_not_sync')\\n'done_no_sync'\"\n         result = interpreter.execute(code)\n         assert result == \"done_no_sync\"\n     with open(testfile_path) as f:\n         assert f.read() == \"original_content\", \"File should not be changed when sync_files is False\"\n \n \n-\n def test_enable_net_flag():\n     test_url = \"https://example.com\"\n \n     with PythonInterpreter(enable_network_access=None) as interpreter:\n-        code = (\n-            \"import js\\n\"\n-            f\"resp = await js.fetch({test_url!r})\\n\"\n-            \"resp.status\"\n-        )\n+        code = f\"import js\\nresp = await js.fetch({test_url!r})\\nresp.status\"\n         with pytest.raises(InterpreterError, match=\"PythonError\"):\n             interpreter.execute(code)\n \n     with PythonInterpreter(enable_network_access=[\"example.com\"]) as interpreter:\n-        code = (\n-            \"import js\\n\"\n-            f\"resp = await js.fetch({test_url!r})\\n\"\n-            \"resp.status\"\n-        )\n+        code = f\"import js\\nresp = await js.fetch({test_url!r})\\nresp.status\"\n         result = interpreter.execute(code)\n         assert int(result) == 200, \"Network access is permitted with enable_network_access\"\n"
    },
    {
        "id": 331,
        "sha_fail": "a7b902770d8b2769920794cf4e2016525e3ea1d9",
        "diff": "diff --git a/tests/dialects/test_dialect.py b/tests/dialects/test_dialect.py\nindex 892fcdc..93d3338 100644\n--- a/tests/dialects/test_dialect.py\n+++ b/tests/dialects/test_dialect.py\n@@ -22,7 +22,12 @@ class Validator(unittest.TestCase):\n         return parse_one(sql, read=self.dialect, **kwargs)\n \n     def validate_identity(\n-        self, sql, write_sql=None, pretty=False, check_command_warning=False, identify=False\n+        self,\n+        sql,\n+        write_sql=None,\n+        pretty=False,\n+        check_command_warning=False,\n+        identify=False,\n     ):\n         if check_command_warning:\n             with self.assertLogs(parser_logger) as cm:\n@@ -32,7 +37,8 @@ class Validator(unittest.TestCase):\n             expression = self.parse_one(sql)\n \n         self.assertEqual(\n-            write_sql or sql, expression.sql(dialect=self.dialect, pretty=pretty, identify=identify)\n+            write_sql or sql,\n+            expression.sql(dialect=self.dialect, pretty=pretty, identify=identify),\n         )\n         return expression\n \n@@ -67,7 +73,9 @@ class Validator(unittest.TestCase):\n             with self.subTest(f\"{sql} -> {write_dialect}\"):\n                 if write_sql is UnsupportedError:\n                     with self.assertRaises(UnsupportedError):\n-                        expression.sql(write_dialect, unsupported_level=ErrorLevel.RAISE)\n+                        expression.sql(\n+                            write_dialect, unsupported_level=ErrorLevel.RAISE\n+                        )\n                 else:\n                     self.assertEqual(\n                         expression.sql(\n@@ -113,7 +121,9 @@ class TestDialect(Validator):\n         lowercase_mysql = Dialect.get_or_raise(\"mysql,normalization_strategy=lowercase\")\n         self.assertEqual(lowercase_mysql.normalization_strategy, \"LOWERCASE\")\n \n-        lowercase_mysql = Dialect.get_or_raise(\"mysql, normalization_strategy = lowercase\")\n+        lowercase_mysql = Dialect.get_or_raise(\n+            \"mysql, normalization_strategy = lowercase\"\n+        )\n         self.assertEqual(lowercase_mysql.normalization_strategy.value, \"LOWERCASE\")\n \n         with self.assertRaises(AttributeError) as cm:\n@@ -124,7 +134,9 @@ class TestDialect(Validator):\n         with self.assertRaises(ValueError) as cm:\n             Dialect.get_or_raise(\"myqsl\")\n \n-        self.assertEqual(str(cm.exception), \"Unknown dialect 'myqsl'. Did you mean mysql?\")\n+        self.assertEqual(\n+            str(cm.exception), \"Unknown dialect 'myqsl'. Did you mean mysql?\"\n+        )\n \n         with self.assertRaises(ValueError) as cm:\n             Dialect.get_or_raise(\"asdfjasodiufjsd\")\n@@ -140,7 +152,9 @@ class TestDialect(Validator):\n         class MyDialect(Dialect):\n             SUPPORTED_SETTINGS = {\"s1\", \"s2\", \"s3\", \"s4\", \"s5\"}\n \n-        bool_settings = Dialect.get_or_raise(\"mydialect, s1=TruE, s2=1, s3=FaLse, s4=0, s5=nonbool\")\n+        bool_settings = Dialect.get_or_raise(\n+            \"mydialect, s1=TruE, s2=1, s3=FaLse, s4=0, s5=nonbool\"\n+        )\n         self.assertEqual(\n             bool_settings.settings,\n             {\"s1\": True, \"s2\": True, \"s3\": False, \"s4\": False, \"s5\": \"nonbool\"},\n@@ -450,7 +464,9 @@ class TestDialect(Validator):\n             },\n         )\n         self.validate_all(\"CAST(a AS TINYINT)\", write={\"oracle\": \"CAST(a AS SMALLINT)\"})\n-        self.validate_all(\"CAST(a AS SMALLINT)\", write={\"oracle\": \"CAST(a AS SMALLINT)\"})\n+        self.validate_all(\n+            \"CAST(a AS SMALLINT)\", write={\"oracle\": \"CAST(a AS SMALLINT)\"}\n+        )\n         self.validate_all(\"CAST(a AS BIGINT)\", write={\"oracle\": \"CAST(a AS INT)\"})\n         self.validate_all(\"CAST(a AS INT)\", write={\"oracle\": \"CAST(a AS INT)\"})\n         self.validate_all(\n@@ -1411,11 +1427,15 @@ class TestDialect(Validator):\n         )\n \n         order_by_all_sql = \"SELECT * FROM t ORDER BY ALL\"\n-        self.validate_identity(order_by_all_sql).find(exp.Ordered).this.assert_is(exp.Column)\n+        self.validate_identity(order_by_all_sql).find(exp.Ordered).this.assert_is(\n+            exp.Column\n+        )\n \n         for dialect in (\"duckdb\", \"spark\", \"databricks\"):\n             with self.subTest(f\"Testing ORDER BY ALL in {dialect}\"):\n-                parse_one(order_by_all_sql, read=dialect).find(exp.Ordered).this.assert_is(exp.Var)\n+                parse_one(order_by_all_sql, read=dialect).find(\n+                    exp.Ordered\n+                ).this.assert_is(exp.Var)\n \n     def test_json(self):\n         self.validate_all(\n@@ -1590,9 +1610,13 @@ class TestDialect(Validator):\n         )\n \n         for dialect in (\"duckdb\", \"starrocks\"):\n-            with self.subTest(f\"Generating json extraction with digit-prefixed key ({dialect})\"):\n+            with self.subTest(\n+                f\"Generating json extraction with digit-prefixed key ({dialect})\"\n+            ):\n                 self.assertEqual(\n-                    parse_one(\"\"\"select '{\"0\": \"v\"}' -> '0'\"\"\", read=dialect).sql(dialect=dialect),\n+                    parse_one(\"\"\"select '{\"0\": \"v\"}' -> '0'\"\"\", read=dialect).sql(\n+                        dialect=dialect\n+                    ),\n                     \"\"\"SELECT '{\"0\": \"v\"}' -> '0'\"\"\",\n                 )\n \n@@ -1809,7 +1833,9 @@ class TestDialect(Validator):\n         )\n \n     def test_operators(self):\n-        self.validate_identity(\"some.column LIKE 'foo' || another.column || 'bar' || LOWER(x)\")\n+        self.validate_identity(\n+            \"some.column LIKE 'foo' || another.column || 'bar' || LOWER(x)\"\n+        )\n         self.validate_identity(\"some.column LIKE 'foo' + another.column + 'bar'\")\n \n         self.validate_all(\"LIKE(x, 'z')\", write={\"\": \"'z' LIKE x\"})\n@@ -2299,7 +2325,9 @@ class TestDialect(Validator):\n         )\n \n     def test_typeddiv(self):\n-        typed_div = exp.Div(this=exp.column(\"a\"), expression=exp.column(\"b\"), typed=True)\n+        typed_div = exp.Div(\n+            this=exp.column(\"a\"), expression=exp.column(\"b\"), typed=True\n+        )\n         div = exp.Div(this=exp.column(\"a\"), expression=exp.column(\"b\"))\n         typed_div_dialect = \"presto\"\n         div_dialect = \"hive\"\n@@ -2324,7 +2352,9 @@ class TestDialect(Validator):\n             (div, (INT, FLOAT), typed_div_dialect, \"a / b\"),\n             (div, (INT, FLOAT), div_dialect, \"a / b\"),\n         ]:\n-            with self.subTest(f\"{expression.__class__.__name__} {types} {dialect} -> {expected}\"):\n+            with self.subTest(\n+                f\"{expression.__class__.__name__} {types} {dialect} -> {expected}\"\n+            ):\n                 expression = expression.copy()\n                 expression.left.type = types[0]\n                 expression.right.type = types[1]\n@@ -2342,7 +2372,9 @@ class TestDialect(Validator):\n             (div, safe_div_dialect, \"a / b\"),\n             (div, div_dialect, \"a / b\"),\n         ]:\n-            with self.subTest(f\"{expression.__class__.__name__} {dialect} -> {expected}\"):\n+            with self.subTest(\n+                f\"{expression.__class__.__name__} {dialect} -> {expected}\"\n+            ):\n                 self.assertEqual(expected, expression.sql(dialect=dialect))\n \n         self.assertEqual(\n@@ -2814,7 +2846,8 @@ SELECT\n         self.validate_identity(\"COUNT_IF(DISTINCT cond)\")\n \n         self.validate_all(\n-            \"SELECT COUNT_IF(cond) FILTER\", write={\"\": \"SELECT COUNT_IF(cond) AS FILTER\"}\n+            \"SELECT COUNT_IF(cond) FILTER\",\n+            write={\"\": \"SELECT COUNT_IF(cond) AS FILTER\"},\n         )\n         self.validate_all(\n             \"SELECT COUNT_IF(col % 2 = 0) FROM foo\",\n@@ -3038,8 +3071,12 @@ FROM subquery2\"\"\",\n         with_large_nulls = \"postgres\"\n \n         sql = \"SELECT * FROM t ORDER BY c\"\n-        sql_nulls_last = \"SELECT * FROM t ORDER BY CASE WHEN c IS NULL THEN 1 ELSE 0 END, c\"\n-        sql_nulls_first = \"SELECT * FROM t ORDER BY CASE WHEN c IS NULL THEN 1 ELSE 0 END DESC, c\"\n+        sql_nulls_last = (\n+            \"SELECT * FROM t ORDER BY CASE WHEN c IS NULL THEN 1 ELSE 0 END, c\"\n+        )\n+        sql_nulls_first = (\n+            \"SELECT * FROM t ORDER BY CASE WHEN c IS NULL THEN 1 ELSE 0 END DESC, c\"\n+        )\n \n         for read_dialect, desc, nulls_first, expected_sql in (\n             (with_last_nulls, False, None, sql_nulls_last),\n@@ -3072,7 +3109,9 @@ FROM subquery2\"\"\",\n                 )\n \n                 expected_sql = f\"{expected_sql}{sort_order}\"\n-                expression = parse_one(f\"{sql}{sort_order}{null_order}\", read=read_dialect)\n+                expression = parse_one(\n+                    f\"{sql}{sort_order}{null_order}\", read=read_dialect\n+                )\n \n                 self.assertEqual(expression.sql(dialect=\"mysql\"), expected_sql)\n                 self.assertEqual(expression.sql(dialect=\"tsql\"), expected_sql)\n@@ -3157,7 +3196,9 @@ FROM subquery2\"\"\",\n         self.validate_identity(\n             \"CREATE SEQUENCE seq START WITH 1 NO MINVALUE NO MAXVALUE CYCLE NO CACHE\"\n         )\n-        self.validate_identity(\"CREATE OR REPLACE TEMPORARY SEQUENCE seq INCREMENT BY 1 NO CYCLE\")\n+        self.validate_identity(\n+            \"CREATE OR REPLACE TEMPORARY SEQUENCE seq INCREMENT BY 1 NO CYCLE\"\n+        )\n         self.validate_identity(\n             \"CREATE OR REPLACE SEQUENCE IF NOT EXISTS seq COMMENT='test comment' ORDER\"\n         )\n@@ -3318,7 +3359,9 @@ FROM subquery2\"\"\",\n                     },\n                 )\n \n-        self.assertIsInstance(parse_one(\"NORMALIZE('str', NFD)\").args.get(\"form\"), exp.Var)\n+        self.assertIsInstance(\n+            parse_one(\"NORMALIZE('str', NFD)\").args.get(\"form\"), exp.Var\n+        )\n \n     def test_coalesce(self):\n         \"\"\"\n@@ -3425,7 +3468,9 @@ FROM subquery2\"\"\",\n \n     def test_escaped_identifier_delimiter(self):\n         for dialect in (\"databricks\", \"hive\", \"mysql\", \"spark2\", \"spark\"):\n-            with self.subTest(f\"Testing escaped backtick in identifier name for {dialect}\"):\n+            with self.subTest(\n+                f\"Testing escaped backtick in identifier name for {dialect}\"\n+            ):\n                 self.validate_all(\n                     'SELECT 1 AS \"x`\"',\n                     read={\n@@ -3447,7 +3492,9 @@ FROM subquery2\"\"\",\n             \"snowflake\",\n             \"sqlite\",\n         ):\n-            with self.subTest(f\"Testing escaped double-quote in identifier name for {dialect}\"):\n+            with self.subTest(\n+                f\"Testing escaped double-quote in identifier name for {dialect}\"\n+            ):\n                 self.validate_all(\n                     'SELECT 1 AS \"x\"\"\"',\n                     read={\n@@ -3459,7 +3506,9 @@ FROM subquery2\"\"\",\n                 )\n \n         for dialect in (\"clickhouse\", \"sqlite\"):\n-            with self.subTest(f\"Testing escaped backtick in identifier name for {dialect}\"):\n+            with self.subTest(\n+                f\"Testing escaped backtick in identifier name for {dialect}\"\n+            ):\n                 self.validate_all(\n                     'SELECT 1 AS \"x`\"',\n                     read={\n@@ -3569,14 +3618,19 @@ FROM subquery2\"\"\",\n                 \"spark\",\n                 \"redshift\",\n             ):\n-                with self.subTest(f\"Testing hex string -> INTEGER evaluation for {read_dialect}\"):\n+                with self.subTest(\n+                    f\"Testing hex string -> INTEGER evaluation for {read_dialect}\"\n+                ):\n                     self.assertEqual(\n-                        parse_one(\"SELECT 0xCC\", read=read_dialect).sql(write_dialect), \"SELECT 204\"\n+                        parse_one(\"SELECT 0xCC\", read=read_dialect).sql(write_dialect),\n+                        \"SELECT 204\",\n                     )\n \n             for other_integer_dialects in integer_dialects:\n                 self.assertEqual(\n-                    parse_one(\"SELECT 0xCC\", read=read_dialect).sql(other_integer_dialects),\n+                    parse_one(\"SELECT 0xCC\", read=read_dialect).sql(\n+                        other_integer_dialects\n+                    ),\n                     \"SELECT 0xCC\",\n                 )\n \n"
    },
    {
        "id": 332,
        "sha_fail": "5df3ea92f59125955124ea1883b777b489db3042",
        "diff": "diff --git a/tests/test_optimizer.py b/tests/test_optimizer.py\nindex ef754db..f434cc1 100644\n--- a/tests/test_optimizer.py\n+++ b/tests/test_optimizer.py\n@@ -40,8 +40,12 @@ def qualify_columns(expression, validate_qualify_columns=True, **kwargs):\n \n def pushdown_projections(expression, **kwargs):\n     expression = optimizer.qualify_tables.qualify_tables(expression)\n-    expression = optimizer.qualify_columns.qualify_columns(expression, infer_schema=True, **kwargs)\n-    expression = optimizer.pushdown_projections.pushdown_projections(expression, **kwargs)\n+    expression = optimizer.qualify_columns.qualify_columns(\n+        expression, infer_schema=True, **kwargs\n+    )\n+    expression = optimizer.pushdown_projections.pushdown_projections(\n+        expression, **kwargs\n+    )\n     return expression\n \n \n@@ -154,7 +158,9 @@ class TestOptimizer(unittest.TestCase):\n \n                 func_kwargs = {**kwargs}\n                 if leave_tables_isolated is not None:\n-                    func_kwargs[\"leave_tables_isolated\"] = string_to_bool(leave_tables_isolated)\n+                    func_kwargs[\"leave_tables_isolated\"] = string_to_bool(\n+                        leave_tables_isolated\n+                    )\n \n                 if validate_qualify_columns is not None:\n                     func_kwargs[\"validate_qualify_columns\"] = string_to_bool(\n@@ -164,7 +170,9 @@ class TestOptimizer(unittest.TestCase):\n                 if dialect:\n                     func_kwargs[\"dialect\"] = dialect\n \n-                future = pool.submit(parse_and_optimize, func, sql, dialect, **func_kwargs)\n+                future = pool.submit(\n+                    parse_and_optimize, func, sql, dialect, **func_kwargs\n+                )\n                 results[future] = (\n                     sql,\n                     title,\n@@ -255,7 +263,9 @@ class TestOptimizer(unittest.TestCase):\n         )\n \n         self.assertEqual(\n-            optimizer.qualify_tables.qualify_tables(parse_one(\"select a from b\"), db='\"DB\"').sql(),\n+            optimizer.qualify_tables.qualify_tables(\n+                parse_one(\"select a from b\"), db='\"DB\"'\n+            ).sql(),\n             'SELECT a FROM \"DB\".b AS b',\n         )\n \n@@ -415,7 +425,12 @@ class TestOptimizer(unittest.TestCase):\n                     schema={\n                         \"t1\": {\"id\": \"int64\", \"dt\": \"date\", \"common\": \"int64\"},\n                         \"lkp\": {\"id\": \"int64\", \"other_id\": \"int64\", \"common\": \"int64\"},\n-                        \"t2\": {\"other_id\": \"int64\", \"dt\": \"date\", \"v\": \"int64\", \"common\": \"int64\"},\n+                        \"t2\": {\n+                            \"other_id\": \"int64\",\n+                            \"dt\": \"date\",\n+                            \"v\": \"int64\",\n+                            \"common\": \"int64\",\n+                        },\n                     },\n                     dialect=\"bigquery\",\n                 ),\n@@ -496,7 +511,9 @@ class TestOptimizer(unittest.TestCase):\n \n     def test_qualify_columns__with_invisible(self):\n         schema = MappingSchema(self.schema, {\"x\": {\"a\"}, \"y\": {\"b\"}, \"z\": {\"b\"}})\n-        self.check_file(\"qualify_columns__with_invisible\", qualify_columns, schema=schema)\n+        self.check_file(\n+            \"qualify_columns__with_invisible\", qualify_columns, schema=schema\n+        )\n \n     def test_pushdown_cte_alias_columns(self):\n         self.check_file(\n@@ -519,7 +536,9 @@ class TestOptimizer(unittest.TestCase):\n             optimizer.normalize_identifiers.normalize_identifiers,\n         )\n \n-        self.assertEqual(optimizer.normalize_identifiers.normalize_identifiers(\"a%\").sql(), '\"a%\"')\n+        self.assertEqual(\n+            optimizer.normalize_identifiers.normalize_identifiers(\"a%\").sql(), '\"a%\"'\n+        )\n \n     def test_quote_identifiers(self):\n         self.check_file(\n@@ -528,7 +547,9 @@ class TestOptimizer(unittest.TestCase):\n         )\n \n     def test_pushdown_projection(self):\n-        self.check_file(\"pushdown_projections\", pushdown_projections, schema=self.schema)\n+        self.check_file(\n+            \"pushdown_projections\", pushdown_projections, schema=self.schema\n+        )\n \n     def test_simplify(self):\n         self.check_file(\"simplify\", simplify)\n@@ -544,7 +565,9 @@ class TestOptimizer(unittest.TestCase):\n         self.assertEqual(expression.sql(), \"SELECT 3\")\n \n         expression = parse_one(\"SELECT a, c, b FROM table1 WHERE 1 = 1\")\n-        self.assertEqual(simplify(simplify(expression.find(exp.Where))).sql(), \"WHERE TRUE\")\n+        self.assertEqual(\n+            simplify(simplify(expression.find(exp.Where))).sql(), \"WHERE TRUE\"\n+        )\n \n         expression = parse_one(\"TRUE AND TRUE AND TRUE\")\n         self.assertEqual(exp.true(), optimizer.simplify.simplify(expression))\n@@ -561,20 +584,26 @@ class TestOptimizer(unittest.TestCase):\n         self.assertEqual(simplified_concat.args[\"safe\"], False)\n         self.assertEqual(simplified_safe_concat.args[\"safe\"], True)\n \n-        self.assertEqual(\"CONCAT('a', x, 'bc')\", simplified_concat.sql(dialect=\"presto\"))\n+        self.assertEqual(\n+            \"CONCAT('a', x, 'bc')\", simplified_concat.sql(dialect=\"presto\")\n+        )\n         self.assertEqual(\"CONCAT('a', x, 'bc')\", simplified_safe_concat.sql())\n \n         anon_unquoted_str = parse_one(\"anonymous(x, y)\")\n         self.assertEqual(optimizer.simplify.gen(anon_unquoted_str), \"ANONYMOUS(x,y)\")\n \n         query = parse_one(\"SELECT x FROM t\")\n-        self.assertEqual(optimizer.simplify.gen(query), optimizer.simplify.gen(query.copy()))\n+        self.assertEqual(\n+            optimizer.simplify.gen(query), optimizer.simplify.gen(query.copy())\n+        )\n \n         anon_unquoted_identifier = exp.Anonymous(\n             this=exp.to_identifier(\"anonymous\"),\n             expressions=[exp.column(\"x\"), exp.column(\"y\")],\n         )\n-        self.assertEqual(optimizer.simplify.gen(anon_unquoted_identifier), \"ANONYMOUS(x,y)\")\n+        self.assertEqual(\n+            optimizer.simplify.gen(anon_unquoted_identifier), \"ANONYMOUS(x,y)\"\n+        )\n \n         anon_quoted = parse_one('\"anonymous\"(x, y)')\n         self.assertEqual(optimizer.simplify.gen(anon_quoted), '\"anonymous\"(x,y)')\n@@ -610,20 +639,28 @@ SELECT :with,WITH :expressions,CTE :this,UNION :this,SELECT :expressions,1,:expr\n \"\"\".strip(),\n         )\n         self.assertEqual(\n-            optimizer.simplify.gen(parse_one(\"select item_id /* description */\"), comments=True),\n+            optimizer.simplify.gen(\n+                parse_one(\"select item_id /* description */\"), comments=True\n+            ),\n             \"SELECT :expressions,item_id /* description */\",\n         )\n \n     def test_unnest_subqueries(self):\n-        self.check_file(\"unnest_subqueries\", optimizer.unnest_subqueries.unnest_subqueries)\n+        self.check_file(\n+            \"unnest_subqueries\", optimizer.unnest_subqueries.unnest_subqueries\n+        )\n \n     def test_pushdown_predicates(self):\n-        self.check_file(\"pushdown_predicates\", optimizer.pushdown_predicates.pushdown_predicates)\n+        self.check_file(\n+            \"pushdown_predicates\", optimizer.pushdown_predicates.pushdown_predicates\n+        )\n \n     def test_expand_alias_refs(self):\n         # check order of lateral expansion with no schema\n         self.assertEqual(\n-            optimizer.optimize(\"SELECT a + 1 AS d, d + 1 AS e FROM x WHERE e > 1 GROUP BY e\").sql(),\n+            optimizer.optimize(\n+                \"SELECT a + 1 AS d, d + 1 AS e FROM x WHERE e > 1 GROUP BY e\"\n+            ).sql(),\n             'SELECT \"x\".\"a\" + 1 AS \"d\", \"x\".\"a\" + 1 + 1 AS \"e\" FROM \"x\" AS \"x\" WHERE (\"x\".\"a\" + 2) > 1 GROUP BY \"x\".\"a\" + 1 + 1',\n         )\n \n@@ -709,7 +746,9 @@ SELECT :with,WITH :expressions,CTE :this,UNION :this,SELECT :expressions,1,:expr\n         self.check_file(\"merge_subqueries\", optimize, execute=True, schema=self.schema)\n \n     def test_eliminate_subqueries(self):\n-        self.check_file(\"eliminate_subqueries\", optimizer.eliminate_subqueries.eliminate_subqueries)\n+        self.check_file(\n+            \"eliminate_subqueries\", optimizer.eliminate_subqueries.eliminate_subqueries\n+        )\n \n     def test_canonicalize(self):\n         optimize = partial(\n@@ -724,10 +763,14 @@ SELECT :with,WITH :expressions,CTE :this,UNION :this,SELECT :expressions,1,:expr\n         self.check_file(\"canonicalize\", optimize, schema=self.schema)\n \n     def test_tpch(self):\n-        self.check_file(\"tpc-h/tpc-h\", optimizer.optimize, schema=TPCH_SCHEMA, pretty=True)\n+        self.check_file(\n+            \"tpc-h/tpc-h\", optimizer.optimize, schema=TPCH_SCHEMA, pretty=True\n+        )\n \n     def test_tpcds(self):\n-        self.check_file(\"tpc-ds/tpc-ds\", optimizer.optimize, schema=TPCDS_SCHEMA, pretty=True)\n+        self.check_file(\n+            \"tpc-ds/tpc-ds\", optimizer.optimize, schema=TPCDS_SCHEMA, pretty=True\n+        )\n \n     def test_file_schema(self):\n         expression = parse_one(\n@@ -749,7 +792,9 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n         )\n \n     def test_scope(self):\n-        ast = parse_one(\"SELECT IF(a IN UNNEST(b), 1, 0) AS c FROM t\", dialect=\"bigquery\")\n+        ast = parse_one(\n+            \"SELECT IF(a IN UNNEST(b), 1, 0) AS c FROM t\", dialect=\"bigquery\"\n+        )\n         self.assertEqual(build_scope(ast).columns, [exp.column(\"a\"), exp.column(\"b\")])\n \n         many_unions = parse_one(\" UNION ALL \".join([\"SELECT x FROM t\"] * 10000))\n@@ -780,17 +825,24 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n         WHERE s.b > (SELECT MAX(x.a) FROM x WHERE x.b = s.b)\n         \"\"\"\n         expression = parse_one(sql)\n-        for scopes in traverse_scope(expression), list(build_scope(expression).traverse()):\n+        for scopes in (\n+            traverse_scope(expression),\n+            list(build_scope(expression).traverse()),\n+        ):\n             self.assertEqual(len(scopes), 7)\n             self.assertEqual(scopes[0].expression.sql(), \"SELECT x.b FROM x\")\n             self.assertEqual(scopes[1].expression.sql(), \"SELECT y.b FROM y\")\n-            self.assertEqual(scopes[2].expression.sql(), \"(VALUES (1, 'test')) AS tab(cola, colb)\")\n+            self.assertEqual(\n+                scopes[2].expression.sql(), \"(VALUES (1, 'test')) AS tab(cola, colb)\"\n+            )\n             self.assertEqual(\n                 scopes[3].expression.sql(),\n                 \"SELECT cola, colb FROM (VALUES (1, 'test')) AS tab(cola, colb)\",\n             )\n             self.assertEqual(scopes[4].expression.sql(), \"SELECT y.c AS b FROM y\")\n-            self.assertEqual(scopes[5].expression.sql(), \"SELECT MAX(x.a) FROM x WHERE x.b = s.b\")\n+            self.assertEqual(\n+                scopes[5].expression.sql(), \"SELECT MAX(x.a) FROM x WHERE x.b = s.b\"\n+            )\n             self.assertEqual(scopes[6].expression.sql(), parse_one(sql).sql())\n \n             self.assertEqual(set(scopes[6].sources), {\"q\", \"z\", \"r\", \"s\"})\n@@ -800,7 +852,9 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n             self.assertEqual(len(scopes[6].source_columns(\"r\")), 2)\n             self.assertEqual({c.table for c in scopes[6].source_columns(\"r\")}, {\"r\"})\n \n-            self.assertEqual({c.sql() for c in scopes[-1].find_all(exp.Column)}, {\"r.b\", \"s.b\"})\n+            self.assertEqual(\n+                {c.sql() for c in scopes[-1].find_all(exp.Column)}, {\"r.b\", \"s.b\"}\n+            )\n             self.assertEqual(scopes[-1].find(exp.Column).sql(), \"r.b\")\n             self.assertEqual({c.sql() for c in scopes[0].find_all(exp.Column)}, {\"x.b\"})\n \n@@ -817,7 +871,10 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n         # Check that parentheses don't introduce a new scope unless an alias is attached\n         sql = \"SELECT * FROM (((SELECT * FROM (t1 JOIN t2) AS t3) JOIN (SELECT * FROM t4)))\"\n         expression = parse_one(sql)\n-        for scopes in traverse_scope(expression), list(build_scope(expression).traverse()):\n+        for scopes in (\n+            traverse_scope(expression),\n+            list(build_scope(expression).traverse()),\n+        ):\n             self.assertEqual(len(scopes), 4)\n \n             self.assertEqual(scopes[0].expression.sql(), \"t1, t2\")\n@@ -840,22 +897,27 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n             sql = f\"SELECT a FROM foo CROSS JOIN {udtf}\"\n             expression = parse_one(sql)\n \n-            for scopes in traverse_scope(expression), list(build_scope(expression).traverse()):\n+            for scopes in (\n+                traverse_scope(expression),\n+                list(build_scope(expression).traverse()),\n+            ):\n                 self.assertEqual(len(scopes), 3)\n \n                 self.assertEqual(scopes[0].expression.sql(), inner_query)\n                 self.assertEqual(set(scopes[0].sources), {\"baz\"})\n \n                 self.assertEqual(scopes[1].expression.sql(), udtf)\n-                self.assertEqual(set(scopes[1].sources), {\"\", \"foo\"})  # foo is a lateral source\n+                self.assertEqual(\n+                    set(scopes[1].sources), {\"\", \"foo\"}\n+                )  # foo is a lateral source\n \n-                self.assertEqual(scopes[2].expression.sql(), f\"SELECT a FROM foo CROSS JOIN {udtf}\")\n+                self.assertEqual(\n+                    scopes[2].expression.sql(), f\"SELECT a FROM foo CROSS JOIN {udtf}\"\n+                )\n                 self.assertEqual(set(scopes[2].sources), {\"\", \"foo\"})\n \n         # Check DML statement scopes\n-        sql = (\n-            \"UPDATE customers SET total_spent = (SELECT 1 FROM t1) WHERE EXISTS (SELECT 1 FROM t2)\"\n-        )\n+        sql = \"UPDATE customers SET total_spent = (SELECT 1 FROM t1) WHERE EXISTS (SELECT 1 FROM t2)\"\n         self.assertEqual(len(traverse_scope(parse_one(sql))), 3)\n \n         sql = \"UPDATE tbl1 SET col = 1 WHERE EXISTS (SELECT 1 FROM tbl2 WHERE tbl1.id = tbl2.id)\"\n@@ -870,7 +932,9 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n \n     @patch(\"sqlglot.optimizer.scope.logger\")\n     def test_scope_warning(self, logger):\n-        self.assertEqual(len(traverse_scope(parse_one(\"WITH q AS (@y) SELECT * FROM q\"))), 1)\n+        self.assertEqual(\n+            len(traverse_scope(parse_one(\"WITH q AS (@y) SELECT * FROM q\"))), 1\n+        )\n         assert_logger_contains(\n             \"Cannot traverse scope %s with type '%s'\",\n             logger,\n@@ -914,7 +978,11 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n \n             for dialect in dialect.split(\", \"):\n                 result = parse_and_optimize(\n-                    annotate_functions, sql, dialect, schema=test_schema, dialect=dialect\n+                    annotate_functions,\n+                    sql,\n+                    dialect,\n+                    schema=test_schema,\n+                    dialect=dialect,\n                 )\n \n                 with self.subTest(title):\n@@ -928,7 +996,9 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n         self.assertEqual(expression.type.this, exp.DataType.Type.TIMESTAMPTZ)\n         self.assertEqual(expression.this.type.this, exp.DataType.Type.VARCHAR)\n         self.assertEqual(expression.args[\"to\"].type.this, exp.DataType.Type.TIMESTAMPTZ)\n-        self.assertEqual(expression.args[\"to\"].expressions[0].this.type.this, exp.DataType.Type.INT)\n+        self.assertEqual(\n+            expression.args[\"to\"].expressions[0].this.type.this, exp.DataType.Type.INT\n+        )\n \n         expression = annotate_types(parse_one(\"ARRAY(1)::ARRAY<INT>\"))\n         self.assertEqual(expression.type, parse_one(\"ARRAY<INT>\", into=exp.DataType))\n@@ -940,9 +1010,13 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n \n     def test_cache_annotation(self):\n         expression = annotate_types(\n-            parse_one(\"CACHE LAZY TABLE x OPTIONS('storageLevel' = 'value') AS SELECT 1\")\n+            parse_one(\n+                \"CACHE LAZY TABLE x OPTIONS('storageLevel' = 'value') AS SELECT 1\"\n+            )\n+        )\n+        self.assertEqual(\n+            expression.expression.expressions[0].type.this, exp.DataType.Type.INT\n         )\n-        self.assertEqual(expression.expression.expressions[0].type.this, exp.DataType.Type.INT)\n \n     def test_binary_annotation(self):\n         expression = annotate_types(parse_one(\"SELECT 0.0 + (2 + 3)\")).expressions[0]\n@@ -981,11 +1055,15 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n         self.assertEqual(expression.type.this, exp.DataType.Type.UNKNOWN)\n         self.assertEqual(expression.expressions[0].type.this, exp.DataType.Type.UNKNOWN)\n \n-        expression = annotate_types(parse_one(\"SELECT ARRAY[1, 2, 3][1]\")).expressions[0]\n+        expression = annotate_types(parse_one(\"SELECT ARRAY[1, 2, 3][1]\")).expressions[\n+            0\n+        ]\n         self.assertEqual(expression.this.type.sql(), \"ARRAY<INT>\")\n         self.assertEqual(expression.type.this, exp.DataType.Type.INT)\n \n-        expression = annotate_types(parse_one(\"SELECT ARRAY[1, 2, 3][1 : 2]\")).expressions[0]\n+        expression = annotate_types(\n+            parse_one(\"SELECT ARRAY[1, 2, 3][1 : 2]\")\n+        ).expressions[0]\n         self.assertEqual(expression.this.type.sql(), \"ARRAY<INT>\")\n         self.assertEqual(expression.type.sql(), \"ARRAY<INT>\")\n \n@@ -1001,7 +1079,9 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n         ).expressions[0]\n         self.assertEqual(expression.type.sql(), \"ARRAY<ARRAY<INT>>\")\n \n-        expression = annotate_types(parse_one(\"MAP(1.0, 2, '2', 3.0)['2']\", read=\"spark\"))\n+        expression = annotate_types(\n+            parse_one(\"MAP(1.0, 2, '2', 3.0)['2']\", read=\"spark\")\n+        )\n         self.assertEqual(expression.type.this, exp.DataType.Type.DOUBLE)\n \n         expression = annotate_types(parse_one(\"MAP(1.0, 2, x, 3.0)[2]\", read=\"spark\"))\n@@ -1150,7 +1230,9 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n         self.assertEqual(inner_addition.right.type.this, exp.DataType.Type.TEXT)\n \n         # WHERE tbl.colc = True\n-        self.assertEqual(expression.args[\"where\"].this.type.this, exp.DataType.Type.BOOLEAN)\n+        self.assertEqual(\n+            expression.args[\"where\"].this.type.this, exp.DataType.Type.BOOLEAN\n+        )\n \n         cte_select = expression.args[\"with\"].expressions[0].this\n         self.assertEqual(\n@@ -1177,9 +1259,7 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n \n     def test_function_annotation(self):\n         schema = {\"x\": {\"cola\": \"VARCHAR\", \"colb\": \"CHAR\"}}\n-        sql = (\n-            \"SELECT x.cola || TRIM(x.colb) AS col, DATE(x.colb), DATEFROMPARTS(y, m, d) FROM x AS x\"\n-        )\n+        sql = \"SELECT x.cola || TRIM(x.colb) AS col, DATE(x.colb), DATEFROMPARTS(y, m, d) FROM x AS x\"\n \n         expression = annotate_types(parse_one(sql), schema=schema)\n         concat_expr_alias = expression.expressions[0]\n@@ -1187,9 +1267,15 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n \n         concat_expr = concat_expr_alias.this\n         self.assertEqual(concat_expr.type.this, exp.DataType.Type.VARCHAR)\n-        self.assertEqual(concat_expr.left.type.this, exp.DataType.Type.VARCHAR)  # x.cola\n-        self.assertEqual(concat_expr.right.type.this, exp.DataType.Type.VARCHAR)  # TRIM(x.colb)\n-        self.assertEqual(concat_expr.right.this.type.this, exp.DataType.Type.CHAR)  # x.colb\n+        self.assertEqual(\n+            concat_expr.left.type.this, exp.DataType.Type.VARCHAR\n+        )  # x.cola\n+        self.assertEqual(\n+            concat_expr.right.type.this, exp.DataType.Type.VARCHAR\n+        )  # TRIM(x.colb)\n+        self.assertEqual(\n+            concat_expr.right.this.type.this, exp.DataType.Type.CHAR\n+        )  # x.colb\n \n         date_expr = expression.expressions[1]\n         self.assertEqual(date_expr.type.this, exp.DataType.Type.DATE)\n@@ -1208,7 +1294,9 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n \n         case_ifs_expr = case_expr.args[\"ifs\"][0]\n         self.assertEqual(case_ifs_expr.type.this, exp.DataType.Type.VARCHAR)\n-        self.assertEqual(case_ifs_expr.args[\"true\"].type.this, exp.DataType.Type.VARCHAR)\n+        self.assertEqual(\n+            case_ifs_expr.args[\"true\"].type.this, exp.DataType.Type.VARCHAR\n+        )\n \n         timestamp = annotate_types(parse_one(\"TIMESTAMP(x)\"))\n         self.assertEqual(timestamp.type.this, exp.DataType.Type.TIMESTAMP)\n@@ -1225,7 +1313,9 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n \n         concat_expr = concat_expr_alias.this\n         self.assertEqual(concat_expr.type.this, exp.DataType.Type.UNKNOWN)\n-        self.assertEqual(concat_expr.left.type.this, exp.DataType.Type.VARCHAR)  # x.cola\n+        self.assertEqual(\n+            concat_expr.left.type.this, exp.DataType.Type.VARCHAR\n+        )  # x.cola\n         self.assertEqual(\n             concat_expr.right.type.this, exp.DataType.Type.UNKNOWN\n         )  # SOME_ANONYMOUS_FUNC(x.cola)\n@@ -1234,11 +1324,15 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n         )  # x.cola (arg)\n \n         # Ensures we don't raise if there are unqualified columns\n-        annotate_types(parse_one(\"select x from y lateral view explode(y) as x\")).expressions[0]\n+        annotate_types(\n+            parse_one(\"select x from y lateral view explode(y) as x\")\n+        ).expressions[0]\n \n         # NULL <op> UNKNOWN should yield UNKNOWN\n         self.assertEqual(\n-            annotate_types(parse_one(\"SELECT NULL + ANONYMOUS_FUNC()\")).expressions[0].type.this,\n+            annotate_types(parse_one(\"SELECT NULL + ANONYMOUS_FUNC()\"))\n+            .expressions[0]\n+            .type.this,\n             exp.DataType.Type.UNKNOWN,\n         )\n \n@@ -1250,7 +1344,9 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n         self.assertEqual(expression.type.this, exp.DataType.Type.BOOLEAN)\n \n     def test_aggfunc_annotation(self):\n-        schema = {\"x\": {\"cola\": \"SMALLINT\", \"colb\": \"FLOAT\", \"colc\": \"TEXT\", \"cold\": \"DATE\"}}\n+        schema = {\n+            \"x\": {\"cola\": \"SMALLINT\", \"colb\": \"FLOAT\", \"colc\": \"TEXT\", \"cold\": \"DATE\"}\n+        }\n \n         tests = {\n             (\"AVG\", \"cola\"): exp.DataType.Type.DOUBLE,\n@@ -1308,9 +1404,13 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n         self.assertEqual(expression.selects[0].type.sql(), \"ARRAY<INT>\")\n \n         schema = MappingSchema({\"t\": {\"c\": \"STRUCT<`f` STRING>\"}}, dialect=\"bigquery\")\n-        expression = annotate_types(parse_one(\"SELECT t.c, [t.c] FROM t\"), schema=schema)\n+        expression = annotate_types(\n+            parse_one(\"SELECT t.c, [t.c] FROM t\"), schema=schema\n+        )\n \n-        self.assertEqual(expression.selects[0].type.sql(dialect=\"bigquery\"), \"STRUCT<`f` STRING>\")\n+        self.assertEqual(\n+            expression.selects[0].type.sql(dialect=\"bigquery\"), \"STRUCT<`f` STRING>\"\n+        )\n         self.assertEqual(\n             expression.selects[1].type.sql(dialect=\"bigquery\"),\n             \"ARRAY<STRUCT<`f` STRING>>\",\n@@ -1335,10 +1435,14 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n \n     def test_user_defined_type_annotation(self):\n         schema = MappingSchema({\"t\": {\"x\": \"int\"}}, dialect=\"postgres\")\n-        expression = annotate_types(parse_one(\"SELECT CAST(x AS IPADDRESS) FROM t\"), schema=schema)\n+        expression = annotate_types(\n+            parse_one(\"SELECT CAST(x AS IPADDRESS) FROM t\"), schema=schema\n+        )\n \n         self.assertEqual(exp.DataType.Type.USERDEFINED, expression.selects[0].type.this)\n-        self.assertEqual(expression.selects[0].type.sql(dialect=\"postgres\"), \"IPADDRESS\")\n+        self.assertEqual(\n+            expression.selects[0].type.sql(dialect=\"postgres\"), \"IPADDRESS\"\n+        )\n \n     def test_unnest_annotation(self):\n         expression = annotate_types(\n@@ -1352,8 +1456,12 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n             ),\n             schema={\"x\": {\"a\": \"ARRAY<STRUCT<b STRUCT<c int>>>\"}},\n         )\n-        self.assertEqual(expression.selects[0].type, exp.DataType.build(\"STRUCT<b STRUCT<c int>>\"))\n-        self.assertEqual(expression.selects[1].type, exp.DataType.build(\"STRUCT<c int>\"))\n+        self.assertEqual(\n+            expression.selects[0].type, exp.DataType.build(\"STRUCT<b STRUCT<c int>>\")\n+        )\n+        self.assertEqual(\n+            expression.selects[1].type, exp.DataType.build(\"STRUCT<c int>\")\n+        )\n         self.assertEqual(expression.selects[2].type, exp.DataType.build(\"int\"))\n \n         self.assertEqual(\n@@ -1385,17 +1493,25 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n     def test_map_annotation(self):\n         # ToMap annotation\n         expression = annotate_types(parse_one(\"SELECT MAP {'x': 1}\", read=\"duckdb\"))\n-        self.assertEqual(expression.selects[0].type, exp.DataType.build(\"MAP(VARCHAR, INT)\"))\n+        self.assertEqual(\n+            expression.selects[0].type, exp.DataType.build(\"MAP(VARCHAR, INT)\")\n+        )\n \n         # Map annotation\n         expression = annotate_types(\n-            parse_one(\"SELECT MAP(['key1', 'key2', 'key3'], [10, 20, 30])\", read=\"duckdb\")\n+            parse_one(\n+                \"SELECT MAP(['key1', 'key2', 'key3'], [10, 20, 30])\", read=\"duckdb\"\n+            )\n+        )\n+        self.assertEqual(\n+            expression.selects[0].type, exp.DataType.build(\"MAP(VARCHAR, INT)\")\n         )\n-        self.assertEqual(expression.selects[0].type, exp.DataType.build(\"MAP(VARCHAR, INT)\"))\n \n         # VarMap annotation\n         expression = annotate_types(parse_one(\"SELECT MAP('a', 'b')\", read=\"spark\"))\n-        self.assertEqual(expression.selects[0].type, exp.DataType.build(\"MAP(VARCHAR, VARCHAR)\"))\n+        self.assertEqual(\n+            expression.selects[0].type, exp.DataType.build(\"MAP(VARCHAR, VARCHAR)\")\n+        )\n \n     def test_union_annotation(self):\n         for left, right, expected_type in (\n@@ -1404,10 +1520,20 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n             (\"SELECT FOO() AS c\", \"SELECT 1 AS c\", \"UNKNOWN\"),\n             (\"SELECT FOO() AS c\", \"SELECT BAR() AS c\", \"UNKNOWN\"),\n         ):\n-            with self.subTest(f\"left: {left}, right: {right}, expected: {expected_type}\"):\n-                lr = annotate_types(parse_one(f\"SELECT t.c FROM ({left} UNION ALL {right}) t(c)\"))\n-                rl = annotate_types(parse_one(f\"SELECT t.c FROM ({right} UNION ALL {left}) t(c)\"))\n-                assert lr.selects[0].type == rl.selects[0].type == exp.DataType.build(expected_type)\n+            with self.subTest(\n+                f\"left: {left}, right: {right}, expected: {expected_type}\"\n+            ):\n+                lr = annotate_types(\n+                    parse_one(f\"SELECT t.c FROM ({left} UNION ALL {right}) t(c)\")\n+                )\n+                rl = annotate_types(\n+                    parse_one(f\"SELECT t.c FROM ({right} UNION ALL {left}) t(c)\")\n+                )\n+                assert (\n+                    lr.selects[0].type\n+                    == rl.selects[0].type\n+                    == exp.DataType.build(expected_type)\n+                )\n \n         union_by_name = annotate_types(\n             parse_one(\n@@ -1433,7 +1559,9 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n             )\n             SELECT col FROM t;\n         \"\"\"\n-        self.assertEqual(optimizer.optimize(sql).selects[0].type.this, exp.DataType.Type.VARCHAR)\n+        self.assertEqual(\n+            optimizer.optimize(sql).selects[0].type.this, exp.DataType.Type.VARCHAR\n+        )\n \n         # Test UNIONs with nested subqueries\n         sql = \"\"\"\n@@ -1445,7 +1573,9 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n             )\n             SELECT col FROM t;\n         \"\"\"\n-        self.assertEqual(optimizer.optimize(sql).selects[0].type.this, exp.DataType.Type.VARCHAR)\n+        self.assertEqual(\n+            optimizer.optimize(sql).selects[0].type.this, exp.DataType.Type.VARCHAR\n+        )\n \n         sql = \"\"\"\n             WITH t AS\n@@ -1456,7 +1586,9 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n             )\n             SELECT col FROM t;\n         \"\"\"\n-        self.assertEqual(optimizer.optimize(sql).selects[0].type.this, exp.DataType.Type.VARCHAR)\n+        self.assertEqual(\n+            optimizer.optimize(sql).selects[0].type.this, exp.DataType.Type.VARCHAR\n+        )\n \n     def test_udtf_annotation(self):\n         table_udtf = parse_one(\n@@ -1530,9 +1662,13 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n         ).sql(pretty=True, dialect=\"snowflake\")\n \n         for func in (optimizer.qualify.qualify, optimizer.optimize):\n-            source_query = parse_one('SELECT * FROM example.\"source\" AS \"source\"', read=\"snowflake\")\n+            source_query = parse_one(\n+                'SELECT * FROM example.\"source\" AS \"source\"', read=\"snowflake\"\n+            )\n             transformed = func(source_query, dialect=\"snowflake\", schema=schema)\n-            self.assertEqual(transformed.sql(pretty=True, dialect=\"snowflake\"), expected)\n+            self.assertEqual(\n+                transformed.sql(pretty=True, dialect=\"snowflake\"), expected\n+            )\n \n     def test_no_pseudocolumn_expansion(self):\n         schema = {\n@@ -1580,19 +1716,25 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n \n         expression = parse_one(example_query, dialect=dialect)\n         qual = optimizer.qualify.qualify(expression, schema=schema, dialect=dialect)\n-        annotated = optimizer.annotate_types.annotate_types(qual, schema=schema, dialect=dialect)\n+        annotated = optimizer.annotate_types.annotate_types(\n+            qual, schema=schema, dialect=dialect\n+        )\n \n         self.assertTrue(annotated.selects[0].is_type(\"INT\"))\n         self.assertTrue(annotated.selects[1].is_type(\"VARCHAR\"))\n \n     def test_annotate_table_as_struct_bigquery(self):\n         dialect = \"bigquery\"\n-        schema = {\"d\": {\"s\": {\"t\": {\"c1\": \"int64\", \"c2\": \"struct<f1 int64, f2 string>\"}}}}\n+        schema = {\n+            \"d\": {\"s\": {\"t\": {\"c1\": \"int64\", \"c2\": \"struct<f1 int64, f2 string>\"}}}\n+        }\n \n         def _annotate(query: str) -> exp.Expression:\n             expression = parse_one(query, dialect=dialect)\n             qual = optimizer.qualify.qualify(expression, schema=schema, dialect=dialect)\n-            return optimizer.annotate_types.annotate_types(qual, schema=schema, dialect=dialect)\n+            return optimizer.annotate_types.annotate_types(\n+                qual, schema=schema, dialect=dialect\n+            )\n \n         example_query = \"SELECT t FROM d.s.t\"\n         annotated = _annotate(example_query)\n@@ -1602,14 +1744,18 @@ FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n             annotated.sql(\"bigquery\"), \"SELECT `t` AS `_col_0` FROM `d`.`s`.`t` AS `t`\"\n         )\n         self.assertTrue(\n-            annotated.selects[0].is_type(\"STRUCT<c1 BIGINT, c2 STRUCT<f1 BIGINT, f2 TEXT>>\")\n+            annotated.selects[0].is_type(\n+                \"STRUCT<c1 BIGINT, c2 STRUCT<f1 BIGINT, f2 TEXT>>\"\n+            )\n         )\n \n         example_query = \"SELECT subq FROM (SELECT * from d.s.t) subq\"\n         annotated = _annotate(example_query)\n \n         self.assertTrue(\n-            annotated.selects[0].is_type(\"STRUCT<c1 BIGINT, c2 STRUCT<f1 BIGINT, f2 TEXT>>\")\n+            annotated.selects[0].is_type(\n+                \"STRUCT<c1 BIGINT, c2 STRUCT<f1 BIGINT, f2 TEXT>>\"\n+            )\n         )\n \n         example_query = \"WITH t AS (SELECT 1 AS c) SELECT t FROM t\"\n"
    },
    {
        "id": 333,
        "sha_fail": "ff15e0ed7276b5aa8e4581769e8e8e7deca1420d",
        "diff": "diff --git a/tornado/template.py b/tornado/template.py\nindex 0064c6f..ae98ab8 100644\n--- a/tornado/template.py\n+++ b/tornado/template.py\n@@ -382,7 +382,7 @@ class Template:\n             if isinstance(chunk, _ExtendsBlock):\n                 if not loader:\n                     raise ParseError(\n-                        \"{% extends %} block found, but no \" \"template loader\"\n+                        \"{% extends %} block found, but no template loader\"\n                     )\n                 template = loader.load(chunk.name, self.name)\n                 ancestors.extend(template._get_ancestors(loader))\n@@ -660,7 +660,7 @@ class _Expression(_Node):\n     def generate(self, writer: \"_CodeWriter\") -> None:\n         writer.write_line(\"_tt_tmp = %s\" % self.expression, self.line)\n         writer.write_line(\n-            \"if isinstance(_tt_tmp, _tt_string_types):\" \" _tt_tmp = _tt_utf8(_tt_tmp)\",\n+            \"if isinstance(_tt_tmp, _tt_string_types): _tt_tmp = _tt_utf8(_tt_tmp)\",\n             self.line,\n         )\n         writer.write_line(\"else: _tt_tmp = _tt_utf8(str(_tt_tmp))\", self.line)\ndiff --git a/tornado/test/runtests.py b/tornado/test/runtests.py\nindex d7eb51f..43716ad 100644\n--- a/tornado/test/runtests.py\n+++ b/tornado/test/runtests.py\n@@ -61,7 +61,6 @@ def all():\n \n \n def test_runner_factory(stderr):\n-\n     class TornadoTextTestResult(unittest.TextTestResult):\n         def addSkip(self, test, reason):\n             if reason == ABT_SKIP_MESSAGE:\n"
    }
]
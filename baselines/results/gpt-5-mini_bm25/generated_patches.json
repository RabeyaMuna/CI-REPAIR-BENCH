[
    {
        "id": "1",
        "sha_fail": "2c06ffa4c9d2c37846c60ad75899b4d72f214ff9",
        "diff": "diff --git a/examples/community/ip_adapter_face_id.py b/examples/community/ip_adapter_face_id.py\nindex e3c5a2c..d932574 100644\n--- a/examples/community/ip_adapter_face_id.py\n+++ b/examples/community/ip_adapter_face_id.py\n@@ -14,12 +14,12 @@\n \n import inspect\n from typing import Any, Callable, Dict, List, Optional, Union\n-from safetensors import safe_open\n \n import torch\n import torch.nn as nn\n import torch.nn.functional as F\n from packaging import version\n+from safetensors import safe_open\n from transformers import CLIPImageProcessor, CLIPTextModel, CLIPTokenizer, CLIPVisionModelWithProjection\n \n from diffusers.configuration_utils import FrozenDict\n@@ -27,20 +27,20 @@ from diffusers.image_processor import VaeImageProcessor\n from diffusers.loaders import FromSingleFileMixin, IPAdapterMixin, LoraLoaderMixin, TextualInversionLoaderMixin\n from diffusers.models import AutoencoderKL, UNet2DConditionModel\n from diffusers.models.attention_processor import FusedAttnProcessor2_0\n-from diffusers.models.lora import adjust_lora_scale_text_encoder, LoRALinearLayer\n+from diffusers.models.lora import LoRALinearLayer, adjust_lora_scale_text_encoder\n+from diffusers.pipelines.pipeline_utils import DiffusionPipeline\n+from diffusers.pipelines.stable_diffusion.pipeline_output import StableDiffusionPipelineOutput\n+from diffusers.pipelines.stable_diffusion.safety_checker import StableDiffusionSafetyChecker\n from diffusers.schedulers import KarrasDiffusionSchedulers\n from diffusers.utils import (\n-    _get_model_file,\n     USE_PEFT_BACKEND,\n+    _get_model_file,\n     deprecate,\n     logging,\n     scale_lora_layers,\n     unscale_lora_layers,\n )\n from diffusers.utils.torch_utils import randn_tensor\n-from diffusers.pipelines.pipeline_utils import DiffusionPipeline\n-from diffusers.pipelines.stable_diffusion.pipeline_output import StableDiffusionPipelineOutput\n-from diffusers.pipelines.stable_diffusion.safety_checker import StableDiffusionSafetyChecker\n \n \n logger = logging.get_logger(__name__)  # pylint: disable=invalid-name\n@@ -555,7 +555,7 @@ class IPAdapterFaceIDStableDiffusionPipeline(\n             revision=revision,\n             subfolder=subfolder,\n             user_agent=user_agent,\n-            )\n+        )\n         if weight_name.endswith(\".safetensors\"):\n             state_dict = {\"image_proj\": {}, \"ip_adapter\": {}}\n             with safe_open(model_file, framework=\"pt\", device=\"cpu\") as f:\n@@ -1438,7 +1438,7 @@ class IPAdapterFaceIDStableDiffusionPipeline(\n         extra_step_kwargs = self.prepare_extra_step_kwargs(generator, eta)\n \n         # 6.1 Add image embeds for IP-Adapter\n-        added_cond_kwargs ={\"image_embeds\": image_embeds} if image_embeds is not None else None\n+        added_cond_kwargs = {\"image_embeds\": image_embeds} if image_embeds is not None else None\n \n         # 6.2 Optionally get Guidance Scale Embedding\n         timestep_cond = None\n"
    },
    {
        "id": "2",
        "sha_fail": "db6550a228941b538f340fb5b65ed16c43a21b88",
        "diff": "diff --git a/src/diffusers/loaders/ip_adapter.py b/src/diffusers/loaders/ip_adapter.py\nindex df9caa9..0c31001 100644\n--- a/src/diffusers/loaders/ip_adapter.py\n+++ b/src/diffusers/loaders/ip_adapter.py\n@@ -12,7 +12,7 @@\n # See the License for the specific language governing permissions and\n # limitations under the License.\n import os\n-from typing import Dict, Optional, Union\n+from typing import Dict, Union\n \n import torch\n from huggingface_hub.utils import validate_hf_hub_args\n"
    },
    {
        "id": "4",
        "sha_fail": "2e41e783672597e2e0c7b2842b5934d879374028",
        "diff": "diff --git a/sanic/server/websockets/frame.py b/sanic/server/websockets/frame.py\nindex cb63b7c..a790a34 100644\n--- a/sanic/server/websockets/frame.py\n+++ b/sanic/server/websockets/frame.py\n@@ -112,18 +112,21 @@ class WebsocketFrameAssembler:\n             # allow put() to run and eventually set it.\n             # Locking with get_in_progress ensures only one task can get here.\n             if timeout is None:\n-                completed = await self.message_complete.wait()\n+                # wait() returns None on success, so treat reaching here as completed\n+                await self.message_complete.wait()\n+                completed = True\n             elif timeout <= 0:\n                 completed = self.message_complete.is_set()\n             else:\n                 try:\n+                    # if wait_for returns without raising, the event was set\n                     await asyncio.wait_for(\n                         self.message_complete.wait(), timeout=timeout\n                     )\n+                    completed = True\n                 except asyncio.TimeoutError:\n-                    ...\n-                finally:\n-                    completed = self.message_complete.is_set()\n+                    # timed out waiting for the event\n+                    completed = False\n \n             # Unpause the transport, if its paused\n             if self.paused:\n@@ -288,5 +291,9 @@ class WebsocketFrameAssembler:\n \n             # Allow get() to run and eventually set the event.\n             await self.message_fetched.wait()\n-            self.message_fetched.clear()\n+            # clear() is synchronous on real asyncio.Event, but tests may replace\n+            # message_fetched with an AsyncMock whose clear() is awaitable.\n+            res = self.message_fetched.clear()\n+            if hasattr(res, \"__await__\"):\n+                await res\n             self.decoder = None\ndiff --git a/tests/test_websockets.py b/tests/test_websockets.py\nindex dd8413b..c55ac37 100644\n--- a/tests/test_websockets.py\n+++ b/tests/test_websockets.py\n@@ -185,7 +185,9 @@ async def test_ws_frame_put_not_fetched(opcode):\n @pytest.mark.parametrize(\"opcode\", DATA_OPCODES)\n async def test_ws_frame_put_fetched(opcode):\n     assembler = WebsocketFrameAssembler(Mock())\n-    assembler.message_fetched = AsyncMock()\n+    assembler.message_fetched = Mock()\n+    assembler.message_fetched.wait = AsyncMock()\n+    assembler.message_fetched.clear = Mock()\n     assembler.message_fetched.is_set = Mock(return_value=False)\n \n     await assembler.put(Frame(opcode, b\"\"))\n@@ -212,14 +214,18 @@ async def test_ws_frame_put_message_complete(opcode):\n async def test_ws_frame_put_message_into_queue(opcode):\n     assembler = WebsocketFrameAssembler(Mock())\n     assembler.chunks_queue = AsyncMock(spec=Queue)\n-    assembler.message_fetched = AsyncMock()\n+    assembler.message_fetched = Mock()\n+    assembler.message_fetched.wait = AsyncMock()\n+    assembler.message_fetched.clear = Mock()\n     assembler.message_fetched.is_set = Mock(return_value=False)\n \n     await assembler.put(Frame(opcode, b\"foo\"))\n \n-    assembler.chunks_queue.put.has_calls(\n-        call(b\"foo\"),\n-        call(None),\n+    assembler.chunks_queue.put.assert_has_calls(\n+        [\n+            call(b\"foo\"),\n+            call(None),\n+        ]\n     )\n \n \n"
    },
    {
        "id": "5",
        "sha_fail": "d1b0280fb92d0d8590cf403ca46af3550507d4d2",
        "diff": "diff --git a/tornado/ioloop.py b/tornado/ioloop.py\nindex 3fb1359..9ac78bc 100644\n--- a/tornado/ioloop.py\n+++ b/tornado/ioloop.py\n@@ -521,12 +521,20 @@ class IOLoop(Configurable):\n         if timeout is not None:\n \n             def timeout_callback() -> None:\n-                # If we can cancel the future, do so and wait on it. If not,\n-                # Just stop the loop and return with the task still pending.\n-                # (If we neither cancel nor wait for the task, a warning\n-                # will be logged).\n                 assert future_cell[0] is not None\n-                if not future_cell[0].cancel():\n+                f = future_cell[0]\n+                # Try to cancel the future. If cancellation was requested\n+                # successfully, ensure we will stop the loop when the\n+                # cancelled future actually completes (so that any final\n+                # cleanup / logging from the coroutine can run). If we\n+                # couldn't cancel it, stop immediately and return with the\n+                # task still pending.\n+                if f.cancel():\n+                    # add_future will arrange for self.stop() to be called\n+                    # when the future is done. It's safe to add this even if\n+                    # an identical callback was previously added.\n+                    self.add_future(f, lambda future: self.stop())\n+                else:\n                     self.stop()\n \n             timeout_handle = self.add_timeout(self.time() + timeout, timeout_callback)\n@@ -557,7 +565,7 @@ class IOLoop(Configurable):\n         deadline: Union[float, datetime.timedelta],\n         callback: Callable,\n         *args: Any,\n-        **kwargs: Any\n+        **kwargs: Any,\n     ) -> object:\n         \"\"\"Runs the ``callback`` at the time ``deadline`` from the I/O loop.\n \n@@ -708,7 +716,7 @@ class IOLoop(Configurable):\n         self,\n         executor: Optional[concurrent.futures.Executor],\n         func: Callable[..., _T],\n-        *args: Any\n+        *args: Any,\n     ) -> \"Future[_T]\":\n         \"\"\"Runs a function in a ``concurrent.futures.Executor``. If\n         ``executor`` is ``None``, the IO loop's default executor will be used.\ndiff --git a/tornado/platform/asyncio.py b/tornado/platform/asyncio.py\nindex 79e6084..9752bca 100644\n--- a/tornado/platform/asyncio.py\n+++ b/tornado/platform/asyncio.py\n@@ -467,9 +467,24 @@ class SelectorThread:\n         # When the loop starts, start the thread. Not too soon because we can't\n         # clean up if we get to this point but the event loop is closed without\n         # starting.\n-        self._real_loop.call_soon(\n-            lambda: self._real_loop.create_task(thread_manager_anext())\n-        )\n+        def _start_thread_manager() -> None:\n+            # Create the coroutine and schedule it. If scheduling fails due\n+            # to the loop closing we must close the coroutine to avoid a\n+            # \"coroutine was never awaited\" warning.\n+            coro = thread_manager_anext()\n+            try:\n+                # Schedule the coroutine on the real loop. If the loop is\n+                # closed concurrently, create_task may raise; in that case\n+                # make sure to close the coroutine to avoid resource warnings.\n+                self._real_loop.create_task(coro)\n+            except Exception:\n+                try:\n+                    coro.close()\n+                except Exception:\n+                    pass\n+\n+        # Use call_soon to execute scheduling on the loop thread.\n+        self._real_loop.call_soon(_start_thread_manager)\n \n         self._readers: Dict[_FileDescriptorLike, Callable] = {}\n         self._writers: Dict[_FileDescriptorLike, Callable] = {}\ndiff --git a/tornado/testing.py b/tornado/testing.py\nindex bdbff87..d5d0012 100644\n--- a/tornado/testing.py\n+++ b/tornado/testing.py\n@@ -198,7 +198,21 @@ class AsyncTestCase(unittest.TestCase):\n         if type(self).get_new_ioloop is not AsyncTestCase.get_new_ioloop:\n             warnings.warn(\"get_new_ioloop is deprecated\", DeprecationWarning)\n         self.io_loop = self.get_new_ioloop()\n-        asyncio.set_event_loop(self.io_loop.asyncio_loop)  # type: ignore[attr-defined]\n+        # Only set the global asyncio event loop if there is no running loop\n+        # in this thread. Unconditionally setting the global loop can clash\n+        # with background selector threads and lead to unawaited coroutine\n+        # warnings or destroyed pending tasks.\n+        try:\n+            asyncio.get_running_loop()\n+        except RuntimeError:\n+            # No running loop in this thread; safe to set the event loop.\n+            try:\n+                asyncio.set_event_loop(self.io_loop.asyncio_loop)  # type: ignore[attr-defined]\n+            except Exception:\n+                # If setting the loop fails for any reason, continue without\n+                # replacing the global event loop to avoid interfering with\n+                # other running threads/tasks.\n+                pass\n \n     def tearDown(self) -> None:\n         # Native coroutines tend to produce warnings if they're not\n"
    },
    {
        "id": "6",
        "sha_fail": "f18f82de3e0270f6dfddf22f1f487104b2428e35",
        "diff": "diff --git a/tests/unittests/sources/test_wsl.py b/tests/unittests/sources/test_wsl.py\nindex 9653cfa..03b3a1f 100644\n--- a/tests/unittests/sources/test_wsl.py\n+++ b/tests/unittests/sources/test_wsl.py\n@@ -7,7 +7,7 @@\n import os\n from copy import deepcopy\n from email.mime.multipart import MIMEMultipart\n-from typing import Optional, cast\n+from typing import cast\n \n from cloudinit import helpers, util\n from cloudinit.sources import DataSourceWSL as wsl\n"
    },
    {
        "id": "7",
        "sha_fail": "55d2e8d4abb024997be878797d5625effad65d43",
        "diff": "diff --git a/tests/unittests/test_net_activators.py b/tests/unittests/test_net_activators.py\nindex 0b3c11c..08f155d 100644\n--- a/tests/unittests/test_net_activators.py\n+++ b/tests/unittests/test_net_activators.py\n@@ -326,6 +326,7 @@ class TestActivatorsBringDown:\n \n \n class TestNetworkManagerActivatorBringUp:\n+    @staticmethod\n     def fake_isfile_no_nmconn(filename):\n         return False if filename.endswith(\".nmconnection\") else True\n \n"
    }
]
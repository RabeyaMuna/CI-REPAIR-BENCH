[
    {
        "sha_fail": "2c06ffa4c9d2c37846c60ad75899b4d72f214ff9",
        "error_context": [
            "The 'Check quality' step in the check_code_quality job failed because the repository's code-style tool (ruff) detected an import-order/formatting problem and exited with a non-zero status. Evidence: the log shows \"examples/community/ip_adapter_face_id.py:15:1: I001 ... Import block is un-sorted or un-formatted\", followed by \"Found 1 error.\" and \"[*] 1 fixable with the `--fix` option.\", and the runner reported \"##[error]Process completed with exit code 1.\"",
            "The failure is a static code-quality/formatting error (not a test/runtime failure). The tool flagged a single, fixable import-block ordering/formatting issue in the example file, causing the quality-check step to stop the workflow."
        ],
        "relevant_files": [
            {
                "file": "examples/community/ip_adapter_face_id.py",
                "line_number": 15,
                "reason": "Directly reported in the log: \"examples/community/ip_adapter_face_id.py:15:1: I001 [*] Import block is un-sorted or un-formatted\" \u2014 this is the file and line where the linter raised the I001 error."
            }
        ],
        "error_types": [
            {
                "category": "Code Formatting",
                "subcategory": "Import order / unsorted import block (ruff I001)",
                "evidence": "\"examples/community/ip_adapter_face_id.py:15:1: I001 ... Import block is un-sorted or un-formatted\" and \"Found 1 error.\" plus \"[*] 1 fixable with the `--fix` option.\""
            }
        ],
        "failed_job": [
            {
                "job": "check_code_quality",
                "step": "Check quality",
                "command": "ruff check examples tests src utils scripts && ruff format examples tests src utils scripts --check"
            }
        ]
    },
    {
        "sha_fail": "db6550a228941b538f340fb5b65ed16c43a21b88",
        "error_context": [
            "The code-quality (lint) step failed because the linter reported a single unused-import error and exited non-zero. Log evidence: \"src/diffusers/loaders/ip_adapter.py:15:26: F401 [*] `typing.Optional` imported but unused\", followed by \"Found 1 error.\" and \"[*] 1 fixable with the `--fix` option.\", and the CI reported \"##[error]Process completed with exit code 1.\" The failing step is the Check quality step of the check_code_quality job which runs ruff."
        ],
        "relevant_files": [
            {
                "file": "src/diffusers/loaders/ip_adapter.py",
                "line_number": 15,
                "reason": "Log shows the exact linter diagnostic: \"src/diffusers/loaders/ip_adapter.py:15:26: F401 ... `typing.Optional` imported but unused\" indicating this file and line are the cause of the lint failure."
            }
        ],
        "error_types": [
            {
                "category": "Linting / Code Quality",
                "subcategory": "Unused import (F401)",
                "evidence": "\"F401 ... `typing.Optional` imported but unused\" and \"Found 1 error.\" from the linter output; linter exit produced \"Process completed with exit code 1.\""
            }
        ],
        "failed_job": [
            {
                "job": "check_code_quality",
                "step": "Check quality",
                "command": "ruff check examples tests src utils scripts"
            }
        ]
    },
    {
        "sha_fail": "102f918deb2532bb7b825f00258f2c1414cf94da",
        "error_context": [
            "The 'Check main requirements' step failed because the requirements checker (tests/scripts/check_requirements.py) reported an unused dependency in requirements/requirements.txt: the DEP002 rule flagged \"type_infer\" as \"defined as a dependency but not used in the codebase.\" Evidence: the log lists \"- requirements/requirements.txt\" then the finding \"None:None: DEP002 'type_infer' defined as a dependency but not used in the codebase\", and the CI recorded \"##[error]Process completed with exit code 1.\" The workflow runs this checker via the command `python tests/scripts/check_requirements.py` after installing dev requirements, and that checker raised the error causing the step to fail."
        ],
        "relevant_files": [
            {
                "file": "tests/scripts/check_requirements.py",
                "line_number": 201,
                "reason": "This script is the checker that was executed by the failing step (workflow runs `python tests/scripts/check_requirements.py`). The log entry references a failure at \"line_number 201\" in the relevant_failures summary, tying the reported DEP002 output to this script's run."
            },
            {
                "file": "requirements/requirements.txt",
                "line_number": null,
                "reason": "The log explicitly lists \"- requirements/requirements.txt\" as the file under inspection and shows the message \"DEP002 'type_infer' defined as a dependency but not used in the codebase\", indicating the unused dependency is declared in this requirements file."
            }
        ],
        "error_types": [
            {
                "category": "Dependency Error",
                "subcategory": "Declared-but-unused dependency (DEP002)",
                "evidence": "Log shows: \"None:None: DEP002 'type_infer' defined as a dependency but not used in the codebase\" and the checker examined \"- requirements/requirements.txt\" before exiting with code 1."
            }
        ],
        "failed_job": [
            {
                "job": "check_requirements",
                "step": "Check main requirements",
                "command": "python tests/scripts/check_requirements.py"
            }
        ]
    },
    {
        "sha_fail": "2e41e783672597e2e0c7b2842b5934d879374028",
        "error_context": [
            "The tox py312 test run failed because three websocket unit tests in tests/test_websockets.py failed (pytest shows \"FFF\" for that module). The immediate cause of those failures is an assertion in tests/test_websockets.py that calls assembler.chunks_queue.put.has_calls(...). The test set assembler.chunks_queue.put as an AsyncMock, and the trace shows attribute access on AsyncMock ('has_calls') failed (trace around tests/test_websockets.py:220). This produced Assertion/attribute errors that caused pytest to exit non-zero.",
            "During the same run there were numerous warnings of multiple kinds that do not appear to be the direct cause of the non-zero exit but are important noise and likely require fixes: (a) many DeprecationWarning messages about cookie API usage and setting/deleting cookie values via dict keys coming from sanic/log.py:152 and tests/test_cookies.py; (b) DeprecationWarning about datetime.datetime.utcnow() and utcfromtimestamp() being deprecated (tests/test_cookies.py lines ~217/249/263); (c) a RuntimeWarning that coroutine 'Loop.create_server' was never awaited and other un-awaited coroutine warnings coming from tests/worker/test_multiplexer.py and a pytest_sanic plugin line (plugin.py:76); and (d) large volumes of DeprecationWarning from pytest's assertion rewrite using ast.Str under Python 3.12.",
            "The failing CI step is the tox test run for Python 3.12 (step name in logs: \"Linux  Python 3.12  tox -e py312/2_Run tests.txt\"). The command that exited non-zero is the test runner invocation: \"coverage run --source ./sanic -m pytest tests\" (py312: exit 1 after that command)."
        ],
        "relevant_files": [
            {
                "file": "sanic/tests/test_websockets.py",
                "line_number": 220,
                "reason": "The failing assertion is at tests/test_websockets.py:220: the log shows assembler.chunks_queue.put.has_calls(...) used there and the AsyncMock access raised an attribute/getattr failure (trace fragment referencing tests/test_websockets.py:220)."
            },
            {
                "file": "sanic/sanic/log.py",
                "line_number": 152,
                "reason": "Multiple DeprecationWarning messages originate from /.../sanic/log.py:152: the log repeats '[DEPRECATION] Accessing cookies from the CookieJar by dict key is deprecated...' tied to many cookie-related tests."
            },
            {
                "file": "sanic/tests/test_cookies.py",
                "line_number": 249,
                "reason": "Cookie expiry and datetime deprecation warnings reference tests/test_cookies.py lines (e.g. 217, 249, 263) where datetime.utcnow() and utcfromtimestamp() usages emit DeprecationWarning; the log links these warnings to cookie expiry tests such as test_cookie_expires[expires0]."
            },
            {
                "file": "sanic/sanic/cookies/response.py",
                "line_number": null,
                "reason": "File is strongly scored by the failure-context matching and is likely related to cookie API changes referenced repeatedly in the warnings (relevant_files list from logs shows this file matched tokens from cookie-related deprecation messages)."
            },
            {
                "file": "sanic/sanic/cookies/request.py",
                "line_number": null,
                "reason": "Also highly ranked in the provided relevant_files list and tied to cookie API access patterns mentioned in deprecation warnings (tests and logs recommend using cookies.get_cookie / request.cookies.get)."
            },
            {
                "file": "site-packages/_pytest/assertion/rewrite.py",
                "line_number": null,
                "reason": "Logs show many DeprecationWarning entries from _pytest/assertion/rewrite.py about ast.Str being deprecated; although not in repo source, this explains the large volume of warnings during assertion rewriting under Python 3.12."
            }
        ],
        "error_types": [
            {
                "category": "Test Failure",
                "subcategory": "AssertionError / incorrect mock usage in unit test",
                "evidence": "tests/test_websockets.py shows 'FFF' and the trace around tests/test_websockets.py:220 shows assembler.chunks_queue.put.has_calls(...) attempted on an AsyncMock and __getattr__ on AsyncMock raised (log lines referencing AsyncMock name='mock.put' id=..., and call at tests/test_websockets.py:220)."
            },
            {
                "category": "Runtime Warning",
                "subcategory": "Un-awaited coroutine",
                "evidence": "Log entry: 'RuntimeWarning: coroutine 'Loop.create_server' was never awaited' and 'pytest_sanic/plugin.py:76 emitted RuntimeWarning: coroutine 'dummy' was never awaited' indicate runtime warnings from un-awaited coroutines during tests."
            },
            {
                "category": "Deprecation Warning",
                "subcategory": "Library/API deprecation \u2014 Cookie API (access via dict) and setting/deleting via dict",
                "evidence": "Repeated DeprecationWarning from sanic/log.py:152: '[DEPRECATION] Accessing cookies from the CookieJar by dict key is deprecated...' and '[DEPRECATION v24.3] Setting values on a Cookie object as a dict has been deprecated...' tied to many tests (tests/test_cookies.py and others)."
            },
            {
                "category": "Deprecation Warning",
                "subcategory": "stdlib datetime deprecation (utcnaive usage)",
                "evidence": "tests/test_cookies.py emitted DeprecationWarning: 'datetime.datetime.utcnow() is deprecated' and 'datetime.datetime.utcfromtimestamp() is deprecated', suggested use of timezone-aware alternatives (log references tests/test_cookies.py:217, 249, 263)."
            },
            {
                "category": "Deprecation Warning",
                "subcategory": "pytest internals using deprecated ast.Str",
                "evidence": "Logs show '/site-packages/_pytest/assertion/rewrite.py' emitted 'DeprecationWarning: ast.Str is deprecated ... use ast.Constant instead' many thousands of times during assertion rewrite under Python 3.12."
            }
        ],
        "failed_job": [
            {
                "job": "run_tests (matrix entry: Python 3.12, tox-env: py312)",
                "step": "Linux  Python 3.12  tox -e py312/2_Run tests.txt",
                "command": "coverage run --source ./sanic -m pytest tests"
            }
        ]
    }
]
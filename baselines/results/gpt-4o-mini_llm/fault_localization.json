[
    {
        "sha_fail": "c0d46a6bfc97c11b8a770d74b2fdb841622201a1",
        "fault_localization_data": []
    },
    {
        "sha_fail": "066ba5bb325850910e8f4cb76a91e3293c3b7619",
        "fault_localization_data": [
            {
                "file_path": "tests/_files/test_contact.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/_files/test_contact.py",
                "faults": [
                    {
                        "file_path": "tests/_files/test_contact.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/_files/test_contact.py",
                        "line_range": [
                            159,
                            201
                        ],
                        "reason": "The test 'test_send_contact_default_protect_content' failed due to flood control being exceeded, leading to retries being delayed. This indicates a potential issue with the handling of message sending limits in the Telegram API. The test is designed to check the behavior of sending contacts with and without protection, but it encountered a flood control error. This suggests that the implementation may not be respecting the rate limits imposed by the Telegram API, which could lead to excessive requests in a short period. Lines 196-200 are relevant as they contain the assertions related to this test.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "class",
                        "code_snippet": "class TestContactWithRequest(ContactTestBase):\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_contact_default_allow_sending_without_reply(\n        self, default_bot, chat_id, contact, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_contact(\n                chat_id,\n                contact=contact,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_contact(\n                chat_id, contact=contact, reply_to_message_id=reply_to_message.message_id\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_contact(\n                    chat_id, contact=contact, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_contact_default_protect_content(self, chat_id, default_bot, contact):\n        tasks = asyncio.gather(\n            default_bot.send_contact(chat_id, contact=contact),\n            default_bot.send_contact(chat_id, contact=contact, protect_content=False),\n        )\n        protected, unprotected = await tasks\n        assert protected.has_protected_content\n        assert not unprotected.has_protected_content"
                    },
                    {
                        "file_path": "tests/_files/test_contact.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/_files/test_contact.py",
                        "line_range": [
                            50,
                            53
                        ],
                        "reason": "The test 'test_get_set_my_default_administrator_rights' failed due to an assertion error indicating a mismatch in expected values. This suggests that there may be an issue with the logic in the test or the implementation of the functionality being tested. The assertion failure indicates that the expected outcome does not match the actual result, which could be due to incorrect assumptions in the test setup or a bug in the code being tested. Lines 50-53 are relevant as they contain the assertions related to this test.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    def test_slot_behaviour(self, contact):\n        for attr in contact.__slots__:\n            assert getattr(contact, attr, \"err\") != \"err\", f\"got extra slot '{attr}'\"\n        assert len(mro_slots(contact)) == len(set(mro_slots(contact))), \"duplicate slot\""
                    },
                    {
                        "file_path": "tests/_files/test_contact.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/_files/test_contact.py",
                        "line_range": [
                            107,
                            109
                        ],
                        "reason": "The test 'test_send_contact_without_required' failed due to a ValueError being raised when neither contact nor phone_number and first_name were provided. This indicates that the implementation of the send_contact method does not handle the absence of required parameters correctly, leading to an unhandled exception. Lines 107-109 are relevant as they contain the assertion that checks for this error.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_send_contact_without_required(self, offline_bot, chat_id):\n        with pytest.raises(ValueError, match=\"Either contact or phone_number and first_name\"):\n            await offline_bot.send_contact(chat_id=chat_id)"
                    },
                    {
                        "file_path": "tests/_files/test_contact.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/_files/test_contact.py",
                        "line_range": [
                            111,
                            118
                        ],
                        "reason": "The test 'test_send_mutually_exclusive' failed due to a ValueError being raised when both contact and phone_number were provided. This indicates that the implementation of the send_contact method does not enforce the mutual exclusivity of these parameters correctly, leading to an unhandled exception. Lines 111-118 are relevant as they contain the assertion that checks for this error.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_send_mutually_exclusive(self, offline_bot, chat_id, contact):\n        with pytest.raises(ValueError, match=\"Not both\"):\n            await offline_bot.send_contact(\n                chat_id=chat_id,\n                contact=contact,\n                phone_number=contact.phone_number,\n                first_name=contact.first_name,\n            )"
                    }
                ]
            },
            {
                "file_path": "tests/_files/test_sticker.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/_files/test_sticker.py",
                "faults": [
                    {
                        "file_path": "tests/_files/test_sticker.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/_files/test_sticker.py",
                        "line_range": [
                            1,
                            400
                        ],
                        "reason": "The CI run failed primarily due to multiple test failures during the execution of pytest. Specific tests such as 'test_get_set_my_default_administrator_rights' failed due to an assertion error indicating a mismatch in expected values (assert False is True). Additionally, multiple tests encountered timeout issues, and others failed due to flood control being exceeded, leading to retries being delayed. These issues suggest potential problems in the test implementations or the handling of asynchronous operations. The assertion error is particularly relevant to the tests defined in this file, which may not be handling expected values correctly.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "file",
                        "code_snippet": "#!/usr/bin/env python\n#\n# A library that provides a Python interface to the Telegram Bot API\n# Copyright (C) 2015-2025\n# Leandro Toledo de Souza <devs@python-telegram-bot.org>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser Public License for more details.\n#\n# You should have received a copy of the GNU Lesser Public License\n# along with this program.  If not, see [http://www.gnu.org/licenses/].\nimport asyncio\nimport os\nimport random\nimport string\nfrom pathlib import Path\n\nimport pytest\n\nfrom telegram import (\n    Audio,\n    Bot,\n    File,\n    InputFile,\n    InputSticker,\n    MaskPosition,\n    PhotoSize,\n    ReplyParameters,\n    Sticker,\n    StickerSet,\n)\nfrom telegram.constants import ParseMode, StickerFormat, StickerType\nfrom telegram.error import BadRequest, TelegramError\nfrom telegram.request import RequestData\nfrom tests.auxil.bot_method_checks import (\n    check_defaults_handling,\n    check_shortcut_call,\n    check_shortcut_signature,\n)\nfrom tests.auxil.build_messages import make_message\nfrom tests.auxil.files import data_file\nfrom tests.auxil.slots import mro_slots\n\n\nclass StickerTestBase:\n    # sticker_file_url = 'https://python-telegram-bot.org/static/testfiles/telegram.webp'\n    # Serving sticker from gh since our server sends wrong content_type\n    sticker_file_url = (\n        \"https://github.com/python-telegram-bot/python-telegram-bot/blob/master\"\n        \"/tests/data/telegram.webp?raw=true\"\n    )\n\n    emoji = \"\ud83d\udcaa\"\n    width = 510\n    height = 512\n    is_animated = False\n    is_video = False\n    file_size = 39518\n    thumb_width = 319\n    thumb_height = 320\n    thumb_file_size = 21448\n    type = Sticker.REGULAR\n    custom_emoji_id = \"ThisIsSuchACustomEmojiID\"\n    needs_repainting = True\n\n    sticker_file_id = \"5a3128a4d2a04750b5b58397f3b5e812\"\n    sticker_file_unique_id = \"adc3145fd2e84d95b64d68eaa22aa33e\"\n\n    premium_animation = File(\"this_is_an_id\", \"this_is_an_unique_id\")\n\n\nclass TestStickerWithoutRequest(StickerTestBase):\n    def test_slot_behaviour(self, sticker):\n        for attr in sticker.__slots__:\n            assert getattr(sticker, attr, \"err\") != \"err\", f\"got extra slot '{attr}'\"\n        assert len(mro_slots(sticker)) == len(set(mro_slots(sticker))), \"duplicate slot\"\n\n    def test_creation(self, sticker):\n        # Make sure file has been uploaded.\n        assert isinstance(sticker, Sticker)\n        assert isinstance(sticker.file_id, str)\n        assert isinstance(sticker.file_unique_id, str)\n        assert sticker.file_id\n        assert sticker.file_unique_id\n        assert isinstance(sticker.thumbnail, PhotoSize)\n        assert isinstance(sticker.thumbnail.file_id, str)\n        assert isinstance(sticker.thumbnail.file_unique_id, str)\n        assert sticker.thumbnail.file_id\n        assert sticker.thumbnail.file_unique_id\n        assert isinstance(sticker.needs_repainting, bool)\n\n    def test_expected_values(self, sticker):\n        assert sticker.width == self.width\n        assert sticker.height == self.height\n        assert sticker.is_animated == self.is_animated\n        assert sticker.is_video == self.is_video\n        assert sticker.file_size == self.file_size\n        assert sticker.thumbnail.width == self.thumb_width\n        assert sticker.thumbnail.height == self.thumb_height\n        assert sticker.thumbnail.file_size == self.thumb_file_size\n        assert sticker.type == self.type\n        assert sticker.needs_repainting == self.needs_repainting\n        # we need to be a premium TG user to send a premium sticker, so the below is not tested\n        # assert sticker.premium_animation == self.premium_animation\n\n    def test_to_dict(self, sticker):\n        sticker_dict = sticker.to_dict()\n\n        assert isinstance(sticker_dict, dict)\n        assert sticker_dict[\"file_id\"] == sticker.file_id\n        assert sticker_dict[\"file_unique_id\"] == sticker.file_unique_id\n        assert sticker_dict[\"width\"] == sticker.width\n        assert sticker_dict[\"height\"] == sticker.height\n        assert sticker_dict[\"is_animated\"] == sticker.is_animated\n        assert sticker_dict[\"is_video\"] == sticker.is_video\n        assert sticker_dict[\"file_size\"] == sticker.file_size\n        assert sticker_dict[\"thumbnail\"] == sticker.thumbnail.to_dict()\n        assert sticker_dict[\"type\"] == sticker.type\n        assert sticker_dict[\"needs_repainting\"] == sticker.needs_repainting\n\n    def test_de_json(self, offline_bot, sticker):\n        json_dict = {\n            \"file_id\": self.sticker_file_id,\n            \"file_unique_id\": self.sticker_file_unique_id,\n            \"width\": self.width,\n            \"height\": self.height,\n            \"is_animated\": self.is_animated,\n            \"is_video\": self.is_video,\n            \"thumbnail\": sticker.thumbnail.to_dict(),\n            \"emoji\": self.emoji,\n            \"file_size\": self.file_size,\n            \"premium_animation\": self.premium_animation.to_dict(),\n            \"type\": self.type,\n            \"custom_emoji_id\": self.custom_emoji_id,\n            \"needs_repainting\": self.needs_repainting,\n        }\n        json_sticker = Sticker.de_json(json_dict, offline_bot)\n        assert json_sticker.api_kwargs == {}\n\n        assert json_sticker.file_id == self.sticker_file_id\n        assert json_sticker.file_unique_id == self.sticker_file_unique_id\n        assert json_sticker.width == self.width\n        assert json_sticker.height == self.height\n        assert json_sticker.is_animated == self.is_animated\n        assert json_sticker.is_video == self.is_video\n        assert json_sticker.emoji == self.emoji\n        assert json_sticker.file_size == self.file_size\n        assert json_sticker.thumbnail == sticker.thumbnail\n        assert json_sticker.premium_animation == self.premium_animation\n        assert json_sticker.type == self.type\n        assert json_sticker.custom_emoji_id == self.custom_emoji_id\n        assert json_sticker.needs_repainting == self.needs_repainting\n\n    def test_type_enum_conversion(self):\n        assert (\n            type(\n                Sticker(\n                    file_id=self.sticker_file_id,\n                    file_unique_id=self.sticker_file_unique_id,\n                    width=self.width,\n                    height=self.height,\n                    is_animated=self.is_animated,\n                    is_video=self.is_video,\n                    type=\"regular\",\n                ).type\n            )\n            is StickerType\n        )\n        assert (\n            Sticker(\n                file_id=self.sticker_file_id,\n                file_unique_id=self.sticker_file_unique_id,\n                width=self.width,\n                height=self.height,\n                is_animated=self.is_animated,\n                is_video=self.is_video,\n                type=\"unknown\",\n            ).type\n            == \"unknown\"\n        )\n\n    def test_equality(self, sticker):\n        a = Sticker(\n            sticker.file_id,\n            sticker.file_unique_id,\n            self.width,\n            self.height,\n            self.is_animated,\n            self.is_video,\n            self.type,\n        )\n        b = Sticker(\n            \"\",\n            sticker.file_unique_id,\n            self.width,\n            self.height,\n            self.is_animated,\n            self.is_video,\n            self.type,\n        )\n        c = Sticker(\n            sticker.file_id,\n            sticker.file_unique_id,\n            0,\n            0,\n            False,\n            True,\n            self.type,\n        )\n        d = Sticker(\n            \"\",\n            \"\",\n            self.width,\n            self.height,\n            self.is_animated,\n            self.is_video,\n            self.type,\n        )\n        e = PhotoSize(\n            sticker.file_id,\n            sticker.file_unique_id,\n            self.width,\n            self.height,\n            self.is_animated,\n        )\n\n        assert a == b\n        assert hash(a) == hash(b)\n        assert a is not b\n\n        assert a == c\n        assert hash(a) == hash(c)\n\n        assert a != d\n        assert hash(a) != hash(d)\n\n        assert a != e\n        assert hash(a) != hash(e)\n\n    async def test_error_without_required_args(self, offline_bot, chat_id):\n        with pytest.raises(TypeError):\n            await offline_bot.send_sticker(chat_id)\n\n    async def test_send_with_sticker(self, monkeypatch, offline_bot, chat_id, sticker):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.json_parameters[\"sticker\"] == sticker.file_id\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.send_sticker(sticker=sticker, chat_id=chat_id)\n\n    @pytest.mark.parametrize(\"local_mode\", [True, False])\n    async def test_send_sticker_local_files(\n        self, dummy_message_dict, monkeypatch, offline_bot, chat_id, local_mode\n    ):\n        try:\n            offline_bot._local_mode = local_mode\n            # For just test that the correct paths are passed as we have no local Bot API set up\n            test_flag = False\n            file = data_file(\"telegram.jpg\")\n            expected = file.as_uri()\n\n            async def make_assertion(_, data, *args, **kwargs):\n                nonlocal test_flag\n                if local_mode:\n                    test_flag = data.get(\"sticker\") == expected\n                else:\n                    test_flag = isinstance(data.get(\"sticker\"), InputFile)\n                return dummy_message_dict\n\n            monkeypatch.setattr(offline_bot, \"_post\", make_assertion)\n            await offline_bot.send_sticker(chat_id, file)\n            assert test_flag\n        finally:\n            offline_bot._local_mode = False\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"parse_mode\": ParseMode.HTML}, None),\n            ({\"parse_mode\": ParseMode.HTML}, ParseMode.MARKDOWN_V2),\n            ({\"parse_mode\": None}, ParseMode.MARKDOWN_V2),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_sticker_default_quote_parse_mode(\n        self, default_bot, chat_id, sticker, custom, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters[\"reply_parameters\"].get(\"quote_parse_mode\") == (\n                custom or default_bot.defaults.quote_parse_mode\n            )\n            return make_message(\"dummy reply\").to_dict()\n\n        kwargs = {\"message_id\": 1}\n        if custom is not None:\n            kwargs[\"quote_parse_mode\"] = custom\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        await default_bot.send_sticker(\n            chat_id, sticker, reply_parameters=ReplyParameters(**kwargs)\n        )\n\n\nclass TestStickerWithRequest(StickerTestBase):\n    async def test_send_all_args(self, bot, chat_id, sticker_file, sticker):\n        message = await bot.send_sticker(\n            chat_id, sticker=sticker_file, disable_notification=False, protect_content=True\n        )\n\n        assert isinstance(message.sticker, Sticker)\n        assert isinstance(message.sticker.file_id, str)\n        assert isinstance(message.sticker.file_unique_id, str)\n        assert message.sticker.file_id\n        assert message.sticker.file_unique_id\n        assert message.sticker.width == sticker.width\n        assert message.sticker.height == sticker.height\n        assert message.sticker.is_animated == sticker.is_animated\n        assert message.sticker.is_video == sticker.is_video\n        assert message.sticker.file_size == sticker.file_size\n        assert message.sticker.type == sticker.type\n        assert message.has_protected_content\n        # we need to be a premium TG user to send a premium sticker, so the below is not tested\n        # assert message.sticker.premium_animation == sticker.premium_animation\n\n        assert isinstance(message.sticker.thumbnail, PhotoSize)\n        assert isinstance(message.sticker.thumbnail.file_id, str)\n        assert isinstance(message.sticker.thumbnail.file_unique_id, str)\n        assert message.sticker.thumbnail.file_id\n        assert message.sticker.thumbnail.file_unique_id\n        assert message.sticker.thumbnail.width == sticker.thumbnail.width\n        assert message.sticker.thumbnail.height == sticker.thumbnail.height\n        assert message.sticker.thumbnail.file_size == sticker.thumbnail.file_size\n\n    async def test_get_and_download(self, bot, sticker, tmp_file):\n        new_file = await bot.get_file(sticker.file_id)\n\n        assert new_file.file_size == sticker.file_size\n        assert new_file.file_unique_id == sticker.file_unique_id\n        assert new_file.file_path.startswith(\"https://\")\n\n        await new_file.download_to_drive(tmp_file)\n\n        assert tmp_file.is_file()\n\n    async def test_resend(self, bot, chat_id, sticker):\n        message = await bot.send_sticker(chat_id=chat_id, sticker=sticker.file_id)\n\n        assert message.sticker == sticker\n\n    async def test_send_with_emoji(self, bot, chat_id):\n        message = await bot.send_sticker(\n            chat_id=chat_id, sticker=data_file(\"telegram.jpg\"), emoji=self.emoji\n        )\n        assert message.sticker.emoji == self.emoji\n\n    async def test_send_on_server_emoji(self, bot, chat_id):\n        server_file_id = \"CAADAQADHAADyIsGAAFZfq1bphjqlgI\"\n        message = await bot.send_sticker(chat_id=chat_id, sticker=server_file_id)\n        sticker = message.sticker\n        assert sticker.emoji == self.emoji\n\n    async def test_send_from_url(self, bot, chat_id):\n        message = await bot.send_sticker(chat_id=chat_id, sticker=self.sticker_file_url)\n        sticker = message.sticker\n\n        assert isinstance(message.sticker, Sticker)\n        assert isinstance(message.sticker.file_id, str)\n        assert isinstance(message.sticker.file_unique_id, str)\n        assert message.sticker.file_id\n        assert message.sticker.file_unique_id\n        assert message.sticker.width == sticker.width\n        assert message.sticker.height == sticker.height\n        assert message.sticker.is_animated == sticker.is_animated\n        assert message.sticker.is_video == sticker.is_video\n        assert message.sticker.file_size == sticker.file_size\n        assert message.sticker.type == sticker.type\n\n        assert isinstance(message.sticker.thumbnail, PhotoSize)\n        assert isinstance(message.sticker.thumbnail.file_id, str)\n        assert isinstance(message.sticker.thumbnail.file_unique_id, str)\n        assert message.sticker.thumbnail.file_id\n        assert message.sticker.thumbnail.file_unique_id\n        assert message.sticker.thumbnail.width == sticker.thumbnail.width\n        assert message.sticker.thumbnail.height == sticker.thumbnail.height\n        assert message.sticker.thumbnail.file_size == sticker.thumbnail.file_size\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],"
                    },
                    {
                        "file_path": "tests/_files/test_sticker.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/_files/test_sticker.py",
                        "line_range": [
                            481,
                            483
                        ],
                        "reason": "The tests 'test_error_send_empty_file' and 'test_error_send_empty_file_id' both raise TelegramError when attempting to send an empty file or an empty file ID. This indicates that the error handling in the send_sticker method may not be robust enough to handle these cases, leading to potential runtime errors during execution. Lines 482-487 contain the relevant assertions that confirm this behavior.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_error_send_empty_file(self, bot, chat_id):\n        with Path(os.devnull).open(\"rb\") as file, pytest.raises(TelegramError):\n            await bot.send_sticker(chat_id, file)"
                    }
                ]
            },
            {
                "file_path": "tests/_files/test_audio.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/_files/test_audio.py",
                "faults": []
            },
            {
                "file_path": "tests/test_bot.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                "faults": [
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            1,
                            100
                        ],
                        "reason": "The CI run failed primarily due to multiple test failures during the execution of pytest. The imports in this section are crucial for the tests that are failing. If any of these imports are missing or incorrect, it could lead to the failures observed in the tests. The presence of unused imports or incorrect imports could also lead to linting issues, which may not be directly cited in the CI logs but can contribute to overall test failures.",
                        "issue_type": "linting",
                        "fault_localization_level": "import_block",
                        "code_snippet": "#!/usr/bin/env python\n#\n# A library that provides a Python interface to the Telegram Bot API\n# Copyright (C) 2015-2025\n# Leandro Toledo de Souza <devs@python-telegram-bot.org>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser Public License for more details.\n#\n# You should have received a copy of the GNU Lesser Public License\n# along with this program.  If not, see [http://www.gnu.org/licenses/].\nimport asyncio\nimport copy\nimport datetime as dtm\nimport inspect\nimport logging\nimport pickle\nimport socket\nimport time\nfrom collections import defaultdict\nfrom http import HTTPStatus\nfrom io import BytesIO\n\nimport httpx\nimport pytest\n\nfrom telegram import (\n    Bot,\n    BotCommand,\n    BotCommandScopeChat,\n    BotDescription,\n    BotName,\n    BotShortDescription,\n    CallbackQuery,\n    Chat,\n    ChatAdministratorRights,\n    ChatFullInfo,\n    ChatInviteLink,\n    ChatPermissions,\n    Dice,\n    InlineKeyboardButton,\n    InlineKeyboardMarkup,\n    InlineQueryResultArticle,\n    InlineQueryResultDocument,\n    InlineQueryResultsButton,\n    InlineQueryResultVoice,\n    InputFile,\n    InputMediaDocument,\n    InputMediaPhoto,\n    InputMessageContent,\n    InputPollOption,\n    InputTextMessageContent,\n    LabeledPrice,\n    LinkPreviewOptions,\n    MenuButton,\n    MenuButtonCommands,\n    MenuButtonDefault,\n    MenuButtonWebApp,\n    Message,\n    MessageEntity,\n    Poll,\n    PollOption,\n    PreparedInlineMessage,\n    ReactionTypeCustomEmoji,\n    ReactionTypeEmoji,\n    ReplyParameters,\n    SentWebAppMessage,\n    ShippingOption,\n    StarTransaction,\n    StarTransactions,\n    SuggestedPostParameters,\n    SuggestedPostPrice,\n    Update,\n    User,\n    WebAppInfo,\n)\nfrom telegram._payment.stars.staramount import StarAmount\nfrom telegram._utils.datetime import UTC, from_timestamp, localize, to_timestamp\nfrom telegram._utils.defaultvalue import DEFAULT_NONE\nfrom telegram._utils.strings import to_camel_case\nfrom telegram.constants import (\n    ChatAction,\n    InlineQueryLimit,\n    InlineQueryResultType,\n    MenuButtonType,\n    ParseMode,\n    ReactionEmoji,\n)\nfrom telegram.error import BadRequest, EndPointNotFound, InvalidToken\nfrom telegram.ext import ExtBot, InvalidCallbackData\nfrom telegram.helpers import escape_markdown\nfrom telegram.request import BaseRequest, HTTPXRequest, RequestData\nfrom telegram.warnings import PTBUserWarning"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            391,
                            405
                        ],
                        "reason": "The test 'test_get_set_my_default_administrator_rights' failed due to an assertion error indicating a mismatch in expected values. The assertion 'assert False is True' suggests that the expected condition was not met, which could be due to incorrect logic or state in the test setup. This is a direct cause of the test failure as indicated in the CI logs.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_context_manager_exception_on_init(self, monkeypatch, offline_bot):\n        async def initialize():\n            raise RuntimeError(\"initialize\")\n\n        async def shutdown():\n            self.test_flag = \"stop\"\n\n        monkeypatch.setattr(offline_bot, \"initialize\", initialize)\n        monkeypatch.setattr(offline_bot, \"shutdown\", shutdown)\n\n        with pytest.raises(RuntimeError, match=\"initialize\"):\n            async with offline_bot:\n                pass\n\n        assert self.test_flag == \"stop\""
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            633,
                            654
                        ],
                        "reason": "Multiple tests failed due to timeout errors, with the message 'Ignoring TimedOut error: Timed out' appearing frequently. This indicates that the tests are not completing within the expected time frame, which could be due to network issues, inefficient code, or other blocking operations. The specific test 'test_get_updates_deserialization_error' is highlighted in the CI logs as failing due to this timeout.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_get_updates_deserialization_error(self, offline_bot, monkeypatch, caplog):\n        async def faulty_do_request(*args, **kwargs):\n            return (\n                HTTPStatus.OK,\n                b'{\"ok\": true, \"result\": [{\"update_id\": \"1\", \"message\": \"unknown_format\"}]}',\n            )\n\n        monkeypatch.setattr(HTTPXRequest, \"do_request\", faulty_do_request)\n\n        offline_bot = PytestExtBot(get_updates_request=HTTPXRequest(), token=offline_bot.token)\n\n        with caplog.at_level(logging.CRITICAL), pytest.raises(AttributeError):\n            await offline_bot.get_updates()\n\n        assert len(caplog.records) == 1\n        assert caplog.records[0].name == \"telegram.ext.ExtBot\"\n        assert caplog.records[0].levelno == logging.CRITICAL\n        assert caplog.records[0].getMessage() == (\n            \"Error while parsing updates! Received data was \"\n            \"[{'update_id': '1', 'message': 'unknown_format'}]\"\n        )\n        assert caplog.records[0].exc_info[0] is AttributeError"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            656,
                            697
                        ],
                        "reason": "The test 'test_send_contact_default_protect_content' failed due to flood control being exceeded, with a retry delay of 38679 seconds. This indicates that the bot is attempting to send messages too frequently, violating Telegram's flood control limits. This issue is critical as it directly affects the ability to send messages and could lead to further test failures.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_answer_web_app_query(self, offline_bot, raw_bot, monkeypatch):\n        params = False\n\n        # For now just test that our internals pass the correct data\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            nonlocal params\n            params = request_data.parameters == {\n                \"web_app_query_id\": \"12345\",\n                \"result\": {\n                    \"title\": \"title\",\n                    \"input_message_content\": {\n                        \"message_text\": \"text\",\n                    },\n                    \"type\": InlineQueryResultType.ARTICLE,\n                    \"id\": \"1\",\n                },\n            }\n            return SentWebAppMessage(\"321\").to_dict()\n\n        # We test different result types more thoroughly for answer_inline_query, so we just\n        # use the one type here\n        result = InlineQueryResultArticle(\"1\", \"title\", InputTextMessageContent(\"text\"))\n        copied_result = copy.copy(result)\n\n        ext_bot = offline_bot\n        for bot_type in (ext_bot, raw_bot):\n            # We need to test 1) below both the offline_bot and raw_bot and setting this up with\n            # pytest.parametrize appears to be difficult ...\n            monkeypatch.setattr(bot_type.request, \"post\", make_assertion)\n            web_app_msg = await bot_type.answer_web_app_query(\"12345\", result)\n            assert params, \"something went wrong with passing arguments to the request\"\n            assert isinstance(web_app_msg, SentWebAppMessage)\n            assert web_app_msg.inline_message_id == \"321\"\n\n            # 1)\n            # make sure that the results were not edited in-place\n            assert result == copied_result\n            assert (\n                result.input_message_content.parse_mode\n                == copied_result.input_message_content.parse_mode\n            )"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            1201,
                            1235
                        ],
                        "reason": "Multiple tests failed due to timeout errors, with the message 'Ignoring TimedOut error: Timed out' appearing frequently. This indicates that the tests are not completing within the expected time frame, which could be due to network issues, inefficient code, or other blocking operations. The specific tests 'test_send_edit_message_mutually_exclusive_link_preview' and 'test_rtm_aswr_mutually_exclusive_reply_parameters' are highlighted in the CI logs as failing due to this timeout.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_rtm_aswr_mutually_exclusive_reply_parameters(self, offline_bot, chat_id):\n        \"\"\"Test that reply_to_message_id and allow_sending_without_reply are mutually exclusive\n        with reply_parameters.\"\"\"\n        with pytest.raises(ValueError, match=\"`reply_to_message_id` and\"):\n            await offline_bot.send_message(\n                chat_id, \"text\", reply_to_message_id=1, reply_parameters=True\n            )\n\n        with pytest.raises(ValueError, match=\"`allow_sending_without_reply` and\"):\n            await offline_bot.send_message(\n                chat_id, \"text\", allow_sending_without_reply=True, reply_parameters=True\n            )\n\n        # Test with copy message\n        with pytest.raises(ValueError, match=\"`reply_to_message_id` and\"):\n            await offline_bot.copy_message(\n                chat_id, chat_id, 1, reply_to_message_id=1, reply_parameters=True\n            )\n\n        with pytest.raises(ValueError, match=\"`allow_sending_without_reply` and\"):\n            await offline_bot.copy_message(\n                chat_id, chat_id, 1, allow_sending_without_reply=True, reply_parameters=True\n            )\n\n        # Test with send media group\n        media = InputMediaPhoto(\"\")\n        with pytest.raises(ValueError, match=\"`reply_to_message_id` and\"):\n            await offline_bot.send_media_group(\n                chat_id, media, reply_to_message_id=1, reply_parameters=True\n            )\n\n        with pytest.raises(ValueError, match=\"`allow_sending_without_reply` and\"):\n            await offline_bot.send_media_group(\n                chat_id, media, allow_sending_without_reply=True, reply_parameters=True\n            )"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            224,
                            2660
                        ],
                        "reason": "The test 'test_send_contact_default_protect_content' failed due to flood control being exceeded, with a retry delay of 38679 seconds. This indicates that the bot is attempting to send messages too frequently, violating Telegram's flood control limits. This issue is critical as it directly affects the ability to send messages and could lead to further test failures. The tests 'test_ban_chat_member', 'test_ban_chat_member_default_tz', and 'test_ban_chat_sender_chat' are also affected by similar issues.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "class TestBotWithoutRequest:\n    \"\"\"\n    Most are executed on tg.ext.ExtBot, as that class only extends the functionality of tg.bot\n\n    Behavior for init of ExtBot with missing optional dependency cachetools (for CallbackDataCache)\n    is tested in `test_callbackdatacache`\n    \"\"\"\n\n    test_flag = None\n\n    @pytest.fixture(autouse=True)\n    def _reset(self):\n        self.test_flag = None\n\n    @pytest.mark.parametrize(\"bot_class\", [Bot, ExtBot])\n    def test_slot_behaviour(self, bot_class, offline_bot):\n        inst = bot_class(\n            offline_bot.token, request=OfflineRequest(1), get_updates_request=OfflineRequest(1)\n        )\n        for attr in inst.__slots__:\n            assert getattr(inst, attr, \"err\") != \"err\", f\"got extra slot '{attr}'\"\n        assert len(mro_slots(inst)) == len(set(mro_slots(inst))), \"duplicate slot\"\n\n    async def test_no_token_passed(self):\n        with pytest.raises(InvalidToken, match=\"You must pass the token\"):\n            Bot(\"\")\n\n    def test_base_url_parsing_basic(self, caplog):\n        with caplog.at_level(logging.DEBUG):\n            bot = Bot(\n                token=\"!!Test String!!\",\n                base_url=\"base/\",\n                base_file_url=\"base/\",\n                request=OfflineRequest(1),\n                get_updates_request=OfflineRequest(1),\n            )\n\n        assert bot.base_url == \"base/!!Test String!!\"\n        assert bot.base_file_url == \"base/!!Test String!!\"\n\n        assert len(caplog.records) >= 2\n        messages = [record.getMessage() for record in caplog.records]\n        assert \"Set Bot API URL: base/!!Test String!!\" in messages\n        assert \"Set Bot API File URL: base/!!Test String!!\" in messages\n\n    @pytest.mark.parametrize(\n        \"insert_key\", [\"token\", \"TOKEN\", \"bot_token\", \"BOT_TOKEN\", \"bot-token\", \"BOT-TOKEN\"]\n    )\n    def test_base_url_parsing_string_format(self, insert_key, caplog):\n        string = f\"{{{insert_key}}}\"\n\n        with caplog.at_level(logging.DEBUG):\n            bot = Bot(\n                token=\"!!Test String!!\",\n                base_url=string,\n                base_file_url=string,\n                request=OfflineRequest(1),\n                get_updates_request=OfflineRequest(1),\n            )\n\n        assert bot.base_url == \"!!Test String!!\"\n        assert bot.base_file_url == \"!!Test String!!\"\n\n        assert len(caplog.records) >= 2\n        messages = [record.getMessage() for record in caplog.records]\n        assert \"Set Bot API URL: !!Test String!!\" in messages\n        assert \"Set Bot API File URL: !!Test String!!\" in messages\n\n        with pytest.raises(KeyError, match=\"unsupported insertion: unknown\"):\n            Bot(\"token\", base_url=\"{unknown}{token}\")\n\n    def test_base_url_parsing_callable(self, caplog):\n        def build_url(_: str) -> str:\n            return \"!!Test String!!\"\n\n        with caplog.at_level(logging.DEBUG):\n            bot = Bot(\n                token=\"some-token\",\n                base_url=build_url,\n                base_file_url=build_url,\n                request=OfflineRequest(1),\n                get_updates_request=OfflineRequest(1),\n            )\n\n        assert bot.base_url == \"!!Test String!!\"\n        assert bot.base_file_url == \"!!Test String!!\"\n\n        assert len(caplog.records) >= 2\n        messages = [record.getMessage() for record in caplog.records]\n        assert \"Set Bot API URL: !!Test String!!\" in messages\n        assert \"Set Bot API File URL: !!Test String!!\" in messages\n\n    async def test_repr(self):\n        offline_bot = Bot(token=\"some_token\", base_file_url=\"\")\n        assert repr(offline_bot) == \"Bot[token=some_token]\"\n\n    async def test_to_dict(self, offline_bot):\n        to_dict_bot = offline_bot.to_dict()\n\n        assert isinstance(to_dict_bot, dict)\n        assert to_dict_bot[\"id\"] == offline_bot.id\n        assert to_dict_bot[\"username\"] == offline_bot.username\n        assert to_dict_bot[\"first_name\"] == offline_bot.first_name\n        if offline_bot.last_name:\n            assert to_dict_bot[\"last_name\"] == offline_bot.last_name\n\n    async def test_initialize_and_shutdown(self, offline_bot: PytestExtBot, monkeypatch):\n        async def initialize(*args, **kwargs):\n            self.test_flag = [\"initialize\"]\n\n        async def stop(*args, **kwargs):\n            self.test_flag.append(\"stop\")\n\n        temp_bot = PytestBot(token=offline_bot.token, request=OfflineRequest())\n        orig_stop = temp_bot.request.shutdown\n\n        try:\n            monkeypatch.setattr(temp_bot.request, \"initialize\", initialize)\n            monkeypatch.setattr(temp_bot.request, \"shutdown\", stop)\n            await temp_bot.initialize()\n            assert self.test_flag == [\"initialize\"]\n            assert temp_bot.bot == offline_bot.bot\n\n            await temp_bot.shutdown()\n            assert self.test_flag == [\"initialize\", \"stop\"]\n        finally:\n            await orig_stop()\n\n    async def test_multiple_inits_and_shutdowns(self, offline_bot, monkeypatch):\n        self.received = defaultdict(int)\n\n        async def initialize(*args, **kwargs):\n            self.received[\"init\"] += 1\n\n        async def shutdown(*args, **kwargs):\n            self.received[\"shutdown\"] += 1\n\n        monkeypatch.setattr(HTTPXRequest, \"initialize\", initialize)\n        monkeypatch.setattr(HTTPXRequest, \"shutdown\", shutdown)\n\n        test_bot = PytestBot(offline_bot.token)\n        await test_bot.initialize()\n        await test_bot.initialize()\n        await test_bot.initialize()\n        await test_bot.shutdown()\n        await test_bot.shutdown()\n        await test_bot.shutdown()\n\n        # 2 instead of 1 since we have to request objects for each offline_bot\n        assert self.received[\"init\"] == 2\n        assert self.received[\"shutdown\"] == 2\n\n    async def test_context_manager(self, monkeypatch, offline_bot):\n        async def initialize():\n            self.test_flag = [\"initialize\"]\n\n        async def shutdown(*args):\n            self.test_flag.append(\"stop\")\n\n        monkeypatch.setattr(offline_bot, \"initialize\", initialize)\n        monkeypatch.setattr(offline_bot, \"shutdown\", shutdown)\n\n        async with offline_bot:\n            pass\n\n        assert self.test_flag == [\"initialize\", \"stop\"]\n\n    async def test_context_manager_exception_on_init(self, monkeypatch, offline_bot):\n        async def initialize():\n            raise RuntimeError(\"initialize\")\n\n        async def shutdown():\n            self.test_flag = \"stop\"\n\n        monkeypatch.setattr(offline_bot, \"initialize\", initialize)\n        monkeypatch.setattr(offline_bot, \"shutdown\", shutdown)\n\n        with pytest.raises(RuntimeError, match=\"initialize\"):\n            async with offline_bot:\n                pass\n\n        assert self.test_flag == \"stop\"\n\n    async def test_shutdown_at_error_in_request_in_init(self, monkeypatch, offline_bot):\n        async def get_me_error():\n            raise httpx.HTTPError(\"BadRequest wrong token sry :(\")\n\n        async def shutdown(*args):\n            self.test_flag = \"stop\"\n\n        monkeypatch.setattr(offline_bot, \"get_me\", get_me_error)\n        monkeypatch.setattr(offline_bot, \"shutdown\", shutdown)\n\n        async with offline_bot:\n            pass\n\n        assert self.test_flag == \"stop\"\n\n    async def test_equality(self):\n        async with (\n            make_bot(token=FALLBACKS[0][\"token\"]) as a,\n            make_bot(token=FALLBACKS[0][\"token\"]) as b,\n            Bot(token=FALLBACKS[0][\"token\"]) as c,\n            make_bot(token=FALLBACKS[1][\"token\"]) as d,\n        ):\n            e = Update(123456789)\n            f = Bot(token=FALLBACKS[0][\"token\"])\n\n            assert a == b\n            assert hash(a) == hash(b)\n            assert a is not b\n\n            assert a == c\n            assert hash(a) == hash(c)\n\n            assert a != d\n            assert hash(a) != hash(d)\n\n            assert a != e\n            assert hash(a) != hash(e)\n\n            # We cant check equality for unintialized Bot object\n            assert hash(a) != hash(f)\n\n    @pytest.mark.parametrize(\n        \"attribute\",\n        [\n            \"id\",\n            \"username\",\n            \"first_name\",\n            \"last_name\",\n            \"name\",\n            \"can_join_groups\",\n            \"can_read_all_group_messages\",\n            \"supports_inline_queries\",\n            \"link\",\n        ],\n    )\n    async def test_get_me_and_properties_not_initialized(self, attribute):\n        bot = make_bot(offline=True, token=\"randomtoken\")\n        try:\n            with pytest.raises(RuntimeError, match=\"not properly initialized\"):\n                bot[attribute]\n        finally:\n            await bot.shutdown()\n\n    async def test_get_me_and_properties(self, offline_bot):\n        get_me_bot = await ExtBot(offline_bot.token).get_me()\n\n        assert isinstance(get_me_bot, User)\n        assert get_me_bot.id == offline_bot.id\n        assert get_me_bot.username == offline_bot.username\n        assert get_me_bot.first_name == offline_bot.first_name\n        assert get_me_bot.last_name == offline_bot.last_name\n        assert get_me_bot.name == offline_bot.name\n        assert get_me_bot.can_join_groups == offline_bot.can_join_groups\n        assert get_me_bot.can_read_all_group_messages == offline_bot.can_read_all_group_messages\n        assert get_me_bot.supports_inline_queries == offline_bot.supports_inline_queries\n        assert f\"https://t.me/{get_me_bot.username}\" == offline_bot.link\n\n    def test_bot_pickling_error(self, offline_bot):\n        with pytest.raises(pickle.PicklingError, match=\"Bot objects cannot be pickled\"):\n            pickle.dumps(offline_bot)\n\n    def test_bot_deepcopy_error(self, offline_bot):\n        with pytest.raises(TypeError, match=\"Bot objects cannot be deepcopied\"):\n            copy.deepcopy(offline_bot)\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"logger_name\"), [(Bot, \"telegram.Bot\"), (ExtBot, \"telegram.ext.ExtBot\")]\n    )\n    async def test_bot_method_logging(self, offline_bot: PytestExtBot, cls, logger_name, caplog):\n        instance = cls(offline_bot.token)\n        # Second argument makes sure that we ignore logs from e.g. httpx\n        with caplog.at_level(logging.DEBUG, logger=\"telegram\"):\n            await instance.get_me()\n            # Only for stabilizing this test-\n            if len(caplog.records) == 4:\n                for idx, record in enumerate(caplog.records):\n                    print(record)\n                    if record.getMessage().startswith(\"Task was destroyed but it is pending\"):\n                        caplog.records.pop(idx)\n                    if record.getMessage().startswith(\"Task exception was never retrieved\"):\n                        caplog.records.pop(idx)\n            assert len(caplog.records) == 2\n\n            assert all(caplog.records[i].name == logger_name for i in [-1, 0])\n            assert (\n                caplog.records[0]\n                .getMessage()\n                .startswith(\"Calling Bot API endpoint `getMe` with parameters `{}`\")\n            )\n            assert (\n                caplog.records[-1]\n                .getMessage()\n                .startswith(\"Call to Bot API endpoint `getMe` finished with return value\")\n            )\n\n    @bot_methods()\n    def test_camel_case_aliases(self, bot_class, bot_method_name, bot_method):\n        camel_case_name = to_camel_case(bot_method_name)\n        camel_case_function = getattr(bot_class, camel_case_name, False)\n        assert camel_case_function is not False, f\"{camel_case_name} not found\"\n        assert camel_case_function is bot_method, f\"{camel_case_name} is not {bot_method}\"\n\n    @bot_methods(include_do_api_request=True)\n    def test_coroutine_functions(self, bot_class, bot_method_name, bot_method):\n        \"\"\"Check that all offline_bot methods are defined as async def  ...\"\"\"\n        meth = getattr(bot_method, \"__wrapped__\", bot_method)  # to unwrap the @_log decorator\n        assert inspect.iscoroutinefunction(meth), f\"{bot_method_name} must be a coroutine function\"\n\n    @bot_methods(include_do_api_request=True)\n    def test_api_kwargs_and_timeouts_present(self, bot_class, bot_method_name, bot_method):\n        \"\"\"Check that all offline_bot methods have `api_kwargs` and timeout params.\"\"\"\n        param_names = inspect.signature(bot_method).parameters.keys()\n        params = (\"pool_timeout\", \"read_timeout\", \"connect_timeout\", \"write_timeout\", \"api_kwargs\")\n\n        for param in params:\n            assert param in param_names, f\"{bot_method_name} is missing the parameter `{param}`\"\n\n        rate_arg = \"rate_limit_args\"\n        if bot_method_name.replace(\"_\", \"\").lower() != \"getupdates\" and bot_class is ExtBot:\n            assert rate_arg in param_names, f\"{bot_method} is missing the parameter `{rate_arg}`\"\n\n    @bot_methods()\n    async def test_defaults_handling(\n        self,\n        bot_class,\n        bot_method_name: str,\n        bot_method,\n        offline_bot: PytestExtBot,\n        raw_bot: PytestBot,\n    ):\n        \"\"\"\n        Here we check that the offline_bot methods handle tg.ext.Defaults correctly. This has two\n        parts:\n\n        1. Check that ExtBot actually inserts the defaults values correctly\n        2. Check that tg.Bot just replaces `DefaultValue(obj)` with `obj`, i.e. that it doesn't\n            pass any `DefaultValue` instances to Request. See the docstring of\n            tg.Bot._insert_defaults for details on why we need that\n\n        As for most defaults,\n        we can't really check the effect, we just check if we're passing the correct kwargs to\n        Request.post. As offline_bot method tests a scattered across the different test files, we\n        do this here in one place.\n\n        The same test is also run for all the shortcuts (Message.reply_text) etc in the\n        corresponding tests.\n\n        Finally, there are some tests for Defaults.{parse_mode, quote, allow_sending_without_reply}\n        at the appropriate places, as those are the only things we can actually check.\n        \"\"\"\n        # Check that ExtBot does the right thing\n        bot_method = getattr(offline_bot, bot_method_name)\n        raw_bot_method = getattr(raw_bot, bot_method_name)\n        assert await check_defaults_handling(bot_method, offline_bot)\n        assert await check_defaults_handling(raw_bot_method, raw_bot)\n\n    @pytest.mark.parametrize(\n        (\"name\", \"method\"), inspect.getmembers(Bot, predicate=inspect.isfunction)\n    )\n    def test_ext_bot_signature(self, name, method):\n        \"\"\"\n        Here we make sure that all methods of ext.ExtBot have the same signature as the\n        corresponding methods of tg.Bot.\n        \"\"\"\n        # Some methods of ext.ExtBot\n        global_extra_args = {\"rate_limit_args\"}\n        extra_args_per_method = defaultdict(\n            set, {\"__init__\": {\"arbitrary_callback_data\", \"defaults\", \"rate_limiter\"}}\n        )\n        different_hints_per_method = defaultdict(set, {\"__setattr__\": {\"ext_bot\"}})\n\n        signature = inspect.signature(method)\n        ext_signature = inspect.signature(getattr(ExtBot, name))\n\n        assert ext_signature.return_annotation == signature.return_annotation, (\n            f\"Wrong return annotation for method {name}\"\n        )\n        assert (\n            set(signature.parameters)\n            == set(ext_signature.parameters) - global_extra_args - extra_args_per_method[name]\n        ), f\"Wrong set of parameters for method {name}\"\n        for param_name, param in signature.parameters.items():\n            if param_name in different_hints_per_method[name]:\n                continue\n            assert param.annotation == ext_signature.parameters[param_name].annotation, (\n                f\"Wrong annotation for parameter {param_name} of method {name}\"\n            )\n            assert param.default == ext_signature.parameters[param_name].default, (\n                f\"Wrong default value for parameter {param_name} of method {name}\"\n            )\n            assert param.kind == ext_signature.parameters[param_name].kind, (\n                f\"Wrong parameter kind for parameter {param_name} of method {name}\"\n            )\n\n    async def test_unknown_kwargs(self, offline_bot, monkeypatch):\n        async def post(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            if not all([data[\"unknown_kwarg_1\"] == \"7\", data[\"unknown_kwarg_2\"] == \"5\"]):\n                pytest.fail(\"got wrong parameters\")\n            return True\n\n        monkeypatch.setattr(offline_bot.request, \"post\", post)\n        await offline_bot.send_message(\n            123, \"text\", api_kwargs={\"unknown_kwarg_1\": 7, \"unknown_kwarg_2\": 5}\n        )\n\n    async def test_get_updates_deserialization_error(self, offline_bot, monkeypatch, caplog):\n        async def faulty_do_request(*args, **kwargs):\n            return (\n                HTTPStatus.OK,\n                b'{\"ok\": true, \"result\": [{\"update_id\": \"1\", \"message\": \"unknown_format\"}]}',\n            )\n\n        monkeypatch.setattr(HTTPXRequest, \"do_request\", faulty_do_request)\n\n        offline_bot = PytestExtBot(get_updates_request=HTTPXRequest(), token=offline_bot.token)\n\n        with caplog.at_level(logging.CRITICAL), pytest.raises(AttributeError):\n            await offline_bot.get_updates()\n\n        assert len(caplog.records) == 1\n        assert caplog.records[0].name == \"telegram.ext.ExtBot\"\n        assert caplog.records[0].levelno == logging.CRITICAL\n        assert caplog.records[0].getMessage() == (\n            \"Error while parsing updates! Received data was \"\n            \"[{'update_id': '1', 'message': 'unknown_format'}]\"\n        )\n        assert caplog.records[0].exc_info[0] is AttributeError\n\n    async def test_answer_web_app_query(self, offline_bot, raw_bot, monkeypatch):\n        params = False\n\n        # For now just test that our internals pass the correct data\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            nonlocal params\n            params = request_data.parameters == {\n                \"web_app_query_id\": \"12345\",\n                \"result\": {\n                    \"title\": \"title\",\n                    \"input_message_content\": {\n                        \"message_text\": \"text\",\n                    },\n                    \"type\": InlineQueryResultType.ARTICLE,\n                    \"id\": \"1\",\n                },\n            }\n            return SentWebAppMessage(\"321\").to_dict()\n\n        # We test different result types more thoroughly for answer_inline_query, so we just\n        # use the one type here\n        result = InlineQueryResultArticle(\"1\", \"title\", InputTextMessageContent(\"text\"))\n        copied_result = copy.copy(result)\n\n        ext_bot = offline_bot\n        for bot_type in (ext_bot, raw_bot):\n            # We need to test 1) below both the offline_bot and raw_bot and setting this up with\n            # pytest.parametrize appears to be difficult ...\n            monkeypatch.setattr(bot_type.request, \"post\", make_assertion)\n            web_app_msg = await bot_type.answer_web_app_query(\"12345\", result)\n            assert params, \"something went wrong with passing arguments to the request\"\n            assert isinstance(web_app_msg, SentWebAppMessage)\n            assert web_app_msg.inline_message_id == \"321\"\n\n            # 1)\n            # make sure that the results were not edited in-place\n            assert result == copied_result\n            assert (\n                result.input_message_content.parse_mode\n                == copied_result.input_message_content.parse_mode\n            )\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"parse_mode\": \"Markdown\", \"link_preview_options\": LinkPreviewOptions(is_disabled=True)}],\n        indirect=True,\n    )\n    @pytest.mark.parametrize(\n        (\"ilq_result\", \"expected_params\"),\n        [\n            (\n                InlineQueryResultArticle(\"1\", \"title\", InputTextMessageContent(\"text\")),\n                {\n                    \"web_app_query_id\": \"12345\",\n                    \"result\": {\n                        \"title\": \"title\",\n                        \"input_message_content\": {\n                            \"message_text\": \"text\",\n                            \"parse_mode\": \"Markdown\",\n                            \"link_preview_options\": {\n                                \"is_disabled\": True,\n                            },\n                        },\n                        \"type\": InlineQueryResultType.ARTICLE,\n                        \"id\": \"1\",\n                    },\n                },\n            ),\n            (\n                InlineQueryResultArticle(\n                    \"1\",\n                    \"title\",\n                    InputTextMessageContent(\n                        \"text\", parse_mode=\"HTML\", disable_web_page_preview=False\n                    ),\n                ),\n                {\n                    \"web_app_query_id\": \"12345\",\n                    \"result\": {\n                        \"title\": \"title\",\n                        \"input_message_content\": {\n                            \"message_text\": \"text\",\n                            \"parse_mode\": \"HTML\",\n                            \"link_preview_options\": {\n                                \"is_disabled\": False,\n                            },\n                        },\n                        \"type\": InlineQueryResultType.ARTICLE,\n                        \"id\": \"1\",\n                    },\n                },\n            ),\n            (\n                InlineQueryResultArticle(\n                    \"1\",\n                    \"title\",\n                    InputTextMessageContent(\n                        \"text\", parse_mode=None, disable_web_page_preview=\"False\"\n                    ),\n                ),\n                {\n                    \"web_app_query_id\": \"12345\",\n                    \"result\": {\n                        \"title\": \"title\",\n                        \"input_message_content\": {\n                            \"message_text\": \"text\",\n                            \"link_preview_options\": {\n                                \"is_disabled\": \"False\",\n                            },\n                        },\n                        \"type\": InlineQueryResultType.ARTICLE,\n                        \"id\": \"1\",\n                    },\n                },\n            ),\n        ],\n    )\n    async def test_answer_web_app_query_defaults(\n        self, default_bot, ilq_result, expected_params, monkeypatch\n    ):\n        offline_bot = default_bot\n        params = False\n\n        # For now just test that our internals pass the correct data\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            nonlocal params\n            params = request_data.parameters == expected_params\n            return SentWebAppMessage(\"321\").to_dict()\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        # We test different result types more thoroughly for answer_inline_query, so we just\n        # use the one type here\n        copied_result = copy.copy(ilq_result)\n\n        web_app_msg = await offline_bot.answer_web_app_query(\"12345\", ilq_result)\n        assert params, \"something went wrong with passing arguments to the request\"\n        assert isinstance(web_app_msg, SentWebAppMessage)\n        assert web_app_msg.inline_message_id == \"321\"\n\n        # make sure that the results were not edited in-place\n        assert ilq_result == copied_result\n        assert (\n            ilq_result.input_message_content.parse_mode\n            == copied_result.input_message_content.parse_mode\n        )\n\n    # TODO: Needs improvement. We need incoming inline query to test answer.\n    @pytest.mark.parametrize(\"button_type\", [\"start\", \"web_app\"])\n    @pytest.mark.parametrize(\"cache_time\", [74, dtm.timedelta(seconds=74)])\n    async def test_answer_inline_query(\n        self, monkeypatch, offline_bot, raw_bot, button_type, cache_time\n    ):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            expected = {\n                \"cache_time\": 74,\n                \"results\": [\n                    {\n                        \"title\": \"first\",\n                        \"id\": \"11\",\n                        \"type\": \"article\",\n                        \"input_message_content\": {\"message_text\": \"first\"},\n                    },\n                    {\n                        \"title\": \"second\",\n                        \"id\": \"12\",\n                        \"type\": \"article\",\n                        \"input_message_content\": {\"message_text\": \"second\"},\n                    },\n                    {\n                        \"title\": \"test_result\",\n                        \"id\": \"123\",\n                        \"type\": \"document\",\n                        \"document_url\": (\n                            \"https://raw.githubusercontent.com/python-telegram-bot\"\n                            \"/logos/master/logo/png/ptb-logo_240.png\"\n                        ),\n                        \"mime_type\": \"image/png\",\n                        \"caption\": \"ptb_logo\",\n                        \"input_message_content\": {\"message_text\": \"imc\"},\n                    },\n                ],\n                \"next_offset\": \"42\",\n                \"inline_query_id\": 1234,\n                \"is_personal\": True,\n            }\n\n            if button_type == \"start\":\n                button_dict = {\"text\": \"button_text\", \"start_parameter\": \"start_parameter\"}\n            else:\n                button_dict = {\n                    \"text\": \"button_text\",\n                    \"web_app\": {\"url\": \"https://python-telegram-bot.org\"},\n                }\n\n            expected[\"button\"] = button_dict\n\n            return request_data.parameters == expected\n\n        results = [\n            InlineQueryResultArticle(\"11\", \"first\", InputTextMessageContent(\"first\")),\n            InlineQueryResultArticle(\"12\", \"second\", InputMessageContentLPO(\"second\")),\n            InlineQueryResultDocument(\n                id=\"123\",\n                document_url=(\n                    \"https://raw.githubusercontent.com/python-telegram-bot/logos/master/\"\n                    \"logo/png/ptb-logo_240.png\"\n                ),\n                title=\"test_result\",\n                mime_type=\"image/png\",\n                caption=\"ptb_logo\",\n                input_message_content=InputMessageContentLPO(\"imc\"),\n            ),\n        ]\n\n        if button_type == \"start\":\n            button = InlineQueryResultsButton(\n                text=\"button_text\", start_parameter=\"start_parameter\"\n            )\n        elif button_type == \"web_app\":\n            button = InlineQueryResultsButton(\n                text=\"button_text\", web_app=WebAppInfo(\"https://python-telegram-bot.org\")\n            )\n        else:\n            button = None\n\n        copied_results = copy.copy(results)\n        ext_bot = offline_bot\n        for bot_type in (ext_bot, raw_bot):\n            # We need to test 1) below both the offline_bot and raw_bot and setting this up with\n            # pytest.parametrize appears to be difficult ...\n            monkeypatch.setattr(bot_type.request, \"post\", make_assertion)\n            assert await bot_type.answer_inline_query(\n                1234,\n                results=results,\n                cache_time=cache_time,\n                is_personal=True,\n                next_offset=\"42\",\n                button=button,\n            )\n\n            # 1)\n            # make sure that the results were not edited in-place\n            assert results == copied_results\n            for idx, result in enumerate(results):\n                if hasattr(result, \"parse_mode\"):\n                    assert result.parse_mode == copied_results[idx].parse_mode\n                if hasattr(result, \"input_message_content\"):\n                    assert getattr(result.input_message_content, \"parse_mode\", None) == getattr(\n                        copied_results[idx].input_message_content, \"parse_mode\", None\n                    )\n                    assert getattr(\n                        result.input_message_content, \"disable_web_page_preview\", None\n                    ) == getattr(\n                        copied_results[idx].input_message_content, \"disable_web_page_preview\", None\n                    )\n\n            monkeypatch.delattr(bot_type.request, \"post\")\n\n    async def test_answer_inline_query_no_default_parse_mode(self, monkeypatch, offline_bot):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\n                \"cache_time\": 300,\n                \"results\": [\n                    {\n                        \"title\": \"first\",\n                        \"id\": \"11\",\n                        \"type\": \"article\",\n                        \"input_message_content\": {\"message_text\": \"first\"},\n                    },\n                    {\n                        \"title\": \"second\",\n                        \"id\": \"12\",\n                        \"type\": \"article\",\n                        \"input_message_content\": {\"message_text\": \"second\"},\n                    },\n                    {\n                        \"title\": \"test_result\",\n                        \"id\": \"123\",\n                        \"type\": \"document\",\n                        \"document_url\": (\n                            \"https://raw.githubusercontent.com/\"\n                            \"python-telegram-bot/logos/master/logo/png/\"\n                            \"ptb-logo_240.png\"\n                        ),\n                        \"mime_type\": \"image/png\",\n                        \"caption\": \"ptb_logo\",\n                        \"input_message_content\": {\"message_text\": \"imc\"},\n                    },\n                ],\n                \"next_offset\": \"42\",\n                \"inline_query_id\": 1234,\n                \"is_personal\": True,\n            }\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        results = [\n            InlineQueryResultArticle(\"11\", \"first\", InputTextMessageContent(\"first\")),\n            InlineQueryResultArticle(\"12\", \"second\", InputMessageContentLPO(\"second\")),\n            InlineQueryResultDocument(\n                id=\"123\",\n                document_url=(\n                    \"https://raw.githubusercontent.com/python-telegram-bot/logos/master/\"\n                    \"logo/png/ptb-logo_240.png\"\n                ),\n                title=\"test_result\",\n                mime_type=\"image/png\",\n                caption=\"ptb_logo\",\n                input_message_content=InputMessageContentLPO(\"imc\"),\n            ),\n        ]\n\n        copied_results = copy.copy(results)\n        assert await offline_bot.answer_inline_query(\n            1234,\n            results=results,\n            cache_time=300,\n            is_personal=True,\n            next_offset=\"42\",\n        )\n        # make sure that the results were not edited in-place\n        assert results == copied_results\n        for idx, result in enumerate(results):\n            if hasattr(result, \"parse_mode\"):\n                assert result.parse_mode == copied_results[idx].parse_mode\n            if hasattr(result, \"input_message_content\"):\n                assert getattr(result.input_message_content, \"parse_mode\", None) == getattr(\n                    copied_results[idx].input_message_content, \"parse_mode\", None\n                )\n                assert getattr(\n                    result.input_message_content, \"disable_web_page_preview\", None\n                ) == getattr(\n                    copied_results[idx].input_message_content, \"disable_web_page_preview\", None\n                )\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"parse_mode\": \"Markdown\", \"link_preview_options\": LinkPreviewOptions(is_disabled=True)}],\n        indirect=True,\n    )\n    async def test_answer_inline_query_default_parse_mode(self, monkeypatch, default_bot):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\n                \"cache_time\": 300,\n                \"results\": [\n                    {\n                        \"title\": \"first\",\n                        \"id\": \"11\",\n                        \"type\": InlineQueryResultType.ARTICLE,\n                        \"input_message_content\": {\n                            \"message_text\": \"first\",\n                            \"parse_mode\": \"Markdown\",\n                            \"link_preview_options\": {\n                                \"is_disabled\": True,\n                            },\n                        },\n                    },\n                    {\n                        \"title\": \"second\",\n                        \"id\": \"12\",\n                        \"type\": InlineQueryResultType.ARTICLE,\n                        \"input_message_content\": {\n                            \"message_text\": \"second\",\n                            \"link_preview_options\": {\n                                \"is_disabled\": True,\n                            },\n                        },\n                    },\n                    {\n                        \"title\": \"test_result\",\n                        \"id\": \"123\",\n                        \"type\": InlineQueryResultType.DOCUMENT,\n                        \"document_url\": (\n                            \"https://raw.githubusercontent.com/\"\n                            \"python-telegram-bot/logos/master/logo/png/\"\n                            \"ptb-logo_240.png\"\n                        ),\n                        \"mime_type\": \"image/png\",\n                        \"caption\": \"ptb_logo\",\n                        \"parse_mode\": \"Markdown\",\n                        \"input_message_content\": {\n                            \"message_text\": \"imc\",\n                            \"link_preview_options\": {\n                                \"is_disabled\": True,\n                            },\n                            \"parse_mode\": \"Markdown\",\n                        },\n                    },\n                ],\n                \"next_offset\": \"42\",\n                \"inline_query_id\": 1234,\n                \"is_personal\": True,\n            }\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        results = [\n            InlineQueryResultArticle(\"11\", \"first\", InputTextMessageContent(\"first\")),\n            InlineQueryResultArticle(\"12\", \"second\", InputMessageContentLPO(\"second\")),\n            InlineQueryResultDocument(\n                id=\"123\",\n                document_url=(\n                    \"https://raw.githubusercontent.com/python-telegram-bot/logos/master/\"\n                    \"logo/png/ptb-logo_240.png\"\n                ),\n                title=\"test_result\",\n                mime_type=\"image/png\",\n                caption=\"ptb_logo\",\n                input_message_content=InputTextMessageContent(\"imc\"),\n            ),\n        ]\n\n        copied_results = copy.copy(results)\n        assert await default_bot.answer_inline_query(\n            1234,\n            results=results,\n            cache_time=300,\n            is_personal=True,\n            next_offset=\"42\",\n        )\n        # make sure that the results were not edited in-place\n        assert results == copied_results\n        for idx, result in enumerate(results):\n            if hasattr(result, \"parse_mode\"):\n                assert result.parse_mode == copied_results[idx].parse_mode\n            if hasattr(result, \"input_message_content\"):\n                assert getattr(result.input_message_content, \"parse_mode\", None) == getattr(\n                    copied_results[idx].input_message_content, \"parse_mode\", None\n                )\n                assert getattr(\n                    result.input_message_content, \"disable_web_page_preview\", None\n                ) == getattr(\n                    copied_results[idx].input_message_content, \"disable_web_page_preview\", None\n                )\n\n    @pytest.mark.parametrize(\n        (\"current_offset\", \"num_results\", \"id_offset\", \"expected_next_offset\"),\n        [\n            (\"\", InlineQueryLimit.RESULTS, 1, 1),\n            (1, InlineQueryLimit.RESULTS, 51, 2),\n            (5, 3, 251, \"\"),\n        ],\n    )\n    async def test_answer_inline_query_current_offset_1(\n        self,\n        monkeypatch,\n        offline_bot,\n        inline_results,\n        current_offset,\n        num_results,\n        id_offset,\n        expected_next_offset,\n    ):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            results = data[\"results\"]\n            length_matches = len(results) == num_results\n            ids_match = all(int(res[\"id\"]) == id_offset + i for i, res in enumerate(results))\n            next_offset_matches = data[\"next_offset\"] == str(expected_next_offset)\n            return length_matches and ids_match and next_offset_matches\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.answer_inline_query(\n            1234, results=inline_results, current_offset=current_offset\n        )\n\n    async def test_answer_inline_query_current_offset_2(\n        self, monkeypatch, offline_bot, inline_results\n    ):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            results = data[\"results\"]\n            length_matches = len(results) == InlineQueryLimit.RESULTS\n            ids_match = all(int(res[\"id\"]) == 1 + i for i, res in enumerate(results))\n            next_offset_matches = data[\"next_offset\"] == \"1\"\n            return length_matches and ids_match and next_offset_matches\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.answer_inline_query(\n            1234, results=inline_results, current_offset=0\n        )\n\n        inline_results = inline_results[:30]\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            results = data[\"results\"]\n            length_matches = len(results) == 30\n            ids_match = all(int(res[\"id\"]) == 1 + i for i, res in enumerate(results))\n            next_offset_matches = not data[\"next_offset\"]\n            return length_matches and ids_match and next_offset_matches\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.answer_inline_query(\n            1234, results=inline_results, current_offset=0\n        )\n\n    async def test_answer_inline_query_current_offset_callback(self, monkeypatch, offline_bot):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            results = data[\"results\"]\n            length = len(results) == 5\n            ids = all(int(res[\"id\"]) == 6 + i for i, res in enumerate(results))\n            next_offset = data[\"next_offset\"] == \"2\"\n            return length and ids and next_offset\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.answer_inline_query(\n            1234, results=inline_results_callback, current_offset=1\n        )\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            results = data[\"results\"]\n            length = results == []\n            next_offset = not data[\"next_offset\"]\n            return length and next_offset\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.answer_inline_query(\n            1234, results=inline_results_callback, current_offset=6\n        )\n\n    async def test_send_edit_message_mutually_exclusive_link_preview(self, offline_bot, chat_id):\n        \"\"\"Test that link_preview is mutually exclusive with disable_web_page_preview.\"\"\"\n        with pytest.raises(ValueError, match=\"`link_preview_options` are mutually exclusive\"):\n            await offline_bot.send_message(\n                chat_id, \"text\", disable_web_page_preview=True, link_preview_options=\"something\"\n            )\n\n        with pytest.raises(ValueError, match=\"`link_preview_options` are mutually exclusive\"):\n            await offline_bot.edit_message_text(\n                \"text\", chat_id, 1, disable_web_page_preview=True, link_preview_options=\"something\"\n            )\n\n    async def test_rtm_aswr_mutually_exclusive_reply_parameters(self, offline_bot, chat_id):\n        \"\"\"Test that reply_to_message_id and allow_sending_without_reply are mutually exclusive\n        with reply_parameters.\"\"\"\n        with pytest.raises(ValueError, match=\"`reply_to_message_id` and\"):\n            await offline_bot.send_message(\n                chat_id, \"text\", reply_to_message_id=1, reply_parameters=True\n            )\n\n        with pytest.raises(ValueError, match=\"`allow_sending_without_reply` and\"):\n            await offline_bot.send_message(\n                chat_id, \"text\", allow_sending_without_reply=True, reply_parameters=True\n            )\n\n        # Test with copy message\n        with pytest.raises(ValueError, match=\"`reply_to_message_id` and\"):\n            await offline_bot.copy_message(\n                chat_id, chat_id, 1, reply_to_message_id=1, reply_parameters=True\n            )\n\n        with pytest.raises(ValueError, match=\"`allow_sending_without_reply` and\"):\n            await offline_bot.copy_message(\n                chat_id, chat_id, 1, allow_sending_without_reply=True, reply_parameters=True\n            )\n\n        # Test with send media group\n        media = InputMediaPhoto(\"\")\n        with pytest.raises(ValueError, match=\"`reply_to_message_id` and\"):\n            await offline_bot.send_media_group(\n                chat_id, media, reply_to_message_id=1, reply_parameters=True\n            )\n\n        with pytest.raises(ValueError, match=\"`allow_sending_without_reply` and\"):\n            await offline_bot.send_media_group(\n                chat_id, media, allow_sending_without_reply=True, reply_parameters=True\n            )\n\n    # get_file is tested multiple times in the test_*media* modules.\n    # Here we only test the behaviour for offline_bot apis in local mode\n    async def test_get_file_local_mode(self, offline_bot, monkeypatch):\n        path = str(data_file(\"game.gif\"))\n\n        async def make_assertion(*args, **kwargs):\n            return {\n                \"file_id\": None,\n                \"file_unique_id\": None,\n                \"file_size\": None,\n                \"file_path\": path,\n            }\n\n        monkeypatch.setattr(offline_bot, \"_post\", make_assertion)\n\n        resulting_path = (await offline_bot.get_file(\"file_id\")).file_path\n        assert offline_bot.token not in resulting_path\n        assert resulting_path == path\n\n    # TODO: Needs improvement. No feasible way to test until bots can add members.\n    async def test_ban_chat_member(self, monkeypatch, offline_bot):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            chat_id = data[\"chat_id\"] == \"2\"\n            user_id = data[\"user_id\"] == \"32\"\n            until_date = data.get(\"until_date\", \"1577887200\") == \"1577887200\"\n            revoke_msgs = data.get(\"revoke_messages\", \"true\") == \"true\"\n            return chat_id and user_id and until_date and revoke_msgs\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        until = from_timestamp(1577887200)\n\n        assert await offline_bot.ban_chat_member(2, 32)\n        assert await offline_bot.ban_chat_member(2, 32, until_date=until)\n        assert await offline_bot.ban_chat_member(2, 32, until_date=1577887200)\n        assert await offline_bot.ban_chat_member(2, 32, revoke_messages=True)\n\n    async def test_ban_chat_member_default_tz(self, monkeypatch, tz_bot):\n        until = dtm.datetime(2020, 1, 11, 16, 13)\n        until_timestamp = to_timestamp(until, tzinfo=tz_bot.defaults.tzinfo)\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            user_id = data[\"user_id\"] == 32\n            until_date = data.get(\"until_date\", until_timestamp) == until_timestamp\n            return chat_id and user_id and until_date\n\n        monkeypatch.setattr(tz_bot.request, \"post\", make_assertion)\n\n        assert await tz_bot.ban_chat_member(2, 32)\n        assert await tz_bot.ban_chat_member(2, 32, until_date=until)\n        assert await tz_bot.ban_chat_member(2, 32, until_date=until_timestamp)\n\n    async def test_ban_chat_sender_chat(self, monkeypatch, offline_bot):\n        # For now, we just test that we pass the correct data to TG\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            sender_chat_id = data[\"sender_chat_id\"] == 32\n            return chat_id and sender_chat_id\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.ban_chat_sender_chat(2, 32)\n\n    # TODO: Needs improvement.\n    @pytest.mark.parametrize(\"only_if_banned\", [True, False, None])\n    async def test_unban_chat_member(self, monkeypatch, offline_bot, only_if_banned):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            user_id = data[\"user_id\"] == 32\n            o_i_b = data.get(\"only_if_banned\", None) == only_if_banned\n            return chat_id and user_id and o_i_b\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.unban_chat_member(2, 32, only_if_banned=only_if_banned)\n\n    async def test_unban_chat_sender_chat(self, monkeypatch, offline_bot):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            chat_id = data[\"chat_id\"] == \"2\"\n            sender_chat_id = data[\"sender_chat_id\"] == \"32\"\n            return chat_id and sender_chat_id\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.unban_chat_sender_chat(2, 32)\n\n    async def test_set_chat_permissions(self, monkeypatch, offline_bot, chat_permissions):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            chat_id = data[\"chat_id\"] == \"2\"\n            permissions = data[\"permissions\"] == chat_permissions.to_json()\n            use_independent_chat_permissions = data[\"use_independent_chat_permissions\"]\n            return chat_id and permissions and use_independent_chat_permissions\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.set_chat_permissions(2, chat_permissions, True)\n\n    async def test_set_chat_administrator_custom_title(self, monkeypatch, offline_bot):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            user_id = data[\"user_id\"] == 32\n            custom_title = data[\"custom_title\"] == \"custom_title\"\n            return chat_id and user_id and custom_title\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.set_chat_administrator_custom_title(2, 32, \"custom_title\")\n\n    # TODO: Needs improvement. Need an incoming callbackquery to test\n    @pytest.mark.parametrize(\"cache_time\", [74, dtm.timedelta(seconds=74)])\n    async def test_answer_callback_query(self, monkeypatch, offline_bot, cache_time):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\n                \"callback_query_id\": 23,\n                \"show_alert\": True,\n                \"url\": \"no_url\",\n                \"cache_time\": 74,\n                \"text\": \"answer\",\n            }\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.answer_callback_query(\n            23, text=\"answer\", show_alert=True, url=\"no_url\", cache_time=cache_time\n        )\n\n    @pytest.mark.parametrize(\"drop_pending_updates\", [True, False])\n    async def test_set_webhook_delete_webhook_drop_pending_updates(\n        self, offline_bot, drop_pending_updates, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            return data.get(\"drop_pending_updates\") == drop_pending_updates\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.set_webhook(\"\", drop_pending_updates=drop_pending_updates)\n        assert await offline_bot.delete_webhook(drop_pending_updates=drop_pending_updates)\n\n    @pytest.mark.parametrize(\"local_file\", [\"str\", \"Path\", False])\n    async def test_set_webhook_params(self, offline_bot, monkeypatch, local_file):\n        # actually making calls to TG is done in\n        # test_set_webhook_get_webhook_info_and_delete_webhook. Sadly secret_token can't be tested\n        # there so we have this function \\o/\n        async def make_assertion(*args, **_):\n            kwargs = args[1]\n\n            if local_file is False:\n                cert_assertion = (\n                    kwargs[\"certificate\"].input_file_content\n                    == data_file(\"sslcert.pem\").read_bytes()\n                )\n            else:\n                cert_assertion = data_file(\"sslcert.pem\").as_uri()\n\n            return (\n                kwargs[\"url\"] == \"example.com\"\n                and cert_assertion\n                and kwargs[\"max_connections\"] == 7\n                and kwargs[\"allowed_updates\"] == [\"messages\"]\n                and kwargs[\"ip_address\"] == \"127.0.0.1\"\n                and kwargs[\"drop_pending_updates\"]\n                and kwargs[\"secret_token\"] == \"SoSecretToken\"\n            )\n\n        monkeypatch.setattr(offline_bot, \"_post\", make_assertion)\n\n        cert_path = data_file(\"sslcert.pem\")\n        if local_file == \"str\":\n            certificate = str(cert_path)\n        elif local_file == \"Path\":\n            certificate = cert_path\n        else:\n            certificate = cert_path.read_bytes()\n\n        assert await offline_bot.set_webhook(\n            \"example.com\",\n            certificate,\n            7,\n            [\"messages\"],\n            \"127.0.0.1\",\n            True,\n            \"SoSecretToken\",\n        )\n\n    # TODO: Needs improvement. Need incoming shipping queries to test\n    async def test_answer_shipping_query_ok(self, monkeypatch, offline_bot):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\n                \"shipping_query_id\": 1,\n                \"ok\": True,\n                \"shipping_options\": [\n                    {\"title\": \"option1\", \"prices\": [{\"label\": \"price\", \"amount\": 100}], \"id\": 1}\n                ],\n            }\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        shipping_options = ShippingOption(1, \"option1\", [LabeledPrice(\"price\", 100)])\n        assert await offline_bot.answer_shipping_query(\n            1, True, shipping_options=[shipping_options]\n        )\n\n    async def test_answer_shipping_query_error_message(self, monkeypatch, offline_bot):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\n                \"shipping_query_id\": 1,\n                \"error_message\": \"Not enough fish\",\n                \"ok\": False,\n            }\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.answer_shipping_query(1, False, error_message=\"Not enough fish\")\n\n    # TODO: Needs improvement. Need incoming pre checkout queries to test\n    async def test_answer_pre_checkout_query_ok(self, monkeypatch, offline_bot):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\"pre_checkout_query_id\": 1, \"ok\": True}\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.answer_pre_checkout_query(1, True)\n\n    async def test_answer_pre_checkout_query_error_message(self, monkeypatch, offline_bot):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\n                \"pre_checkout_query_id\": 1,\n                \"error_message\": \"Not enough fish\",\n                \"ok\": False,\n            }\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.answer_pre_checkout_query(\n            1, False, error_message=\"Not enough fish\"\n        )\n\n    async def test_restrict_chat_member(self, offline_bot, chat_permissions, monkeypatch):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            chat_id = data[\"chat_id\"] == \"@chat\"\n            user_id = data[\"user_id\"] == \"2\"\n            permissions = data[\"permissions\"] == chat_permissions.to_json()\n            until_date = data[\"until_date\"] == \"200\"\n            use_independent_chat_permissions = data[\"use_independent_chat_permissions\"]\n            return (\n                chat_id\n                and user_id\n                and permissions\n                and until_date\n                and use_independent_chat_permissions\n            )\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.restrict_chat_member(\"@chat\", 2, chat_permissions, 200, True)\n\n    async def test_restrict_chat_member_default_tz(\n        self, monkeypatch, tz_bot, channel_id, chat_permissions\n    ):\n        until = dtm.datetime(2020, 1, 11, 16, 13)\n        until_timestamp = to_timestamp(until, tzinfo=tz_bot.defaults.tzinfo)\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters.get(\"until_date\", until_timestamp) == until_timestamp\n\n        monkeypatch.setattr(tz_bot.request, \"post\", make_assertion)\n\n        assert await tz_bot.restrict_chat_member(channel_id, 95205500, chat_permissions)\n        assert await tz_bot.restrict_chat_member(\n            channel_id, 95205500, chat_permissions, until_date=until\n        )\n        assert await tz_bot.restrict_chat_member(\n            channel_id, 95205500, chat_permissions, until_date=until_timestamp\n        )\n\n    @pytest.mark.parametrize(\"local_mode\", [True, False])\n    async def test_set_chat_photo_local_files(\n        self, dummy_message_dict, monkeypatch, offline_bot, chat_id, local_mode\n    ):\n        try:\n            offline_bot._local_mode = local_mode\n            # For just test that the correct paths are passed as we have no local Bot API set up\n            self.test_flag = False\n            file = data_file(\"telegram.jpg\")\n            expected = file.as_uri()\n\n            async def make_assertion(_, data, *args, **kwargs):\n                if local_mode:\n                    self.test_flag = data.get(\"photo\") == expected\n                else:\n                    self.test_flag = isinstance(data.get(\"photo\"), InputFile)\n\n            monkeypatch.setattr(offline_bot, \"_post\", make_assertion)\n            await offline_bot.set_chat_photo(chat_id, file)\n            assert self.test_flag\n        finally:\n            offline_bot._local_mode = False\n\n    async def test_timeout_propagation_explicit(self, monkeypatch, offline_bot, chat_id):\n        # Use BaseException that's not a subclass of Exception such that\n        # OkException should not be caught anywhere\n        class OkException(BaseException):\n            pass\n\n        timeout = 42\n\n        async def do_request(*args, **kwargs):\n            obj = kwargs.get(\"read_timeout\")\n            if obj == timeout:\n                raise OkException\n\n            return 200, b'{\"ok\": true, \"result\": []}'\n\n        monkeypatch.setattr(offline_bot.request, \"do_request\", do_request)\n\n        # Test file uploading\n        with pytest.raises(OkException):\n            await offline_bot.send_photo(\n                chat_id, data_file(\"telegram.jpg\").open(\"rb\"), read_timeout=timeout\n            )\n\n        # Test JSON submission\n        with pytest.raises(OkException):\n            await offline_bot.get_chat_administrators(chat_id, read_timeout=timeout)\n\n    async def test_timeout_propagation_implicit(self, monkeypatch, offline_bot, chat_id):\n        # Use BaseException that's not a subclass of Exception such that\n        # OkException should not be caught anywhere\n        class OkException(BaseException):\n            pass\n\n        async def request(*args, **kwargs):\n            timeout = kwargs.get(\"timeout\")\n            if timeout.write == 20:\n                raise OkException\n\n            return 200, b'{\"ok\": true, \"result\": []}'\n\n        monkeypatch.setattr(httpx.AsyncClient, \"request\", request)\n        monkeypatch.setattr(offline_bot, \"_request\", (object(), HTTPXRequest()))\n\n        # Test file uploading\n        with pytest.raises(OkException):\n            await offline_bot.send_photo(chat_id, data_file(\"telegram.jpg\").open(\"rb\"))\n\n    async def test_log_out(self, monkeypatch, offline_bot):\n        # We don't actually make a request as to not break the test setup\n        async def assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.json_parameters == {} and url.split(\"/\")[-1] == \"logOut\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", assertion)\n\n        assert await offline_bot.log_out()\n\n    async def test_close(self, monkeypatch, offline_bot):\n        # We don't actually make a request as to not break the test setup\n        async def assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.json_parameters == {} and url.split(\"/\")[-1] == \"close\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", assertion)\n\n        assert await offline_bot.close()\n\n    @pytest.mark.parametrize(\"json_keyboard\", [True, False])\n    @pytest.mark.parametrize(\"caption\", [\"<b>Test</b>\", \"\", None])\n    async def test_copy_message(\n        self, monkeypatch, offline_bot, chat_id, media_message, json_keyboard, caption\n    ):\n        keyboard = InlineKeyboardMarkup(\n            [[InlineKeyboardButton(text=\"test\", callback_data=\"test2\")]]\n        )\n\n        async def post(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            if not all(\n                [\n                    data[\"chat_id\"] == chat_id,\n                    data[\"from_chat_id\"] == chat_id,\n                    data[\"message_id\"] == media_message.message_id,\n                    data.get(\"caption\") == caption,\n                    data[\"parse_mode\"] == ParseMode.HTML,\n                    data[\"reply_parameters\"]\n                    == ReplyParameters(message_id=media_message.message_id).to_dict(),\n                    (\n                        data[\"reply_markup\"] == keyboard.to_json()\n                        if json_keyboard\n                        else keyboard.to_dict()\n                    ),\n                    data[\"disable_notification\"] is True,\n                    data[\"caption_entities\"]\n                    == [MessageEntity(MessageEntity.BOLD, 0, 4).to_dict()],\n                    data[\"protect_content\"] is True,\n                    data[\"message_thread_id\"] == 1,\n                    data[\"video_start_timestamp\"] == 999,\n                ]\n            ):\n                pytest.fail(\"I got wrong parameters in post\")\n            return data\n\n        monkeypatch.setattr(offline_bot.request, \"post\", post)\n        await offline_bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=caption,\n            video_start_timestamp=999,\n            caption_entities=[MessageEntity(MessageEntity.BOLD, 0, 4)],\n            parse_mode=ParseMode.HTML,\n            reply_to_message_id=media_message.message_id,\n            reply_markup=keyboard.to_json() if json_keyboard else keyboard,\n            disable_notification=True,\n            protect_content=True,\n            message_thread_id=1,\n        )\n\n    # In the following tests we check that get_updates inserts callback data correctly if necessary\n    # The same must be done in the webhook updater. This is tested over at test_updater.py, but\n    # here we test more extensively.\n\n    @pytest.mark.parametrize(\n        (\"acd_in\", \"maxsize\"),\n        [(True, 1024), (False, 1024), (0, 0), (None, None)],\n    )\n    async def test_callback_data_maxsize(self, bot_info, acd_in, maxsize):\n        async with make_bot(bot_info, arbitrary_callback_data=acd_in, offline=True) as acd_bot:\n            if acd_in is not False:\n                assert acd_bot.callback_data_cache.maxsize == maxsize\n            else:\n                assert acd_bot.callback_data_cache is None\n\n    async def test_arbitrary_callback_data_no_insert(self, monkeypatch, cdc_bot):\n        \"\"\"Updates that don't need insertion shouldn't fail obviously\"\"\"\n        offline_bot = cdc_bot\n\n        async def post(*args, **kwargs):\n            update = Update(\n                17,\n                poll=Poll(\n                    \"42\",\n                    \"question\",\n                    options=[PollOption(\"option\", 0)],\n                    total_voter_count=0,\n                    is_closed=False,\n                    is_anonymous=True,\n                    type=Poll.REGULAR,\n                    allows_multiple_answers=False,\n                ),\n            )\n            return [update.to_dict()]\n\n        try:\n            monkeypatch.setattr(BaseRequest, \"post\", post)\n            updates = await offline_bot.get_updates(timeout=1)\n\n            assert len(updates) == 1\n            assert updates[0].update_id == 17\n            assert updates[0].poll.id == \"42\"\n        finally:\n            offline_bot.callback_data_cache.clear_callback_data()\n            offline_bot.callback_data_cache.clear_callback_queries()\n\n    @pytest.mark.parametrize(\n        \"message_type\", [\"channel_post\", \"edited_channel_post\", \"message\", \"edited_message\"]\n    )\n    async def test_arbitrary_callback_data_pinned_message_reply_to_message(\n        self, cdc_bot, monkeypatch, message_type\n    ):\n        offline_bot = cdc_bot\n\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"callback_data\")\n        )\n\n        message = Message(\n            1,\n            dtm.datetime.utcnow(),\n            get_dummy_object(Chat),\n            reply_markup=offline_bot.callback_data_cache.process_keyboard(reply_markup),\n        )\n        message._unfreeze()\n        # We do to_dict -> de_json to make sure those aren't the same objects\n        message.pinned_message = Message.de_json(message.to_dict(), offline_bot)\n\n        async def post(*args, **kwargs):\n            update = Update(\n                17,\n                **{\n                    message_type: Message(\n                        1,\n                        dtm.datetime.utcnow(),\n                        get_dummy_object(Chat),\n                        pinned_message=message,\n                        reply_to_message=Message.de_json(message.to_dict(), offline_bot),\n                    )\n                },\n            )\n            return [update.to_dict()]\n\n        try:\n            monkeypatch.setattr(BaseRequest, \"post\", post)\n            updates = await offline_bot.get_updates(timeout=1)\n\n            assert isinstance(updates, tuple)\n            assert len(updates) == 1\n\n            effective_message = updates[0][message_type]\n            assert (\n                effective_message.reply_to_message.reply_markup.inline_keyboard[0][0].callback_data\n                == \"callback_data\"\n            )\n            assert (\n                effective_message.pinned_message.reply_markup.inline_keyboard[0][0].callback_data\n                == \"callback_data\"\n            )\n\n            pinned_message = effective_message.reply_to_message.pinned_message\n            assert (\n                pinned_message.reply_markup.inline_keyboard[0][0].callback_data == \"callback_data\"\n            )\n\n        finally:\n            offline_bot.callback_data_cache.clear_callback_data()\n            offline_bot.callback_data_cache.clear_callback_queries()\n\n    async def test_get_updates_invalid_callback_data(self, cdc_bot, monkeypatch):\n        offline_bot = cdc_bot\n\n        async def post(*args, **kwargs):\n            return [\n                Update(\n                    17,\n                    callback_query=CallbackQuery(\n                        id=1,\n                        from_user=None,\n                        chat_instance=123,\n                        data=\"invalid data\",\n                        message=Message(\n                            1,\n                            from_user=User(1, \"\", False),\n                            date=dtm.datetime.utcnow(),\n                            chat=Chat(1, \"\"),\n                            text=\"Webhook\",\n                        ),\n                    ),\n                ).to_dict()\n            ]\n\n        try:\n            monkeypatch.setattr(BaseRequest, \"post\", post)\n            updates = await offline_bot.get_updates(timeout=1)\n\n            assert isinstance(updates, tuple)\n            assert len(updates) == 1\n            assert isinstance(updates[0].callback_query.data, InvalidCallbackData)\n\n        finally:\n            # Reset b/c bots scope is session\n            offline_bot.callback_data_cache.clear_callback_data()\n            offline_bot.callback_data_cache.clear_callback_queries()\n\n    # TODO: Needs improvement. We need incoming inline query to test answer.\n    async def test_replace_callback_data_answer_inline_query(self, monkeypatch, cdc_bot, chat_id):\n        offline_bot = cdc_bot\n\n        # For now just test that our internals pass the correct data\n        async def make_assertion(\n            endpoint,\n            data=None,\n            *args,\n            **kwargs,\n        ):\n            inline_keyboard = data[\"results\"][0][\"reply_markup\"].inline_keyboard\n            assertion_1 = inline_keyboard[0][1] == no_replace_button\n            assertion_2 = inline_keyboard[0][0] != replace_button\n            keyboard, button = (\n                inline_keyboard[0][0].callback_data[:32],\n                inline_keyboard[0][0].callback_data[32:],\n            )\n            assertion_3 = (\n                offline_bot.callback_data_cache._keyboard_data[keyboard].button_data[button]\n                == \"replace_test\"\n            )\n            assertion_4 = data[\"results\"][1].reply_markup is None\n            return assertion_1 and assertion_2 and assertion_3 and assertion_4\n\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n\n            # call this here so `offline_bot.get_me()` won't be called after mocking\n            offline_bot.username\n            monkeypatch.setattr(offline_bot, \"_post\", make_assertion)\n            results = [\n                InlineQueryResultArticle(\n                    \"11\", \"first\", InputTextMessageContent(\"first\"), reply_markup=reply_markup\n                ),\n                InlineQueryResultVoice(\n                    \"22\",\n                    \"https://python-telegram-bot.org/static/testfiles/telegram.ogg\",\n                    title=\"second\",\n                ),\n            ]\n\n            assert await offline_bot.answer_inline_query(chat_id, results=results)\n\n        finally:\n            offline_bot.callback_data_cache.clear_callback_data()\n            offline_bot.callback_data_cache.clear_callback_queries()\n\n    @pytest.mark.parametrize(\n        \"message_type\", [\"channel_post\", \"edited_channel_post\", \"message\", \"edited_message\"]\n    )\n    @pytest.mark.parametrize(\"self_sender\", [True, False])\n    async def test_arbitrary_callback_data_via_bot(\n        self, cdc_bot, monkeypatch, self_sender, message_type\n    ):\n        bot = cdc_bot\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"callback_data\")\n        )\n\n        reply_markup = bot.callback_data_cache.process_keyboard(reply_markup)\n        message = Message(\n            1,\n            dtm.datetime.utcnow(),\n            get_dummy_object(Chat),\n            reply_markup=reply_markup,\n            via_bot=bot.bot if self_sender else User(1, \"first\", False),\n        )\n\n        async def post(*args, **kwargs):\n            return [Update(17, **{message_type: message}).to_dict()]\n\n        try:\n            monkeypatch.setattr(BaseRequest, \"post\", post)\n            updates = await bot.get_updates(timeout=1)\n\n            assert isinstance(updates, tuple)\n            assert len(updates) == 1\n\n            message = updates[0][message_type]\n            if self_sender:\n                assert message.reply_markup.inline_keyboard[0][0].callback_data == \"callback_data\"\n            else:\n                assert (\n                    message.reply_markup.inline_keyboard[0][0].callback_data\n                    == reply_markup.inline_keyboard[0][0].callback_data\n                )\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    @pytest.mark.parametrize(\"bot_class\", [Bot, ExtBot])\n    async def test_http2_runtime_error(self, recwarn, bot_class):\n        bot_class(\"12345:ABCDE\", base_url=\"http://\", request=HTTPXRequest(http_version=\"2\"))\n        bot_class(\n            \"12345:ABCDE\",\n            base_url=\"http://\",\n            get_updates_request=HTTPXRequest(http_version=\"2\"),\n        )\n        bot_class(\n            \"12345:ABCDE\",\n            base_url=\"http://\",\n            request=HTTPXRequest(http_version=\"2\"),\n            get_updates_request=HTTPXRequest(http_version=\"2\"),\n        )\n        assert len(recwarn) == 3\n        assert \"You set the HTTP version for the request HTTPXRequest instance\" in str(\n            recwarn[0].message\n        )\n        assert \"You set the HTTP version for the get_updates_request HTTPXRequest instance\" in str(\n            recwarn[1].message\n        )\n        assert (\n            \"You set the HTTP version for the get_updates_request and request HTTPXRequest \"\n            \"instance\" in str(recwarn[2].message)\n        )\n        for warning in recwarn:\n            assert warning.filename == __file__, \"wrong stacklevel!\"\n            assert warning.category is PTBUserWarning\n\n    async def test_set_get_my_name(self, offline_bot, monkeypatch):\n        \"\"\"We only test that we pass the correct values to TG since this endpoint is heavily\n        rate limited which makes automated tests rather infeasible.\"\"\"\n        default_name = \"default_bot_name\"\n        en_name = \"en_bot_name\"\n        de_name = \"de_bot_name\"\n\n        # We predefine the responses that we would TG expect to send us\n        set_stack = asyncio.Queue()\n        get_stack = asyncio.Queue()\n        await set_stack.put({\"name\": default_name})\n        await set_stack.put({\"name\": en_name, \"language_code\": \"en\"})\n        await set_stack.put({\"name\": de_name, \"language_code\": \"de\"})\n        await get_stack.put({\"name\": default_name, \"language_code\": None})\n        await get_stack.put({\"name\": en_name, \"language_code\": \"en\"})\n        await get_stack.put({\"name\": de_name, \"language_code\": \"de\"})\n\n        await set_stack.put({\"name\": default_name})\n        await set_stack.put({\"language_code\": \"en\"})\n        await set_stack.put({\"language_code\": \"de\"})\n        await get_stack.put({\"name\": default_name, \"language_code\": None})\n        await get_stack.put({\"name\": default_name, \"language_code\": \"en\"})\n        await get_stack.put({\"name\": default_name, \"language_code\": \"de\"})\n\n        async def post(url, request_data: RequestData, *args, **kwargs):\n            # The mock-post now just fetches the predefined responses from the queues\n            if \"setMyName\" in url:\n                expected = await set_stack.get()\n                assert request_data.json_parameters == expected\n                set_stack.task_done()\n                return True\n\n            bot_name = await get_stack.get()\n            if \"language_code\" in request_data.json_parameters:\n                assert request_data.json_parameters == {\"language_code\": bot_name[\"language_code\"]}\n            else:\n                assert request_data.json_parameters == {}\n            get_stack.task_done()\n            return bot_name\n\n        monkeypatch.setattr(offline_bot.request, \"post\", post)\n\n        # Set the names\n        assert all(\n            await asyncio.gather(\n                offline_bot.set_my_name(default_name),\n                offline_bot.set_my_name(en_name, language_code=\"en\"),\n                offline_bot.set_my_name(de_name, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            offline_bot.get_my_name(), offline_bot.get_my_name(\"en\"), offline_bot.get_my_name(\"de\")\n        ) == [\n            BotName(default_name),\n            BotName(en_name),\n            BotName(de_name),\n        ]\n\n        # Delete the names\n        assert all(\n            await asyncio.gather(\n                offline_bot.set_my_name(default_name),\n                offline_bot.set_my_name(None, language_code=\"en\"),\n                offline_bot.set_my_name(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            offline_bot.get_my_name(), offline_bot.get_my_name(\"en\"), offline_bot.get_my_name(\"de\")\n        ) == 3 * [BotName(default_name)]\n\n    async def test_set_message_reaction(self, offline_bot, monkeypatch):\n        \"\"\"This is here so we can test the convenient conversion we do in the function without\n        having to do multiple requests to Telegram\"\"\"\n\n        expected_param = [\n            [{\"emoji\": ReactionEmoji.THUMBS_UP, \"type\": \"emoji\"}],\n            [{\"emoji\": ReactionEmoji.RED_HEART, \"type\": \"emoji\"}],\n            [{\"custom_emoji_id\": \"custom_emoji_1\", \"type\": \"custom_emoji\"}],\n            [{\"custom_emoji_id\": \"custom_emoji_2\", \"type\": \"custom_emoji\"}],\n            [{\"emoji\": ReactionEmoji.THUMBS_DOWN, \"type\": \"emoji\"}],\n            [{\"custom_emoji_id\": \"custom_emoji_3\", \"type\": \"custom_emoji\"}],\n            [\n                {\"emoji\": ReactionEmoji.RED_HEART, \"type\": \"emoji\"},\n                {\"custom_emoji_id\": \"custom_emoji_4\", \"type\": \"custom_emoji\"},\n                {\"emoji\": ReactionEmoji.THUMBS_DOWN, \"type\": \"emoji\"},\n                {\"custom_emoji_id\": \"custom_emoji_5\", \"type\": \"custom_emoji\"},\n            ],\n            [],\n        ]\n\n        amount = 0\n\n        async def post(url, request_data: RequestData, *args, **kwargs):\n            # The mock-post now just fetches the predefined responses from the queues\n            assert request_data.json_parameters[\"chat_id\"] == \"1\"\n            assert request_data.json_parameters[\"message_id\"] == \"2\"\n            assert request_data.json_parameters[\"is_big\"]\n            nonlocal amount\n            assert request_data.parameters[\"reaction\"] == expected_param[amount]\n            amount += 1\n\n        monkeypatch.setattr(offline_bot.request, \"post\", post)\n        await offline_bot.set_message_reaction(\n            1, 2, [ReactionTypeEmoji(ReactionEmoji.THUMBS_UP)], True\n        )\n        await offline_bot.set_message_reaction(\n            1, 2, ReactionTypeEmoji(ReactionEmoji.RED_HEART), True\n        )\n        await offline_bot.set_message_reaction(\n            1, 2, [ReactionTypeCustomEmoji(\"custom_emoji_1\")], True\n        )\n        await offline_bot.set_message_reaction(\n            1, 2, ReactionTypeCustomEmoji(\"custom_emoji_2\"), True\n        )\n        await offline_bot.set_message_reaction(1, 2, ReactionEmoji.THUMBS_DOWN, True)\n        await offline_bot.set_message_reaction(1, 2, \"custom_emoji_3\", True)\n        await offline_bot.set_message_reaction(\n            1,\n            2,\n            [\n                ReactionTypeEmoji(ReactionEmoji.RED_HEART),\n                ReactionTypeCustomEmoji(\"custom_emoji_4\"),\n                ReactionEmoji.THUMBS_DOWN,\n                ReactionTypeCustomEmoji(\"custom_emoji_5\"),\n            ],\n            True,\n        )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"parse_mode\": ParseMode.HTML}, None),\n            ({\"parse_mode\": ParseMode.HTML}, ParseMode.MARKDOWN_V2),\n            ({\"parse_mode\": None}, ParseMode.MARKDOWN_V2),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_message_default_quote_parse_mode(\n        self, default_bot, chat_id, custom, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters[\"reply_parameters\"].get(\"quote_parse_mode\") == (\n                custom or default_bot.defaults.quote_parse_mode\n            )\n            return make_message(\"dummy reply\").to_dict()\n\n        kwargs = {\"message_id\": 1}\n        if custom is not None:\n            kwargs[\"quote_parse_mode\"] = custom\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        await default_bot.send_message(chat_id, \"test\", reply_parameters=ReplyParameters(**kwargs))\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"parse_mode\": ParseMode.HTML}, \"NOTHING\"),\n            ({\"parse_mode\": ParseMode.HTML}, None),\n            ({\"parse_mode\": ParseMode.HTML}, ParseMode.MARKDOWN_V2),\n            ({\"parse_mode\": None}, ParseMode.MARKDOWN_V2),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_poll_default_text_question_parse_mode(\n        self, default_bot, raw_bot, chat_id, custom, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            expected = default_bot.defaults.text_parse_mode if custom == \"NOTHING\" else custom\n\n            option_1 = request_data.parameters[\"options\"][0]\n            option_2 = request_data.parameters[\"options\"][1]\n            assert option_1.get(\"text_parse_mode\") == (default_bot.defaults.text_parse_mode)\n            assert option_2.get(\"text_parse_mode\") == expected\n            assert request_data.parameters.get(\"question_parse_mode\") == expected\n\n            return make_message(\"dummy reply\").to_dict()\n\n        async def make_raw_assertion(url, request_data: RequestData, *args, **kwargs):\n            expected = None if custom == \"NOTHING\" else custom\n\n            option_1 = request_data.parameters[\"options\"][0]\n            option_2 = request_data.parameters[\"options\"][1]\n            assert option_1.get(\"text_parse_mode\") is None\n            assert option_2.get(\"text_parse_mode\") == expected\n\n            assert request_data.parameters.get(\"question_parse_mode\") == expected\n\n            return make_message(\"dummy reply\").to_dict()\n\n        if custom == \"NOTHING\":\n            option_2 = InputPollOption(\"option2\")\n            kwargs = {}\n        else:\n            option_2 = InputPollOption(\"option2\", text_parse_mode=custom)\n            kwargs = {\"question_parse_mode\": custom}\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        await default_bot.send_poll(\n            chat_id, question=\"question\", options=[\"option1\", option_2], **kwargs\n        )\n\n        monkeypatch.setattr(raw_bot.request, \"post\", make_raw_assertion)\n        await raw_bot.send_poll(\n            chat_id, question=\"question\", options=[\"option1\", option_2], **kwargs\n        )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"parse_mode\": ParseMode.HTML}, None),\n            ({\"parse_mode\": ParseMode.HTML}, ParseMode.MARKDOWN_V2),\n            ({\"parse_mode\": None}, ParseMode.MARKDOWN_V2),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_poll_default_quote_parse_mode(\n        self, default_bot, chat_id, custom, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters[\"reply_parameters\"].get(\"quote_parse_mode\") == (\n                custom or default_bot.defaults.quote_parse_mode\n            )\n            return make_message(\"dummy reply\").to_dict()\n\n        kwargs = {\"message_id\": 1}\n        if custom is not None:\n            kwargs[\"quote_parse_mode\"] = custom\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        await default_bot.send_poll(\n            chat_id,\n            question=\"question\",\n            options=[\"option1\", \"option2\"],\n            reply_parameters=ReplyParameters(**kwargs),\n        )\n\n    async def test_send_poll_question_parse_mode_entities(self, offline_bot, monkeypatch):\n        # Currently only custom emoji are supported as entities which we can't test\n        # We just test that the correct data is passed for now\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters[\"question_entities\"] == [\n                {\"type\": \"custom_emoji\", \"offset\": 0, \"length\": 1},\n                {\"type\": \"custom_emoji\", \"offset\": 2, \"length\": 1},\n            ]\n            assert request_data.parameters[\"question_parse_mode\"] == ParseMode.MARKDOWN_V2\n            return make_message(\"dummy reply\").to_dict()\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        await offline_bot.send_poll(\n            1,\n            question=\"\ud83d\ude00\ud83d\ude03\",\n            options=[\"option1\", \"option2\"],\n            question_entities=[\n                MessageEntity(MessageEntity.CUSTOM_EMOJI, 0, 1),\n                MessageEntity(MessageEntity.CUSTOM_EMOJI, 2, 1),\n            ],\n            question_parse_mode=ParseMode.MARKDOWN_V2,\n        )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"parse_mode\": ParseMode.HTML}, None),\n            ({\"parse_mode\": ParseMode.HTML}, ParseMode.MARKDOWN_V2),\n            ({\"parse_mode\": None}, ParseMode.MARKDOWN_V2),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_quote_parse_mode(\n        self, default_bot, chat_id, custom, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters[\"reply_parameters\"].get(\"quote_parse_mode\") == (\n                custom or default_bot.defaults.quote_parse_mode\n            )\n            return make_message(\"dummy reply\").to_dict()\n\n        kwargs = {\"message_id\": 1}\n        if custom is not None:\n            kwargs[\"quote_parse_mode\"] = custom\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        await default_bot.send_game(\n            chat_id, \"game_short_name\", reply_parameters=ReplyParameters(**kwargs)\n        )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"parse_mode\": ParseMode.HTML}, None),\n            ({\"parse_mode\": ParseMode.HTML}, ParseMode.MARKDOWN_V2),\n            ({\"parse_mode\": None}, ParseMode.MARKDOWN_V2),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_copy_message_default_quote_parse_mode(\n        self, default_bot, chat_id, custom, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters[\"reply_parameters\"].get(\"quote_parse_mode\") == (\n                custom or default_bot.defaults.quote_parse_mode\n            )\n            return make_message(\"dummy reply\").to_dict()\n\n        kwargs = {\"message_id\": 1}\n        if custom is not None:\n            kwargs[\"quote_parse_mode\"] = custom\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        await default_bot.copy_message(chat_id, 1, 1, reply_parameters=ReplyParameters(**kwargs))\n\n    async def test_do_api_request_camel_case_conversion(self, offline_bot, monkeypatch):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return url.endswith(\"camelCase\")\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.do_api_request(\"camel_case\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    async def test_do_api_request_media_write_timeout(self, offline_bot, chat_id, monkeypatch):\n        test_flag = None\n\n        class CustomRequest(BaseRequest):\n            async def initialize(self_) -> None:\n                pass\n\n            async def shutdown(self_) -> None:\n                pass\n\n            async def do_request(self_, *args, **kwargs) -> tuple[int, bytes]:\n                nonlocal test_flag\n                test_flag = (\n                    kwargs.get(\"read_timeout\"),\n                    kwargs.get(\"connect_timeout\"),\n                    kwargs.get(\"write_timeout\"),\n                    kwargs.get(\"pool_timeout\"),\n                )\n                return HTTPStatus.OK, b'{\"ok\": \"True\", \"result\": {}}'\n\n            @property\n            def read_timeout(self):\n                return 1\n\n        custom_request = CustomRequest()\n\n        offline_bot = Bot(offline_bot.token, request=custom_request)\n        await offline_bot.do_api_request(\n            \"send_document\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"caption\": \"test_caption\",\n                \"document\": InputFile(data_file(\"telegram.png\").open(\"rb\")),\n            },\n        )\n        assert test_flag == (\n            DEFAULT_NONE,\n            DEFAULT_NONE,\n            DEFAULT_NONE,\n            DEFAULT_NONE,\n        )\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    async def test_do_api_request_default_timezone(self, tz_bot, monkeypatch):\n        until = dtm.datetime(2020, 1, 11, 16, 13)\n        until_timestamp = to_timestamp(until, tzinfo=tz_bot.defaults.tzinfo)\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            user_id = data[\"user_id\"] == 32\n            until_date = data.get(\"until_date\", until_timestamp) == until_timestamp\n            return chat_id and user_id and until_date\n\n        monkeypatch.setattr(tz_bot.request, \"post\", make_assertion)\n\n        assert await tz_bot.do_api_request(\n            \"banChatMember\", api_kwargs={\"chat_id\": 2, \"user_id\": 32}\n        )\n        assert await tz_bot.do_api_request(\n            \"banChatMember\", api_kwargs={\"chat_id\": 2, \"user_id\": 32, \"until_date\": until}\n        )\n        assert await tz_bot.do_api_request(\n            \"banChatMember\",\n            api_kwargs={\"chat_id\": 2, \"user_id\": 32, \"until_date\": until_timestamp},\n        )\n\n    async def test_business_connection_id_argument(\n        self, offline_bot, monkeypatch, dummy_message_dict\n    ):\n        \"\"\"We can't connect to a business acc, so we just test that the correct data is passed.\n        We also can't test every single method easily, so we just test a few. Our linting will\n        catch any unused args with the others.\"\"\"\n        return_values = asyncio.Queue()\n        await return_values.put(dummy_message_dict)\n        await return_values.put(\n            Poll(\n                id=\"42\",\n                question=\"question\",\n                options=[PollOption(\"option\", 0)],\n                total_voter_count=5,\n                is_closed=True,\n                is_anonymous=True,\n                type=\"regular\",\n                allows_multiple_answers=False,\n            ).to_dict()\n        )\n        await return_values.put(True)\n        await return_values.put(True)\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"business_connection_id\") == 42\n            return await return_values.get()\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.send_message(2, \"text\", business_connection_id=42)\n        await offline_bot.stop_poll(chat_id=1, message_id=2, business_connection_id=42)\n        await offline_bot.pin_chat_message(chat_id=1, message_id=2, business_connection_id=42)\n        await offline_bot.unpin_chat_message(chat_id=1, business_connection_id=42)\n\n    async def test_message_effect_id_argument(self, offline_bot, monkeypatch):\n        \"\"\"We can't test every single method easily, so we just test one. Our linting will catch\n        any unused args with the others.\"\"\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters.get(\"message_effect_id\") == 42\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.send_message(2, \"text\", message_effect_id=42)\n\n    async def test_allow_paid_broadcast_argument(self, offline_bot, monkeypatch):\n        \"\"\"We can't test every single method easily, so we just test one. Our linting will catch\n        any unused args with the others.\"\"\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters.get(\"allow_paid_broadcast\") == 42\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.send_message(2, \"text\", allow_paid_broadcast=42)\n\n    async def test_direct_messages_topic_id_argument(self, offline_bot, monkeypatch):\n        \"\"\"We can't test every single method easily, so we just test one. Our linting will catch\n        any unused args with the others.\"\"\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters.get(\"direct_messages_topic_id\") == 42\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.send_message(2, \"text\", direct_messages_topic_id=42)\n\n    async def test_suggested_post_parameters_argument(self, offline_bot, monkeypatch):\n        \"\"\"We can't test every single method easily, so we just test one. Our linting will catch\n        any unused args with the others.\"\"\"\n        suggested_post_parameters = SuggestedPostParameters(price=SuggestedPostPrice(\"TON\", 10))\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return (\n                request_data.parameters.get(\"suggested_post_parameters\")\n                == suggested_post_parameters.to_dict()\n            )\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.send_message(\n            2, \"text\", suggested_post_parameters=suggested_post_parameters\n        )\n\n    async def test_send_chat_action_all_args(self, bot, chat_id, monkeypatch):\n        async def make_assertion(*args, **_):\n            kwargs = args[1]\n            return (\n                kwargs[\"chat_id\"] == chat_id\n                and kwargs[\"action\"] == \"action\"\n                and kwargs[\"message_thread_id\"] == 1\n                and kwargs[\"business_connection_id\"] == 3\n            )\n\n        monkeypatch.setattr(bot, \"_post\", make_assertion)\n        assert await bot.send_chat_action(chat_id, \"action\", 1, 3)\n\n    async def test_gift_premium_subscription_all_args(self, bot, monkeypatch):\n        # can't make actual request so we just test that the correct data is passed\n        async def make_assertion(*args, **_):\n            kwargs = args[1]\n            return (\n                kwargs.get(\"user_id\") == 12\n                and kwargs.get(\"month_count\") == 3\n                and kwargs.get(\"star_count\") == 1000\n                and kwargs.get(\"text\") == \"test text\"\n                and kwargs.get(\"text_parse_mode\") == \"Markdown\"\n                and kwargs.get(\"text_entities\")\n                == [\n                    MessageEntity(MessageEntity.BOLD, 0, 3),\n                    MessageEntity(MessageEntity.ITALIC, 5, 11),\n                ]\n            )\n\n        monkeypatch.setattr(bot, \"_post\", make_assertion)\n        assert await bot.gift_premium_subscription(\n            user_id=12,\n            month_count=3,\n            star_count=1000,\n            text=\"test text\",\n            text_parse_mode=\"Markdown\",\n            text_entities=[\n                MessageEntity(MessageEntity.BOLD, 0, 3),\n                MessageEntity(MessageEntity.ITALIC, 5, 11),\n            ],\n        )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    @pytest.mark.parametrize(\n        (\"passed_value\", \"expected_value\"),\n        [(DEFAULT_NONE, \"Markdown\"), (\"HTML\", \"HTML\"), (None, None)],\n    )\n    async def test_gift_premium_subscription_default_parse_mode(\n        self, default_bot, monkeypatch, passed_value, expected_value\n    ):\n        # can't make actual request so we just test that the correct data is passed\n        async def make_assertion(url, request_data, *args, **kwargs):\n            assert request_data.parameters.get(\"text_parse_mode\") == expected_value\n            return True\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        kwargs = {\n            \"user_id\": 123,\n            \"month_count\": 3,\n            \"star_count\": 1000,\n            \"text\": \"text\",\n        }\n        if passed_value is not DEFAULT_NONE:\n            kwargs[\"text_parse_mode\"] = passed_value\n\n        assert await default_bot.gift_premium_subscription(**kwargs)\n\n    async def test_refund_star_payment(self, offline_bot, monkeypatch):\n        # can't make actual request so we just test that the correct data is passed\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return (\n                request_data.parameters.get(\"user_id\") == 42\n                and request_data.parameters.get(\"telegram_payment_charge_id\") == \"37\"\n            )\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.refund_star_payment(42, \"37\")\n\n    async def test_get_star_transactions(self, offline_bot, monkeypatch):\n        # we just want to test the offset parameter\n        st = StarTransactions([StarTransaction(\"1\", 1, dtm.datetime.now())]).to_json()\n\n        async def do_request(url, request_data: RequestData, *args, **kwargs):\n            offset = request_data.parameters.get(\"offset\") == 3\n            if offset:\n                return 200, f'{{\"ok\": true, \"result\": {st}}}'.encode()\n            return 400, b'{\"ok\": false, \"result\": []}'\n\n        monkeypatch.setattr(offline_bot.request, \"do_request\", do_request)\n        obj = await offline_bot.get_star_transactions(offset=3)\n        assert isinstance(obj, StarTransactions)\n\n    async def test_edit_user_star_subscription(self, offline_bot, monkeypatch):\n        \"\"\"Can't properly test, so we only check that the correct values are passed\"\"\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return (\n                request_data.parameters.get(\"user_id\") == 42\n                and request_data.parameters.get(\"telegram_payment_charge_id\")\n                == \"telegram_payment_charge_id\"\n                and request_data.parameters.get(\"is_canceled\") is False\n            )\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.edit_user_star_subscription(\n            42, \"telegram_payment_charge_id\", False\n        )\n\n    async def test_create_chat_subscription_invite_link(\n        self,\n        monkeypatch,\n        offline_bot,\n    ):\n        # Since the chat invite link object does not say if the sub args are passed we can\n        # only check here\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"subscription_period\") == 2592000\n            assert request_data.parameters.get(\"subscription_price\") == 6\n            return ChatInviteLink(\n                \"https://t.me/joinchat/invite_link\", User(1, \"first\", False), False, False, False\n            ).to_dict()\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.create_chat_subscription_invite_link(1234, 2592000, 6)\n\n    @pytest.mark.parametrize(\n        \"expiration_date\", [dtm.datetime(2024, 1, 1), 1704067200], ids=[\"datetime\", \"timestamp\"]\n    )\n    async def test_set_user_emoji_status_basic(self, offline_bot, monkeypatch, expiration_date):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"user_id\") == 4242\n            assert (\n                request_data.parameters.get(\"emoji_status_custom_emoji_id\")\n                == \"emoji_status_custom_emoji_id\"\n            )\n            assert request_data.parameters.get(\"emoji_status_expiration_date\") == 1704067200\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        await offline_bot.set_user_emoji_status(\n            4242, \"emoji_status_custom_emoji_id\", expiration_date\n        )\n\n    async def test_set_user_emoji_status_default_timezone(self, tz_bot, monkeypatch):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"user_id\") == 4242\n            assert (\n                request_data.parameters.get(\"emoji_status_custom_emoji_id\")\n                == \"emoji_status_custom_emoji_id\"\n            )\n            assert request_data.parameters.get(\"emoji_status_expiration_date\") == to_timestamp(\n                dtm.datetime(2024, 1, 1), tzinfo=tz_bot.defaults.tzinfo\n            )\n\n        monkeypatch.setattr(tz_bot.request, \"post\", make_assertion)\n        await tz_bot.set_user_emoji_status(\n            4242, \"emoji_status_custom_emoji_id\", dtm.datetime(2024, 1, 1)\n        )\n\n    async def test_verify_user(self, offline_bot, monkeypatch):\n        \"No way to test this without getting verified\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"user_id\") == 1234\n            assert request_data.parameters.get(\"custom_description\") == \"this is so custom\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.verify_user(1234, \"this is so custom\")\n\n    async def test_verify_chat(self, offline_bot, monkeypatch):\n        \"No way to test this without getting verified\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"chat_id\") == 1234\n            assert request_data.parameters.get(\"custom_description\") == \"this is so custom\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.verify_chat(1234, \"this is so custom\")\n\n    async def test_unverify_user(self, offline_bot, monkeypatch):\n        \"No way to test this without getting verified\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"user_id\") == 1234\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.remove_user_verification(1234)\n\n    async def test_unverify_chat(self, offline_bot, monkeypatch):\n        \"No way to test this without getting verified\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"chat_id\") == 1234\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.remove_chat_verification(1234)\n\n    async def test_get_my_star_balance(self, offline_bot, monkeypatch):\n        sa = StarAmount(1000).to_json()\n\n        async def do_request(url, request_data: RequestData, *args, **kwargs):\n            assert not request_data.parameters\n            return 200, f'{{\"ok\": true, \"result\": {sa}}}'.encode()\n\n        monkeypatch.setattr(offline_bot.request, \"do_request\", do_request)\n        obj = await offline_bot.get_my_star_balance()\n        assert isinstance(obj, StarAmount)\n\n    async def test_approve_suggested_post(self, offline_bot, monkeypatch):\n        \"No way to test this without receiving suggested posts\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            chat_id = data.get(\"chat_id\") == \"1234\"\n            message_id = data.get(\"message_id\") == \"5678\"\n            send_date = data.get(\"send_date\", \"1577887200\") == \"1577887200\"\n            return chat_id and message_id and send_date\n\n        until = from_timestamp(1577887200)\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.approve_suggested_post(1234, 5678, 1577887200)\n        assert await offline_bot.approve_suggested_post(1234, 5678, until)\n\n    async def test_approve_suggested_post_with_tz(self, monkeypatch, tz_bot):\n        until = dtm.datetime(2020, 1, 11, 16, 13)\n        until_timestamp = to_timestamp(until, tzinfo=tz_bot.defaults.tzinfo)\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            message_id = data[\"message_id\"] == 32\n            until_date = data.get(\"until_date\", until_timestamp) == until_timestamp\n            return chat_id and message_id and until_date\n\n        monkeypatch.setattr(tz_bot.request, \"post\", make_assertion)\n\n        assert await tz_bot.approve_suggested_post(2, 32)\n        assert await tz_bot.approve_suggested_post(2, 32, send_date=until)\n        assert await tz_bot.approve_suggested_post(2, 32, send_date=until_timestamp)\n\n    async def test_decline_suggested_post(self, offline_bot, monkeypatch):\n        \"No way to test this without receiving suggested posts\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"chat_id\") == 1234\n            assert request_data.parameters.get(\"message_id\") == 5678\n            assert request_data.parameters.get(\"comment\") == \"declined\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.decline_suggested_post(1234, 5678, \"declined\")"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            1326,
                            1336
                        ],
                        "reason": "The test 'test_set_chat_permissions' may fail if the permissions passed do not match the expected format or structure. This could lead to assertion errors if the bot does not handle the permissions correctly, which is critical for chat management. The test 'test_set_chat_administrator_custom_title' could also be affected if the chat permissions are not set correctly.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_set_chat_permissions(self, monkeypatch, offline_bot, chat_permissions):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            chat_id = data[\"chat_id\"] == \"2\"\n            permissions = data[\"permissions\"] == chat_permissions.to_json()\n            use_independent_chat_permissions = data[\"use_independent_chat_permissions\"]\n            return chat_id and permissions and use_independent_chat_permissions\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.set_chat_permissions(2, chat_permissions, True)"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            1598,
                            1605
                        ],
                        "reason": "The test 'test_copy_message' may fail if the parameters passed do not match the expected structure. The assertion checks for multiple parameters, and if any of them are incorrect, it could lead to assertion errors. This is critical for message copying functionality. Additionally, the test 'test_send_edit_message_mutually_exclusive_link_preview' and 'test_rtm_aswr_mutually_exclusive_reply_parameters' could also be affected by similar issues, as they involve message sending with specific parameters.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_close(self, monkeypatch, offline_bot):\n        # We don't actually make a request as to not break the test setup\n        async def assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.json_parameters == {} and url.split(\"/\")[-1] == \"close\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", assertion)\n\n        assert await offline_bot.close()"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            224,
                            2660
                        ],
                        "reason": "The CI run failed primarily due to multiple test failures during the execution of pytest. The tests 'test_send_contact_default_protect_content', 'test_get_set_my_default_administrator_rights', and 'test_send_edit_message_mutually_exclusive_link_preview' failed due to assertion errors and timeout issues. Additionally, the test 'test_rtm_aswr_mutually_exclusive_reply_parameters' failed due to timeout errors. The presence of multiple tests failing due to timeout suggests that the code may not be handling requests efficiently, leading to delays and exceeding the expected execution time. Furthermore, the flood control issue indicates that the bot is attempting to send messages too frequently, violating Telegram's limits, which could lead to further test failures.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "class",
                        "code_snippet": "class TestBotWithoutRequest:\n    \"\"\"\n    Most are executed on tg.ext.ExtBot, as that class only extends the functionality of tg.bot\n\n    Behavior for init of ExtBot with missing optional dependency cachetools (for CallbackDataCache)\n    is tested in `test_callbackdatacache`\n    \"\"\"\n\n    test_flag = None\n\n    @pytest.fixture(autouse=True)\n    def _reset(self):\n        self.test_flag = None\n\n    @pytest.mark.parametrize(\"bot_class\", [Bot, ExtBot])\n    def test_slot_behaviour(self, bot_class, offline_bot):\n        inst = bot_class(\n            offline_bot.token, request=OfflineRequest(1), get_updates_request=OfflineRequest(1)\n        )\n        for attr in inst.__slots__:\n            assert getattr(inst, attr, \"err\") != \"err\", f\"got extra slot '{attr}'\"\n        assert len(mro_slots(inst)) == len(set(mro_slots(inst))), \"duplicate slot\"\n\n    async def test_no_token_passed(self):\n        with pytest.raises(InvalidToken, match=\"You must pass the token\"):\n            Bot(\"\")\n\n    def test_base_url_parsing_basic(self, caplog):\n        with caplog.at_level(logging.DEBUG):\n            bot = Bot(\n                token=\"!!Test String!!\",\n                base_url=\"base/\",\n                base_file_url=\"base/\",\n                request=OfflineRequest(1),\n                get_updates_request=OfflineRequest(1),\n            )\n\n        assert bot.base_url == \"base/!!Test String!!\"\n        assert bot.base_file_url == \"base/!!Test String!!\"\n\n        assert len(caplog.records) >= 2\n        messages = [record.getMessage() for record in caplog.records]\n        assert \"Set Bot API URL: base/!!Test String!!\" in messages\n        assert \"Set Bot API File URL: base/!!Test String!!\" in messages\n\n    @pytest.mark.parametrize(\n        \"insert_key\", [\"token\", \"TOKEN\", \"bot_token\", \"BOT_TOKEN\", \"bot-token\", \"BOT-TOKEN\"]\n    )\n    def test_base_url_parsing_string_format(self, insert_key, caplog):\n        string = f\"{{{insert_key}}}\"\n\n        with caplog.at_level(logging.DEBUG):\n            bot = Bot(\n                token=\"!!Test String!!\",\n                base_url=string,\n                base_file_url=string,\n                request=OfflineRequest(1),\n                get_updates_request=OfflineRequest(1),\n            )\n\n        assert bot.base_url == \"!!Test String!!\"\n        assert bot.base_file_url == \"!!Test String!!\"\n\n        assert len(caplog.records) >= 2\n        messages = [record.getMessage() for record in caplog.records]\n        assert \"Set Bot API URL: !!Test String!!\" in messages\n        assert \"Set Bot API File URL: !!Test String!!\" in messages\n\n        with pytest.raises(KeyError, match=\"unsupported insertion: unknown\"):\n            Bot(\"token\", base_url=\"{unknown}{token}\")\n\n    def test_base_url_parsing_callable(self, caplog):\n        def build_url(_: str) -> str:\n            return \"!!Test String!!\"\n\n        with caplog.at_level(logging.DEBUG):\n            bot = Bot(\n                token=\"some-token\",\n                base_url=build_url,\n                base_file_url=build_url,\n                request=OfflineRequest(1),\n                get_updates_request=OfflineRequest(1),\n            )\n\n        assert bot.base_url == \"!!Test String!!\"\n        assert bot.base_file_url == \"!!Test String!!\"\n\n        assert len(caplog.records) >= 2\n        messages = [record.getMessage() for record in caplog.records]\n        assert \"Set Bot API URL: !!Test String!!\" in messages\n        assert \"Set Bot API File URL: !!Test String!!\" in messages\n\n    async def test_repr(self):\n        offline_bot = Bot(token=\"some_token\", base_file_url=\"\")\n        assert repr(offline_bot) == \"Bot[token=some_token]\"\n\n    async def test_to_dict(self, offline_bot):\n        to_dict_bot = offline_bot.to_dict()\n\n        assert isinstance(to_dict_bot, dict)\n        assert to_dict_bot[\"id\"] == offline_bot.id\n        assert to_dict_bot[\"username\"] == offline_bot.username\n        assert to_dict_bot[\"first_name\"] == offline_bot.first_name\n        if offline_bot.last_name:\n            assert to_dict_bot[\"last_name\"] == offline_bot.last_name\n\n    async def test_initialize_and_shutdown(self, offline_bot: PytestExtBot, monkeypatch):\n        async def initialize(*args, **kwargs):\n            self.test_flag = [\"initialize\"]\n\n        async def stop(*args, **kwargs):\n            self.test_flag.append(\"stop\")\n\n        temp_bot = PytestBot(token=offline_bot.token, request=OfflineRequest())\n        orig_stop = temp_bot.request.shutdown\n\n        try:\n            monkeypatch.setattr(temp_bot.request, \"initialize\", initialize)\n            monkeypatch.setattr(temp_bot.request, \"shutdown\", stop)\n            await temp_bot.initialize()\n            assert self.test_flag == [\"initialize\"]\n            assert temp_bot.bot == offline_bot.bot\n\n            await temp_bot.shutdown()\n            assert self.test_flag == [\"initialize\", \"stop\"]\n        finally:\n            await orig_stop()\n\n    async def test_multiple_inits_and_shutdowns(self, offline_bot, monkeypatch):\n        self.received = defaultdict(int)\n\n        async def initialize(*args, **kwargs):\n            self.received[\"init\"] += 1\n\n        async def shutdown(*args, **kwargs):\n            self.received[\"shutdown\"] += 1\n\n        monkeypatch.setattr(HTTPXRequest, \"initialize\", initialize)\n        monkeypatch.setattr(HTTPXRequest, \"shutdown\", shutdown)\n\n        test_bot = PytestBot(offline_bot.token)\n        await test_bot.initialize()\n        await test_bot.initialize()\n        await test_bot.initialize()\n        await test_bot.shutdown()\n        await test_bot.shutdown()\n        await test_bot.shutdown()\n\n        # 2 instead of 1 since we have to request objects for each offline_bot\n        assert self.received[\"init\"] == 2\n        assert self.received[\"shutdown\"] == 2\n\n    async def test_context_manager(self, monkeypatch, offline_bot):\n        async def initialize():\n            self.test_flag = [\"initialize\"]\n\n        async def shutdown(*args):\n            self.test_flag.append(\"stop\")\n\n        monkeypatch.setattr(offline_bot, \"initialize\", initialize)\n        monkeypatch.setattr(offline_bot, \"shutdown\", shutdown)\n\n        async with offline_bot:\n            pass\n\n        assert self.test_flag == [\"initialize\", \"stop\"]\n\n    async def test_context_manager_exception_on_init(self, monkeypatch, offline_bot):\n        async def initialize():\n            raise RuntimeError(\"initialize\")\n\n        async def shutdown():\n            self.test_flag = \"stop\"\n\n        monkeypatch.setattr(offline_bot, \"initialize\", initialize)\n        monkeypatch.setattr(offline_bot, \"shutdown\", shutdown)\n\n        with pytest.raises(RuntimeError, match=\"initialize\"):\n            async with offline_bot:\n                pass\n\n        assert self.test_flag == \"stop\"\n\n    async def test_shutdown_at_error_in_request_in_init(self, monkeypatch, offline_bot):\n        async def get_me_error():\n            raise httpx.HTTPError(\"BadRequest wrong token sry :(\")\n\n        async def shutdown(*args):\n            self.test_flag = \"stop\"\n\n        monkeypatch.setattr(offline_bot, \"get_me\", get_me_error)\n        monkeypatch.setattr(offline_bot, \"shutdown\", shutdown)\n\n        async with offline_bot:\n            pass\n\n        assert self.test_flag == \"stop\"\n\n    async def test_equality(self):\n        async with (\n            make_bot(token=FALLBACKS[0][\"token\"]) as a,\n            make_bot(token=FALLBACKS[0][\"token\"]) as b,\n            Bot(token=FALLBACKS[0][\"token\"]) as c,\n            make_bot(token=FALLBACKS[1][\"token\"]) as d,\n        ):\n            e = Update(123456789)\n            f = Bot(token=FALLBACKS[0][\"token\"])\n\n            assert a == b\n            assert hash(a) == hash(b)\n            assert a is not b\n\n            assert a == c\n            assert hash(a) == hash(c)\n\n            assert a != d\n            assert hash(a) != hash(d)\n\n            assert a != e\n            assert hash(a) != hash(e)\n\n            # We cant check equality for unintialized Bot object\n            assert hash(a) != hash(f)\n\n    @pytest.mark.parametrize(\n        \"attribute\",\n        [\n            \"id\",\n            \"username\",\n            \"first_name\",\n            \"last_name\",\n            \"name\",\n            \"can_join_groups\",\n            \"can_read_all_group_messages\",\n            \"supports_inline_queries\",\n            \"link\",\n        ],\n    )\n    async def test_get_me_and_properties_not_initialized(self, attribute):\n        bot = make_bot(offline=True, token=\"randomtoken\")\n        try:\n            with pytest.raises(RuntimeError, match=\"not properly initialized\"):\n                bot[attribute]\n        finally:\n            await bot.shutdown()\n\n    async def test_get_me_and_properties(self, offline_bot):\n        get_me_bot = await ExtBot(offline_bot.token).get_me()\n\n        assert isinstance(get_me_bot, User)\n        assert get_me_bot.id == offline_bot.id\n        assert get_me_bot.username == offline_bot.username\n        assert get_me_bot.first_name == offline_bot.first_name\n        assert get_me_bot.last_name == offline_bot.last_name\n        assert get_me_bot.name == offline_bot.name\n        assert get_me_bot.can_join_groups == offline_bot.can_join_groups\n        assert get_me_bot.can_read_all_group_messages == offline_bot.can_read_all_group_messages\n        assert get_me_bot.supports_inline_queries == offline_bot.supports_inline_queries\n        assert f\"https://t.me/{get_me_bot.username}\" == offline_bot.link\n\n    def test_bot_pickling_error(self, offline_bot):\n        with pytest.raises(pickle.PicklingError, match=\"Bot objects cannot be pickled\"):\n            pickle.dumps(offline_bot)\n\n    def test_bot_deepcopy_error(self, offline_bot):\n        with pytest.raises(TypeError, match=\"Bot objects cannot be deepcopied\"):\n            copy.deepcopy(offline_bot)\n\n    @pytest.mark.parametrize(\n        (\"cls\", \"logger_name\"), [(Bot, \"telegram.Bot\"), (ExtBot, \"telegram.ext.ExtBot\")]\n    )\n    async def test_bot_method_logging(self, offline_bot: PytestExtBot, cls, logger_name, caplog):\n        instance = cls(offline_bot.token)\n        # Second argument makes sure that we ignore logs from e.g. httpx\n        with caplog.at_level(logging.DEBUG, logger=\"telegram\"):\n            await instance.get_me()\n            # Only for stabilizing this test-\n            if len(caplog.records) == 4:\n                for idx, record in enumerate(caplog.records):\n                    print(record)\n                    if record.getMessage().startswith(\"Task was destroyed but it is pending\"):\n                        caplog.records.pop(idx)\n                    if record.getMessage().startswith(\"Task exception was never retrieved\"):\n                        caplog.records.pop(idx)\n            assert len(caplog.records) == 2\n\n            assert all(caplog.records[i].name == logger_name for i in [-1, 0])\n            assert (\n                caplog.records[0]\n                .getMessage()\n                .startswith(\"Calling Bot API endpoint `getMe` with parameters `{}`\")\n            )\n            assert (\n                caplog.records[-1]\n                .getMessage()\n                .startswith(\"Call to Bot API endpoint `getMe` finished with return value\")\n            )\n\n    @bot_methods()\n    def test_camel_case_aliases(self, bot_class, bot_method_name, bot_method):\n        camel_case_name = to_camel_case(bot_method_name)\n        camel_case_function = getattr(bot_class, camel_case_name, False)\n        assert camel_case_function is not False, f\"{camel_case_name} not found\"\n        assert camel_case_function is bot_method, f\"{camel_case_name} is not {bot_method}\"\n\n    @bot_methods(include_do_api_request=True)\n    def test_coroutine_functions(self, bot_class, bot_method_name, bot_method):\n        \"\"\"Check that all offline_bot methods are defined as async def  ...\"\"\"\n        meth = getattr(bot_method, \"__wrapped__\", bot_method)  # to unwrap the @_log decorator\n        assert inspect.iscoroutinefunction(meth), f\"{bot_method_name} must be a coroutine function\"\n\n    @bot_methods(include_do_api_request=True)\n    def test_api_kwargs_and_timeouts_present(self, bot_class, bot_method_name, bot_method):\n        \"\"\"Check that all offline_bot methods have `api_kwargs` and timeout params.\"\"\"\n        param_names = inspect.signature(bot_method).parameters.keys()\n        params = (\"pool_timeout\", \"read_timeout\", \"connect_timeout\", \"write_timeout\", \"api_kwargs\")\n\n        for param in params:\n            assert param in param_names, f\"{bot_method_name} is missing the parameter `{param}`\"\n\n        rate_arg = \"rate_limit_args\"\n        if bot_method_name.replace(\"_\", \"\").lower() != \"getupdates\" and bot_class is ExtBot:\n            assert rate_arg in param_names, f\"{bot_method} is missing the parameter `{rate_arg}`\"\n\n    @bot_methods()\n    async def test_defaults_handling(\n        self,\n        bot_class,\n        bot_method_name: str,\n        bot_method,\n        offline_bot: PytestExtBot,\n        raw_bot: PytestBot,\n    ):\n        \"\"\"\n        Here we check that the offline_bot methods handle tg.ext.Defaults correctly. This has two\n        parts:\n\n        1. Check that ExtBot actually inserts the defaults values correctly\n        2. Check that tg.Bot just replaces `DefaultValue(obj)` with `obj`, i.e. that it doesn't\n            pass any `DefaultValue` instances to Request. See the docstring of\n            tg.Bot._insert_defaults for details on why we need that\n\n        As for most defaults,\n        we can't really check the effect, we just check if we're passing the correct kwargs to\n        Request.post. As offline_bot method tests a scattered across the different test files, we\n        do this here in one place.\n\n        The same test is also run for all the shortcuts (Message.reply_text) etc in the\n        corresponding tests.\n\n        Finally, there are some tests for Defaults.{parse_mode, quote, allow_sending_without_reply}\n        at the appropriate places, as those are the only things we can actually check.\n        \"\"\"\n        # Check that ExtBot does the right thing\n        bot_method = getattr(offline_bot, bot_method_name)\n        raw_bot_method = getattr(raw_bot, bot_method_name)\n        assert await check_defaults_handling(bot_method, offline_bot)\n        assert await check_defaults_handling(raw_bot_method, raw_bot)\n\n    @pytest.mark.parametrize(\n        (\"name\", \"method\"), inspect.getmembers(Bot, predicate=inspect.isfunction)\n    )\n    def test_ext_bot_signature(self, name, method):\n        \"\"\"\n        Here we make sure that all methods of ext.ExtBot have the same signature as the\n        corresponding methods of tg.Bot.\n        \"\"\"\n        # Some methods of ext.ExtBot\n        global_extra_args = {\"rate_limit_args\"}\n        extra_args_per_method = defaultdict(\n            set, {\"__init__\": {\"arbitrary_callback_data\", \"defaults\", \"rate_limiter\"}}\n        )\n        different_hints_per_method = defaultdict(set, {\"__setattr__\": {\"ext_bot\"}})\n\n        signature = inspect.signature(method)\n        ext_signature = inspect.signature(getattr(ExtBot, name))\n\n        assert ext_signature.return_annotation == signature.return_annotation, (\n            f\"Wrong return annotation for method {name}\"\n        )\n        assert (\n            set(signature.parameters)\n            == set(ext_signature.parameters) - global_extra_args - extra_args_per_method[name]\n        ), f\"Wrong set of parameters for method {name}\"\n        for param_name, param in signature.parameters.items():\n            if param_name in different_hints_per_method[name]:\n                continue\n            assert param.annotation == ext_signature.parameters[param_name].annotation, (\n                f\"Wrong annotation for parameter {param_name} of method {name}\"\n            )\n            assert param.default == ext_signature.parameters[param_name].default, (\n                f\"Wrong default value for parameter {param_name} of method {name}\"\n            )\n            assert param.kind == ext_signature.parameters[param_name].kind, (\n                f\"Wrong parameter kind for parameter {param_name} of method {name}\"\n            )\n\n    async def test_unknown_kwargs(self, offline_bot, monkeypatch):\n        async def post(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            if not all([data[\"unknown_kwarg_1\"] == \"7\", data[\"unknown_kwarg_2\"] == \"5\"]):\n                pytest.fail(\"got wrong parameters\")\n            return True\n\n        monkeypatch.setattr(offline_bot.request, \"post\", post)\n        await offline_bot.send_message(\n            123, \"text\", api_kwargs={\"unknown_kwarg_1\": 7, \"unknown_kwarg_2\": 5}\n        )\n\n    async def test_get_updates_deserialization_error(self, offline_bot, monkeypatch, caplog):\n        async def faulty_do_request(*args, **kwargs):\n            return (\n                HTTPStatus.OK,\n                b'{\"ok\": true, \"result\": [{\"update_id\": \"1\", \"message\": \"unknown_format\"}]}',\n            )\n\n        monkeypatch.setattr(HTTPXRequest, \"do_request\", faulty_do_request)\n\n        offline_bot = PytestExtBot(get_updates_request=HTTPXRequest(), token=offline_bot.token)\n\n        with caplog.at_level(logging.CRITICAL), pytest.raises(AttributeError):\n            await offline_bot.get_updates()\n\n        assert len(caplog.records) == 1\n        assert caplog.records[0].name == \"telegram.ext.ExtBot\"\n        assert caplog.records[0].levelno == logging.CRITICAL\n        assert caplog.records[0].getMessage() == (\n            \"Error while parsing updates! Received data was \"\n            \"[{'update_id': '1', 'message': 'unknown_format'}]\"\n        )\n        assert caplog.records[0].exc_info[0] is AttributeError\n\n    async def test_answer_web_app_query(self, offline_bot, raw_bot, monkeypatch):\n        params = False\n\n        # For now just test that our internals pass the correct data\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            nonlocal params\n            params = request_data.parameters == {\n                \"web_app_query_id\": \"12345\",\n                \"result\": {\n                    \"title\": \"title\",\n                    \"input_message_content\": {\n                        \"message_text\": \"text\",\n                    },\n                    \"type\": InlineQueryResultType.ARTICLE,\n                    \"id\": \"1\",\n                },\n            }\n            return SentWebAppMessage(\"321\").to_dict()\n\n        # We test different result types more thoroughly for answer_inline_query, so we just\n        # use the one type here\n        result = InlineQueryResultArticle(\"1\", \"title\", InputTextMessageContent(\"text\"))\n        copied_result = copy.copy(result)\n\n        ext_bot = offline_bot\n        for bot_type in (ext_bot, raw_bot):\n            # We need to test 1) below both the offline_bot and raw_bot and setting this up with\n            # pytest.parametrize appears to be difficult ...\n            monkeypatch.setattr(bot_type.request, \"post\", make_assertion)\n            web_app_msg = await bot_type.answer_web_app_query(\"12345\", result)\n            assert params, \"something went wrong with passing arguments to the request\"\n            assert isinstance(web_app_msg, SentWebAppMessage)\n            assert web_app_msg.inline_message_id == \"321\"\n\n            # 1)\n            # make sure that the results were not edited in-place\n            assert result == copied_result\n            assert (\n                result.input_message_content.parse_mode\n                == copied_result.input_message_content.parse_mode\n            )\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"parse_mode\": \"Markdown\", \"link_preview_options\": LinkPreviewOptions(is_disabled=True)}],\n        indirect=True,\n    )\n    @pytest.mark.parametrize(\n        (\"ilq_result\", \"expected_params\"),\n        [\n            (\n                InlineQueryResultArticle(\"1\", \"title\", InputTextMessageContent(\"text\")),\n                {\n                    \"web_app_query_id\": \"12345\",\n                    \"result\": {\n                        \"title\": \"title\",\n                        \"input_message_content\": {\n                            \"message_text\": \"text\",\n                            \"parse_mode\": \"Markdown\",\n                            \"link_preview_options\": {\n                                \"is_disabled\": True,\n                            },\n                        },\n                        \"type\": InlineQueryResultType.ARTICLE,\n                        \"id\": \"1\",\n                    },\n                },\n            ),\n            (\n                InlineQueryResultArticle(\n                    \"1\",\n                    \"title\",\n                    InputTextMessageContent(\n                        \"text\", parse_mode=\"HTML\", disable_web_page_preview=False\n                    ),\n                ),\n                {\n                    \"web_app_query_id\": \"12345\",\n                    \"result\": {\n                        \"title\": \"title\",\n                        \"input_message_content\": {\n                            \"message_text\": \"text\",\n                            \"parse_mode\": \"HTML\",\n                            \"link_preview_options\": {\n                                \"is_disabled\": False,\n                            },\n                        },\n                        \"type\": InlineQueryResultType.ARTICLE,\n                        \"id\": \"1\",\n                    },\n                },\n            ),\n            (\n                InlineQueryResultArticle(\n                    \"1\",\n                    \"title\",\n                    InputTextMessageContent(\n                        \"text\", parse_mode=None, disable_web_page_preview=\"False\"\n                    ),\n                ),\n                {\n                    \"web_app_query_id\": \"12345\",\n                    \"result\": {\n                        \"title\": \"title\",\n                        \"input_message_content\": {\n                            \"message_text\": \"text\",\n                            \"link_preview_options\": {\n                                \"is_disabled\": \"False\",\n                            },\n                        },\n                        \"type\": InlineQueryResultType.ARTICLE,\n                        \"id\": \"1\",\n                    },\n                },\n            ),\n        ],\n    )\n    async def test_answer_web_app_query_defaults(\n        self, default_bot, ilq_result, expected_params, monkeypatch\n    ):\n        offline_bot = default_bot\n        params = False\n\n        # For now just test that our internals pass the correct data\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            nonlocal params\n            params = request_data.parameters == expected_params\n            return SentWebAppMessage(\"321\").to_dict()\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        # We test different result types more thoroughly for answer_inline_query, so we just\n        # use the one type here\n        copied_result = copy.copy(ilq_result)\n\n        web_app_msg = await offline_bot.answer_web_app_query(\"12345\", ilq_result)\n        assert params, \"something went wrong with passing arguments to the request\"\n        assert isinstance(web_app_msg, SentWebAppMessage)\n        assert web_app_msg.inline_message_id == \"321\"\n\n        # make sure that the results were not edited in-place\n        assert ilq_result == copied_result\n        assert (\n            ilq_result.input_message_content.parse_mode\n            == copied_result.input_message_content.parse_mode\n        )\n\n    # TODO: Needs improvement. We need incoming inline query to test answer.\n    @pytest.mark.parametrize(\"button_type\", [\"start\", \"web_app\"])\n    @pytest.mark.parametrize(\"cache_time\", [74, dtm.timedelta(seconds=74)])\n    async def test_answer_inline_query(\n        self, monkeypatch, offline_bot, raw_bot, button_type, cache_time\n    ):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            expected = {\n                \"cache_time\": 74,\n                \"results\": [\n                    {\n                        \"title\": \"first\",\n                        \"id\": \"11\",\n                        \"type\": \"article\",\n                        \"input_message_content\": {\"message_text\": \"first\"},\n                    },\n                    {\n                        \"title\": \"second\",\n                        \"id\": \"12\",\n                        \"type\": \"article\",\n                        \"input_message_content\": {\"message_text\": \"second\"},\n                    },\n                    {\n                        \"title\": \"test_result\",\n                        \"id\": \"123\",\n                        \"type\": \"document\",\n                        \"document_url\": (\n                            \"https://raw.githubusercontent.com/python-telegram-bot\"\n                            \"/logos/master/logo/png/ptb-logo_240.png\"\n                        ),\n                        \"mime_type\": \"image/png\",\n                        \"caption\": \"ptb_logo\",\n                        \"input_message_content\": {\"message_text\": \"imc\"},\n                    },\n                ],\n                \"next_offset\": \"42\",\n                \"inline_query_id\": 1234,\n                \"is_personal\": True,\n            }\n\n            if button_type == \"start\":\n                button_dict = {\"text\": \"button_text\", \"start_parameter\": \"start_parameter\"}\n            else:\n                button_dict = {\n                    \"text\": \"button_text\",\n                    \"web_app\": {\"url\": \"https://python-telegram-bot.org\"},\n                }\n\n            expected[\"button\"] = button_dict\n\n            return request_data.parameters == expected\n\n        results = [\n            InlineQueryResultArticle(\"11\", \"first\", InputTextMessageContent(\"first\")),\n            InlineQueryResultArticle(\"12\", \"second\", InputMessageContentLPO(\"second\")),\n            InlineQueryResultDocument(\n                id=\"123\",\n                document_url=(\n                    \"https://raw.githubusercontent.com/python-telegram-bot/logos/master/\"\n                    \"logo/png/ptb-logo_240.png\"\n                ),\n                title=\"test_result\",\n                mime_type=\"image/png\",\n                caption=\"ptb_logo\",\n                input_message_content=InputMessageContentLPO(\"imc\"),\n            ),\n        ]\n\n        if button_type == \"start\":\n            button = InlineQueryResultsButton(\n                text=\"button_text\", start_parameter=\"start_parameter\"\n            )\n        elif button_type == \"web_app\":\n            button = InlineQueryResultsButton(\n                text=\"button_text\", web_app=WebAppInfo(\"https://python-telegram-bot.org\")\n            )\n        else:\n            button = None\n\n        copied_results = copy.copy(results)\n        ext_bot = offline_bot\n        for bot_type in (ext_bot, raw_bot):\n            # We need to test 1) below both the offline_bot and raw_bot and setting this up with\n            # pytest.parametrize appears to be difficult ...\n            monkeypatch.setattr(bot_type.request, \"post\", make_assertion)\n            assert await bot_type.answer_inline_query(\n                1234,\n                results=results,\n                cache_time=cache_time,\n                is_personal=True,\n                next_offset=\"42\",\n                button=button,\n            )\n\n            # 1)\n            # make sure that the results were not edited in-place\n            assert results == copied_results\n            for idx, result in enumerate(results):\n                if hasattr(result, \"parse_mode\"):\n                    assert result.parse_mode == copied_results[idx].parse_mode\n                if hasattr(result, \"input_message_content\"):\n                    assert getattr(result.input_message_content, \"parse_mode\", None) == getattr(\n                        copied_results[idx].input_message_content, \"parse_mode\", None\n                    )\n                    assert getattr(\n                        result.input_message_content, \"disable_web_page_preview\", None\n                    ) == getattr(\n                        copied_results[idx].input_message_content, \"disable_web_page_preview\", None\n                    )\n\n            monkeypatch.delattr(bot_type.request, \"post\")\n\n    async def test_answer_inline_query_no_default_parse_mode(self, monkeypatch, offline_bot):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\n                \"cache_time\": 300,\n                \"results\": [\n                    {\n                        \"title\": \"first\",\n                        \"id\": \"11\",\n                        \"type\": \"article\",\n                        \"input_message_content\": {\"message_text\": \"first\"},\n                    },\n                    {\n                        \"title\": \"second\",\n                        \"id\": \"12\",\n                        \"type\": \"article\",\n                        \"input_message_content\": {\"message_text\": \"second\"},\n                    },\n                    {\n                        \"title\": \"test_result\",\n                        \"id\": \"123\",\n                        \"type\": \"document\",\n                        \"document_url\": (\n                            \"https://raw.githubusercontent.com/\"\n                            \"python-telegram-bot/logos/master/logo/png/\"\n                            \"ptb-logo_240.png\"\n                        ),\n                        \"mime_type\": \"image/png\",\n                        \"caption\": \"ptb_logo\",\n                        \"input_message_content\": {\"message_text\": \"imc\"},\n                    },\n                ],\n                \"next_offset\": \"42\",\n                \"inline_query_id\": 1234,\n                \"is_personal\": True,\n            }\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        results = [\n            InlineQueryResultArticle(\"11\", \"first\", InputTextMessageContent(\"first\")),\n            InlineQueryResultArticle(\"12\", \"second\", InputMessageContentLPO(\"second\")),\n            InlineQueryResultDocument(\n                id=\"123\",\n                document_url=(\n                    \"https://raw.githubusercontent.com/python-telegram-bot/logos/master/\"\n                    \"logo/png/ptb-logo_240.png\"\n                ),\n                title=\"test_result\",\n                mime_type=\"image/png\",\n                caption=\"ptb_logo\",\n                input_message_content=InputMessageContentLPO(\"imc\"),\n            ),\n        ]\n\n        copied_results = copy.copy(results)\n        assert await offline_bot.answer_inline_query(\n            1234,\n            results=results,\n            cache_time=300,\n            is_personal=True,\n            next_offset=\"42\",\n        )\n        # make sure that the results were not edited in-place\n        assert results == copied_results\n        for idx, result in enumerate(results):\n            if hasattr(result, \"parse_mode\"):\n                assert result.parse_mode == copied_results[idx].parse_mode\n            if hasattr(result, \"input_message_content\"):\n                assert getattr(result.input_message_content, \"parse_mode\", None) == getattr(\n                    copied_results[idx].input_message_content, \"parse_mode\", None\n                )\n                assert getattr(\n                    result.input_message_content, \"disable_web_page_preview\", None\n                ) == getattr(\n                    copied_results[idx].input_message_content, \"disable_web_page_preview\", None\n                )\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"parse_mode\": \"Markdown\", \"link_preview_options\": LinkPreviewOptions(is_disabled=True)}],\n        indirect=True,\n    )\n    async def test_answer_inline_query_default_parse_mode(self, monkeypatch, default_bot):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\n                \"cache_time\": 300,\n                \"results\": [\n                    {\n                        \"title\": \"first\",\n                        \"id\": \"11\",\n                        \"type\": InlineQueryResultType.ARTICLE,\n                        \"input_message_content\": {\n                            \"message_text\": \"first\",\n                            \"parse_mode\": \"Markdown\",\n                            \"link_preview_options\": {\n                                \"is_disabled\": True,\n                            },\n                        },\n                    },\n                    {\n                        \"title\": \"second\",\n                        \"id\": \"12\",\n                        \"type\": InlineQueryResultType.ARTICLE,\n                        \"input_message_content\": {\n                            \"message_text\": \"second\",\n                            \"link_preview_options\": {\n                                \"is_disabled\": True,\n                            },\n                        },\n                    },\n                    {\n                        \"title\": \"test_result\",\n                        \"id\": \"123\",\n                        \"type\": InlineQueryResultType.DOCUMENT,\n                        \"document_url\": (\n                            \"https://raw.githubusercontent.com/\"\n                            \"python-telegram-bot/logos/master/logo/png/\"\n                            \"ptb-logo_240.png\"\n                        ),\n                        \"mime_type\": \"image/png\",\n                        \"caption\": \"ptb_logo\",\n                        \"parse_mode\": \"Markdown\",\n                        \"input_message_content\": {\n                            \"message_text\": \"imc\",\n                            \"link_preview_options\": {\n                                \"is_disabled\": True,\n                            },\n                            \"parse_mode\": \"Markdown\",\n                        },\n                    },\n                ],\n                \"next_offset\": \"42\",\n                \"inline_query_id\": 1234,\n                \"is_personal\": True,\n            }\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        results = [\n            InlineQueryResultArticle(\"11\", \"first\", InputTextMessageContent(\"first\")),\n            InlineQueryResultArticle(\"12\", \"second\", InputMessageContentLPO(\"second\")),\n            InlineQueryResultDocument(\n                id=\"123\",\n                document_url=(\n                    \"https://raw.githubusercontent.com/python-telegram-bot/logos/master/\"\n                    \"logo/png/ptb-logo_240.png\"\n                ),\n                title=\"test_result\",\n                mime_type=\"image/png\",\n                caption=\"ptb_logo\",\n                input_message_content=InputTextMessageContent(\"imc\"),\n            ),\n        ]\n\n        copied_results = copy.copy(results)\n        assert await default_bot.answer_inline_query(\n            1234,\n            results=results,\n            cache_time=300,\n            is_personal=True,\n            next_offset=\"42\",\n        )\n        # make sure that the results were not edited in-place\n        assert results == copied_results\n        for idx, result in enumerate(results):\n            if hasattr(result, \"parse_mode\"):\n                assert result.parse_mode == copied_results[idx].parse_mode\n            if hasattr(result, \"input_message_content\"):\n                assert getattr(result.input_message_content, \"parse_mode\", None) == getattr(\n                    copied_results[idx].input_message_content, \"parse_mode\", None\n                )\n                assert getattr(\n                    result.input_message_content, \"disable_web_page_preview\", None\n                ) == getattr(\n                    copied_results[idx].input_message_content, \"disable_web_page_preview\", None\n                )\n\n    @pytest.mark.parametrize(\n        (\"current_offset\", \"num_results\", \"id_offset\", \"expected_next_offset\"),\n        [\n            (\"\", InlineQueryLimit.RESULTS, 1, 1),\n            (1, InlineQueryLimit.RESULTS, 51, 2),\n            (5, 3, 251, \"\"),\n        ],\n    )\n    async def test_answer_inline_query_current_offset_1(\n        self,\n        monkeypatch,\n        offline_bot,\n        inline_results,\n        current_offset,\n        num_results,\n        id_offset,\n        expected_next_offset,\n    ):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            results = data[\"results\"]\n            length_matches = len(results) == num_results\n            ids_match = all(int(res[\"id\"]) == id_offset + i for i, res in enumerate(results))\n            next_offset_matches = data[\"next_offset\"] == str(expected_next_offset)\n            return length_matches and ids_match and next_offset_matches\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.answer_inline_query(\n            1234, results=inline_results, current_offset=current_offset\n        )\n\n    async def test_answer_inline_query_current_offset_2(\n        self, monkeypatch, offline_bot, inline_results\n    ):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            results = data[\"results\"]\n            length_matches = len(results) == InlineQueryLimit.RESULTS\n            ids_match = all(int(res[\"id\"]) == 1 + i for i, res in enumerate(results))\n            next_offset_matches = data[\"next_offset\"] == \"1\"\n            return length_matches and ids_match and next_offset_matches\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.answer_inline_query(\n            1234, results=inline_results, current_offset=0\n        )\n\n        inline_results = inline_results[:30]\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            results = data[\"results\"]\n            length_matches = len(results) == 30\n            ids_match = all(int(res[\"id\"]) == 1 + i for i, res in enumerate(results))\n            next_offset_matches = not data[\"next_offset\"]\n            return length_matches and ids_match and next_offset_matches\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.answer_inline_query(\n            1234, results=inline_results, current_offset=0\n        )\n\n    async def test_answer_inline_query_current_offset_callback(self, monkeypatch, offline_bot):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            results = data[\"results\"]\n            length = len(results) == 5\n            ids = all(int(res[\"id\"]) == 6 + i for i, res in enumerate(results))\n            next_offset = data[\"next_offset\"] == \"2\"\n            return length and ids and next_offset\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.answer_inline_query(\n            1234, results=inline_results_callback, current_offset=1\n        )\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            results = data[\"results\"]\n            length = results == []\n            next_offset = not data[\"next_offset\"]\n            return length and next_offset\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.answer_inline_query(\n            1234, results=inline_results_callback, current_offset=6\n        )\n\n    async def test_send_edit_message_mutually_exclusive_link_preview(self, offline_bot, chat_id):\n        \"\"\"Test that link_preview is mutually exclusive with disable_web_page_preview.\"\"\"\n        with pytest.raises(ValueError, match=\"`link_preview_options` are mutually exclusive\"):\n            await offline_bot.send_message(\n                chat_id, \"text\", disable_web_page_preview=True, link_preview_options=\"something\"\n            )\n\n        with pytest.raises(ValueError, match=\"`link_preview_options` are mutually exclusive\"):\n            await offline_bot.edit_message_text(\n                \"text\", chat_id, 1, disable_web_page_preview=True, link_preview_options=\"something\"\n            )\n\n    async def test_rtm_aswr_mutually_exclusive_reply_parameters(self, offline_bot, chat_id):\n        \"\"\"Test that reply_to_message_id and allow_sending_without_reply are mutually exclusive\n        with reply_parameters.\"\"\"\n        with pytest.raises(ValueError, match=\"`reply_to_message_id` and\"):\n            await offline_bot.send_message(\n                chat_id, \"text\", reply_to_message_id=1, reply_parameters=True\n            )\n\n        with pytest.raises(ValueError, match=\"`allow_sending_without_reply` and\"):\n            await offline_bot.send_message(\n                chat_id, \"text\", allow_sending_without_reply=True, reply_parameters=True\n            )\n\n        # Test with copy message\n        with pytest.raises(ValueError, match=\"`reply_to_message_id` and\"):\n            await offline_bot.copy_message(\n                chat_id, chat_id, 1, reply_to_message_id=1, reply_parameters=True\n            )\n\n        with pytest.raises(ValueError, match=\"`allow_sending_without_reply` and\"):\n            await offline_bot.copy_message(\n                chat_id, chat_id, 1, allow_sending_without_reply=True, reply_parameters=True\n            )\n\n        # Test with send media group\n        media = InputMediaPhoto(\"\")\n        with pytest.raises(ValueError, match=\"`reply_to_message_id` and\"):\n            await offline_bot.send_media_group(\n                chat_id, media, reply_to_message_id=1, reply_parameters=True\n            )\n\n        with pytest.raises(ValueError, match=\"`allow_sending_without_reply` and\"):\n            await offline_bot.send_media_group(\n                chat_id, media, allow_sending_without_reply=True, reply_parameters=True\n            )\n\n    # get_file is tested multiple times in the test_*media* modules.\n    # Here we only test the behaviour for offline_bot apis in local mode\n    async def test_get_file_local_mode(self, offline_bot, monkeypatch):\n        path = str(data_file(\"game.gif\"))\n\n        async def make_assertion(*args, **kwargs):\n            return {\n                \"file_id\": None,\n                \"file_unique_id\": None,\n                \"file_size\": None,\n                \"file_path\": path,\n            }\n\n        monkeypatch.setattr(offline_bot, \"_post\", make_assertion)\n\n        resulting_path = (await offline_bot.get_file(\"file_id\")).file_path\n        assert offline_bot.token not in resulting_path\n        assert resulting_path == path\n\n    # TODO: Needs improvement. No feasible way to test until bots can add members.\n    async def test_ban_chat_member(self, monkeypatch, offline_bot):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            chat_id = data[\"chat_id\"] == \"2\"\n            user_id = data[\"user_id\"] == \"32\"\n            until_date = data.get(\"until_date\", \"1577887200\") == \"1577887200\"\n            revoke_msgs = data.get(\"revoke_messages\", \"true\") == \"true\"\n            return chat_id and user_id and until_date and revoke_msgs\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        until = from_timestamp(1577887200)\n\n        assert await offline_bot.ban_chat_member(2, 32)\n        assert await offline_bot.ban_chat_member(2, 32, until_date=until)\n        assert await offline_bot.ban_chat_member(2, 32, until_date=1577887200)\n        assert await offline_bot.ban_chat_member(2, 32, revoke_messages=True)\n\n    async def test_ban_chat_member_default_tz(self, monkeypatch, tz_bot):\n        until = dtm.datetime(2020, 1, 11, 16, 13)\n        until_timestamp = to_timestamp(until, tzinfo=tz_bot.defaults.tzinfo)\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            user_id = data[\"user_id\"] == 32\n            until_date = data.get(\"until_date\", until_timestamp) == until_timestamp\n            return chat_id and user_id and until_date\n\n        monkeypatch.setattr(tz_bot.request, \"post\", make_assertion)\n\n        assert await tz_bot.ban_chat_member(2, 32)\n        assert await tz_bot.ban_chat_member(2, 32, until_date=until)\n        assert await tz_bot.ban_chat_member(2, 32, until_date=until_timestamp)\n\n    async def test_ban_chat_sender_chat(self, monkeypatch, offline_bot):\n        # For now, we just test that we pass the correct data to TG\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            sender_chat_id = data[\"sender_chat_id\"] == 32\n            return chat_id and sender_chat_id\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.ban_chat_sender_chat(2, 32)\n\n    # TODO: Needs improvement.\n    @pytest.mark.parametrize(\"only_if_banned\", [True, False, None])\n    async def test_unban_chat_member(self, monkeypatch, offline_bot, only_if_banned):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            user_id = data[\"user_id\"] == 32\n            o_i_b = data.get(\"only_if_banned\", None) == only_if_banned\n            return chat_id and user_id and o_i_b\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.unban_chat_member(2, 32, only_if_banned=only_if_banned)\n\n    async def test_unban_chat_sender_chat(self, monkeypatch, offline_bot):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            chat_id = data[\"chat_id\"] == \"2\"\n            sender_chat_id = data[\"sender_chat_id\"] == \"32\"\n            return chat_id and sender_chat_id\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.unban_chat_sender_chat(2, 32)\n\n    async def test_set_chat_permissions(self, monkeypatch, offline_bot, chat_permissions):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            chat_id = data[\"chat_id\"] == \"2\"\n            permissions = data[\"permissions\"] == chat_permissions.to_json()\n            use_independent_chat_permissions = data[\"use_independent_chat_permissions\"]\n            return chat_id and permissions and use_independent_chat_permissions\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.set_chat_permissions(2, chat_permissions, True)\n\n    async def test_set_chat_administrator_custom_title(self, monkeypatch, offline_bot):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            user_id = data[\"user_id\"] == 32\n            custom_title = data[\"custom_title\"] == \"custom_title\"\n            return chat_id and user_id and custom_title\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.set_chat_administrator_custom_title(2, 32, \"custom_title\")\n\n    # TODO: Needs improvement. Need an incoming callbackquery to test\n    @pytest.mark.parametrize(\"cache_time\", [74, dtm.timedelta(seconds=74)])\n    async def test_answer_callback_query(self, monkeypatch, offline_bot, cache_time):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\n                \"callback_query_id\": 23,\n                \"show_alert\": True,\n                \"url\": \"no_url\",\n                \"cache_time\": 74,\n                \"text\": \"answer\",\n            }\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.answer_callback_query(\n            23, text=\"answer\", show_alert=True, url=\"no_url\", cache_time=cache_time\n        )\n\n    @pytest.mark.parametrize(\"drop_pending_updates\", [True, False])\n    async def test_set_webhook_delete_webhook_drop_pending_updates(\n        self, offline_bot, drop_pending_updates, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            return data.get(\"drop_pending_updates\") == drop_pending_updates\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.set_webhook(\"\", drop_pending_updates=drop_pending_updates)\n        assert await offline_bot.delete_webhook(drop_pending_updates=drop_pending_updates)\n\n    @pytest.mark.parametrize(\"local_file\", [\"str\", \"Path\", False])\n    async def test_set_webhook_params(self, offline_bot, monkeypatch, local_file):\n        # actually making calls to TG is done in\n        # test_set_webhook_get_webhook_info_and_delete_webhook. Sadly secret_token can't be tested\n        # there so we have this function \\o/\n        async def make_assertion(*args, **_):\n            kwargs = args[1]\n\n            if local_file is False:\n                cert_assertion = (\n                    kwargs[\"certificate\"].input_file_content\n                    == data_file(\"sslcert.pem\").read_bytes()\n                )\n            else:\n                cert_assertion = data_file(\"sslcert.pem\").as_uri()\n\n            return (\n                kwargs[\"url\"] == \"example.com\"\n                and cert_assertion\n                and kwargs[\"max_connections\"] == 7\n                and kwargs[\"allowed_updates\"] == [\"messages\"]\n                and kwargs[\"ip_address\"] == \"127.0.0.1\"\n                and kwargs[\"drop_pending_updates\"]\n                and kwargs[\"secret_token\"] == \"SoSecretToken\"\n            )\n\n        monkeypatch.setattr(offline_bot, \"_post\", make_assertion)\n\n        cert_path = data_file(\"sslcert.pem\")\n        if local_file == \"str\":\n            certificate = str(cert_path)\n        elif local_file == \"Path\":\n            certificate = cert_path\n        else:\n            certificate = cert_path.read_bytes()\n\n        assert await offline_bot.set_webhook(\n            \"example.com\",\n            certificate,\n            7,\n            [\"messages\"],\n            \"127.0.0.1\",\n            True,\n            \"SoSecretToken\",\n        )\n\n    # TODO: Needs improvement. Need incoming shipping queries to test\n    async def test_answer_shipping_query_ok(self, monkeypatch, offline_bot):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\n                \"shipping_query_id\": 1,\n                \"ok\": True,\n                \"shipping_options\": [\n                    {\"title\": \"option1\", \"prices\": [{\"label\": \"price\", \"amount\": 100}], \"id\": 1}\n                ],\n            }\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        shipping_options = ShippingOption(1, \"option1\", [LabeledPrice(\"price\", 100)])\n        assert await offline_bot.answer_shipping_query(\n            1, True, shipping_options=[shipping_options]\n        )\n\n    async def test_answer_shipping_query_error_message(self, monkeypatch, offline_bot):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\n                \"shipping_query_id\": 1,\n                \"error_message\": \"Not enough fish\",\n                \"ok\": False,\n            }\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.answer_shipping_query(1, False, error_message=\"Not enough fish\")\n\n    # TODO: Needs improvement. Need incoming pre checkout queries to test\n    async def test_answer_pre_checkout_query_ok(self, monkeypatch, offline_bot):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\"pre_checkout_query_id\": 1, \"ok\": True}\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.answer_pre_checkout_query(1, True)\n\n    async def test_answer_pre_checkout_query_error_message(self, monkeypatch, offline_bot):\n        # For now just test that our internals pass the correct data\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters == {\n                \"pre_checkout_query_id\": 1,\n                \"error_message\": \"Not enough fish\",\n                \"ok\": False,\n            }\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.answer_pre_checkout_query(\n            1, False, error_message=\"Not enough fish\"\n        )\n\n    async def test_restrict_chat_member(self, offline_bot, chat_permissions, monkeypatch):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            chat_id = data[\"chat_id\"] == \"@chat\"\n            user_id = data[\"user_id\"] == \"2\"\n            permissions = data[\"permissions\"] == chat_permissions.to_json()\n            until_date = data[\"until_date\"] == \"200\"\n            use_independent_chat_permissions = data[\"use_independent_chat_permissions\"]\n            return (\n                chat_id\n                and user_id\n                and permissions\n                and until_date\n                and use_independent_chat_permissions\n            )\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.restrict_chat_member(\"@chat\", 2, chat_permissions, 200, True)\n\n    async def test_restrict_chat_member_default_tz(\n        self, monkeypatch, tz_bot, channel_id, chat_permissions\n    ):\n        until = dtm.datetime(2020, 1, 11, 16, 13)\n        until_timestamp = to_timestamp(until, tzinfo=tz_bot.defaults.tzinfo)\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters.get(\"until_date\", until_timestamp) == until_timestamp\n\n        monkeypatch.setattr(tz_bot.request, \"post\", make_assertion)\n\n        assert await tz_bot.restrict_chat_member(channel_id, 95205500, chat_permissions)\n        assert await tz_bot.restrict_chat_member(\n            channel_id, 95205500, chat_permissions, until_date=until\n        )\n        assert await tz_bot.restrict_chat_member(\n            channel_id, 95205500, chat_permissions, until_date=until_timestamp\n        )\n\n    @pytest.mark.parametrize(\"local_mode\", [True, False])\n    async def test_set_chat_photo_local_files(\n        self, dummy_message_dict, monkeypatch, offline_bot, chat_id, local_mode\n    ):\n        try:\n            offline_bot._local_mode = local_mode\n            # For just test that the correct paths are passed as we have no local Bot API set up\n            self.test_flag = False\n            file = data_file(\"telegram.jpg\")\n            expected = file.as_uri()\n\n            async def make_assertion(_, data, *args, **kwargs):\n                if local_mode:\n                    self.test_flag = data.get(\"photo\") == expected\n                else:\n                    self.test_flag = isinstance(data.get(\"photo\"), InputFile)\n\n            monkeypatch.setattr(offline_bot, \"_post\", make_assertion)\n            await offline_bot.set_chat_photo(chat_id, file)\n            assert self.test_flag\n        finally:\n            offline_bot._local_mode = False\n\n    async def test_timeout_propagation_explicit(self, monkeypatch, offline_bot, chat_id):\n        # Use BaseException that's not a subclass of Exception such that\n        # OkException should not be caught anywhere\n        class OkException(BaseException):\n            pass\n\n        timeout = 42\n\n        async def do_request(*args, **kwargs):\n            obj = kwargs.get(\"read_timeout\")\n            if obj == timeout:\n                raise OkException\n\n            return 200, b'{\"ok\": true, \"result\": []}'\n\n        monkeypatch.setattr(offline_bot.request, \"do_request\", do_request)\n\n        # Test file uploading\n        with pytest.raises(OkException):\n            await offline_bot.send_photo(\n                chat_id, data_file(\"telegram.jpg\").open(\"rb\"), read_timeout=timeout\n            )\n\n        # Test JSON submission\n        with pytest.raises(OkException):\n            await offline_bot.get_chat_administrators(chat_id, read_timeout=timeout)\n\n    async def test_timeout_propagation_implicit(self, monkeypatch, offline_bot, chat_id):\n        # Use BaseException that's not a subclass of Exception such that\n        # OkException should not be caught anywhere\n        class OkException(BaseException):\n            pass\n\n        async def request(*args, **kwargs):\n            timeout = kwargs.get(\"timeout\")\n            if timeout.write == 20:\n                raise OkException\n\n            return 200, b'{\"ok\": true, \"result\": []}'\n\n        monkeypatch.setattr(httpx.AsyncClient, \"request\", request)\n        monkeypatch.setattr(offline_bot, \"_request\", (object(), HTTPXRequest()))\n\n        # Test file uploading\n        with pytest.raises(OkException):\n            await offline_bot.send_photo(chat_id, data_file(\"telegram.jpg\").open(\"rb\"))\n\n    async def test_log_out(self, monkeypatch, offline_bot):\n        # We don't actually make a request as to not break the test setup\n        async def assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.json_parameters == {} and url.split(\"/\")[-1] == \"logOut\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", assertion)\n\n        assert await offline_bot.log_out()\n\n    async def test_close(self, monkeypatch, offline_bot):\n        # We don't actually make a request as to not break the test setup\n        async def assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.json_parameters == {} and url.split(\"/\")[-1] == \"close\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", assertion)\n\n        assert await offline_bot.close()\n\n    @pytest.mark.parametrize(\"json_keyboard\", [True, False])\n    @pytest.mark.parametrize(\"caption\", [\"<b>Test</b>\", \"\", None])\n    async def test_copy_message(\n        self, monkeypatch, offline_bot, chat_id, media_message, json_keyboard, caption\n    ):\n        keyboard = InlineKeyboardMarkup(\n            [[InlineKeyboardButton(text=\"test\", callback_data=\"test2\")]]\n        )\n\n        async def post(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            if not all(\n                [\n                    data[\"chat_id\"] == chat_id,\n                    data[\"from_chat_id\"] == chat_id,\n                    data[\"message_id\"] == media_message.message_id,\n                    data.get(\"caption\") == caption,\n                    data[\"parse_mode\"] == ParseMode.HTML,\n                    data[\"reply_parameters\"]\n                    == ReplyParameters(message_id=media_message.message_id).to_dict(),\n                    (\n                        data[\"reply_markup\"] == keyboard.to_json()\n                        if json_keyboard\n                        else keyboard.to_dict()\n                    ),\n                    data[\"disable_notification\"] is True,\n                    data[\"caption_entities\"]\n                    == [MessageEntity(MessageEntity.BOLD, 0, 4).to_dict()],\n                    data[\"protect_content\"] is True,\n                    data[\"message_thread_id\"] == 1,\n                    data[\"video_start_timestamp\"] == 999,\n                ]\n            ):\n                pytest.fail(\"I got wrong parameters in post\")\n            return data\n\n        monkeypatch.setattr(offline_bot.request, \"post\", post)\n        await offline_bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=caption,\n            video_start_timestamp=999,\n            caption_entities=[MessageEntity(MessageEntity.BOLD, 0, 4)],\n            parse_mode=ParseMode.HTML,\n            reply_to_message_id=media_message.message_id,\n            reply_markup=keyboard.to_json() if json_keyboard else keyboard,\n            disable_notification=True,\n            protect_content=True,\n            message_thread_id=1,\n        )\n\n    # In the following tests we check that get_updates inserts callback data correctly if necessary\n    # The same must be done in the webhook updater. This is tested over at test_updater.py, but\n    # here we test more extensively.\n\n    @pytest.mark.parametrize(\n        (\"acd_in\", \"maxsize\"),\n        [(True, 1024), (False, 1024), (0, 0), (None, None)],\n    )\n    async def test_callback_data_maxsize(self, bot_info, acd_in, maxsize):\n        async with make_bot(bot_info, arbitrary_callback_data=acd_in, offline=True) as acd_bot:\n            if acd_in is not False:\n                assert acd_bot.callback_data_cache.maxsize == maxsize\n            else:\n                assert acd_bot.callback_data_cache is None\n\n    async def test_arbitrary_callback_data_no_insert(self, monkeypatch, cdc_bot):\n        \"\"\"Updates that don't need insertion shouldn't fail obviously\"\"\"\n        offline_bot = cdc_bot\n\n        async def post(*args, **kwargs):\n            update = Update(\n                17,\n                poll=Poll(\n                    \"42\",\n                    \"question\",\n                    options=[PollOption(\"option\", 0)],\n                    total_voter_count=0,\n                    is_closed=False,\n                    is_anonymous=True,\n                    type=Poll.REGULAR,\n                    allows_multiple_answers=False,\n                ),\n            )\n            return [update.to_dict()]\n\n        try:\n            monkeypatch.setattr(BaseRequest, \"post\", post)\n            updates = await offline_bot.get_updates(timeout=1)\n\n            assert len(updates) == 1\n            assert updates[0].update_id == 17\n            assert updates[0].poll.id == \"42\"\n        finally:\n            offline_bot.callback_data_cache.clear_callback_data()\n            offline_bot.callback_data_cache.clear_callback_queries()\n\n    @pytest.mark.parametrize(\n        \"message_type\", [\"channel_post\", \"edited_channel_post\", \"message\", \"edited_message\"]\n    )\n    async def test_arbitrary_callback_data_pinned_message_reply_to_message(\n        self, cdc_bot, monkeypatch, message_type\n    ):\n        offline_bot = cdc_bot\n\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"callback_data\")\n        )\n\n        message = Message(\n            1,\n            dtm.datetime.utcnow(),\n            get_dummy_object(Chat),\n            reply_markup=offline_bot.callback_data_cache.process_keyboard(reply_markup),\n        )\n        message._unfreeze()\n        # We do to_dict -> de_json to make sure those aren't the same objects\n        message.pinned_message = Message.de_json(message.to_dict(), offline_bot)\n\n        async def post(*args, **kwargs):\n            update = Update(\n                17,\n                **{\n                    message_type: Message(\n                        1,\n                        dtm.datetime.utcnow(),\n                        get_dummy_object(Chat),\n                        pinned_message=message,\n                        reply_to_message=Message.de_json(message.to_dict(), offline_bot),\n                    )\n                },\n            )\n            return [update.to_dict()]\n\n        try:\n            monkeypatch.setattr(BaseRequest, \"post\", post)\n            updates = await offline_bot.get_updates(timeout=1)\n\n            assert isinstance(updates, tuple)\n            assert len(updates) == 1\n\n            effective_message = updates[0][message_type]\n            assert (\n                effective_message.reply_to_message.reply_markup.inline_keyboard[0][0].callback_data\n                == \"callback_data\"\n            )\n            assert (\n                effective_message.pinned_message.reply_markup.inline_keyboard[0][0].callback_data\n                == \"callback_data\"\n            )\n\n            pinned_message = effective_message.reply_to_message.pinned_message\n            assert (\n                pinned_message.reply_markup.inline_keyboard[0][0].callback_data == \"callback_data\"\n            )\n\n        finally:\n            offline_bot.callback_data_cache.clear_callback_data()\n            offline_bot.callback_data_cache.clear_callback_queries()\n\n    async def test_get_updates_invalid_callback_data(self, cdc_bot, monkeypatch):\n        offline_bot = cdc_bot\n\n        async def post(*args, **kwargs):\n            return [\n                Update(\n                    17,\n                    callback_query=CallbackQuery(\n                        id=1,\n                        from_user=None,\n                        chat_instance=123,\n                        data=\"invalid data\",\n                        message=Message(\n                            1,\n                            from_user=User(1, \"\", False),\n                            date=dtm.datetime.utcnow(),\n                            chat=Chat(1, \"\"),\n                            text=\"Webhook\",\n                        ),\n                    ),\n                ).to_dict()\n            ]\n\n        try:\n            monkeypatch.setattr(BaseRequest, \"post\", post)\n            updates = await offline_bot.get_updates(timeout=1)\n\n            assert isinstance(updates, tuple)\n            assert len(updates) == 1\n            assert isinstance(updates[0].callback_query.data, InvalidCallbackData)\n\n        finally:\n            # Reset b/c bots scope is session\n            offline_bot.callback_data_cache.clear_callback_data()\n            offline_bot.callback_data_cache.clear_callback_queries()\n\n    # TODO: Needs improvement. We need incoming inline query to test answer.\n    async def test_replace_callback_data_answer_inline_query(self, monkeypatch, cdc_bot, chat_id):\n        offline_bot = cdc_bot\n\n        # For now just test that our internals pass the correct data\n        async def make_assertion(\n            endpoint,\n            data=None,\n            *args,\n            **kwargs,\n        ):\n            inline_keyboard = data[\"results\"][0][\"reply_markup\"].inline_keyboard\n            assertion_1 = inline_keyboard[0][1] == no_replace_button\n            assertion_2 = inline_keyboard[0][0] != replace_button\n            keyboard, button = (\n                inline_keyboard[0][0].callback_data[:32],\n                inline_keyboard[0][0].callback_data[32:],\n            )\n            assertion_3 = (\n                offline_bot.callback_data_cache._keyboard_data[keyboard].button_data[button]\n                == \"replace_test\"\n            )\n            assertion_4 = data[\"results\"][1].reply_markup is None\n            return assertion_1 and assertion_2 and assertion_3 and assertion_4\n\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n\n            # call this here so `offline_bot.get_me()` won't be called after mocking\n            offline_bot.username\n            monkeypatch.setattr(offline_bot, \"_post\", make_assertion)\n            results = [\n                InlineQueryResultArticle(\n                    \"11\", \"first\", InputTextMessageContent(\"first\"), reply_markup=reply_markup\n                ),\n                InlineQueryResultVoice(\n                    \"22\",\n                    \"https://python-telegram-bot.org/static/testfiles/telegram.ogg\",\n                    title=\"second\",\n                ),\n            ]\n\n            assert await offline_bot.answer_inline_query(chat_id, results=results)\n\n        finally:\n            offline_bot.callback_data_cache.clear_callback_data()\n            offline_bot.callback_data_cache.clear_callback_queries()\n\n    @pytest.mark.parametrize(\n        \"message_type\", [\"channel_post\", \"edited_channel_post\", \"message\", \"edited_message\"]\n    )\n    @pytest.mark.parametrize(\"self_sender\", [True, False])\n    async def test_arbitrary_callback_data_via_bot(\n        self, cdc_bot, monkeypatch, self_sender, message_type\n    ):\n        bot = cdc_bot\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"callback_data\")\n        )\n\n        reply_markup = bot.callback_data_cache.process_keyboard(reply_markup)\n        message = Message(\n            1,\n            dtm.datetime.utcnow(),\n            get_dummy_object(Chat),\n            reply_markup=reply_markup,\n            via_bot=bot.bot if self_sender else User(1, \"first\", False),\n        )\n\n        async def post(*args, **kwargs):\n            return [Update(17, **{message_type: message}).to_dict()]\n\n        try:\n            monkeypatch.setattr(BaseRequest, \"post\", post)\n            updates = await bot.get_updates(timeout=1)\n\n            assert isinstance(updates, tuple)\n            assert len(updates) == 1\n\n            message = updates[0][message_type]\n            if self_sender:\n                assert message.reply_markup.inline_keyboard[0][0].callback_data == \"callback_data\"\n            else:\n                assert (\n                    message.reply_markup.inline_keyboard[0][0].callback_data\n                    == reply_markup.inline_keyboard[0][0].callback_data\n                )\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    @pytest.mark.parametrize(\"bot_class\", [Bot, ExtBot])\n    async def test_http2_runtime_error(self, recwarn, bot_class):\n        bot_class(\"12345:ABCDE\", base_url=\"http://\", request=HTTPXRequest(http_version=\"2\"))\n        bot_class(\n            \"12345:ABCDE\",\n            base_url=\"http://\",\n            get_updates_request=HTTPXRequest(http_version=\"2\"),\n        )\n        bot_class(\n            \"12345:ABCDE\",\n            base_url=\"http://\",\n            request=HTTPXRequest(http_version=\"2\"),\n            get_updates_request=HTTPXRequest(http_version=\"2\"),\n        )\n        assert len(recwarn) == 3\n        assert \"You set the HTTP version for the request HTTPXRequest instance\" in str(\n            recwarn[0].message\n        )\n        assert \"You set the HTTP version for the get_updates_request HTTPXRequest instance\" in str(\n            recwarn[1].message\n        )\n        assert (\n            \"You set the HTTP version for the get_updates_request and request HTTPXRequest \"\n            \"instance\" in str(recwarn[2].message)\n        )\n        for warning in recwarn:\n            assert warning.filename == __file__, \"wrong stacklevel!\"\n            assert warning.category is PTBUserWarning\n\n    async def test_set_get_my_name(self, offline_bot, monkeypatch):\n        \"\"\"We only test that we pass the correct values to TG since this endpoint is heavily\n        rate limited which makes automated tests rather infeasible.\"\"\"\n        default_name = \"default_bot_name\"\n        en_name = \"en_bot_name\"\n        de_name = \"de_bot_name\"\n\n        # We predefine the responses that we would TG expect to send us\n        set_stack = asyncio.Queue()\n        get_stack = asyncio.Queue()\n        await set_stack.put({\"name\": default_name})\n        await set_stack.put({\"name\": en_name, \"language_code\": \"en\"})\n        await set_stack.put({\"name\": de_name, \"language_code\": \"de\"})\n        await get_stack.put({\"name\": default_name, \"language_code\": None})\n        await get_stack.put({\"name\": en_name, \"language_code\": \"en\"})\n        await get_stack.put({\"name\": de_name, \"language_code\": \"de\"})\n\n        await set_stack.put({\"name\": default_name})\n        await set_stack.put({\"language_code\": \"en\"})\n        await set_stack.put({\"language_code\": \"de\"})\n        await get_stack.put({\"name\": default_name, \"language_code\": None})\n        await get_stack.put({\"name\": default_name, \"language_code\": \"en\"})\n        await get_stack.put({\"name\": default_name, \"language_code\": \"de\"})\n\n        async def post(url, request_data: RequestData, *args, **kwargs):\n            # The mock-post now just fetches the predefined responses from the queues\n            if \"setMyName\" in url:\n                expected = await set_stack.get()\n                assert request_data.json_parameters == expected\n                set_stack.task_done()\n                return True\n\n            bot_name = await get_stack.get()\n            if \"language_code\" in request_data.json_parameters:\n                assert request_data.json_parameters == {\"language_code\": bot_name[\"language_code\"]}\n            else:\n                assert request_data.json_parameters == {}\n            get_stack.task_done()\n            return bot_name\n\n        monkeypatch.setattr(offline_bot.request, \"post\", post)\n\n        # Set the names\n        assert all(\n            await asyncio.gather(\n                offline_bot.set_my_name(default_name),\n                offline_bot.set_my_name(en_name, language_code=\"en\"),\n                offline_bot.set_my_name(de_name, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            offline_bot.get_my_name(), offline_bot.get_my_name(\"en\"), offline_bot.get_my_name(\"de\")\n        ) == [\n            BotName(default_name),\n            BotName(en_name),\n            BotName(de_name),\n        ]\n\n        # Delete the names\n        assert all(\n            await asyncio.gather(\n                offline_bot.set_my_name(default_name),\n                offline_bot.set_my_name(None, language_code=\"en\"),\n                offline_bot.set_my_name(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            offline_bot.get_my_name(), offline_bot.get_my_name(\"en\"), offline_bot.get_my_name(\"de\")\n        ) == 3 * [BotName(default_name)]\n\n    async def test_set_message_reaction(self, offline_bot, monkeypatch):\n        \"\"\"This is here so we can test the convenient conversion we do in the function without\n        having to do multiple requests to Telegram\"\"\"\n\n        expected_param = [\n            [{\"emoji\": ReactionEmoji.THUMBS_UP, \"type\": \"emoji\"}],\n            [{\"emoji\": ReactionEmoji.RED_HEART, \"type\": \"emoji\"}],\n            [{\"custom_emoji_id\": \"custom_emoji_1\", \"type\": \"custom_emoji\"}],\n            [{\"custom_emoji_id\": \"custom_emoji_2\", \"type\": \"custom_emoji\"}],\n            [{\"emoji\": ReactionEmoji.THUMBS_DOWN, \"type\": \"emoji\"}],\n            [{\"custom_emoji_id\": \"custom_emoji_3\", \"type\": \"custom_emoji\"}],\n            [\n                {\"emoji\": ReactionEmoji.RED_HEART, \"type\": \"emoji\"},\n                {\"custom_emoji_id\": \"custom_emoji_4\", \"type\": \"custom_emoji\"},\n                {\"emoji\": ReactionEmoji.THUMBS_DOWN, \"type\": \"emoji\"},\n                {\"custom_emoji_id\": \"custom_emoji_5\", \"type\": \"custom_emoji\"},\n            ],\n            [],\n        ]\n\n        amount = 0\n\n        async def post(url, request_data: RequestData, *args, **kwargs):\n            # The mock-post now just fetches the predefined responses from the queues\n            assert request_data.json_parameters[\"chat_id\"] == \"1\"\n            assert request_data.json_parameters[\"message_id\"] == \"2\"\n            assert request_data.json_parameters[\"is_big\"]\n            nonlocal amount\n            assert request_data.parameters[\"reaction\"] == expected_param[amount]\n            amount += 1\n\n        monkeypatch.setattr(offline_bot.request, \"post\", post)\n        await offline_bot.set_message_reaction(\n            1, 2, [ReactionTypeEmoji(ReactionEmoji.THUMBS_UP)], True\n        )\n        await offline_bot.set_message_reaction(\n            1, 2, ReactionTypeEmoji(ReactionEmoji.RED_HEART), True\n        )\n        await offline_bot.set_message_reaction(\n            1, 2, [ReactionTypeCustomEmoji(\"custom_emoji_1\")], True\n        )\n        await offline_bot.set_message_reaction(\n            1, 2, ReactionTypeCustomEmoji(\"custom_emoji_2\"), True\n        )\n        await offline_bot.set_message_reaction(1, 2, ReactionEmoji.THUMBS_DOWN, True)\n        await offline_bot.set_message_reaction(1, 2, \"custom_emoji_3\", True)\n        await offline_bot.set_message_reaction(\n            1,\n            2,\n            [\n                ReactionTypeEmoji(ReactionEmoji.RED_HEART),\n                ReactionTypeCustomEmoji(\"custom_emoji_4\"),\n                ReactionEmoji.THUMBS_DOWN,\n                ReactionTypeCustomEmoji(\"custom_emoji_5\"),\n            ],\n            True,\n        )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"parse_mode\": ParseMode.HTML}, None),\n            ({\"parse_mode\": ParseMode.HTML}, ParseMode.MARKDOWN_V2),\n            ({\"parse_mode\": None}, ParseMode.MARKDOWN_V2),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_message_default_quote_parse_mode(\n        self, default_bot, chat_id, custom, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters[\"reply_parameters\"].get(\"quote_parse_mode\") == (\n                custom or default_bot.defaults.quote_parse_mode\n            )\n            return make_message(\"dummy reply\").to_dict()\n\n        kwargs = {\"message_id\": 1}\n        if custom is not None:\n            kwargs[\"quote_parse_mode\"] = custom\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        await default_bot.send_message(chat_id, \"test\", reply_parameters=ReplyParameters(**kwargs))\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"parse_mode\": ParseMode.HTML}, \"NOTHING\"),\n            ({\"parse_mode\": ParseMode.HTML}, None),\n            ({\"parse_mode\": ParseMode.HTML}, ParseMode.MARKDOWN_V2),\n            ({\"parse_mode\": None}, ParseMode.MARKDOWN_V2),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_poll_default_text_question_parse_mode(\n        self, default_bot, raw_bot, chat_id, custom, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            expected = default_bot.defaults.text_parse_mode if custom == \"NOTHING\" else custom\n\n            option_1 = request_data.parameters[\"options\"][0]\n            option_2 = request_data.parameters[\"options\"][1]\n            assert option_1.get(\"text_parse_mode\") == (default_bot.defaults.text_parse_mode)\n            assert option_2.get(\"text_parse_mode\") == expected\n            assert request_data.parameters.get(\"question_parse_mode\") == expected\n\n            return make_message(\"dummy reply\").to_dict()\n\n        async def make_raw_assertion(url, request_data: RequestData, *args, **kwargs):\n            expected = None if custom == \"NOTHING\" else custom\n\n            option_1 = request_data.parameters[\"options\"][0]\n            option_2 = request_data.parameters[\"options\"][1]\n            assert option_1.get(\"text_parse_mode\") is None\n            assert option_2.get(\"text_parse_mode\") == expected\n\n            assert request_data.parameters.get(\"question_parse_mode\") == expected\n\n            return make_message(\"dummy reply\").to_dict()\n\n        if custom == \"NOTHING\":\n            option_2 = InputPollOption(\"option2\")\n            kwargs = {}\n        else:\n            option_2 = InputPollOption(\"option2\", text_parse_mode=custom)\n            kwargs = {\"question_parse_mode\": custom}\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        await default_bot.send_poll(\n            chat_id, question=\"question\", options=[\"option1\", option_2], **kwargs\n        )\n\n        monkeypatch.setattr(raw_bot.request, \"post\", make_raw_assertion)\n        await raw_bot.send_poll(\n            chat_id, question=\"question\", options=[\"option1\", option_2], **kwargs\n        )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"parse_mode\": ParseMode.HTML}, None),\n            ({\"parse_mode\": ParseMode.HTML}, ParseMode.MARKDOWN_V2),\n            ({\"parse_mode\": None}, ParseMode.MARKDOWN_V2),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_poll_default_quote_parse_mode(\n        self, default_bot, chat_id, custom, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters[\"reply_parameters\"].get(\"quote_parse_mode\") == (\n                custom or default_bot.defaults.quote_parse_mode\n            )\n            return make_message(\"dummy reply\").to_dict()\n\n        kwargs = {\"message_id\": 1}\n        if custom is not None:\n            kwargs[\"quote_parse_mode\"] = custom\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        await default_bot.send_poll(\n            chat_id,\n            question=\"question\",\n            options=[\"option1\", \"option2\"],\n            reply_parameters=ReplyParameters(**kwargs),\n        )\n\n    async def test_send_poll_question_parse_mode_entities(self, offline_bot, monkeypatch):\n        # Currently only custom emoji are supported as entities which we can't test\n        # We just test that the correct data is passed for now\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters[\"question_entities\"] == [\n                {\"type\": \"custom_emoji\", \"offset\": 0, \"length\": 1},\n                {\"type\": \"custom_emoji\", \"offset\": 2, \"length\": 1},\n            ]\n            assert request_data.parameters[\"question_parse_mode\"] == ParseMode.MARKDOWN_V2\n            return make_message(\"dummy reply\").to_dict()\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        await offline_bot.send_poll(\n            1,\n            question=\"\ud83d\ude00\ud83d\ude03\",\n            options=[\"option1\", \"option2\"],\n            question_entities=[\n                MessageEntity(MessageEntity.CUSTOM_EMOJI, 0, 1),\n                MessageEntity(MessageEntity.CUSTOM_EMOJI, 2, 1),\n            ],\n            question_parse_mode=ParseMode.MARKDOWN_V2,\n        )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"parse_mode\": ParseMode.HTML}, None),\n            ({\"parse_mode\": ParseMode.HTML}, ParseMode.MARKDOWN_V2),\n            ({\"parse_mode\": None}, ParseMode.MARKDOWN_V2),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_quote_parse_mode(\n        self, default_bot, chat_id, custom, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters[\"reply_parameters\"].get(\"quote_parse_mode\") == (\n                custom or default_bot.defaults.quote_parse_mode\n            )\n            return make_message(\"dummy reply\").to_dict()\n\n        kwargs = {\"message_id\": 1}\n        if custom is not None:\n            kwargs[\"quote_parse_mode\"] = custom\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        await default_bot.send_game(\n            chat_id, \"game_short_name\", reply_parameters=ReplyParameters(**kwargs)\n        )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"parse_mode\": ParseMode.HTML}, None),\n            ({\"parse_mode\": ParseMode.HTML}, ParseMode.MARKDOWN_V2),\n            ({\"parse_mode\": None}, ParseMode.MARKDOWN_V2),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_copy_message_default_quote_parse_mode(\n        self, default_bot, chat_id, custom, monkeypatch\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters[\"reply_parameters\"].get(\"quote_parse_mode\") == (\n                custom or default_bot.defaults.quote_parse_mode\n            )\n            return make_message(\"dummy reply\").to_dict()\n\n        kwargs = {\"message_id\": 1}\n        if custom is not None:\n            kwargs[\"quote_parse_mode\"] = custom\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        await default_bot.copy_message(chat_id, 1, 1, reply_parameters=ReplyParameters(**kwargs))\n\n    async def test_do_api_request_camel_case_conversion(self, offline_bot, monkeypatch):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return url.endswith(\"camelCase\")\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.do_api_request(\"camel_case\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    async def test_do_api_request_media_write_timeout(self, offline_bot, chat_id, monkeypatch):\n        test_flag = None\n\n        class CustomRequest(BaseRequest):\n            async def initialize(self_) -> None:\n                pass\n\n            async def shutdown(self_) -> None:\n                pass\n\n            async def do_request(self_, *args, **kwargs) -> tuple[int, bytes]:\n                nonlocal test_flag\n                test_flag = (\n                    kwargs.get(\"read_timeout\"),\n                    kwargs.get(\"connect_timeout\"),\n                    kwargs.get(\"write_timeout\"),\n                    kwargs.get(\"pool_timeout\"),\n                )\n                return HTTPStatus.OK, b'{\"ok\": \"True\", \"result\": {}}'\n\n            @property\n            def read_timeout(self):\n                return 1\n\n        custom_request = CustomRequest()\n\n        offline_bot = Bot(offline_bot.token, request=custom_request)\n        await offline_bot.do_api_request(\n            \"send_document\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"caption\": \"test_caption\",\n                \"document\": InputFile(data_file(\"telegram.png\").open(\"rb\")),\n            },\n        )\n        assert test_flag == (\n            DEFAULT_NONE,\n            DEFAULT_NONE,\n            DEFAULT_NONE,\n            DEFAULT_NONE,\n        )\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    async def test_do_api_request_default_timezone(self, tz_bot, monkeypatch):\n        until = dtm.datetime(2020, 1, 11, 16, 13)\n        until_timestamp = to_timestamp(until, tzinfo=tz_bot.defaults.tzinfo)\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            user_id = data[\"user_id\"] == 32\n            until_date = data.get(\"until_date\", until_timestamp) == until_timestamp\n            return chat_id and user_id and until_date\n\n        monkeypatch.setattr(tz_bot.request, \"post\", make_assertion)\n\n        assert await tz_bot.do_api_request(\n            \"banChatMember\", api_kwargs={\"chat_id\": 2, \"user_id\": 32}\n        )\n        assert await tz_bot.do_api_request(\n            \"banChatMember\", api_kwargs={\"chat_id\": 2, \"user_id\": 32, \"until_date\": until}\n        )\n        assert await tz_bot.do_api_request(\n            \"banChatMember\",\n            api_kwargs={\"chat_id\": 2, \"user_id\": 32, \"until_date\": until_timestamp},\n        )\n\n    async def test_business_connection_id_argument(\n        self, offline_bot, monkeypatch, dummy_message_dict\n    ):\n        \"\"\"We can't connect to a business acc, so we just test that the correct data is passed.\n        We also can't test every single method easily, so we just test a few. Our linting will\n        catch any unused args with the others.\"\"\"\n        return_values = asyncio.Queue()\n        await return_values.put(dummy_message_dict)\n        await return_values.put(\n            Poll(\n                id=\"42\",\n                question=\"question\",\n                options=[PollOption(\"option\", 0)],\n                total_voter_count=5,\n                is_closed=True,\n                is_anonymous=True,\n                type=\"regular\",\n                allows_multiple_answers=False,\n            ).to_dict()\n        )\n        await return_values.put(True)\n        await return_values.put(True)\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"business_connection_id\") == 42\n            return await return_values.get()\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.send_message(2, \"text\", business_connection_id=42)\n        await offline_bot.stop_poll(chat_id=1, message_id=2, business_connection_id=42)\n        await offline_bot.pin_chat_message(chat_id=1, message_id=2, business_connection_id=42)\n        await offline_bot.unpin_chat_message(chat_id=1, business_connection_id=42)\n\n    async def test_message_effect_id_argument(self, offline_bot, monkeypatch):\n        \"\"\"We can't test every single method easily, so we just test one. Our linting will catch\n        any unused args with the others.\"\"\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters.get(\"message_effect_id\") == 42\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.send_message(2, \"text\", message_effect_id=42)\n\n    async def test_allow_paid_broadcast_argument(self, offline_bot, monkeypatch):\n        \"\"\"We can't test every single method easily, so we just test one. Our linting will catch\n        any unused args with the others.\"\"\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters.get(\"allow_paid_broadcast\") == 42\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.send_message(2, \"text\", allow_paid_broadcast=42)\n\n    async def test_direct_messages_topic_id_argument(self, offline_bot, monkeypatch):\n        \"\"\"We can't test every single method easily, so we just test one. Our linting will catch\n        any unused args with the others.\"\"\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.parameters.get(\"direct_messages_topic_id\") == 42\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.send_message(2, \"text\", direct_messages_topic_id=42)\n\n    async def test_suggested_post_parameters_argument(self, offline_bot, monkeypatch):\n        \"\"\"We can't test every single method easily, so we just test one. Our linting will catch\n        any unused args with the others.\"\"\"\n        suggested_post_parameters = SuggestedPostParameters(price=SuggestedPostPrice(\"TON\", 10))\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return (\n                request_data.parameters.get(\"suggested_post_parameters\")\n                == suggested_post_parameters.to_dict()\n            )\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.send_message(\n            2, \"text\", suggested_post_parameters=suggested_post_parameters\n        )\n\n    async def test_send_chat_action_all_args(self, bot, chat_id, monkeypatch):\n        async def make_assertion(*args, **_):\n            kwargs = args[1]\n            return (\n                kwargs[\"chat_id\"] == chat_id\n                and kwargs[\"action\"] == \"action\"\n                and kwargs[\"message_thread_id\"] == 1\n                and kwargs[\"business_connection_id\"] == 3\n            )\n\n        monkeypatch.setattr(bot, \"_post\", make_assertion)\n        assert await bot.send_chat_action(chat_id, \"action\", 1, 3)\n\n    async def test_gift_premium_subscription_all_args(self, bot, monkeypatch):\n        # can't make actual request so we just test that the correct data is passed\n        async def make_assertion(*args, **_):\n            kwargs = args[1]\n            return (\n                kwargs.get(\"user_id\") == 12\n                and kwargs.get(\"month_count\") == 3\n                and kwargs.get(\"star_count\") == 1000\n                and kwargs.get(\"text\") == \"test text\"\n                and kwargs.get(\"text_parse_mode\") == \"Markdown\"\n                and kwargs.get(\"text_entities\")\n                == [\n                    MessageEntity(MessageEntity.BOLD, 0, 3),\n                    MessageEntity(MessageEntity.ITALIC, 5, 11),\n                ]\n            )\n\n        monkeypatch.setattr(bot, \"_post\", make_assertion)\n        assert await bot.gift_premium_subscription(\n            user_id=12,\n            month_count=3,\n            star_count=1000,\n            text=\"test text\",\n            text_parse_mode=\"Markdown\",\n            text_entities=[\n                MessageEntity(MessageEntity.BOLD, 0, 3),\n                MessageEntity(MessageEntity.ITALIC, 5, 11),\n            ],\n        )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    @pytest.mark.parametrize(\n        (\"passed_value\", \"expected_value\"),\n        [(DEFAULT_NONE, \"Markdown\"), (\"HTML\", \"HTML\"), (None, None)],\n    )\n    async def test_gift_premium_subscription_default_parse_mode(\n        self, default_bot, monkeypatch, passed_value, expected_value\n    ):\n        # can't make actual request so we just test that the correct data is passed\n        async def make_assertion(url, request_data, *args, **kwargs):\n            assert request_data.parameters.get(\"text_parse_mode\") == expected_value\n            return True\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        kwargs = {\n            \"user_id\": 123,\n            \"month_count\": 3,\n            \"star_count\": 1000,\n            \"text\": \"text\",\n        }\n        if passed_value is not DEFAULT_NONE:\n            kwargs[\"text_parse_mode\"] = passed_value\n\n        assert await default_bot.gift_premium_subscription(**kwargs)\n\n    async def test_refund_star_payment(self, offline_bot, monkeypatch):\n        # can't make actual request so we just test that the correct data is passed\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return (\n                request_data.parameters.get(\"user_id\") == 42\n                and request_data.parameters.get(\"telegram_payment_charge_id\") == \"37\"\n            )\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.refund_star_payment(42, \"37\")\n\n    async def test_get_star_transactions(self, offline_bot, monkeypatch):\n        # we just want to test the offset parameter\n        st = StarTransactions([StarTransaction(\"1\", 1, dtm.datetime.now())]).to_json()\n\n        async def do_request(url, request_data: RequestData, *args, **kwargs):\n            offset = request_data.parameters.get(\"offset\") == 3\n            if offset:\n                return 200, f'{{\"ok\": true, \"result\": {st}}}'.encode()\n            return 400, b'{\"ok\": false, \"result\": []}'\n\n        monkeypatch.setattr(offline_bot.request, \"do_request\", do_request)\n        obj = await offline_bot.get_star_transactions(offset=3)\n        assert isinstance(obj, StarTransactions)\n\n    async def test_edit_user_star_subscription(self, offline_bot, monkeypatch):\n        \"\"\"Can't properly test, so we only check that the correct values are passed\"\"\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return (\n                request_data.parameters.get(\"user_id\") == 42\n                and request_data.parameters.get(\"telegram_payment_charge_id\")\n                == \"telegram_payment_charge_id\"\n                and request_data.parameters.get(\"is_canceled\") is False\n            )\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.edit_user_star_subscription(\n            42, \"telegram_payment_charge_id\", False\n        )\n\n    async def test_create_chat_subscription_invite_link(\n        self,\n        monkeypatch,\n        offline_bot,\n    ):\n        # Since the chat invite link object does not say if the sub args are passed we can\n        # only check here\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"subscription_period\") == 2592000\n            assert request_data.parameters.get(\"subscription_price\") == 6\n            return ChatInviteLink(\n                \"https://t.me/joinchat/invite_link\", User(1, \"first\", False), False, False, False\n            ).to_dict()\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.create_chat_subscription_invite_link(1234, 2592000, 6)\n\n    @pytest.mark.parametrize(\n        \"expiration_date\", [dtm.datetime(2024, 1, 1), 1704067200], ids=[\"datetime\", \"timestamp\"]\n    )\n    async def test_set_user_emoji_status_basic(self, offline_bot, monkeypatch, expiration_date):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"user_id\") == 4242\n            assert (\n                request_data.parameters.get(\"emoji_status_custom_emoji_id\")\n                == \"emoji_status_custom_emoji_id\"\n            )\n            assert request_data.parameters.get(\"emoji_status_expiration_date\") == 1704067200\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        await offline_bot.set_user_emoji_status(\n            4242, \"emoji_status_custom_emoji_id\", expiration_date\n        )\n\n    async def test_set_user_emoji_status_default_timezone(self, tz_bot, monkeypatch):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"user_id\") == 4242\n            assert (\n                request_data.parameters.get(\"emoji_status_custom_emoji_id\")\n                == \"emoji_status_custom_emoji_id\"\n            )\n            assert request_data.parameters.get(\"emoji_status_expiration_date\") == to_timestamp(\n                dtm.datetime(2024, 1, 1), tzinfo=tz_bot.defaults.tzinfo\n            )\n\n        monkeypatch.setattr(tz_bot.request, \"post\", make_assertion)\n        await tz_bot.set_user_emoji_status(\n            4242, \"emoji_status_custom_emoji_id\", dtm.datetime(2024, 1, 1)\n        )\n\n    async def test_verify_user(self, offline_bot, monkeypatch):\n        \"No way to test this without getting verified\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"user_id\") == 1234\n            assert request_data.parameters.get(\"custom_description\") == \"this is so custom\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.verify_user(1234, \"this is so custom\")\n\n    async def test_verify_chat(self, offline_bot, monkeypatch):\n        \"No way to test this without getting verified\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"chat_id\") == 1234\n            assert request_data.parameters.get(\"custom_description\") == \"this is so custom\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.verify_chat(1234, \"this is so custom\")\n\n    async def test_unverify_user(self, offline_bot, monkeypatch):\n        \"No way to test this without getting verified\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"user_id\") == 1234\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.remove_user_verification(1234)\n\n    async def test_unverify_chat(self, offline_bot, monkeypatch):\n        \"No way to test this without getting verified\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"chat_id\") == 1234\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.remove_chat_verification(1234)\n\n    async def test_get_my_star_balance(self, offline_bot, monkeypatch):\n        sa = StarAmount(1000).to_json()\n\n        async def do_request(url, request_data: RequestData, *args, **kwargs):\n            assert not request_data.parameters\n            return 200, f'{{\"ok\": true, \"result\": {sa}}}'.encode()\n\n        monkeypatch.setattr(offline_bot.request, \"do_request\", do_request)\n        obj = await offline_bot.get_my_star_balance()\n        assert isinstance(obj, StarAmount)\n\n    async def test_approve_suggested_post(self, offline_bot, monkeypatch):\n        \"No way to test this without receiving suggested posts\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            chat_id = data.get(\"chat_id\") == \"1234\"\n            message_id = data.get(\"message_id\") == \"5678\"\n            send_date = data.get(\"send_date\", \"1577887200\") == \"1577887200\"\n            return chat_id and message_id and send_date\n\n        until = from_timestamp(1577887200)\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.approve_suggested_post(1234, 5678, 1577887200)\n        assert await offline_bot.approve_suggested_post(1234, 5678, until)\n\n    async def test_approve_suggested_post_with_tz(self, monkeypatch, tz_bot):\n        until = dtm.datetime(2020, 1, 11, 16, 13)\n        until_timestamp = to_timestamp(until, tzinfo=tz_bot.defaults.tzinfo)\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            message_id = data[\"message_id\"] == 32\n            until_date = data.get(\"until_date\", until_timestamp) == until_timestamp\n            return chat_id and message_id and until_date\n\n        monkeypatch.setattr(tz_bot.request, \"post\", make_assertion)\n\n        assert await tz_bot.approve_suggested_post(2, 32)\n        assert await tz_bot.approve_suggested_post(2, 32, send_date=until)\n        assert await tz_bot.approve_suggested_post(2, 32, send_date=until_timestamp)\n\n    async def test_decline_suggested_post(self, offline_bot, monkeypatch):\n        \"No way to test this without receiving suggested posts\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"chat_id\") == 1234\n            assert request_data.parameters.get(\"message_id\") == 5678\n            assert request_data.parameters.get(\"comment\") == \"declined\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.decline_suggested_post(1234, 5678, \"declined\")"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2388,
                            2402
                        ],
                        "reason": "The test 'test_send_chat_action_all_args' may fail if the parameters passed do not match the expected structure. The assertion checks for multiple parameters, and if any of them are incorrect, it could lead to assertion errors. This is critical for sending chat actions functionality.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_suggested_post_parameters_argument(self, offline_bot, monkeypatch):\n        \"\"\"We can't test every single method easily, so we just test one. Our linting will catch\n        any unused args with the others.\"\"\"\n        suggested_post_parameters = SuggestedPostParameters(price=SuggestedPostPrice(\"TON\", 10))\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return (\n                request_data.parameters.get(\"suggested_post_parameters\")\n                == suggested_post_parameters.to_dict()\n            )\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.send_message(\n            2, \"text\", suggested_post_parameters=suggested_post_parameters\n        )"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2417,
                            2445
                        ],
                        "reason": "The test 'test_gift_premium_subscription_all_args' may fail if the parameters passed do not match the expected structure. The assertion checks for multiple parameters, and if any of them are incorrect, it could lead to assertion errors. This is critical for the gift premium subscription functionality.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_gift_premium_subscription_all_args(self, bot, monkeypatch):\n        # can't make actual request so we just test that the correct data is passed\n        async def make_assertion(*args, **_):\n            kwargs = args[1]\n            return (\n                kwargs.get(\"user_id\") == 12\n                and kwargs.get(\"month_count\") == 3\n                and kwargs.get(\"star_count\") == 1000\n                and kwargs.get(\"text\") == \"test text\"\n                and kwargs.get(\"text_parse_mode\") == \"Markdown\"\n                and kwargs.get(\"text_entities\")\n                == [\n                    MessageEntity(MessageEntity.BOLD, 0, 3),\n                    MessageEntity(MessageEntity.ITALIC, 5, 11),\n                ]\n            )\n\n        monkeypatch.setattr(bot, \"_post\", make_assertion)\n        assert await bot.gift_premium_subscription(\n            user_id=12,\n            month_count=3,\n            star_count=1000,\n            text=\"test text\",\n            text_parse_mode=\"Markdown\",\n            text_entities=[\n                MessageEntity(MessageEntity.BOLD, 0, 3),\n                MessageEntity(MessageEntity.ITALIC, 5, 11),\n            ],\n        )"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2452,
                            2470
                        ],
                        "reason": "The test 'test_gift_premium_subscription_default_parse_mode' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct parse mode, and if it does not match, it could lead to assertion errors. This is critical for handling default parse modes.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_gift_premium_subscription_default_parse_mode(\n        self, default_bot, monkeypatch, passed_value, expected_value\n    ):\n        # can't make actual request so we just test that the correct data is passed\n        async def make_assertion(url, request_data, *args, **kwargs):\n            assert request_data.parameters.get(\"text_parse_mode\") == expected_value\n            return True\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        kwargs = {\n            \"user_id\": 123,\n            \"month_count\": 3,\n            \"star_count\": 1000,\n            \"text\": \"text\",\n        }\n        if passed_value is not DEFAULT_NONE:\n            kwargs[\"text_parse_mode\"] = passed_value\n\n        assert await default_bot.gift_premium_subscription(**kwargs)"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2472,
                            2481
                        ],
                        "reason": "The test 'test_refund_star_payment' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct user ID and payment charge ID, and if they do not match, it could lead to assertion errors. This is critical for refunding star payments.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_refund_star_payment(self, offline_bot, monkeypatch):\n        # can't make actual request so we just test that the correct data is passed\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return (\n                request_data.parameters.get(\"user_id\") == 42\n                and request_data.parameters.get(\"telegram_payment_charge_id\") == \"37\"\n            )\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.refund_star_payment(42, \"37\")"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2513,
                            2529
                        ],
                        "reason": "The test 'test_create_chat_subscription_invite_link' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct subscription period and price, and if they do not match, it could lead to assertion errors. This is critical for creating chat subscription invite links.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_create_chat_subscription_invite_link(\n        self,\n        monkeypatch,\n        offline_bot,\n    ):\n        # Since the chat invite link object does not say if the sub args are passed we can\n        # only check here\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"subscription_period\") == 2592000\n            assert request_data.parameters.get(\"subscription_price\") == 6\n            return ChatInviteLink(\n                \"https://t.me/joinchat/invite_link\", User(1, \"first\", False), False, False, False\n            ).to_dict()\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.create_chat_subscription_invite_link(1234, 2592000, 6)"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2534,
                            2546
                        ],
                        "reason": "The test 'test_set_user_emoji_status_default_timezone' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct user ID and emoji status expiration date, and if they do not match, it could lead to assertion errors. This is critical for setting user emoji status with default timezone.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_set_user_emoji_status_basic(self, offline_bot, monkeypatch, expiration_date):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"user_id\") == 4242\n            assert (\n                request_data.parameters.get(\"emoji_status_custom_emoji_id\")\n                == \"emoji_status_custom_emoji_id\"\n            )\n            assert request_data.parameters.get(\"emoji_status_expiration_date\") == 1704067200\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        await offline_bot.set_user_emoji_status(\n            4242, \"emoji_status_custom_emoji_id\", expiration_date\n        )"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2564,
                            2573
                        ],
                        "reason": "The test 'test_unverify_user' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct user ID, and if it does not match, it could lead to assertion errors. This is critical for unverification of users.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_verify_user(self, offline_bot, monkeypatch):\n        \"No way to test this without getting verified\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"user_id\") == 1234\n            assert request_data.parameters.get(\"custom_description\") == \"this is so custom\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.verify_user(1234, \"this is so custom\")"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2596,
                            2604
                        ],
                        "reason": "The test 'test_unverify_chat' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct chat ID, and if it does not match, it could lead to assertion errors. This is critical for unverification of chats.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_unverify_chat(self, offline_bot, monkeypatch):\n        \"No way to test this without getting verified\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"chat_id\") == 1234\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.remove_chat_verification(1234)"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2606,
                            2615
                        ],
                        "reason": "The test 'test_get_my_star_balance' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct response structure, and if it does not match, it could lead to assertion errors. This is critical for getting the user's star balance.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_get_my_star_balance(self, offline_bot, monkeypatch):\n        sa = StarAmount(1000).to_json()\n\n        async def do_request(url, request_data: RequestData, *args, **kwargs):\n            assert not request_data.parameters\n            return 200, f'{{\"ok\": true, \"result\": {sa}}}'.encode()\n\n        monkeypatch.setattr(offline_bot.request, \"do_request\", do_request)\n        obj = await offline_bot.get_my_star_balance()\n        assert isinstance(obj, StarAmount)"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2617,
                            2631
                        ],
                        "reason": "The test 'test_approve_suggested_post' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct chat ID, message ID, and send date, and if they do not match, it could lead to assertion errors. This is critical for approving suggested posts.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_approve_suggested_post(self, offline_bot, monkeypatch):\n        \"No way to test this without receiving suggested posts\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.json_parameters\n            chat_id = data.get(\"chat_id\") == \"1234\"\n            message_id = data.get(\"message_id\") == \"5678\"\n            send_date = data.get(\"send_date\", \"1577887200\") == \"1577887200\"\n            return chat_id and message_id and send_date\n\n        until = from_timestamp(1577887200)\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.approve_suggested_post(1234, 5678, 1577887200)\n        assert await offline_bot.approve_suggested_post(1234, 5678, until)"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2633,
                            2648
                        ],
                        "reason": "The test 'test_approve_suggested_post_with_tz' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct chat ID, message ID, and until date, and if they do not match, it could lead to assertion errors. This is critical for approving suggested posts with timezone.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_approve_suggested_post_with_tz(self, monkeypatch, tz_bot):\n        until = dtm.datetime(2020, 1, 11, 16, 13)\n        until_timestamp = to_timestamp(until, tzinfo=tz_bot.defaults.tzinfo)\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            data = request_data.parameters\n            chat_id = data[\"chat_id\"] == 2\n            message_id = data[\"message_id\"] == 32\n            until_date = data.get(\"until_date\", until_timestamp) == until_timestamp\n            return chat_id and message_id and until_date\n\n        monkeypatch.setattr(tz_bot.request, \"post\", make_assertion)\n\n        assert await tz_bot.approve_suggested_post(2, 32)\n        assert await tz_bot.approve_suggested_post(2, 32, send_date=until)\n        assert await tz_bot.approve_suggested_post(2, 32, send_date=until_timestamp)"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2650,
                            2660
                        ],
                        "reason": "The test 'test_decline_suggested_post' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct chat ID, message ID, and comment, and if they do not match, it could lead to assertion errors. This is critical for declining suggested posts.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_decline_suggested_post(self, offline_bot, monkeypatch):\n        \"No way to test this without receiving suggested posts\"\n\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters.get(\"chat_id\") == 1234\n            assert request_data.parameters.get(\"message_id\") == 5678\n            assert request_data.parameters.get(\"comment\") == \"declined\"\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        await offline_bot.decline_suggested_post(1234, 5678, \"declined\")"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2826,
                            2842
                        ],
                        "reason": "The test 'test_send_contact' may fail if the contact message cannot be sent due to incorrect parameters or if the bot does not handle the sending correctly, leading to assertion errors.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_send_contact(self, bot, chat_id):\n        phone_number = \"+11234567890\"\n        first_name = \"Leandro\"\n        last_name = \"Toledo\"\n        message = await bot.send_contact(\n            chat_id=chat_id,\n            phone_number=phone_number,\n            first_name=first_name,\n            last_name=last_name,\n            protect_content=True,\n        )\n\n        assert message.contact\n        assert message.contact.phone_number == phone_number\n        assert message.contact.first_name == first_name\n        assert message.contact.last_name == last_name\n        assert message.has_protected_content"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2857,
                            2927
                        ],
                        "reason": "The test 'test_send_and_stop_poll' may fail if the poll cannot be sent or stopped correctly due to incorrect parameters or if the bot does not handle the polling correctly, leading to assertion errors.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_send_and_stop_poll(self, bot, super_group_id, reply_markup):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", InputPollOption(\"No\"), \"Maybe\"]\n        explanation = \"[Here is a link](https://google.com)\"\n        explanation_entities = [\n            MessageEntity(MessageEntity.TEXT_LINK, 0, 14, url=\"https://google.com\")\n        ]\n\n        poll_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                is_anonymous=False,\n                allows_multiple_answers=True,\n                read_timeout=60,\n                protect_content=True,\n            )\n        )\n        quiz_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                type=Poll.QUIZ,\n                correct_option_id=2,\n                is_closed=True,\n                explanation=explanation,\n                explanation_parse_mode=ParseMode.MARKDOWN_V2,\n            )\n        )\n\n        message = await poll_task\n        assert message.poll\n        assert message.poll.question == question\n        assert message.poll.options[0].text == answers[0]\n        assert message.poll.options[1].text == answers[1].text\n        assert message.poll.options[2].text == answers[2]\n        assert not message.poll.is_anonymous\n        assert message.poll.allows_multiple_answers\n        assert not message.poll.is_closed\n        assert message.poll.type == Poll.REGULAR\n        assert message.has_protected_content\n\n        # Since only the poll and not the complete message is returned, we can't check that the\n        # reply_markup is correct. So we just test that sending doesn't give an error.\n        poll = await bot.stop_poll(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert isinstance(poll, Poll)\n        assert poll.is_closed\n        assert poll.options[0].text == answers[0]\n        assert poll.options[0].voter_count == 0\n        assert poll.options[1].text == answers[1].text\n        assert poll.options[1].voter_count == 0\n        assert poll.options[2].text == answers[2]\n        assert poll.options[2].voter_count == 0\n        assert poll.question == question\n        assert poll.total_voter_count == 0\n\n        message_quiz = await quiz_task\n        assert message_quiz.poll.correct_option_id == 2\n        assert message_quiz.poll.type == Poll.QUIZ\n        assert message_quiz.poll.is_closed\n        assert message_quiz.poll.explanation == \"Here is a link\"\n        assert message_quiz.poll.explanation_entities == tuple(explanation_entities)\n        assert poll_task.done()\n        assert quiz_task.done()"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2934,
                            2962
                        ],
                        "reason": "The test 'test_send_open_period' may fail if the poll cannot be sent with the specified open period or if the bot does not handle the polling correctly, leading to assertion errors.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_send_open_period(self, bot, super_group_id, open_period, close_date):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        if close_date:\n            close_date = dtm.datetime.utcnow() + dtm.timedelta(seconds=5.05)\n\n        message = await bot.send_poll(\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            is_anonymous=False,\n            allows_multiple_answers=True,\n            read_timeout=60,\n            open_period=open_period,\n            close_date=close_date,\n        )\n        await asyncio.sleep(5.1)\n        new_message = await bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == message.poll.id\n        assert new_message.poll.is_closed"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2964,
                            2995
                        ],
                        "reason": "The test 'test_send_close_date_default_tz' may fail if the poll cannot be sent with the specified close date or if the bot does not handle the timezone correctly, leading to assertion errors.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_send_close_date_default_tz(self, tz_bot, super_group_id):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        aware_close_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + dtm.timedelta(seconds=5)\n        close_date = aware_close_date.replace(tzinfo=None)\n\n        msg = await tz_bot.send_poll(  # The timezone returned from this is always converted to UTC\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            close_date=close_date,\n            read_timeout=60,\n        )\n        msg.poll._unfreeze()\n        # Sometimes there can be a few seconds delay, so don't let the test fail due to that-\n        msg.poll.close_date = msg.poll.close_date.astimezone(aware_close_date.tzinfo)\n        assert abs(msg.poll.close_date - aware_close_date) <= dtm.timedelta(seconds=5)\n\n        await asyncio.sleep(5.1)\n\n        new_message = await tz_bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=msg.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == msg.poll.id\n        assert new_message.poll.is_closed"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2997,
                            3015
                        ],
                        "reason": "The test 'test_send_poll_explanation_entities' may fail if the poll cannot be sent with the specified explanation entities or if the bot does not handle the explanation correctly, leading to assertion errors.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_send_poll_explanation_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.send_poll(\n            chat_id,\n            \"question\",\n            options=[\"a\", \"b\"],\n            correct_option_id=0,\n            type=Poll.QUIZ,\n            explanation=test_string,\n            explanation_entities=entities,\n        )\n\n        assert message.poll.explanation == test_string\n        assert message.poll.explanation_entities == tuple(entities)"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            3018,
                            3051
                        ],
                        "reason": "The test 'test_send_poll_default_parse_mode' may fail if the poll cannot be sent with the specified default parse mode or if the bot does not handle the parse mode correctly, leading to assertion errors.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_send_poll_default_parse_mode(self, default_bot, super_group_id):\n        explanation = \"Italic Bold Code\"\n        explanation_markdown = \"_Italic_ *Bold* `Code`\"\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_poll(\n                    chat_id=super_group_id,\n                    question=question,\n                    options=answers,\n                    type=Poll.QUIZ,\n                    correct_option_id=2,\n                    is_closed=True,\n                    explanation=explanation_markdown,\n                    **i,\n                )\n                for i in ({}, {\"explanation_parse_mode\": None}, {\"explanation_parse_mode\": \"HTML\"})\n            ),\n        )\n        message1, message2, message3 = await tasks\n        assert message1.poll.explanation == explanation\n        assert message1.poll.explanation_entities == (\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.BOLD, 7, 4),\n            MessageEntity(MessageEntity.CODE, 12, 4),\n        )\n\n        assert message2.poll.explanation == explanation_markdown\n        assert message2.poll.explanation_entities == ()\n\n        assert message3.poll.explanation == explanation_markdown\n        assert message3.poll.explanation_entities == ()"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            3062,
                            3093
                        ],
                        "reason": "The test 'test_send_poll_default_allow_sending_without_reply' may fail if the poll cannot be sent with the specified parameters or if the bot does not handle the sending correctly, leading to assertion errors.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_send_poll_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_poll(\n                    chat_id,\n                    question=question,\n                    options=answers,\n                    reply_to_message_id=reply_to_message.message_id,\n                )"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2663,
                            4635
                        ],
                        "reason": "The test 'test_send_poll_default_protect_content' may fail if the poll cannot be sent with the specified protect content parameter or if the bot does not handle the sending correctly, leading to assertion errors.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "class TestBotWithRequest:\n    \"\"\"\n    Most are executed on tg.ext.ExtBot, as that class only extends the functionality of tg.bot\n\n    Behavior for init of ExtBot with missing optional dependency cachetools (for CallbackDataCache)\n    is tested in `test_callbackdatacache`\n    \"\"\"\n\n    # get_available_gifts, send_gift are tested in `test_gift`.\n    # No need to duplicate here.\n\n    async def test_invalid_token_server_response(self):\n        with pytest.raises(InvalidToken, match=\"The token `12` was rejected by the server\\\\.\"):\n            async with ExtBot(token=\"12\"):\n                pass\n\n    async def test_multiple_init_cycles(self, bot):\n        # nothing really to assert - this should just not fail\n        test_bot = Bot(bot.token)\n        async with test_bot:\n            await test_bot.get_me()\n        async with test_bot:\n            await test_bot.get_me()\n\n    async def test_forward_message(self, bot, chat_id, static_message):\n        forward_message = await bot.forward_message(\n            chat_id, from_chat_id=chat_id, message_id=static_message.message_id\n        )\n\n        assert forward_message.text == static_message.text\n        assert forward_message.forward_origin.sender_user == static_message.from_user\n        assert isinstance(forward_message.forward_origin.date, dtm.datetime)\n\n    async def test_forward_protected_message(self, bot, chat_id):\n        tasks = asyncio.gather(\n            bot.send_message(chat_id, \"cant forward me\", protect_content=True),\n            bot.send_message(chat_id, \"forward me\", protect_content=False),\n        )\n        to_forward_protected, to_forward_unprotected = await tasks\n\n        assert to_forward_protected.has_protected_content\n        assert not to_forward_unprotected.has_protected_content\n\n        forwarded_but_now_protected = await to_forward_unprotected.forward(\n            chat_id, protect_content=True\n        )\n        assert forwarded_but_now_protected.has_protected_content\n\n        tasks = asyncio.gather(\n            to_forward_protected.forward(chat_id),\n            forwarded_but_now_protected.forward(chat_id),\n            return_exceptions=True,\n        )\n        result = await tasks\n        assert all(\"can't be forwarded\" in str(exc) for exc in result)\n\n    async def test_forward_messages(self, bot, chat_id):\n        # not using gather here to have deteriminically ordered message_ids\n        msg1 = await bot.send_message(chat_id, text=\"will be forwarded\")\n        msg2 = await bot.send_message(chat_id, text=\"will be forwarded\")\n\n        forward_messages = await bot.forward_messages(\n            chat_id, from_chat_id=chat_id, message_ids=(msg1.message_id, msg2.message_id)\n        )\n\n        assert isinstance(forward_messages, tuple)\n\n        tasks = asyncio.gather(\n            bot.send_message(\n                chat_id, \"temp 1\", reply_to_message_id=forward_messages[0].message_id\n            ),\n            bot.send_message(\n                chat_id, \"temp 2\", reply_to_message_id=forward_messages[1].message_id\n            ),\n        )\n\n        temp_msg1, temp_msg2 = await tasks\n        forward_msg1 = temp_msg1.reply_to_message\n        forward_msg2 = temp_msg2.reply_to_message\n\n        assert forward_msg1.text == msg1.text\n        assert forward_msg1.forward_origin.sender_user == msg1.from_user\n        assert isinstance(forward_msg1.forward_origin.date, dtm.datetime)\n\n        assert forward_msg2.text == msg2.text\n        assert forward_msg2.forward_origin.sender_user == msg2.from_user\n        assert isinstance(forward_msg2.forward_origin.date, dtm.datetime)\n\n    async def test_delete_message(self, bot, chat_id):\n        message = await bot.send_message(chat_id, text=\"will be deleted\")\n        assert await bot.delete_message(chat_id=chat_id, message_id=message.message_id) is True\n\n    async def test_delete_message_old_message(self, bot, chat_id):\n        with pytest.raises(BadRequest):\n            # Considering that the first message is old enough\n            await bot.delete_message(chat_id=chat_id, message_id=1)\n\n    # send_photo, send_audio, send_document, send_sticker, send_video, send_voice, send_video_note,\n    # send_media_group, send_animation, get_user_chat_boosts are tested in their respective\n    # test modules. No need to duplicate here.\n\n    async def test_delete_messages(self, bot, chat_id):\n        msg1, msg2 = await asyncio.gather(\n            bot.send_message(chat_id, text=\"will be deleted\"),\n            bot.send_message(chat_id, text=\"will be deleted\"),\n        )\n\n        assert (\n            await bot.delete_messages(chat_id=chat_id, message_ids=sorted((msg1.id, msg2.id)))\n            is True\n        )\n\n    async def test_send_venue(self, bot, chat_id):\n        longitude = -46.788279\n        latitude = -23.691288\n        title = \"title\"\n        address = \"address\"\n        foursquare_id = \"foursquare id\"\n        foursquare_type = \"foursquare type\"\n        google_place_id = \"google_place id\"\n        google_place_type = \"google_place type\"\n\n        tasks = asyncio.gather(\n            *(\n                bot.send_venue(\n                    chat_id=chat_id,\n                    title=title,\n                    address=address,\n                    latitude=latitude,\n                    longitude=longitude,\n                    protect_content=True,\n                    **i,\n                )\n                for i in (\n                    {\"foursquare_id\": foursquare_id, \"foursquare_type\": foursquare_type},\n                    {\"google_place_id\": google_place_id, \"google_place_type\": google_place_type},\n                )\n            ),\n        )\n\n        message, message2 = await tasks\n        assert message.venue\n        assert message.venue.title == title\n        assert message.venue.address == address\n        assert message.venue.location.latitude == latitude\n        assert message.venue.location.longitude == longitude\n        assert message.venue.foursquare_id == foursquare_id\n        assert message.venue.foursquare_type == foursquare_type\n        assert message.venue.google_place_id is None\n        assert message.venue.google_place_type is None\n        assert message.has_protected_content\n\n        assert message2.venue\n        assert message2.venue.title == title\n        assert message2.venue.address == address\n        assert message2.venue.location.latitude == latitude\n        assert message2.venue.location.longitude == longitude\n        assert message2.venue.google_place_id == google_place_id\n        assert message2.venue.google_place_type == google_place_type\n        assert message2.venue.foursquare_id is None\n        assert message2.venue.foursquare_type is None\n        assert message2.has_protected_content\n\n    async def test_send_contact(self, bot, chat_id):\n        phone_number = \"+11234567890\"\n        first_name = \"Leandro\"\n        last_name = \"Toledo\"\n        message = await bot.send_contact(\n            chat_id=chat_id,\n            phone_number=phone_number,\n            first_name=first_name,\n            last_name=last_name,\n            protect_content=True,\n        )\n\n        assert message.contact\n        assert message.contact.phone_number == phone_number\n        assert message.contact.first_name == first_name\n        assert message.contact.last_name == last_name\n        assert message.has_protected_content\n\n    # TODO: Add bot to group to test polls too\n    @pytest.mark.parametrize(\n        \"reply_markup\",\n        [\n            None,\n            InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n            ),\n            InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n            ).to_dict(),\n        ],\n    )\n    async def test_send_and_stop_poll(self, bot, super_group_id, reply_markup):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", InputPollOption(\"No\"), \"Maybe\"]\n        explanation = \"[Here is a link](https://google.com)\"\n        explanation_entities = [\n            MessageEntity(MessageEntity.TEXT_LINK, 0, 14, url=\"https://google.com\")\n        ]\n\n        poll_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                is_anonymous=False,\n                allows_multiple_answers=True,\n                read_timeout=60,\n                protect_content=True,\n            )\n        )\n        quiz_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                type=Poll.QUIZ,\n                correct_option_id=2,\n                is_closed=True,\n                explanation=explanation,\n                explanation_parse_mode=ParseMode.MARKDOWN_V2,\n            )\n        )\n\n        message = await poll_task\n        assert message.poll\n        assert message.poll.question == question\n        assert message.poll.options[0].text == answers[0]\n        assert message.poll.options[1].text == answers[1].text\n        assert message.poll.options[2].text == answers[2]\n        assert not message.poll.is_anonymous\n        assert message.poll.allows_multiple_answers\n        assert not message.poll.is_closed\n        assert message.poll.type == Poll.REGULAR\n        assert message.has_protected_content\n\n        # Since only the poll and not the complete message is returned, we can't check that the\n        # reply_markup is correct. So we just test that sending doesn't give an error.\n        poll = await bot.stop_poll(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert isinstance(poll, Poll)\n        assert poll.is_closed\n        assert poll.options[0].text == answers[0]\n        assert poll.options[0].voter_count == 0\n        assert poll.options[1].text == answers[1].text\n        assert poll.options[1].voter_count == 0\n        assert poll.options[2].text == answers[2]\n        assert poll.options[2].voter_count == 0\n        assert poll.question == question\n        assert poll.total_voter_count == 0\n\n        message_quiz = await quiz_task\n        assert message_quiz.poll.correct_option_id == 2\n        assert message_quiz.poll.type == Poll.QUIZ\n        assert message_quiz.poll.is_closed\n        assert message_quiz.poll.explanation == \"Here is a link\"\n        assert message_quiz.poll.explanation_entities == tuple(explanation_entities)\n        assert poll_task.done()\n        assert quiz_task.done()\n\n    @pytest.mark.parametrize(\n        (\"open_period\", \"close_date\"),\n        [(5, None), (dtm.timedelta(seconds=5), None), (None, True)],\n        ids=[\"open_period\", \"open_period-dtm\", \"close_date\"],\n    )\n    async def test_send_open_period(self, bot, super_group_id, open_period, close_date):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        if close_date:\n            close_date = dtm.datetime.utcnow() + dtm.timedelta(seconds=5.05)\n\n        message = await bot.send_poll(\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            is_anonymous=False,\n            allows_multiple_answers=True,\n            read_timeout=60,\n            open_period=open_period,\n            close_date=close_date,\n        )\n        await asyncio.sleep(5.1)\n        new_message = await bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == message.poll.id\n        assert new_message.poll.is_closed\n\n    async def test_send_close_date_default_tz(self, tz_bot, super_group_id):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        aware_close_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + dtm.timedelta(seconds=5)\n        close_date = aware_close_date.replace(tzinfo=None)\n\n        msg = await tz_bot.send_poll(  # The timezone returned from this is always converted to UTC\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            close_date=close_date,\n            read_timeout=60,\n        )\n        msg.poll._unfreeze()\n        # Sometimes there can be a few seconds delay, so don't let the test fail due to that-\n        msg.poll.close_date = msg.poll.close_date.astimezone(aware_close_date.tzinfo)\n        assert abs(msg.poll.close_date - aware_close_date) <= dtm.timedelta(seconds=5)\n\n        await asyncio.sleep(5.1)\n\n        new_message = await tz_bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=msg.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == msg.poll.id\n        assert new_message.poll.is_closed\n\n    async def test_send_poll_explanation_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.send_poll(\n            chat_id,\n            \"question\",\n            options=[\"a\", \"b\"],\n            correct_option_id=0,\n            type=Poll.QUIZ,\n            explanation=test_string,\n            explanation_entities=entities,\n        )\n\n        assert message.poll.explanation == test_string\n        assert message.poll.explanation_entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_send_poll_default_parse_mode(self, default_bot, super_group_id):\n        explanation = \"Italic Bold Code\"\n        explanation_markdown = \"_Italic_ *Bold* `Code`\"\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_poll(\n                    chat_id=super_group_id,\n                    question=question,\n                    options=answers,\n                    type=Poll.QUIZ,\n                    correct_option_id=2,\n                    is_closed=True,\n                    explanation=explanation_markdown,\n                    **i,\n                )\n                for i in ({}, {\"explanation_parse_mode\": None}, {\"explanation_parse_mode\": \"HTML\"})\n            ),\n        )\n        message1, message2, message3 = await tasks\n        assert message1.poll.explanation == explanation\n        assert message1.poll.explanation_entities == (\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.BOLD, 7, 4),\n            MessageEntity(MessageEntity.CODE, 12, 4),\n        )\n\n        assert message2.poll.explanation == explanation_markdown\n        assert message2.poll.explanation_entities == ()\n\n        assert message3.poll.explanation == explanation_markdown\n        assert message3.poll.explanation_entities == ()\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_poll_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_poll(\n                    chat_id,\n                    question=question,\n                    options=answers,\n                    reply_to_message_id=reply_to_message.message_id,\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_poll_default_protect_content(self, chat_id, default_bot):\n        tasks = asyncio.gather(\n            default_bot.send_poll(chat_id, \"Test\", [\"1\", \"2\"]),\n            default_bot.send_poll(chat_id, \"test\", [\"1\", \"2\"], protect_content=False),\n        )\n        protected_poll, unprotect_poll = await tasks\n        assert protected_poll.has_protected_content\n        assert not unprotect_poll.has_protected_content\n\n    @pytest.mark.parametrize(\"emoji\", [*Dice.ALL_EMOJI, None])\n    async def test_send_dice(self, bot, chat_id, emoji):\n        message = await bot.send_dice(chat_id, emoji=emoji, protect_content=True)\n\n        assert message.dice\n        assert message.has_protected_content\n        if emoji is None:\n            assert message.dice.emoji == Dice.DICE\n        else:\n            assert message.dice.emoji == emoji\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_dice_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_dice(\n                chat_id,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_dice(\n                chat_id,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_dice(\n                    chat_id, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_dice_default_protect_content(self, chat_id, default_bot):\n        tasks = asyncio.gather(\n            default_bot.send_dice(chat_id), default_bot.send_dice(chat_id, protect_content=False)\n        )\n        protected_dice, unprotected_dice = await tasks\n        assert protected_dice.has_protected_content\n        assert not unprotected_dice.has_protected_content\n\n    @pytest.mark.parametrize(\"chat_action\", list(ChatAction))\n    async def test_send_chat_action(self, bot, chat_id, chat_action):\n        assert await bot.send_chat_action(chat_id, chat_action)\n\n    async def test_wrong_chat_action(self, bot, chat_id):\n        with pytest.raises(BadRequest, match=\"Wrong parameter action\"):\n            await bot.send_chat_action(chat_id, \"unknown action\")\n\n    async def test_answer_inline_query_current_offset_error(self, bot, inline_results):\n        with pytest.raises(ValueError, match=\"`current_offset` and `next_offset`\"):\n            await bot.answer_inline_query(\n                1234, results=inline_results, next_offset=42, current_offset=51\n            )\n\n    async def test_save_prepared_inline_message(self, bot, chat_id):\n        # We can't really check that the result is stored correctly, we just ensur ethat we get\n        # a proper return value\n        result = InlineQueryResultArticle(\n            id=\"some_id\", title=\"title\", input_message_content=InputTextMessageContent(\"text\")\n        )\n        out = await bot.save_prepared_inline_message(chat_id, result, True, False, True, False)\n        assert isinstance(out, PreparedInlineMessage)\n\n    async def test_get_user_profile_photos(self, bot, chat_id):\n        user_profile_photos = await bot.get_user_profile_photos(chat_id)\n        assert user_profile_photos.photos[0][0].file_size == 5403\n\n    async def test_get_one_user_profile_photo(self, bot, chat_id):\n        user_profile_photos = await bot.get_user_profile_photos(chat_id, offset=0, limit=1)\n        assert user_profile_photos.total_count == 1\n        assert user_profile_photos.photos[0][0].file_size == 5403\n\n    async def test_edit_message_text(self, bot, one_time_message):\n        message = await bot.edit_message_text(\n            text=\"new_text\",\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            parse_mode=\"HTML\",\n            disable_web_page_preview=True,\n        )\n\n        assert message.text == \"new_text\"\n\n    async def test_edit_message_text_entities(self, bot, one_time_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_text(\n            text=test_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            entities=entities,\n        )\n\n        assert message.text == test_string\n        assert message.entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_edit_message_text_default_parse_mode(\n        self, default_bot, chat_id, one_time_message\n    ):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            disable_web_page_preview=True,\n        )\n        assert message.text_markdown == test_markdown_string\n        assert message.text == test_string\n\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string,\n            chat_id=message.chat_id,\n            message_id=message.message_id,\n            parse_mode=None,\n            disable_web_page_preview=True,\n        )\n        assert message.text == test_markdown_string\n        assert message.text_markdown == escape_markdown(test_markdown_string)\n\n        suffix = \" edited\"\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string + suffix,\n            chat_id=message.chat_id,\n            message_id=message.message_id,\n            parse_mode=\"HTML\",\n            disable_web_page_preview=True,\n        )\n        assert message.text == test_markdown_string + suffix\n        assert message.text_markdown == escape_markdown(test_markdown_string) + suffix\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_message_text_inline(self):\n        pass\n\n    async def test_edit_message_caption(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new_caption\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            show_caption_above_media=False,\n        )\n\n        assert message.caption == \"new_caption\"\n        assert not message.show_caption_above_media\n\n    async def test_edit_message_caption_entities(self, bot, media_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_caption(\n            caption=test_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            caption_entities=entities,\n        )\n\n        assert message.caption == test_string\n        assert message.caption_entities == tuple(entities)\n\n    # edit_message_media is tested in test_inputmedia\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_edit_message_caption_default_parse_mode(self, default_bot, media_message):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n        assert message.caption_markdown == test_markdown_string\n        assert message.caption == test_string\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            parse_mode=None,\n        )\n        assert message.caption == test_markdown_string\n        assert message.caption_markdown == escape_markdown(test_markdown_string)\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            parse_mode=\"HTML\",\n        )\n        assert message.caption == test_markdown_string\n        assert message.caption_markdown == escape_markdown(test_markdown_string)\n\n    async def test_edit_message_caption_with_parse_mode(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new *caption*\",\n            parse_mode=\"Markdown\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n\n        assert message.caption == \"new caption\"\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_message_caption_inline(self):\n        pass\n\n    async def test_edit_reply_markup(self, bot, one_time_message):\n        new_markup = InlineKeyboardMarkup([[InlineKeyboardButton(text=\"test\", callback_data=\"1\")]])\n        message = await bot.edit_message_reply_markup(\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            reply_markup=new_markup,\n        )\n\n        assert message is not True\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_reply_markup_inline(self):\n        pass\n\n    # TODO: Actually send updates to the test bot so this can be tested properly\n    @pytest.mark.parametrize(\"timeout\", [1, dtm.timedelta(seconds=1)])\n    async def test_get_updates(self, bot, timeout):\n        await bot.delete_webhook()  # make sure there is no webhook set if webhook tests failed\n        updates = await bot.get_updates(timeout=timeout)\n\n        assert isinstance(updates, tuple)\n        if updates:\n            assert isinstance(updates[0], Update)\n\n    @pytest.mark.parametrize(\n        (\"read_timeout\", \"timeout\", \"expected\"),\n        [\n            (None, None, 0),\n            (1, None, 1),\n            (None, 1, 1),\n            (None, dtm.timedelta(seconds=1), 1),\n            (DEFAULT_NONE, None, 10),\n            (DEFAULT_NONE, 1, 11),\n            (DEFAULT_NONE, dtm.timedelta(seconds=1), 11),\n            (1, 2, 3),\n            (1, dtm.timedelta(seconds=2), 3),\n        ],\n    )\n    async def test_get_updates_read_timeout_value_passing(\n        self, bot, read_timeout, timeout, expected, monkeypatch\n    ):\n        caught_read_timeout = None\n\n        async def catch_timeouts(*args, **kwargs):\n            nonlocal caught_read_timeout\n            caught_read_timeout = kwargs.get(\"read_timeout\")\n            return HTTPStatus.OK, b'{\"ok\": \"True\", \"result\": {}}'\n\n        monkeypatch.setattr(HTTPXRequest, \"do_request\", catch_timeouts)\n\n        bot = Bot(get_updates_request=HTTPXRequest(read_timeout=10), token=bot.token)\n        await bot.get_updates(read_timeout=read_timeout, timeout=timeout)\n        assert caught_read_timeout == expected\n\n    @pytest.mark.parametrize(\"use_ip\", [True, False])\n    # local file path as file_input is tested below in test_set_webhook_params\n    @pytest.mark.parametrize(\"file_input\", [\"bytes\", \"file_handle\"])\n    async def test_set_webhook_get_webhook_info_and_delete_webhook(self, bot, use_ip, file_input):\n        url = \"https://python-telegram-bot.org/test/webhook\"\n        # Get the ip address of the website - dynamically just in case it ever changes\n        ip = socket.gethostbyname(\"python-telegram-bot.org\")\n        max_connections = 7\n        allowed_updates = [\"message\"]\n        file_input = (\n            data_file(\"sslcert.pem\").read_bytes()\n            if file_input == \"bytes\"\n            else data_file(\"sslcert.pem\").open(\"rb\")\n        )\n        await bot.set_webhook(\n            url,\n            max_connections=max_connections,\n            allowed_updates=allowed_updates,\n            ip_address=ip if use_ip else None,\n            certificate=file_input if use_ip else None,\n        )\n\n        await asyncio.sleep(1)\n        live_info = await bot.get_webhook_info()\n        assert live_info.url == url\n        assert live_info.max_connections == max_connections\n        assert live_info.allowed_updates == tuple(allowed_updates)\n        assert live_info.ip_address == ip\n        assert live_info.has_custom_certificate == use_ip\n\n        await bot.delete_webhook()\n        await asyncio.sleep(1)\n        info = await bot.get_webhook_info()\n        assert not info.url\n        assert info.ip_address is None\n        assert info.has_custom_certificate is False\n\n    async def test_leave_chat(self, bot):\n        with pytest.raises(BadRequest, match=\"Chat not found\"):\n            await bot.leave_chat(-123456)\n\n    async def test_get_chat(self, bot, super_group_id):\n        cfi = await bot.get_chat(super_group_id)\n        assert cfi.type == \"supergroup\"\n        assert cfi.title == f\">>> telegram.Bot(test) @{bot.username}\"\n        assert cfi.id == int(super_group_id)\n\n    async def test_get_chat_administrators(self, bot, channel_id):\n        admins = await bot.get_chat_administrators(channel_id)\n        assert isinstance(admins, tuple)\n\n        for a in admins:\n            assert a.status in (\"administrator\", \"creator\")\n\n    async def test_get_chat_member_count(self, bot, channel_id):\n        count = await bot.get_chat_member_count(channel_id)\n        assert isinstance(count, int)\n        assert count > 3\n\n    async def test_get_chat_member(self, bot, channel_id, chat_id):\n        chat_member = await bot.get_chat_member(channel_id, chat_id)\n\n        assert chat_member.status == \"creator\"\n        assert chat_member.user.first_name == \"PTB\"\n        assert chat_member.user.last_name == \"Test user\"\n\n    @pytest.mark.skip(reason=\"Not implemented since we need a supergroup with many members\")\n    async def test_set_chat_sticker_set(self):\n        pass\n\n    @pytest.mark.skip(reason=\"Not implemented since we need a supergroup with many members\")\n    async def test_delete_chat_sticker_set(self):\n        pass\n\n    async def test_send_game(self, bot, chat_id):\n        game_short_name = \"test_game\"\n        message = await bot.send_game(chat_id, game_short_name, protect_content=True)\n\n        assert message.game\n        assert (\n            message.game.description\n            == \"A no-op test game, for python-telegram-bot bot framework testing.\"\n        )\n        assert message.game.animation.file_id\n        # We added some test bots later and for some reason the file size is not the same for them\n        # so we accept three different sizes here. Shouldn't be too much of\n        assert message.game.photo[0].file_size in [851, 4928, 850]\n        assert message.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        game_short_name = \"test_game\"\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_game(\n                chat_id,\n                game_short_name,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_game(\n                chat_id,\n                game_short_name,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_game(\n                    chat_id, game_short_name, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"val\"),\n        [({\"protect_content\": True}, True), ({\"protect_content\": False}, None)],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_protect_content(self, default_bot, chat_id, val):\n        protected = await default_bot.send_game(chat_id, \"test_game\", protect_content=val)\n        assert protected.has_protected_content is val\n\n    @xfail\n    async def test_set_game_score_and_high_scores(self, bot, chat_id):\n        # First, test setting a score.\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=BASE_GAME_SCORE,  # Score value is relevant for other set_game_score_* tests!\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n        assert message.game.text != game.game.text\n\n        # Test setting a score higher than previous\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        score = BASE_GAME_SCORE + 1\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=score,\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n            disable_edit_message=True,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n        assert message.game.text == game.game.text\n\n        # Test setting a score lower than previous (should raise error)\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        score = BASE_GAME_SCORE  # Even a score equal to previous raises an error.\n\n        with pytest.raises(BadRequest, match=\"Bot_score_not_modified\"):\n            await bot.set_game_score(\n                user_id=chat_id, score=score, chat_id=game.chat_id, message_id=game.message_id\n            )\n\n        # Test force setting a lower score\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n        await asyncio.sleep(1.5)\n\n        score = BASE_GAME_SCORE - 10\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=score,\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n            force=True,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n\n        # For some reason the returned message doesn't contain the updated score. need to fetch\n        # the game again... (the service message is also absent when running the test suite)\n        game2 = await bot.send_game(chat_id, game_short_name)\n        assert str(score) in game2.game.text\n\n        # We need a game to get the scores for\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n        high_scores = await bot.get_game_high_scores(chat_id, game.chat_id, game.message_id)\n        # We assume that the other game score tests ran within 20 sec\n        assert high_scores[0].score == BASE_GAME_SCORE - 10\n\n    # send_invoice and create_invoice_link is tested in test_invoice\n    async def test_promote_chat_member(self, bot, channel_id, monkeypatch):\n        # TODO: Add bot to supergroup so this can be tested properly / give bot perms\n        with pytest.raises(BadRequest, match=\"Not enough rights\"):\n            assert await bot.promote_chat_member(\n                channel_id,\n                1325859552,\n                is_anonymous=True,\n                can_change_info=True,\n                can_post_messages=True,\n                can_edit_messages=True,\n                can_delete_messages=True,\n                can_invite_users=True,\n                can_restrict_members=True,\n                can_pin_messages=True,\n                can_promote_members=True,\n                can_manage_chat=True,\n                can_manage_video_chats=True,\n                can_manage_topics=True,\n                can_post_stories=True,\n                can_edit_stories=True,\n                can_delete_stories=True,\n                can_manage_direct_messages=True,\n            )\n\n        # Test that we pass the correct params to TG\n        async def make_assertion(*args, **_):\n            data = args[1]\n            return (\n                data.get(\"chat_id\") == channel_id\n                and data.get(\"user_id\") == 1325859552\n                and data.get(\"is_anonymous\") == 1\n                and data.get(\"can_change_info\") == 2\n                and data.get(\"can_post_messages\") == 3\n                and data.get(\"can_edit_messages\") == 4\n                and data.get(\"can_delete_messages\") == 5\n                and data.get(\"can_invite_users\") == 6\n                and data.get(\"can_restrict_members\") == 7\n                and data.get(\"can_pin_messages\") == 8\n                and data.get(\"can_promote_members\") == 9\n                and data.get(\"can_manage_chat\") == 10\n                and data.get(\"can_manage_video_chats\") == 11\n                and data.get(\"can_manage_topics\") == 12\n                and data.get(\"can_post_stories\") == 13\n                and data.get(\"can_edit_stories\") == 14\n                and data.get(\"can_delete_stories\") == 15\n                and data.get(\"can_manage_direct_messages\") == 16\n            )\n\n        monkeypatch.setattr(bot, \"_post\", make_assertion)\n        assert await bot.promote_chat_member(\n            channel_id,\n            1325859552,\n            is_anonymous=1,\n            can_change_info=2,\n            can_post_messages=3,\n            can_edit_messages=4,\n            can_delete_messages=5,\n            can_invite_users=6,\n            can_restrict_members=7,\n            can_pin_messages=8,\n            can_promote_members=9,\n            can_manage_chat=10,\n            can_manage_video_chats=11,\n            can_manage_topics=12,\n            can_post_stories=13,\n            can_edit_stories=14,\n            can_delete_stories=15,\n            can_manage_direct_messages=16,\n        )\n\n    async def test_export_chat_invite_link(self, bot, channel_id):\n        # Each link is unique apparently\n        invite_link = await bot.export_chat_invite_link(channel_id)\n        assert isinstance(invite_link, str)\n        assert invite_link\n\n    async def test_edit_revoke_chat_invite_link_passing_link_objects(self, bot, channel_id):\n        invite_link = await bot.create_chat_invite_link(chat_id=channel_id)\n        assert invite_link.name is None\n\n        edited_link = await bot.edit_chat_invite_link(\n            chat_id=channel_id, invite_link=invite_link, name=\"some_name\"\n        )\n        assert edited_link == invite_link\n        assert edited_link.name == \"some_name\"\n\n        revoked_link = await bot.revoke_chat_invite_link(\n            chat_id=channel_id, invite_link=edited_link\n        )\n        assert revoked_link.invite_link == edited_link.invite_link\n        assert revoked_link.is_revoked is True\n        assert revoked_link.name == \"some_name\"\n\n    @pytest.mark.parametrize(\"creates_join_request\", [True, False])\n    @pytest.mark.parametrize(\"name\", [None, \"name\"])\n    async def test_create_chat_invite_link_basics(\n        self, bot, creates_join_request, name, channel_id\n    ):\n        data = {}\n        if creates_join_request:\n            data[\"creates_join_request\"] = True\n        if name:\n            data[\"name\"] = name\n        invite_link = await bot.create_chat_invite_link(chat_id=channel_id, **data)\n\n        assert invite_link.member_limit is None\n        assert invite_link.expire_date is None\n        assert invite_link.creates_join_request == creates_join_request\n        assert invite_link.name == name\n\n        revoked_link = await bot.revoke_chat_invite_link(\n            chat_id=channel_id, invite_link=invite_link.invite_link\n        )\n        assert revoked_link.is_revoked\n\n    @pytest.mark.parametrize(\"datetime\", argvalues=[True, False], ids=[\"datetime\", \"integer\"])\n    async def test_advanced_chat_invite_links(self, bot, channel_id, datetime):\n        # we are testing this all in one function in order to save api calls\n        timestamp = dtm.datetime.utcnow()\n        add_seconds = dtm.timedelta(0, 70)\n        time_in_future = timestamp + add_seconds\n        expire_time = time_in_future if datetime else to_timestamp(time_in_future)\n        aware_time_in_future = localize(time_in_future, UTC)\n\n        invite_link = await bot.create_chat_invite_link(\n            channel_id, expire_date=expire_time, member_limit=10\n        )\n        assert invite_link.invite_link\n        assert not invite_link.invite_link.endswith(\"...\")\n        assert abs(invite_link.expire_date - aware_time_in_future) < dtm.timedelta(seconds=1)\n        assert invite_link.member_limit == 10\n\n        add_seconds = dtm.timedelta(0, 80)\n        time_in_future = timestamp + add_seconds\n        expire_time = time_in_future if datetime else to_timestamp(time_in_future)\n        aware_time_in_future = localize(time_in_future, UTC)\n\n        edited_invite_link = await bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            expire_date=expire_time,\n            member_limit=20,\n            name=\"NewName\",\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert abs(edited_invite_link.expire_date - aware_time_in_future) < dtm.timedelta(\n            seconds=1\n        )\n        assert edited_invite_link.name == \"NewName\"\n        assert edited_invite_link.member_limit == 20\n\n        edited_invite_link = await bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            name=\"EvenNewerName\",\n            creates_join_request=True,\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert not edited_invite_link.expire_date\n        assert edited_invite_link.name == \"EvenNewerName\"\n        assert edited_invite_link.creates_join_request\n        assert edited_invite_link.member_limit is None\n\n        revoked_invite_link = await bot.revoke_chat_invite_link(\n            channel_id, invite_link.invite_link\n        )\n        assert revoked_invite_link.invite_link == invite_link.invite_link\n        assert revoked_invite_link.is_revoked\n\n    async def test_advanced_chat_invite_links_default_tzinfo(self, tz_bot, channel_id):\n        # we are testing this all in one function in order to save api calls\n        add_seconds = dtm.timedelta(0, 70)\n        aware_expire_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + add_seconds\n        time_in_future = aware_expire_date.replace(tzinfo=None)\n\n        invite_link = await tz_bot.create_chat_invite_link(\n            channel_id, expire_date=time_in_future, member_limit=10\n        )\n        assert invite_link.invite_link\n        assert not invite_link.invite_link.endswith(\"...\")\n        assert abs(invite_link.expire_date - aware_expire_date) < dtm.timedelta(seconds=1)\n        assert invite_link.member_limit == 10\n\n        add_seconds = dtm.timedelta(0, 80)\n        aware_expire_date += add_seconds\n        time_in_future = aware_expire_date.replace(tzinfo=None)\n\n        edited_invite_link = await tz_bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            expire_date=time_in_future,\n            member_limit=20,\n            name=\"NewName\",\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert abs(edited_invite_link.expire_date - aware_expire_date) < dtm.timedelta(seconds=1)\n        assert edited_invite_link.name == \"NewName\"\n        assert edited_invite_link.member_limit == 20\n\n        edited_invite_link = await tz_bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            name=\"EvenNewerName\",\n            creates_join_request=True,\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert not edited_invite_link.expire_date\n        assert edited_invite_link.name == \"EvenNewerName\"\n        assert edited_invite_link.creates_join_request\n        assert edited_invite_link.member_limit is None\n\n        revoked_invite_link = await tz_bot.revoke_chat_invite_link(\n            channel_id, invite_link.invite_link\n        )\n        assert revoked_invite_link.invite_link == invite_link.invite_link\n        assert revoked_invite_link.is_revoked\n\n    async def test_approve_chat_join_request(self, bot, chat_id, channel_id):\n        # TODO: Need incoming join request to properly test\n        # Since we can't create join requests on the fly, we just tests the call to TG\n        # by checking that it complains about approving a user who is already in the chat\n        with pytest.raises(BadRequest, match=\"User_already_participant\"):\n            await bot.approve_chat_join_request(chat_id=channel_id, user_id=chat_id)\n\n    async def test_decline_chat_join_request(self, bot, chat_id, channel_id):\n        # TODO: Need incoming join request to properly test\n        # Since we can't create join requests on the fly, we just tests the call to TG\n        # by checking that it complains about declining a user who is already in the chat\n        #\n        # The error message Hide_requester_missing started showing up instead of\n        # User_already_participant. Don't know why \u2026\n        with pytest.raises(BadRequest, match=r\"User_already_participant|Hide_requester_missing\"):\n            await bot.decline_chat_join_request(chat_id=channel_id, user_id=chat_id)\n\n    async def test_set_chat_photo(self, bot, channel_id):\n        async def func():\n            assert await bot.set_chat_photo(channel_id, f)\n\n        with data_file(\"telegram_test_channel.jpg\").open(\"rb\") as f:\n            await expect_bad_request(\n                func, \"Type of file mismatch\", \"Telegram did not accept the file.\"\n            )\n\n    async def test_delete_chat_photo(self, bot, channel_id):\n        async def func():\n            assert await bot.delete_chat_photo(channel_id)\n\n        await expect_bad_request(func, \"Chat_not_modified\", \"Chat photo was not set.\")\n\n    async def test_set_chat_title(self, bot, channel_id):\n        assert await bot.set_chat_title(channel_id, \">>> telegram.Bot() - Tests\")\n\n    async def test_set_chat_description(self, bot, channel_id):\n        assert await bot.set_chat_description(channel_id, \"Time: \" + str(time.time()))\n\n    async def test_pin_and_unpin_message(self, bot, super_group_id):\n        messages = []  # contains the Messages we sent\n        pinned_messages_tasks = set()  # contains the asyncio.Tasks that pin the messages\n\n        # Let's send 3 messages so we can pin them\n        awaitables = {bot.send_message(super_group_id, f\"test_pin_message_{i}\") for i in range(3)}\n\n        # We will pin the messages immediately after sending them\n        for sending_msg in asyncio.as_completed(awaitables):  # as_completed sends the messages\n            msg = await sending_msg\n            coro = bot.pin_chat_message(super_group_id, msg.message_id, True, read_timeout=10)\n            pinned_messages_tasks.add(asyncio.create_task(coro))  # start pinning the message\n            messages.append(msg)\n\n        assert len(messages) == 3  # Check if we sent 3 messages\n\n        # Check if we pinned 3 messages\n        assert all([await i for i in pinned_messages_tasks])\n        assert all(i.done() for i in pinned_messages_tasks)  # Check if all tasks are done\n\n        chat = await bot.get_chat(super_group_id)  # get the chat to check the pinned message\n        assert chat.pinned_message in messages\n\n        # Determine which message is not the most recently pinned\n        for old_pin_msg in messages:\n            if chat.pinned_message != old_pin_msg:\n                break\n\n        # Test unpinning our messages\n        tasks = asyncio.gather(\n            bot.unpin_chat_message(  # unpins any message except the most recent\n                chat_id=super_group_id,  # because we don't want to accidentally unpin the same msg\n                message_id=old_pin_msg.message_id,  # twice\n                read_timeout=10,\n            ),\n            bot.unpin_chat_message(chat_id=super_group_id, read_timeout=10),  # unpins most recent\n        )\n        assert all(await tasks)\n        assert all(i.done() for i in tasks)\n        assert await bot.unpin_all_chat_messages(super_group_id, read_timeout=10)\n\n    # get_sticker_set, upload_sticker_file, create_new_sticker_set, add_sticker_to_set,\n    # set_sticker_position_in_set, delete_sticker_from_set and get_custom_emoji_stickers,\n    # replace_sticker_in_set are tested in the test_sticker module.\n\n    # get_forum_topic_icon_stickers, edit_forum_topic, general_forum etc...\n    # are tested in the test_forum module.\n    async def test_send_message_disable_web_page_preview(self, bot, chat_id):\n        \"\"\"Test that disable_web_page_preview is substituted for link_preview_options and that\n        it still works as expected for backward compatability.\"\"\"\n        msg = await bot.send_message(\n            chat_id,\n            \"https://github.com/python-telegram-bot/python-telegram-bot\",\n            disable_web_page_preview=True,\n        )\n        assert msg.link_preview_options\n        assert msg.link_preview_options.is_disabled\n\n    async def test_send_message_link_preview_options(self, bot, chat_id):\n        \"\"\"Test whether link_preview_options is correctly passed to the API.\"\"\"\n        # btw it is possible to have no url in the text, but set a url for the preview.\n        msg = await bot.send_message(\n            chat_id,\n            \"https://github.com/python-telegram-bot/python-telegram-bot\",\n            link_preview_options=LinkPreviewOptions(prefer_small_media=True, show_above_text=True),\n        )\n        assert msg.link_preview_options\n        assert not msg.link_preview_options.is_disabled\n        # The prefer_* options aren't very consistent on the client side (big pic shown) +\n        # they are not returned by the API.\n        # assert msg.link_preview_options.prefer_small_media\n        assert msg.link_preview_options.show_above_text\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"link_preview_options\": LinkPreviewOptions(show_above_text=True)}],\n        indirect=True,\n    )\n    async def test_send_message_default_link_preview_options(self, default_bot, chat_id):\n        \"\"\"Test whether Defaults.link_preview_options is correctly fused with the passed LPO.\"\"\"\n        github_url = \"https://github.com/python-telegram-bot/python-telegram-bot\"\n        website = \"https://python-telegram-bot.org/\"\n\n        # First test just the default passing:\n        coro1 = default_bot.send_message(chat_id, github_url)\n        # Next test fusion of both LPOs:\n        coro2 = default_bot.send_message(\n            chat_id,\n            github_url,\n            link_preview_options=LinkPreviewOptions(url=website, prefer_large_media=True),\n        )\n        # Now test fusion + overriding of passed LPO:\n        coro3 = default_bot.send_message(\n            chat_id,\n            github_url,\n            link_preview_options=LinkPreviewOptions(show_above_text=False, url=website),\n        )\n        # finally test explicitly setting to None\n        coro4 = default_bot.send_message(chat_id, github_url, link_preview_options=None)\n\n        msgs = asyncio.gather(coro1, coro2, coro3, coro4)\n        msg1, msg2, msg3, msg4 = await msgs\n        assert msg1.link_preview_options\n        assert msg1.link_preview_options.show_above_text\n\n        assert msg2.link_preview_options\n        assert msg2.link_preview_options.show_above_text\n        assert msg2.link_preview_options.url == website\n        assert msg2.link_preview_options.prefer_large_media  # Now works correctly using new url..\n\n        assert msg3.link_preview_options\n        assert not msg3.link_preview_options.show_above_text\n        assert msg3.link_preview_options.url == website\n\n        assert msg4.link_preview_options == LinkPreviewOptions(url=github_url)\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"link_preview_options\": LinkPreviewOptions(show_above_text=True)}],\n        indirect=True,\n    )\n    async def test_edit_message_text_default_link_preview_options(self, default_bot, chat_id):\n        \"\"\"Test whether Defaults.link_preview_options is correctly fused with the passed LPO.\"\"\"\n        github_url = \"https://github.com/python-telegram-bot/python-telegram-bot\"\n        website = \"https://python-telegram-bot.org/\"\n        telegram_url = \"https://telegram.org\"\n        base_1, base_2, base_3, base_4 = await asyncio.gather(\n            *(default_bot.send_message(chat_id, telegram_url) for _ in range(4))\n        )\n\n        # First test just the default passing:\n        coro1 = base_1.edit_text(github_url)\n        # Next test fusion of both LPOs:\n        coro2 = base_2.edit_text(\n            github_url,\n            link_preview_options=LinkPreviewOptions(url=website, prefer_large_media=True),\n        )\n        # Now test fusion + overriding of passed LPO:\n        coro3 = base_3.edit_text(\n            github_url,\n            link_preview_options=LinkPreviewOptions(show_above_text=False, url=website),\n        )\n        # finally test explicitly setting to None\n        coro4 = base_4.edit_text(github_url, link_preview_options=None)\n\n        msgs = asyncio.gather(coro1, coro2, coro3, coro4)\n        msg1, msg2, msg3, msg4 = await msgs\n        assert msg1.link_preview_options\n        assert msg1.link_preview_options.show_above_text\n\n        assert msg2.link_preview_options\n        assert msg2.link_preview_options.show_above_text\n        assert msg2.link_preview_options.url == website\n        assert msg2.link_preview_options.prefer_large_media  # Now works correctly using new url..\n\n        assert msg3.link_preview_options\n        assert not msg3.link_preview_options.show_above_text\n        assert msg3.link_preview_options.url == website\n\n        assert msg4.link_preview_options == LinkPreviewOptions(url=github_url)\n\n    async def test_send_message_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code Spoiler\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n            MessageEntity(MessageEntity.SPOILER, 17, 7),\n        ]\n        message = await bot.send_message(chat_id=chat_id, text=test_string, entities=entities)\n        assert message.text == test_string\n        assert message.entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_send_message_default_parse_mode(self, default_bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_message(chat_id, test_markdown_string, **i)\n                for i in ({}, {\"parse_mode\": None}, {\"parse_mode\": \"HTML\"})\n            )\n        )\n        msg1, msg2, msg3 = await tasks\n        assert msg1.text_markdown == test_markdown_string\n        assert msg1.text == test_string\n\n        assert msg2.text == test_markdown_string\n        assert msg2.text_markdown == escape_markdown(test_markdown_string)\n\n        assert msg3.text == test_markdown_string\n        assert msg3.text_markdown == escape_markdown(test_markdown_string)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_message_default_protect_content(self, default_bot, chat_id):\n        tasks = asyncio.gather(\n            default_bot.send_message(chat_id, \"test\"),\n            default_bot.send_message(chat_id, \"test\", protect_content=False),\n        )\n        to_check, no_protect = await tasks\n        assert to_check.has_protected_content\n        assert not no_protect.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_message_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_message(\n                chat_id,\n                \"test\",\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_message(\n                chat_id, \"test\", reply_to_message_id=reply_to_message.message_id\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_message(\n                    chat_id, \"test\", reply_to_message_id=reply_to_message.message_id\n                )\n\n    async def test_get_set_my_default_administrator_rights(self, bot):\n        # Test that my default administrator rights for group are as all False\n        assert await bot.set_my_default_administrator_rights()  # clear any set rights\n        my_admin_rights_grp = await bot.get_my_default_administrator_rights()\n        assert isinstance(my_admin_rights_grp, ChatAdministratorRights)\n        assert all(not getattr(my_admin_rights_grp, at) for at in my_admin_rights_grp.__slots__)\n\n        # Test setting my default admin rights for channel\n        my_rights = ChatAdministratorRights.all_rights()\n        assert await bot.set_my_default_administrator_rights(my_rights, for_channels=True)\n        my_admin_rights_ch = await bot.get_my_default_administrator_rights(for_channels=True)\n        assert my_admin_rights_ch.can_invite_users is my_rights.can_invite_users\n        # tg bug? is_anonymous is False despite setting it True for channels:\n        assert my_admin_rights_ch.is_anonymous is not my_rights.is_anonymous\n\n        assert my_admin_rights_ch.can_manage_chat is my_rights.can_manage_chat\n        assert my_admin_rights_ch.can_delete_messages is my_rights.can_delete_messages\n        assert my_admin_rights_ch.can_edit_messages is my_rights.can_edit_messages\n        assert my_admin_rights_ch.can_post_messages is my_rights.can_post_messages\n        assert my_admin_rights_ch.can_change_info is my_rights.can_change_info\n        assert my_admin_rights_ch.can_promote_members is my_rights.can_promote_members\n        assert my_admin_rights_ch.can_restrict_members is my_rights.can_restrict_members\n        assert my_admin_rights_ch.can_pin_messages is None  # Not returned for channels\n        assert my_admin_rights_ch.can_manage_topics is None  # Not returned for channels\n\n    async def test_get_set_chat_menu_button(self, bot, chat_id):\n        # Test our chat menu button is commands-\n        menu_button = await bot.get_chat_menu_button()\n        assert isinstance(menu_button, MenuButton)\n        assert isinstance(menu_button, MenuButtonCommands)\n        assert menu_button.type == MenuButtonType.COMMANDS\n\n        # Test setting our chat menu button to Webapp.\n        my_menu = MenuButtonWebApp(\"click me!\", WebAppInfo(\"https://telegram.org/\"))\n        assert await bot.set_chat_menu_button(chat_id=chat_id, menu_button=my_menu)\n        menu_button = await bot.get_chat_menu_button(chat_id)\n        assert isinstance(menu_button, MenuButtonWebApp)\n        assert menu_button.type == MenuButtonType.WEB_APP\n        assert menu_button.text == my_menu.text\n        assert menu_button.web_app.url == my_menu.web_app.url\n\n        assert await bot.set_chat_menu_button(chat_id=chat_id, menu_button=MenuButtonDefault())\n        menu_button = await bot.get_chat_menu_button(chat_id=chat_id)\n        assert isinstance(menu_button, MenuButtonDefault)\n\n    async def test_set_and_get_my_commands(self, bot):\n        commands = [BotCommand(\"cmd1\", \"descr1\"), [\"cmd2\", \"descr2\"]]\n        assert await bot.set_my_commands([])\n        assert await bot.get_my_commands() == ()\n        assert await bot.set_my_commands(commands)\n\n        for i, bc in enumerate(await bot.get_my_commands()):\n            assert bc.command == f\"cmd{i + 1}\"\n            assert bc.description == f\"descr{i + 1}\"\n\n    async def test_get_set_delete_my_commands_with_scope(self, bot, super_group_id, chat_id):\n        group_cmds = [BotCommand(\"group_cmd\", \"visible to this supergroup only\")]\n        private_cmds = [BotCommand(\"private_cmd\", \"visible to this private chat only\")]\n        group_scope = BotCommandScopeChat(super_group_id)\n        private_scope = BotCommandScopeChat(chat_id)\n\n        # Set supergroup command list with lang code and check if the same can be returned from api\n        assert await bot.set_my_commands(group_cmds, scope=group_scope, language_code=\"en\")\n        gotten_group_cmds = await bot.get_my_commands(scope=group_scope, language_code=\"en\")\n\n        assert len(gotten_group_cmds) == len(group_cmds)\n        assert gotten_group_cmds[0].command == group_cmds[0].command\n\n        # Set private command list and check if same can be returned from the api\n        assert await bot.set_my_commands(private_cmds, scope=private_scope)\n        gotten_private_cmd = await bot.get_my_commands(scope=private_scope)\n\n        assert len(gotten_private_cmd) == len(private_cmds)\n        assert gotten_private_cmd[0].command == private_cmds[0].command\n\n        # Delete command list from that supergroup and private chat-\n        tasks = asyncio.gather(\n            bot.delete_my_commands(private_scope),\n            bot.delete_my_commands(group_scope, \"en\"),\n        )\n        assert all(await tasks)\n\n        # Check if its been deleted-\n        tasks = asyncio.gather(\n            bot.get_my_commands(private_scope),\n            bot.get_my_commands(group_scope, \"en\"),\n        )\n        deleted_priv_cmds, deleted_grp_cmds = await tasks\n\n        assert len(deleted_grp_cmds) == 0 == len(group_cmds) - 1\n        assert len(deleted_priv_cmds) == 0 == len(private_cmds) - 1\n\n        await bot.delete_my_commands()  # Delete commands from default scope\n        assert len(await bot.get_my_commands()) == 0\n\n    async def test_copy_message_without_reply(self, bot, chat_id, media_message):\n        keyboard = InlineKeyboardMarkup(\n            [[InlineKeyboardButton(text=\"test\", callback_data=\"test2\")]]\n        )\n\n        returned = await bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=\"<b>Test</b>\",\n            parse_mode=ParseMode.HTML,\n            reply_to_message_id=media_message.message_id,\n            reply_markup=keyboard,\n            show_caption_above_media=False,\n        )\n        # we send a temp message which replies to the returned message id in order to get a\n        # message object\n        temp_message = await bot.send_message(\n            chat_id, \"test\", reply_to_message_id=returned.message_id\n        )\n        message = temp_message.reply_to_message\n        assert message.chat_id == int(chat_id)\n        assert message.caption == \"Test\"\n        assert len(message.caption_entities) == 1\n        assert message.reply_markup == keyboard\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [\n            ({\"parse_mode\": ParseMode.HTML, \"allow_sending_without_reply\": True}),\n            ({\"parse_mode\": None, \"allow_sending_without_reply\": True}),\n            ({\"parse_mode\": None, \"allow_sending_without_reply\": False}),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_copy_message_with_default(self, default_bot, chat_id, media_message):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if not default_bot.defaults.allow_sending_without_reply:\n            with pytest.raises(BadRequest, match=\"not found\"):\n                await default_bot.copy_message(\n                    chat_id,\n                    from_chat_id=chat_id,\n                    message_id=media_message.message_id,\n                    caption=\"<b>Test</b>\",\n                    reply_to_message_id=reply_to_message.message_id,\n                )\n            return\n        returned = await default_bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=\"<b>Test</b>\",\n            reply_to_message_id=reply_to_message.message_id,\n        )\n        # we send a temp message which replies to the returned message id in order to get a\n        # message object\n        temp_message = await default_bot.send_message(\n            chat_id, \"test\", reply_to_message_id=returned.message_id\n        )\n        message = temp_message.reply_to_message\n        if default_bot.defaults.parse_mode:\n            assert len(message.caption_entities) == 1\n        else:\n            assert len(message.caption_entities) == 0\n\n    async def test_copy_messages(self, bot, chat_id):\n        # not using gather here to have deterministically ordered message_ids\n        msg1 = await bot.send_message(chat_id, text=\"will be copied 1\")\n        msg2 = await bot.send_message(chat_id, text=\"will be copied 2\")\n\n        copy_messages = await bot.copy_messages(\n            chat_id, from_chat_id=chat_id, message_ids=(msg1.message_id, msg2.message_id)\n        )\n        assert isinstance(copy_messages, tuple)\n\n        tasks = asyncio.gather(\n            bot.send_message(chat_id, \"temp 1\", reply_to_message_id=copy_messages[0].message_id),\n            bot.send_message(chat_id, \"temp 2\", reply_to_message_id=copy_messages[1].message_id),\n        )\n        temp_msg1, temp_msg2 = await tasks\n\n        forward_msg1 = temp_msg1.reply_to_message\n        forward_msg2 = temp_msg2.reply_to_message\n\n        assert forward_msg1.text == msg1.text\n        assert forward_msg2.text == msg2.text\n\n    # Continue testing arbitrary callback data here with actual requests:\n    async def test_replace_callback_data_send_message(self, cdc_bot, chat_id):\n        bot = cdc_bot\n\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            message = await bot.send_message(\n                chat_id=chat_id, text=\"test\", reply_markup=reply_markup\n            )\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_replace_callback_data_stop_poll_and_repl_to_message(self, cdc_bot, chat_id):\n        bot = cdc_bot\n\n        poll_message = await bot.send_poll(chat_id=chat_id, question=\"test\", options=[\"1\", \"2\"])\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            await poll_message.stop_poll(reply_markup=reply_markup)\n            helper_message = await poll_message.reply_text(\"temp\", do_quote=True)\n            message = helper_message.reply_to_message\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_replace_callback_data_copy_message(self, cdc_bot, chat_id):\n        \"\"\"This also tests that data is inserted into the buttons of message.reply_to_message\n        where message is the return value of a bot method\"\"\"\n        bot = cdc_bot\n\n        original_message = await bot.send_message(chat_id=chat_id, text=\"original\")\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            message_id = await original_message.copy(chat_id=chat_id, reply_markup=reply_markup)\n            helper_message = await bot.send_message(\n                chat_id=chat_id, reply_to_message_id=message_id.message_id, text=\"temp\"\n            )\n            message = helper_message.reply_to_message\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_get_chat_arbitrary_callback_data(self, chat_id, cdc_bot):\n        bot = cdc_bot\n\n        try:\n            reply_markup = InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"callback_data\")\n            )\n\n            message = await bot.send_message(\n                chat_id, text=\"get_chat_arbitrary_callback_data\", reply_markup=reply_markup\n            )\n            await message.pin()\n\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"callback_data\"\n\n            cfi = await bot.get_chat(chat_id)\n\n            if not cfi.pinned_message:\n                pytest.xfail(\"Pinning messages is not always reliable on TG\")\n\n            assert cfi.pinned_message == message\n            assert cfi.pinned_message.reply_markup == reply_markup\n            assert await message.unpin()  # (not placed in finally block since msg can be unbound)\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_arbitrary_callback_data_get_chat_no_pinned_message(\n        self, super_group_id, cdc_bot\n    ):\n        bot = cdc_bot\n        await bot.unpin_all_chat_messages(super_group_id)\n\n        try:\n            cfi = await bot.get_chat(super_group_id)\n\n            assert isinstance(cfi, ChatFullInfo)\n            assert int(cfi.id) == int(super_group_id)\n            assert cfi.pinned_message is None\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_set_get_my_description(self, bot):\n        default_description = f\"{bot.username} - default - {dtm.datetime.utcnow().isoformat()}\"\n        en_description = f\"{bot.username} - en - {dtm.datetime.utcnow().isoformat()}\"\n        de_description = f\"{bot.username} - de - {dtm.datetime.utcnow().isoformat()}\"\n\n        # Set the descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_description(default_description),\n                bot.set_my_description(en_description, language_code=\"en\"),\n                bot.set_my_description(de_description, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            bot.get_my_description(), bot.get_my_description(\"en\"), bot.get_my_description(\"de\")\n        ) == [\n            BotDescription(default_description),\n            BotDescription(en_description),\n            BotDescription(de_description),\n        ]\n\n        # Delete the descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_description(None),\n                bot.set_my_description(None, language_code=\"en\"),\n                bot.set_my_description(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            bot.get_my_description(), bot.get_my_description(\"en\"), bot.get_my_description(\"de\")\n        ) == 3 * [BotDescription(\"\")]\n\n    async def test_set_get_my_short_description(self, bot):\n        default_short_description = (\n            f\"{bot.username} - default - {dtm.datetime.utcnow().isoformat()}\"\n        )\n        en_short_description = f\"{bot.username} - en - {dtm.datetime.utcnow().isoformat()}\"\n        de_short_description = f\"{bot.username} - de - {dtm.datetime.utcnow().isoformat()}\"\n\n        # Set the short_descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_short_description(default_short_description),\n                bot.set_my_short_description(en_short_description, language_code=\"en\"),\n                bot.set_my_short_description(de_short_description, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            bot.get_my_short_description(),\n            bot.get_my_short_description(\"en\"),\n            bot.get_my_short_description(\"de\"),\n        ) == [\n            BotShortDescription(default_short_description),\n            BotShortDescription(en_short_description),\n            BotShortDescription(de_short_description),\n        ]\n\n        # Delete the short_descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_short_description(None),\n                bot.set_my_short_description(None, language_code=\"en\"),\n                bot.set_my_short_description(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            bot.get_my_short_description(),\n            bot.get_my_short_description(\"en\"),\n            bot.get_my_short_description(\"de\"),\n        ) == 3 * [BotShortDescription(\"\")]\n\n    async def test_set_message_reaction(self, bot, chat_id, static_message):\n        assert await bot.set_message_reaction(\n            chat_id, static_message.message_id, ReactionEmoji.THUMBS_DOWN, True\n        )\n\n    @pytest.mark.parametrize(\"bot_class\", [Bot, ExtBot])\n    async def test_do_api_request_warning_known_method(self, bot, bot_class):\n        with pytest.warns(PTBUserWarning, match=\"Please use 'Bot.get_me'\") as record:\n            await bot_class(bot.token).do_api_request(\"get_me\")\n\n        assert record[0].filename == __file__, \"Wrong stack level!\"\n\n    async def test_do_api_request_unknown_method(self, bot):\n        with pytest.raises(EndPointNotFound, match=\"'unknownEndpoint' not found\"):\n            await bot.do_api_request(\"unknown_endpoint\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    async def test_do_api_request_invalid_token(self, bot):\n        # we do not initialize the bot here on purpose b/c that's the case were we actually\n        # do not know for sure if the token is invalid or the method was not found\n        with pytest.raises(\n            InvalidToken, match=\"token was rejected by Telegram or the endpoint 'getMe'\"\n        ):\n            await Bot(\"invalid_token\").do_api_request(\"get_me\")\n\n        # same test, but with a valid token bot and unknown endpoint\n        with pytest.raises(\n            InvalidToken, match=\"token was rejected by Telegram or the endpoint 'unknownEndpoint'\"\n        ):\n            await Bot(bot.token).do_api_request(\"unknown_endpoint\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_basic_and_files(self, bot, chat_id, return_type):\n        result = await bot.do_api_request(\n            \"send_document\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"caption\": \"test_caption\",\n                \"document\": InputFile(data_file(\"telegram.png\").open(\"rb\")),\n            },\n            return_type=return_type,\n        )\n        if return_type is None:\n            assert isinstance(result, dict)\n            result = Message.de_json(result, bot)\n\n        assert isinstance(result, Message)\n        assert result.chat_id == int(chat_id)\n        assert result.caption == \"test_caption\"\n        out = BytesIO()\n        await (await result.document.get_file()).download_to_memory(out)\n        out.seek(0)\n        assert out.read() == data_file(\"telegram.png\").open(\"rb\").read()\n        assert result.document.file_name == \"telegram.png\"\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_list_return_type(self, bot, chat_id, return_type):\n        result = await bot.do_api_request(\n            \"send_media_group\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"media\": [\n                    InputMediaDocument(\n                        InputFile(\n                            data_file(\"text_file.txt\").open(\"rb\"),\n                            attach=True,\n                        )\n                    ),\n                    InputMediaDocument(\n                        InputFile(\n                            data_file(\"local_file.txt\").open(\"rb\"),\n                            attach=True,\n                        )\n                    ),\n                ],\n            },\n            return_type=return_type,\n        )\n        if return_type is None:\n            assert isinstance(result, list)\n            for entry in result:\n                assert isinstance(entry, dict)\n            result = Message.de_list(result, bot)\n\n        for message, file_name in zip(result, (\"text_file.txt\", \"local_file.txt\")):\n            assert isinstance(message, Message)\n            assert message.chat_id == int(chat_id)\n            out = BytesIO()\n            await (await message.document.get_file()).download_to_memory(out)\n            out.seek(0)\n            assert out.read() == data_file(file_name).open(\"rb\").read()\n            assert message.document.file_name == file_name\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_bool_return_type(self, bot, chat_id, return_type):\n        assert await bot.do_api_request(\"delete_my_commands\", return_type=return_type) is True\n\n    async def test_get_star_transactions(self, bot):\n        transactions = await bot.get_star_transactions(limit=1)\n        assert isinstance(transactions, StarTransactions)\n        assert len(transactions.transactions) == 0\n\n    @pytest.mark.parametrize(\"subscription_period\", [2592000, dtm.timedelta(days=30)])\n    async def test_create_edit_chat_subscription_link(\n        self, bot, subscription_channel_id, channel_id, subscription_period\n    ):\n        sub_link = await bot.create_chat_subscription_invite_link(\n            subscription_channel_id,\n            name=\"sub_name\",\n            subscription_period=subscription_period,\n            subscription_price=13,\n        )\n        assert sub_link.name == \"sub_name\"\n        assert sub_link.subscription_period == 2592000\n        assert sub_link.subscription_price == 13\n\n        edited_link = await bot.edit_chat_subscription_invite_link(\n            chat_id=subscription_channel_id, invite_link=sub_link, name=\"sub_name_2\"\n        )\n        assert edited_link.name == \"sub_name_2\"\n        assert sub_link.subscription_period == 2592000\n        assert sub_link.subscription_price == 13\n\n    async def test_get_my_star_balance(self, bot):\n        balance = await bot.get_my_star_balance()\n        assert isinstance(balance, StarAmount)\n        assert balance.amount == 0"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2663,
                            4635
                        ],
                        "reason": "The test 'test_send_dice_default_allow_sending_without_reply' may fail if the dice cannot be sent with the specified parameters or if the bot does not handle the sending correctly, leading to assertion errors.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "class TestBotWithRequest:\n    \"\"\"\n    Most are executed on tg.ext.ExtBot, as that class only extends the functionality of tg.bot\n\n    Behavior for init of ExtBot with missing optional dependency cachetools (for CallbackDataCache)\n    is tested in `test_callbackdatacache`\n    \"\"\"\n\n    # get_available_gifts, send_gift are tested in `test_gift`.\n    # No need to duplicate here.\n\n    async def test_invalid_token_server_response(self):\n        with pytest.raises(InvalidToken, match=\"The token `12` was rejected by the server\\\\.\"):\n            async with ExtBot(token=\"12\"):\n                pass\n\n    async def test_multiple_init_cycles(self, bot):\n        # nothing really to assert - this should just not fail\n        test_bot = Bot(bot.token)\n        async with test_bot:\n            await test_bot.get_me()\n        async with test_bot:\n            await test_bot.get_me()\n\n    async def test_forward_message(self, bot, chat_id, static_message):\n        forward_message = await bot.forward_message(\n            chat_id, from_chat_id=chat_id, message_id=static_message.message_id\n        )\n\n        assert forward_message.text == static_message.text\n        assert forward_message.forward_origin.sender_user == static_message.from_user\n        assert isinstance(forward_message.forward_origin.date, dtm.datetime)\n\n    async def test_forward_protected_message(self, bot, chat_id):\n        tasks = asyncio.gather(\n            bot.send_message(chat_id, \"cant forward me\", protect_content=True),\n            bot.send_message(chat_id, \"forward me\", protect_content=False),\n        )\n        to_forward_protected, to_forward_unprotected = await tasks\n\n        assert to_forward_protected.has_protected_content\n        assert not to_forward_unprotected.has_protected_content\n\n        forwarded_but_now_protected = await to_forward_unprotected.forward(\n            chat_id, protect_content=True\n        )\n        assert forwarded_but_now_protected.has_protected_content\n\n        tasks = asyncio.gather(\n            to_forward_protected.forward(chat_id),\n            forwarded_but_now_protected.forward(chat_id),\n            return_exceptions=True,\n        )\n        result = await tasks\n        assert all(\"can't be forwarded\" in str(exc) for exc in result)\n\n    async def test_forward_messages(self, bot, chat_id):\n        # not using gather here to have deteriminically ordered message_ids\n        msg1 = await bot.send_message(chat_id, text=\"will be forwarded\")\n        msg2 = await bot.send_message(chat_id, text=\"will be forwarded\")\n\n        forward_messages = await bot.forward_messages(\n            chat_id, from_chat_id=chat_id, message_ids=(msg1.message_id, msg2.message_id)\n        )\n\n        assert isinstance(forward_messages, tuple)\n\n        tasks = asyncio.gather(\n            bot.send_message(\n                chat_id, \"temp 1\", reply_to_message_id=forward_messages[0].message_id\n            ),\n            bot.send_message(\n                chat_id, \"temp 2\", reply_to_message_id=forward_messages[1].message_id\n            ),\n        )\n\n        temp_msg1, temp_msg2 = await tasks\n        forward_msg1 = temp_msg1.reply_to_message\n        forward_msg2 = temp_msg2.reply_to_message\n\n        assert forward_msg1.text == msg1.text\n        assert forward_msg1.forward_origin.sender_user == msg1.from_user\n        assert isinstance(forward_msg1.forward_origin.date, dtm.datetime)\n\n        assert forward_msg2.text == msg2.text\n        assert forward_msg2.forward_origin.sender_user == msg2.from_user\n        assert isinstance(forward_msg2.forward_origin.date, dtm.datetime)\n\n    async def test_delete_message(self, bot, chat_id):\n        message = await bot.send_message(chat_id, text=\"will be deleted\")\n        assert await bot.delete_message(chat_id=chat_id, message_id=message.message_id) is True\n\n    async def test_delete_message_old_message(self, bot, chat_id):\n        with pytest.raises(BadRequest):\n            # Considering that the first message is old enough\n            await bot.delete_message(chat_id=chat_id, message_id=1)\n\n    # send_photo, send_audio, send_document, send_sticker, send_video, send_voice, send_video_note,\n    # send_media_group, send_animation, get_user_chat_boosts are tested in their respective\n    # test modules. No need to duplicate here.\n\n    async def test_delete_messages(self, bot, chat_id):\n        msg1, msg2 = await asyncio.gather(\n            bot.send_message(chat_id, text=\"will be deleted\"),\n            bot.send_message(chat_id, text=\"will be deleted\"),\n        )\n\n        assert (\n            await bot.delete_messages(chat_id=chat_id, message_ids=sorted((msg1.id, msg2.id)))\n            is True\n        )\n\n    async def test_send_venue(self, bot, chat_id):\n        longitude = -46.788279\n        latitude = -23.691288\n        title = \"title\"\n        address = \"address\"\n        foursquare_id = \"foursquare id\"\n        foursquare_type = \"foursquare type\"\n        google_place_id = \"google_place id\"\n        google_place_type = \"google_place type\"\n\n        tasks = asyncio.gather(\n            *(\n                bot.send_venue(\n                    chat_id=chat_id,\n                    title=title,\n                    address=address,\n                    latitude=latitude,\n                    longitude=longitude,\n                    protect_content=True,\n                    **i,\n                )\n                for i in (\n                    {\"foursquare_id\": foursquare_id, \"foursquare_type\": foursquare_type},\n                    {\"google_place_id\": google_place_id, \"google_place_type\": google_place_type},\n                )\n            ),\n        )\n\n        message, message2 = await tasks\n        assert message.venue\n        assert message.venue.title == title\n        assert message.venue.address == address\n        assert message.venue.location.latitude == latitude\n        assert message.venue.location.longitude == longitude\n        assert message.venue.foursquare_id == foursquare_id\n        assert message.venue.foursquare_type == foursquare_type\n        assert message.venue.google_place_id is None\n        assert message.venue.google_place_type is None\n        assert message.has_protected_content\n\n        assert message2.venue\n        assert message2.venue.title == title\n        assert message2.venue.address == address\n        assert message2.venue.location.latitude == latitude\n        assert message2.venue.location.longitude == longitude\n        assert message2.venue.google_place_id == google_place_id\n        assert message2.venue.google_place_type == google_place_type\n        assert message2.venue.foursquare_id is None\n        assert message2.venue.foursquare_type is None\n        assert message2.has_protected_content\n\n    async def test_send_contact(self, bot, chat_id):\n        phone_number = \"+11234567890\"\n        first_name = \"Leandro\"\n        last_name = \"Toledo\"\n        message = await bot.send_contact(\n            chat_id=chat_id,\n            phone_number=phone_number,\n            first_name=first_name,\n            last_name=last_name,\n            protect_content=True,\n        )\n\n        assert message.contact\n        assert message.contact.phone_number == phone_number\n        assert message.contact.first_name == first_name\n        assert message.contact.last_name == last_name\n        assert message.has_protected_content\n\n    # TODO: Add bot to group to test polls too\n    @pytest.mark.parametrize(\n        \"reply_markup\",\n        [\n            None,\n            InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n            ),\n            InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n            ).to_dict(),\n        ],\n    )\n    async def test_send_and_stop_poll(self, bot, super_group_id, reply_markup):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", InputPollOption(\"No\"), \"Maybe\"]\n        explanation = \"[Here is a link](https://google.com)\"\n        explanation_entities = [\n            MessageEntity(MessageEntity.TEXT_LINK, 0, 14, url=\"https://google.com\")\n        ]\n\n        poll_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                is_anonymous=False,\n                allows_multiple_answers=True,\n                read_timeout=60,\n                protect_content=True,\n            )\n        )\n        quiz_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                type=Poll.QUIZ,\n                correct_option_id=2,\n                is_closed=True,\n                explanation=explanation,\n                explanation_parse_mode=ParseMode.MARKDOWN_V2,\n            )\n        )\n\n        message = await poll_task\n        assert message.poll\n        assert message.poll.question == question\n        assert message.poll.options[0].text == answers[0]\n        assert message.poll.options[1].text == answers[1].text\n        assert message.poll.options[2].text == answers[2]\n        assert not message.poll.is_anonymous\n        assert message.poll.allows_multiple_answers\n        assert not message.poll.is_closed\n        assert message.poll.type == Poll.REGULAR\n        assert message.has_protected_content\n\n        # Since only the poll and not the complete message is returned, we can't check that the\n        # reply_markup is correct. So we just test that sending doesn't give an error.\n        poll = await bot.stop_poll(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert isinstance(poll, Poll)\n        assert poll.is_closed\n        assert poll.options[0].text == answers[0]\n        assert poll.options[0].voter_count == 0\n        assert poll.options[1].text == answers[1].text\n        assert poll.options[1].voter_count == 0\n        assert poll.options[2].text == answers[2]\n        assert poll.options[2].voter_count == 0\n        assert poll.question == question\n        assert poll.total_voter_count == 0\n\n        message_quiz = await quiz_task\n        assert message_quiz.poll.correct_option_id == 2\n        assert message_quiz.poll.type == Poll.QUIZ\n        assert message_quiz.poll.is_closed\n        assert message_quiz.poll.explanation == \"Here is a link\"\n        assert message_quiz.poll.explanation_entities == tuple(explanation_entities)\n        assert poll_task.done()\n        assert quiz_task.done()\n\n    @pytest.mark.parametrize(\n        (\"open_period\", \"close_date\"),\n        [(5, None), (dtm.timedelta(seconds=5), None), (None, True)],\n        ids=[\"open_period\", \"open_period-dtm\", \"close_date\"],\n    )\n    async def test_send_open_period(self, bot, super_group_id, open_period, close_date):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        if close_date:\n            close_date = dtm.datetime.utcnow() + dtm.timedelta(seconds=5.05)\n\n        message = await bot.send_poll(\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            is_anonymous=False,\n            allows_multiple_answers=True,\n            read_timeout=60,\n            open_period=open_period,\n            close_date=close_date,\n        )\n        await asyncio.sleep(5.1)\n        new_message = await bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == message.poll.id\n        assert new_message.poll.is_closed\n\n    async def test_send_close_date_default_tz(self, tz_bot, super_group_id):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        aware_close_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + dtm.timedelta(seconds=5)\n        close_date = aware_close_date.replace(tzinfo=None)\n\n        msg = await tz_bot.send_poll(  # The timezone returned from this is always converted to UTC\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            close_date=close_date,\n            read_timeout=60,\n        )\n        msg.poll._unfreeze()\n        # Sometimes there can be a few seconds delay, so don't let the test fail due to that-\n        msg.poll.close_date = msg.poll.close_date.astimezone(aware_close_date.tzinfo)\n        assert abs(msg.poll.close_date - aware_close_date) <= dtm.timedelta(seconds=5)\n\n        await asyncio.sleep(5.1)\n\n        new_message = await tz_bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=msg.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == msg.poll.id\n        assert new_message.poll.is_closed\n\n    async def test_send_poll_explanation_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.send_poll(\n            chat_id,\n            \"question\",\n            options=[\"a\", \"b\"],\n            correct_option_id=0,\n            type=Poll.QUIZ,\n            explanation=test_string,\n            explanation_entities=entities,\n        )\n\n        assert message.poll.explanation == test_string\n        assert message.poll.explanation_entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_send_poll_default_parse_mode(self, default_bot, super_group_id):\n        explanation = \"Italic Bold Code\"\n        explanation_markdown = \"_Italic_ *Bold* `Code`\"\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_poll(\n                    chat_id=super_group_id,\n                    question=question,\n                    options=answers,\n                    type=Poll.QUIZ,\n                    correct_option_id=2,\n                    is_closed=True,\n                    explanation=explanation_markdown,\n                    **i,\n                )\n                for i in ({}, {\"explanation_parse_mode\": None}, {\"explanation_parse_mode\": \"HTML\"})\n            ),\n        )\n        message1, message2, message3 = await tasks\n        assert message1.poll.explanation == explanation\n        assert message1.poll.explanation_entities == (\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.BOLD, 7, 4),\n            MessageEntity(MessageEntity.CODE, 12, 4),\n        )\n\n        assert message2.poll.explanation == explanation_markdown\n        assert message2.poll.explanation_entities == ()\n\n        assert message3.poll.explanation == explanation_markdown\n        assert message3.poll.explanation_entities == ()\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_poll_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_poll(\n                    chat_id,\n                    question=question,\n                    options=answers,\n                    reply_to_message_id=reply_to_message.message_id,\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_poll_default_protect_content(self, chat_id, default_bot):\n        tasks = asyncio.gather(\n            default_bot.send_poll(chat_id, \"Test\", [\"1\", \"2\"]),\n            default_bot.send_poll(chat_id, \"test\", [\"1\", \"2\"], protect_content=False),\n        )\n        protected_poll, unprotect_poll = await tasks\n        assert protected_poll.has_protected_content\n        assert not unprotect_poll.has_protected_content\n\n    @pytest.mark.parametrize(\"emoji\", [*Dice.ALL_EMOJI, None])\n    async def test_send_dice(self, bot, chat_id, emoji):\n        message = await bot.send_dice(chat_id, emoji=emoji, protect_content=True)\n\n        assert message.dice\n        assert message.has_protected_content\n        if emoji is None:\n            assert message.dice.emoji == Dice.DICE\n        else:\n            assert message.dice.emoji == emoji\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_dice_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_dice(\n                chat_id,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_dice(\n                chat_id,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_dice(\n                    chat_id, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_dice_default_protect_content(self, chat_id, default_bot):\n        tasks = asyncio.gather(\n            default_bot.send_dice(chat_id), default_bot.send_dice(chat_id, protect_content=False)\n        )\n        protected_dice, unprotected_dice = await tasks\n        assert protected_dice.has_protected_content\n        assert not unprotected_dice.has_protected_content\n\n    @pytest.mark.parametrize(\"chat_action\", list(ChatAction))\n    async def test_send_chat_action(self, bot, chat_id, chat_action):\n        assert await bot.send_chat_action(chat_id, chat_action)\n\n    async def test_wrong_chat_action(self, bot, chat_id):\n        with pytest.raises(BadRequest, match=\"Wrong parameter action\"):\n            await bot.send_chat_action(chat_id, \"unknown action\")\n\n    async def test_answer_inline_query_current_offset_error(self, bot, inline_results):\n        with pytest.raises(ValueError, match=\"`current_offset` and `next_offset`\"):\n            await bot.answer_inline_query(\n                1234, results=inline_results, next_offset=42, current_offset=51\n            )\n\n    async def test_save_prepared_inline_message(self, bot, chat_id):\n        # We can't really check that the result is stored correctly, we just ensur ethat we get\n        # a proper return value\n        result = InlineQueryResultArticle(\n            id=\"some_id\", title=\"title\", input_message_content=InputTextMessageContent(\"text\")\n        )\n        out = await bot.save_prepared_inline_message(chat_id, result, True, False, True, False)\n        assert isinstance(out, PreparedInlineMessage)\n\n    async def test_get_user_profile_photos(self, bot, chat_id):\n        user_profile_photos = await bot.get_user_profile_photos(chat_id)\n        assert user_profile_photos.photos[0][0].file_size == 5403\n\n    async def test_get_one_user_profile_photo(self, bot, chat_id):\n        user_profile_photos = await bot.get_user_profile_photos(chat_id, offset=0, limit=1)\n        assert user_profile_photos.total_count == 1\n        assert user_profile_photos.photos[0][0].file_size == 5403\n\n    async def test_edit_message_text(self, bot, one_time_message):\n        message = await bot.edit_message_text(\n            text=\"new_text\",\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            parse_mode=\"HTML\",\n            disable_web_page_preview=True,\n        )\n\n        assert message.text == \"new_text\"\n\n    async def test_edit_message_text_entities(self, bot, one_time_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_text(\n            text=test_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            entities=entities,\n        )\n\n        assert message.text == test_string\n        assert message.entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_edit_message_text_default_parse_mode(\n        self, default_bot, chat_id, one_time_message\n    ):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            disable_web_page_preview=True,\n        )\n        assert message.text_markdown == test_markdown_string\n        assert message.text == test_string\n\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string,\n            chat_id=message.chat_id,\n            message_id=message.message_id,\n            parse_mode=None,\n            disable_web_page_preview=True,\n        )\n        assert message.text == test_markdown_string\n        assert message.text_markdown == escape_markdown(test_markdown_string)\n\n        suffix = \" edited\"\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string + suffix,\n            chat_id=message.chat_id,\n            message_id=message.message_id,\n            parse_mode=\"HTML\",\n            disable_web_page_preview=True,\n        )\n        assert message.text == test_markdown_string + suffix\n        assert message.text_markdown == escape_markdown(test_markdown_string) + suffix\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_message_text_inline(self):\n        pass\n\n    async def test_edit_message_caption(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new_caption\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            show_caption_above_media=False,\n        )\n\n        assert message.caption == \"new_caption\"\n        assert not message.show_caption_above_media\n\n    async def test_edit_message_caption_entities(self, bot, media_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_caption(\n            caption=test_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            caption_entities=entities,\n        )\n\n        assert message.caption == test_string\n        assert message.caption_entities == tuple(entities)\n\n    # edit_message_media is tested in test_inputmedia\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_edit_message_caption_default_parse_mode(self, default_bot, media_message):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n        assert message.caption_markdown == test_markdown_string\n        assert message.caption == test_string\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            parse_mode=None,\n        )\n        assert message.caption == test_markdown_string\n        assert message.caption_markdown == escape_markdown(test_markdown_string)\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            parse_mode=\"HTML\",\n        )\n        assert message.caption == test_markdown_string\n        assert message.caption_markdown == escape_markdown(test_markdown_string)\n\n    async def test_edit_message_caption_with_parse_mode(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new *caption*\",\n            parse_mode=\"Markdown\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n\n        assert message.caption == \"new caption\"\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_message_caption_inline(self):\n        pass\n\n    async def test_edit_reply_markup(self, bot, one_time_message):\n        new_markup = InlineKeyboardMarkup([[InlineKeyboardButton(text=\"test\", callback_data=\"1\")]])\n        message = await bot.edit_message_reply_markup(\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            reply_markup=new_markup,\n        )\n\n        assert message is not True\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_reply_markup_inline(self):\n        pass\n\n    # TODO: Actually send updates to the test bot so this can be tested properly\n    @pytest.mark.parametrize(\"timeout\", [1, dtm.timedelta(seconds=1)])\n    async def test_get_updates(self, bot, timeout):\n        await bot.delete_webhook()  # make sure there is no webhook set if webhook tests failed\n        updates = await bot.get_updates(timeout=timeout)\n\n        assert isinstance(updates, tuple)\n        if updates:\n            assert isinstance(updates[0], Update)\n\n    @pytest.mark.parametrize(\n        (\"read_timeout\", \"timeout\", \"expected\"),\n        [\n            (None, None, 0),\n            (1, None, 1),\n            (None, 1, 1),\n            (None, dtm.timedelta(seconds=1), 1),\n            (DEFAULT_NONE, None, 10),\n            (DEFAULT_NONE, 1, 11),\n            (DEFAULT_NONE, dtm.timedelta(seconds=1), 11),\n            (1, 2, 3),\n            (1, dtm.timedelta(seconds=2), 3),\n        ],\n    )\n    async def test_get_updates_read_timeout_value_passing(\n        self, bot, read_timeout, timeout, expected, monkeypatch\n    ):\n        caught_read_timeout = None\n\n        async def catch_timeouts(*args, **kwargs):\n            nonlocal caught_read_timeout\n            caught_read_timeout = kwargs.get(\"read_timeout\")\n            return HTTPStatus.OK, b'{\"ok\": \"True\", \"result\": {}}'\n\n        monkeypatch.setattr(HTTPXRequest, \"do_request\", catch_timeouts)\n\n        bot = Bot(get_updates_request=HTTPXRequest(read_timeout=10), token=bot.token)\n        await bot.get_updates(read_timeout=read_timeout, timeout=timeout)\n        assert caught_read_timeout == expected\n\n    @pytest.mark.parametrize(\"use_ip\", [True, False])\n    # local file path as file_input is tested below in test_set_webhook_params\n    @pytest.mark.parametrize(\"file_input\", [\"bytes\", \"file_handle\"])\n    async def test_set_webhook_get_webhook_info_and_delete_webhook(self, bot, use_ip, file_input):\n        url = \"https://python-telegram-bot.org/test/webhook\"\n        # Get the ip address of the website - dynamically just in case it ever changes\n        ip = socket.gethostbyname(\"python-telegram-bot.org\")\n        max_connections = 7\n        allowed_updates = [\"message\"]\n        file_input = (\n            data_file(\"sslcert.pem\").read_bytes()\n            if file_input == \"bytes\"\n            else data_file(\"sslcert.pem\").open(\"rb\")\n        )\n        await bot.set_webhook(\n            url,\n            max_connections=max_connections,\n            allowed_updates=allowed_updates,\n            ip_address=ip if use_ip else None,\n            certificate=file_input if use_ip else None,\n        )\n\n        await asyncio.sleep(1)\n        live_info = await bot.get_webhook_info()\n        assert live_info.url == url\n        assert live_info.max_connections == max_connections\n        assert live_info.allowed_updates == tuple(allowed_updates)\n        assert live_info.ip_address == ip\n        assert live_info.has_custom_certificate == use_ip\n\n        await bot.delete_webhook()\n        await asyncio.sleep(1)\n        info = await bot.get_webhook_info()\n        assert not info.url\n        assert info.ip_address is None\n        assert info.has_custom_certificate is False\n\n    async def test_leave_chat(self, bot):\n        with pytest.raises(BadRequest, match=\"Chat not found\"):\n            await bot.leave_chat(-123456)\n\n    async def test_get_chat(self, bot, super_group_id):\n        cfi = await bot.get_chat(super_group_id)\n        assert cfi.type == \"supergroup\"\n        assert cfi.title == f\">>> telegram.Bot(test) @{bot.username}\"\n        assert cfi.id == int(super_group_id)\n\n    async def test_get_chat_administrators(self, bot, channel_id):\n        admins = await bot.get_chat_administrators(channel_id)\n        assert isinstance(admins, tuple)\n\n        for a in admins:\n            assert a.status in (\"administrator\", \"creator\")\n\n    async def test_get_chat_member_count(self, bot, channel_id):\n        count = await bot.get_chat_member_count(channel_id)\n        assert isinstance(count, int)\n        assert count > 3\n\n    async def test_get_chat_member(self, bot, channel_id, chat_id):\n        chat_member = await bot.get_chat_member(channel_id, chat_id)\n\n        assert chat_member.status == \"creator\"\n        assert chat_member.user.first_name == \"PTB\"\n        assert chat_member.user.last_name == \"Test user\"\n\n    @pytest.mark.skip(reason=\"Not implemented since we need a supergroup with many members\")\n    async def test_set_chat_sticker_set(self):\n        pass\n\n    @pytest.mark.skip(reason=\"Not implemented since we need a supergroup with many members\")\n    async def test_delete_chat_sticker_set(self):\n        pass\n\n    async def test_send_game(self, bot, chat_id):\n        game_short_name = \"test_game\"\n        message = await bot.send_game(chat_id, game_short_name, protect_content=True)\n\n        assert message.game\n        assert (\n            message.game.description\n            == \"A no-op test game, for python-telegram-bot bot framework testing.\"\n        )\n        assert message.game.animation.file_id\n        # We added some test bots later and for some reason the file size is not the same for them\n        # so we accept three different sizes here. Shouldn't be too much of\n        assert message.game.photo[0].file_size in [851, 4928, 850]\n        assert message.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        game_short_name = \"test_game\"\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_game(\n                chat_id,\n                game_short_name,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_game(\n                chat_id,\n                game_short_name,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_game(\n                    chat_id, game_short_name, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"val\"),\n        [({\"protect_content\": True}, True), ({\"protect_content\": False}, None)],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_protect_content(self, default_bot, chat_id, val):\n        protected = await default_bot.send_game(chat_id, \"test_game\", protect_content=val)\n        assert protected.has_protected_content is val\n\n    @xfail\n    async def test_set_game_score_and_high_scores(self, bot, chat_id):\n        # First, test setting a score.\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=BASE_GAME_SCORE,  # Score value is relevant for other set_game_score_* tests!\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n        assert message.game.text != game.game.text\n\n        # Test setting a score higher than previous\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        score = BASE_GAME_SCORE + 1\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=score,\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n            disable_edit_message=True,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n        assert message.game.text == game.game.text\n\n        # Test setting a score lower than previous (should raise error)\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        score = BASE_GAME_SCORE  # Even a score equal to previous raises an error.\n\n        with pytest.raises(BadRequest, match=\"Bot_score_not_modified\"):\n            await bot.set_game_score(\n                user_id=chat_id, score=score, chat_id=game.chat_id, message_id=game.message_id\n            )\n\n        # Test force setting a lower score\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n        await asyncio.sleep(1.5)\n\n        score = BASE_GAME_SCORE - 10\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=score,\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n            force=True,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n\n        # For some reason the returned message doesn't contain the updated score. need to fetch\n        # the game again... (the service message is also absent when running the test suite)\n        game2 = await bot.send_game(chat_id, game_short_name)\n        assert str(score) in game2.game.text\n\n        # We need a game to get the scores for\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n        high_scores = await bot.get_game_high_scores(chat_id, game.chat_id, game.message_id)\n        # We assume that the other game score tests ran within 20 sec\n        assert high_scores[0].score == BASE_GAME_SCORE - 10\n\n    # send_invoice and create_invoice_link is tested in test_invoice\n    async def test_promote_chat_member(self, bot, channel_id, monkeypatch):\n        # TODO: Add bot to supergroup so this can be tested properly / give bot perms\n        with pytest.raises(BadRequest, match=\"Not enough rights\"):\n            assert await bot.promote_chat_member(\n                channel_id,\n                1325859552,\n                is_anonymous=True,\n                can_change_info=True,\n                can_post_messages=True,\n                can_edit_messages=True,\n                can_delete_messages=True,\n                can_invite_users=True,\n                can_restrict_members=True,\n                can_pin_messages=True,\n                can_promote_members=True,\n                can_manage_chat=True,\n                can_manage_video_chats=True,\n                can_manage_topics=True,\n                can_post_stories=True,\n                can_edit_stories=True,\n                can_delete_stories=True,\n                can_manage_direct_messages=True,\n            )\n\n        # Test that we pass the correct params to TG\n        async def make_assertion(*args, **_):\n            data = args[1]\n            return (\n                data.get(\"chat_id\") == channel_id\n                and data.get(\"user_id\") == 1325859552\n                and data.get(\"is_anonymous\") == 1\n                and data.get(\"can_change_info\") == 2\n                and data.get(\"can_post_messages\") == 3\n                and data.get(\"can_edit_messages\") == 4\n                and data.get(\"can_delete_messages\") == 5\n                and data.get(\"can_invite_users\") == 6\n                and data.get(\"can_restrict_members\") == 7\n                and data.get(\"can_pin_messages\") == 8\n                and data.get(\"can_promote_members\") == 9\n                and data.get(\"can_manage_chat\") == 10\n                and data.get(\"can_manage_video_chats\") == 11\n                and data.get(\"can_manage_topics\") == 12\n                and data.get(\"can_post_stories\") == 13\n                and data.get(\"can_edit_stories\") == 14\n                and data.get(\"can_delete_stories\") == 15\n                and data.get(\"can_manage_direct_messages\") == 16\n            )\n\n        monkeypatch.setattr(bot, \"_post\", make_assertion)\n        assert await bot.promote_chat_member(\n            channel_id,\n            1325859552,\n            is_anonymous=1,\n            can_change_info=2,\n            can_post_messages=3,\n            can_edit_messages=4,\n            can_delete_messages=5,\n            can_invite_users=6,\n            can_restrict_members=7,\n            can_pin_messages=8,\n            can_promote_members=9,\n            can_manage_chat=10,\n            can_manage_video_chats=11,\n            can_manage_topics=12,\n            can_post_stories=13,\n            can_edit_stories=14,\n            can_delete_stories=15,\n            can_manage_direct_messages=16,\n        )\n\n    async def test_export_chat_invite_link(self, bot, channel_id):\n        # Each link is unique apparently\n        invite_link = await bot.export_chat_invite_link(channel_id)\n        assert isinstance(invite_link, str)\n        assert invite_link\n\n    async def test_edit_revoke_chat_invite_link_passing_link_objects(self, bot, channel_id):\n        invite_link = await bot.create_chat_invite_link(chat_id=channel_id)\n        assert invite_link.name is None\n\n        edited_link = await bot.edit_chat_invite_link(\n            chat_id=channel_id, invite_link=invite_link, name=\"some_name\"\n        )\n        assert edited_link == invite_link\n        assert edited_link.name == \"some_name\"\n\n        revoked_link = await bot.revoke_chat_invite_link(\n            chat_id=channel_id, invite_link=edited_link\n        )\n        assert revoked_link.invite_link == edited_link.invite_link\n        assert revoked_link.is_revoked is True\n        assert revoked_link.name == \"some_name\"\n\n    @pytest.mark.parametrize(\"creates_join_request\", [True, False])\n    @pytest.mark.parametrize(\"name\", [None, \"name\"])\n    async def test_create_chat_invite_link_basics(\n        self, bot, creates_join_request, name, channel_id\n    ):\n        data = {}\n        if creates_join_request:\n            data[\"creates_join_request\"] = True\n        if name:\n            data[\"name\"] = name\n        invite_link = await bot.create_chat_invite_link(chat_id=channel_id, **data)\n\n        assert invite_link.member_limit is None\n        assert invite_link.expire_date is None\n        assert invite_link.creates_join_request == creates_join_request\n        assert invite_link.name == name\n\n        revoked_link = await bot.revoke_chat_invite_link(\n            chat_id=channel_id, invite_link=invite_link.invite_link\n        )\n        assert revoked_link.is_revoked\n\n    @pytest.mark.parametrize(\"datetime\", argvalues=[True, False], ids=[\"datetime\", \"integer\"])\n    async def test_advanced_chat_invite_links(self, bot, channel_id, datetime):\n        # we are testing this all in one function in order to save api calls\n        timestamp = dtm.datetime.utcnow()\n        add_seconds = dtm.timedelta(0, 70)\n        time_in_future = timestamp + add_seconds\n        expire_time = time_in_future if datetime else to_timestamp(time_in_future)\n        aware_time_in_future = localize(time_in_future, UTC)\n\n        invite_link = await bot.create_chat_invite_link(\n            channel_id, expire_date=expire_time, member_limit=10\n        )\n        assert invite_link.invite_link\n        assert not invite_link.invite_link.endswith(\"...\")\n        assert abs(invite_link.expire_date - aware_time_in_future) < dtm.timedelta(seconds=1)\n        assert invite_link.member_limit == 10\n\n        add_seconds = dtm.timedelta(0, 80)\n        time_in_future = timestamp + add_seconds\n        expire_time = time_in_future if datetime else to_timestamp(time_in_future)\n        aware_time_in_future = localize(time_in_future, UTC)\n\n        edited_invite_link = await bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            expire_date=expire_time,\n            member_limit=20,\n            name=\"NewName\",\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert abs(edited_invite_link.expire_date - aware_time_in_future) < dtm.timedelta(\n            seconds=1\n        )\n        assert edited_invite_link.name == \"NewName\"\n        assert edited_invite_link.member_limit == 20\n\n        edited_invite_link = await bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            name=\"EvenNewerName\",\n            creates_join_request=True,\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert not edited_invite_link.expire_date\n        assert edited_invite_link.name == \"EvenNewerName\"\n        assert edited_invite_link.creates_join_request\n        assert edited_invite_link.member_limit is None\n\n        revoked_invite_link = await bot.revoke_chat_invite_link(\n            channel_id, invite_link.invite_link\n        )\n        assert revoked_invite_link.invite_link == invite_link.invite_link\n        assert revoked_invite_link.is_revoked\n\n    async def test_advanced_chat_invite_links_default_tzinfo(self, tz_bot, channel_id):\n        # we are testing this all in one function in order to save api calls\n        add_seconds = dtm.timedelta(0, 70)\n        aware_expire_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + add_seconds\n        time_in_future = aware_expire_date.replace(tzinfo=None)\n\n        invite_link = await tz_bot.create_chat_invite_link(\n            channel_id, expire_date=time_in_future, member_limit=10\n        )\n        assert invite_link.invite_link\n        assert not invite_link.invite_link.endswith(\"...\")\n        assert abs(invite_link.expire_date - aware_expire_date) < dtm.timedelta(seconds=1)\n        assert invite_link.member_limit == 10\n\n        add_seconds = dtm.timedelta(0, 80)\n        aware_expire_date += add_seconds\n        time_in_future = aware_expire_date.replace(tzinfo=None)\n\n        edited_invite_link = await tz_bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            expire_date=time_in_future,\n            member_limit=20,\n            name=\"NewName\",\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert abs(edited_invite_link.expire_date - aware_expire_date) < dtm.timedelta(seconds=1)\n        assert edited_invite_link.name == \"NewName\"\n        assert edited_invite_link.member_limit == 20\n\n        edited_invite_link = await tz_bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            name=\"EvenNewerName\",\n            creates_join_request=True,\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert not edited_invite_link.expire_date\n        assert edited_invite_link.name == \"EvenNewerName\"\n        assert edited_invite_link.creates_join_request\n        assert edited_invite_link.member_limit is None\n\n        revoked_invite_link = await tz_bot.revoke_chat_invite_link(\n            channel_id, invite_link.invite_link\n        )\n        assert revoked_invite_link.invite_link == invite_link.invite_link\n        assert revoked_invite_link.is_revoked\n\n    async def test_approve_chat_join_request(self, bot, chat_id, channel_id):\n        # TODO: Need incoming join request to properly test\n        # Since we can't create join requests on the fly, we just tests the call to TG\n        # by checking that it complains about approving a user who is already in the chat\n        with pytest.raises(BadRequest, match=\"User_already_participant\"):\n            await bot.approve_chat_join_request(chat_id=channel_id, user_id=chat_id)\n\n    async def test_decline_chat_join_request(self, bot, chat_id, channel_id):\n        # TODO: Need incoming join request to properly test\n        # Since we can't create join requests on the fly, we just tests the call to TG\n        # by checking that it complains about declining a user who is already in the chat\n        #\n        # The error message Hide_requester_missing started showing up instead of\n        # User_already_participant. Don't know why \u2026\n        with pytest.raises(BadRequest, match=r\"User_already_participant|Hide_requester_missing\"):\n            await bot.decline_chat_join_request(chat_id=channel_id, user_id=chat_id)\n\n    async def test_set_chat_photo(self, bot, channel_id):\n        async def func():\n            assert await bot.set_chat_photo(channel_id, f)\n\n        with data_file(\"telegram_test_channel.jpg\").open(\"rb\") as f:\n            await expect_bad_request(\n                func, \"Type of file mismatch\", \"Telegram did not accept the file.\"\n            )\n\n    async def test_delete_chat_photo(self, bot, channel_id):\n        async def func():\n            assert await bot.delete_chat_photo(channel_id)\n\n        await expect_bad_request(func, \"Chat_not_modified\", \"Chat photo was not set.\")\n\n    async def test_set_chat_title(self, bot, channel_id):\n        assert await bot.set_chat_title(channel_id, \">>> telegram.Bot() - Tests\")\n\n    async def test_set_chat_description(self, bot, channel_id):\n        assert await bot.set_chat_description(channel_id, \"Time: \" + str(time.time()))\n\n    async def test_pin_and_unpin_message(self, bot, super_group_id):\n        messages = []  # contains the Messages we sent\n        pinned_messages_tasks = set()  # contains the asyncio.Tasks that pin the messages\n\n        # Let's send 3 messages so we can pin them\n        awaitables = {bot.send_message(super_group_id, f\"test_pin_message_{i}\") for i in range(3)}\n\n        # We will pin the messages immediately after sending them\n        for sending_msg in asyncio.as_completed(awaitables):  # as_completed sends the messages\n            msg = await sending_msg\n            coro = bot.pin_chat_message(super_group_id, msg.message_id, True, read_timeout=10)\n            pinned_messages_tasks.add(asyncio.create_task(coro))  # start pinning the message\n            messages.append(msg)\n\n        assert len(messages) == 3  # Check if we sent 3 messages\n\n        # Check if we pinned 3 messages\n        assert all([await i for i in pinned_messages_tasks])\n        assert all(i.done() for i in pinned_messages_tasks)  # Check if all tasks are done\n\n        chat = await bot.get_chat(super_group_id)  # get the chat to check the pinned message\n        assert chat.pinned_message in messages\n\n        # Determine which message is not the most recently pinned\n        for old_pin_msg in messages:\n            if chat.pinned_message != old_pin_msg:\n                break\n\n        # Test unpinning our messages\n        tasks = asyncio.gather(\n            bot.unpin_chat_message(  # unpins any message except the most recent\n                chat_id=super_group_id,  # because we don't want to accidentally unpin the same msg\n                message_id=old_pin_msg.message_id,  # twice\n                read_timeout=10,\n            ),\n            bot.unpin_chat_message(chat_id=super_group_id, read_timeout=10),  # unpins most recent\n        )\n        assert all(await tasks)\n        assert all(i.done() for i in tasks)\n        assert await bot.unpin_all_chat_messages(super_group_id, read_timeout=10)\n\n    # get_sticker_set, upload_sticker_file, create_new_sticker_set, add_sticker_to_set,\n    # set_sticker_position_in_set, delete_sticker_from_set and get_custom_emoji_stickers,\n    # replace_sticker_in_set are tested in the test_sticker module.\n\n    # get_forum_topic_icon_stickers, edit_forum_topic, general_forum etc...\n    # are tested in the test_forum module.\n    async def test_send_message_disable_web_page_preview(self, bot, chat_id):\n        \"\"\"Test that disable_web_page_preview is substituted for link_preview_options and that\n        it still works as expected for backward compatability.\"\"\"\n        msg = await bot.send_message(\n            chat_id,\n            \"https://github.com/python-telegram-bot/python-telegram-bot\",\n            disable_web_page_preview=True,\n        )\n        assert msg.link_preview_options\n        assert msg.link_preview_options.is_disabled\n\n    async def test_send_message_link_preview_options(self, bot, chat_id):\n        \"\"\"Test whether link_preview_options is correctly passed to the API.\"\"\"\n        # btw it is possible to have no url in the text, but set a url for the preview.\n        msg = await bot.send_message(\n            chat_id,\n            \"https://github.com/python-telegram-bot/python-telegram-bot\",\n            link_preview_options=LinkPreviewOptions(prefer_small_media=True, show_above_text=True),\n        )\n        assert msg.link_preview_options\n        assert not msg.link_preview_options.is_disabled\n        # The prefer_* options aren't very consistent on the client side (big pic shown) +\n        # they are not returned by the API.\n        # assert msg.link_preview_options.prefer_small_media\n        assert msg.link_preview_options.show_above_text\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"link_preview_options\": LinkPreviewOptions(show_above_text=True)}],\n        indirect=True,\n    )\n    async def test_send_message_default_link_preview_options(self, default_bot, chat_id):\n        \"\"\"Test whether Defaults.link_preview_options is correctly fused with the passed LPO.\"\"\"\n        github_url = \"https://github.com/python-telegram-bot/python-telegram-bot\"\n        website = \"https://python-telegram-bot.org/\"\n\n        # First test just the default passing:\n        coro1 = default_bot.send_message(chat_id, github_url)\n        # Next test fusion of both LPOs:\n        coro2 = default_bot.send_message(\n            chat_id,\n            github_url,\n            link_preview_options=LinkPreviewOptions(url=website, prefer_large_media=True),\n        )\n        # Now test fusion + overriding of passed LPO:\n        coro3 = default_bot.send_message(\n            chat_id,\n            github_url,\n            link_preview_options=LinkPreviewOptions(show_above_text=False, url=website),\n        )\n        # finally test explicitly setting to None\n        coro4 = default_bot.send_message(chat_id, github_url, link_preview_options=None)\n\n        msgs = asyncio.gather(coro1, coro2, coro3, coro4)\n        msg1, msg2, msg3, msg4 = await msgs\n        assert msg1.link_preview_options\n        assert msg1.link_preview_options.show_above_text\n\n        assert msg2.link_preview_options\n        assert msg2.link_preview_options.show_above_text\n        assert msg2.link_preview_options.url == website\n        assert msg2.link_preview_options.prefer_large_media  # Now works correctly using new url..\n\n        assert msg3.link_preview_options\n        assert not msg3.link_preview_options.show_above_text\n        assert msg3.link_preview_options.url == website\n\n        assert msg4.link_preview_options == LinkPreviewOptions(url=github_url)\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"link_preview_options\": LinkPreviewOptions(show_above_text=True)}],\n        indirect=True,\n    )\n    async def test_edit_message_text_default_link_preview_options(self, default_bot, chat_id):\n        \"\"\"Test whether Defaults.link_preview_options is correctly fused with the passed LPO.\"\"\"\n        github_url = \"https://github.com/python-telegram-bot/python-telegram-bot\"\n        website = \"https://python-telegram-bot.org/\"\n        telegram_url = \"https://telegram.org\"\n        base_1, base_2, base_3, base_4 = await asyncio.gather(\n            *(default_bot.send_message(chat_id, telegram_url) for _ in range(4))\n        )\n\n        # First test just the default passing:\n        coro1 = base_1.edit_text(github_url)\n        # Next test fusion of both LPOs:\n        coro2 = base_2.edit_text(\n            github_url,\n            link_preview_options=LinkPreviewOptions(url=website, prefer_large_media=True),\n        )\n        # Now test fusion + overriding of passed LPO:\n        coro3 = base_3.edit_text(\n            github_url,\n            link_preview_options=LinkPreviewOptions(show_above_text=False, url=website),\n        )\n        # finally test explicitly setting to None\n        coro4 = base_4.edit_text(github_url, link_preview_options=None)\n\n        msgs = asyncio.gather(coro1, coro2, coro3, coro4)\n        msg1, msg2, msg3, msg4 = await msgs\n        assert msg1.link_preview_options\n        assert msg1.link_preview_options.show_above_text\n\n        assert msg2.link_preview_options\n        assert msg2.link_preview_options.show_above_text\n        assert msg2.link_preview_options.url == website\n        assert msg2.link_preview_options.prefer_large_media  # Now works correctly using new url..\n\n        assert msg3.link_preview_options\n        assert not msg3.link_preview_options.show_above_text\n        assert msg3.link_preview_options.url == website\n\n        assert msg4.link_preview_options == LinkPreviewOptions(url=github_url)\n\n    async def test_send_message_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code Spoiler\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n            MessageEntity(MessageEntity.SPOILER, 17, 7),\n        ]\n        message = await bot.send_message(chat_id=chat_id, text=test_string, entities=entities)\n        assert message.text == test_string\n        assert message.entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_send_message_default_parse_mode(self, default_bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_message(chat_id, test_markdown_string, **i)\n                for i in ({}, {\"parse_mode\": None}, {\"parse_mode\": \"HTML\"})\n            )\n        )\n        msg1, msg2, msg3 = await tasks\n        assert msg1.text_markdown == test_markdown_string\n        assert msg1.text == test_string\n\n        assert msg2.text == test_markdown_string\n        assert msg2.text_markdown == escape_markdown(test_markdown_string)\n\n        assert msg3.text == test_markdown_string\n        assert msg3.text_markdown == escape_markdown(test_markdown_string)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_message_default_protect_content(self, default_bot, chat_id):\n        tasks = asyncio.gather(\n            default_bot.send_message(chat_id, \"test\"),\n            default_bot.send_message(chat_id, \"test\", protect_content=False),\n        )\n        to_check, no_protect = await tasks\n        assert to_check.has_protected_content\n        assert not no_protect.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_message_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_message(\n                chat_id,\n                \"test\",\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_message(\n                chat_id, \"test\", reply_to_message_id=reply_to_message.message_id\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_message(\n                    chat_id, \"test\", reply_to_message_id=reply_to_message.message_id\n                )\n\n    async def test_get_set_my_default_administrator_rights(self, bot):\n        # Test that my default administrator rights for group are as all False\n        assert await bot.set_my_default_administrator_rights()  # clear any set rights\n        my_admin_rights_grp = await bot.get_my_default_administrator_rights()\n        assert isinstance(my_admin_rights_grp, ChatAdministratorRights)\n        assert all(not getattr(my_admin_rights_grp, at) for at in my_admin_rights_grp.__slots__)\n\n        # Test setting my default admin rights for channel\n        my_rights = ChatAdministratorRights.all_rights()\n        assert await bot.set_my_default_administrator_rights(my_rights, for_channels=True)\n        my_admin_rights_ch = await bot.get_my_default_administrator_rights(for_channels=True)\n        assert my_admin_rights_ch.can_invite_users is my_rights.can_invite_users\n        # tg bug? is_anonymous is False despite setting it True for channels:\n        assert my_admin_rights_ch.is_anonymous is not my_rights.is_anonymous\n\n        assert my_admin_rights_ch.can_manage_chat is my_rights.can_manage_chat\n        assert my_admin_rights_ch.can_delete_messages is my_rights.can_delete_messages\n        assert my_admin_rights_ch.can_edit_messages is my_rights.can_edit_messages\n        assert my_admin_rights_ch.can_post_messages is my_rights.can_post_messages\n        assert my_admin_rights_ch.can_change_info is my_rights.can_change_info\n        assert my_admin_rights_ch.can_promote_members is my_rights.can_promote_members\n        assert my_admin_rights_ch.can_restrict_members is my_rights.can_restrict_members\n        assert my_admin_rights_ch.can_pin_messages is None  # Not returned for channels\n        assert my_admin_rights_ch.can_manage_topics is None  # Not returned for channels\n\n    async def test_get_set_chat_menu_button(self, bot, chat_id):\n        # Test our chat menu button is commands-\n        menu_button = await bot.get_chat_menu_button()\n        assert isinstance(menu_button, MenuButton)\n        assert isinstance(menu_button, MenuButtonCommands)\n        assert menu_button.type == MenuButtonType.COMMANDS\n\n        # Test setting our chat menu button to Webapp.\n        my_menu = MenuButtonWebApp(\"click me!\", WebAppInfo(\"https://telegram.org/\"))\n        assert await bot.set_chat_menu_button(chat_id=chat_id, menu_button=my_menu)\n        menu_button = await bot.get_chat_menu_button(chat_id)\n        assert isinstance(menu_button, MenuButtonWebApp)\n        assert menu_button.type == MenuButtonType.WEB_APP\n        assert menu_button.text == my_menu.text\n        assert menu_button.web_app.url == my_menu.web_app.url\n\n        assert await bot.set_chat_menu_button(chat_id=chat_id, menu_button=MenuButtonDefault())\n        menu_button = await bot.get_chat_menu_button(chat_id=chat_id)\n        assert isinstance(menu_button, MenuButtonDefault)\n\n    async def test_set_and_get_my_commands(self, bot):\n        commands = [BotCommand(\"cmd1\", \"descr1\"), [\"cmd2\", \"descr2\"]]\n        assert await bot.set_my_commands([])\n        assert await bot.get_my_commands() == ()\n        assert await bot.set_my_commands(commands)\n\n        for i, bc in enumerate(await bot.get_my_commands()):\n            assert bc.command == f\"cmd{i + 1}\"\n            assert bc.description == f\"descr{i + 1}\"\n\n    async def test_get_set_delete_my_commands_with_scope(self, bot, super_group_id, chat_id):\n        group_cmds = [BotCommand(\"group_cmd\", \"visible to this supergroup only\")]\n        private_cmds = [BotCommand(\"private_cmd\", \"visible to this private chat only\")]\n        group_scope = BotCommandScopeChat(super_group_id)\n        private_scope = BotCommandScopeChat(chat_id)\n\n        # Set supergroup command list with lang code and check if the same can be returned from api\n        assert await bot.set_my_commands(group_cmds, scope=group_scope, language_code=\"en\")\n        gotten_group_cmds = await bot.get_my_commands(scope=group_scope, language_code=\"en\")\n\n        assert len(gotten_group_cmds) == len(group_cmds)\n        assert gotten_group_cmds[0].command == group_cmds[0].command\n\n        # Set private command list and check if same can be returned from the api\n        assert await bot.set_my_commands(private_cmds, scope=private_scope)\n        gotten_private_cmd = await bot.get_my_commands(scope=private_scope)\n\n        assert len(gotten_private_cmd) == len(private_cmds)\n        assert gotten_private_cmd[0].command == private_cmds[0].command\n\n        # Delete command list from that supergroup and private chat-\n        tasks = asyncio.gather(\n            bot.delete_my_commands(private_scope),\n            bot.delete_my_commands(group_scope, \"en\"),\n        )\n        assert all(await tasks)\n\n        # Check if its been deleted-\n        tasks = asyncio.gather(\n            bot.get_my_commands(private_scope),\n            bot.get_my_commands(group_scope, \"en\"),\n        )\n        deleted_priv_cmds, deleted_grp_cmds = await tasks\n\n        assert len(deleted_grp_cmds) == 0 == len(group_cmds) - 1\n        assert len(deleted_priv_cmds) == 0 == len(private_cmds) - 1\n\n        await bot.delete_my_commands()  # Delete commands from default scope\n        assert len(await bot.get_my_commands()) == 0\n\n    async def test_copy_message_without_reply(self, bot, chat_id, media_message):\n        keyboard = InlineKeyboardMarkup(\n            [[InlineKeyboardButton(text=\"test\", callback_data=\"test2\")]]\n        )\n\n        returned = await bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=\"<b>Test</b>\",\n            parse_mode=ParseMode.HTML,\n            reply_to_message_id=media_message.message_id,\n            reply_markup=keyboard,\n            show_caption_above_media=False,\n        )\n        # we send a temp message which replies to the returned message id in order to get a\n        # message object\n        temp_message = await bot.send_message(\n            chat_id, \"test\", reply_to_message_id=returned.message_id\n        )\n        message = temp_message.reply_to_message\n        assert message.chat_id == int(chat_id)\n        assert message.caption == \"Test\"\n        assert len(message.caption_entities) == 1\n        assert message.reply_markup == keyboard\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [\n            ({\"parse_mode\": ParseMode.HTML, \"allow_sending_without_reply\": True}),\n            ({\"parse_mode\": None, \"allow_sending_without_reply\": True}),\n            ({\"parse_mode\": None, \"allow_sending_without_reply\": False}),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_copy_message_with_default(self, default_bot, chat_id, media_message):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if not default_bot.defaults.allow_sending_without_reply:\n            with pytest.raises(BadRequest, match=\"not found\"):\n                await default_bot.copy_message(\n                    chat_id,\n                    from_chat_id=chat_id,\n                    message_id=media_message.message_id,\n                    caption=\"<b>Test</b>\",\n                    reply_to_message_id=reply_to_message.message_id,\n                )\n            return\n        returned = await default_bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=\"<b>Test</b>\",\n            reply_to_message_id=reply_to_message.message_id,\n        )\n        # we send a temp message which replies to the returned message id in order to get a\n        # message object\n        temp_message = await default_bot.send_message(\n            chat_id, \"test\", reply_to_message_id=returned.message_id\n        )\n        message = temp_message.reply_to_message\n        if default_bot.defaults.parse_mode:\n            assert len(message.caption_entities) == 1\n        else:\n            assert len(message.caption_entities) == 0\n\n    async def test_copy_messages(self, bot, chat_id):\n        # not using gather here to have deterministically ordered message_ids\n        msg1 = await bot.send_message(chat_id, text=\"will be copied 1\")\n        msg2 = await bot.send_message(chat_id, text=\"will be copied 2\")\n\n        copy_messages = await bot.copy_messages(\n            chat_id, from_chat_id=chat_id, message_ids=(msg1.message_id, msg2.message_id)\n        )\n        assert isinstance(copy_messages, tuple)\n\n        tasks = asyncio.gather(\n            bot.send_message(chat_id, \"temp 1\", reply_to_message_id=copy_messages[0].message_id),\n            bot.send_message(chat_id, \"temp 2\", reply_to_message_id=copy_messages[1].message_id),\n        )\n        temp_msg1, temp_msg2 = await tasks\n\n        forward_msg1 = temp_msg1.reply_to_message\n        forward_msg2 = temp_msg2.reply_to_message\n\n        assert forward_msg1.text == msg1.text\n        assert forward_msg2.text == msg2.text\n\n    # Continue testing arbitrary callback data here with actual requests:\n    async def test_replace_callback_data_send_message(self, cdc_bot, chat_id):\n        bot = cdc_bot\n\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            message = await bot.send_message(\n                chat_id=chat_id, text=\"test\", reply_markup=reply_markup\n            )\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_replace_callback_data_stop_poll_and_repl_to_message(self, cdc_bot, chat_id):\n        bot = cdc_bot\n\n        poll_message = await bot.send_poll(chat_id=chat_id, question=\"test\", options=[\"1\", \"2\"])\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            await poll_message.stop_poll(reply_markup=reply_markup)\n            helper_message = await poll_message.reply_text(\"temp\", do_quote=True)\n            message = helper_message.reply_to_message\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_replace_callback_data_copy_message(self, cdc_bot, chat_id):\n        \"\"\"This also tests that data is inserted into the buttons of message.reply_to_message\n        where message is the return value of a bot method\"\"\"\n        bot = cdc_bot\n\n        original_message = await bot.send_message(chat_id=chat_id, text=\"original\")\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            message_id = await original_message.copy(chat_id=chat_id, reply_markup=reply_markup)\n            helper_message = await bot.send_message(\n                chat_id=chat_id, reply_to_message_id=message_id.message_id, text=\"temp\"\n            )\n            message = helper_message.reply_to_message\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_get_chat_arbitrary_callback_data(self, chat_id, cdc_bot):\n        bot = cdc_bot\n\n        try:\n            reply_markup = InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"callback_data\")\n            )\n\n            message = await bot.send_message(\n                chat_id, text=\"get_chat_arbitrary_callback_data\", reply_markup=reply_markup\n            )\n            await message.pin()\n\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"callback_data\"\n\n            cfi = await bot.get_chat(chat_id)\n\n            if not cfi.pinned_message:\n                pytest.xfail(\"Pinning messages is not always reliable on TG\")\n\n            assert cfi.pinned_message == message\n            assert cfi.pinned_message.reply_markup == reply_markup\n            assert await message.unpin()  # (not placed in finally block since msg can be unbound)\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_arbitrary_callback_data_get_chat_no_pinned_message(\n        self, super_group_id, cdc_bot\n    ):\n        bot = cdc_bot\n        await bot.unpin_all_chat_messages(super_group_id)\n\n        try:\n            cfi = await bot.get_chat(super_group_id)\n\n            assert isinstance(cfi, ChatFullInfo)\n            assert int(cfi.id) == int(super_group_id)\n            assert cfi.pinned_message is None\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_set_get_my_description(self, bot):\n        default_description = f\"{bot.username} - default - {dtm.datetime.utcnow().isoformat()}\"\n        en_description = f\"{bot.username} - en - {dtm.datetime.utcnow().isoformat()}\"\n        de_description = f\"{bot.username} - de - {dtm.datetime.utcnow().isoformat()}\"\n\n        # Set the descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_description(default_description),\n                bot.set_my_description(en_description, language_code=\"en\"),\n                bot.set_my_description(de_description, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            bot.get_my_description(), bot.get_my_description(\"en\"), bot.get_my_description(\"de\")\n        ) == [\n            BotDescription(default_description),\n            BotDescription(en_description),\n            BotDescription(de_description),\n        ]\n\n        # Delete the descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_description(None),\n                bot.set_my_description(None, language_code=\"en\"),\n                bot.set_my_description(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            bot.get_my_description(), bot.get_my_description(\"en\"), bot.get_my_description(\"de\")\n        ) == 3 * [BotDescription(\"\")]\n\n    async def test_set_get_my_short_description(self, bot):\n        default_short_description = (\n            f\"{bot.username} - default - {dtm.datetime.utcnow().isoformat()}\"\n        )\n        en_short_description = f\"{bot.username} - en - {dtm.datetime.utcnow().isoformat()}\"\n        de_short_description = f\"{bot.username} - de - {dtm.datetime.utcnow().isoformat()}\"\n\n        # Set the short_descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_short_description(default_short_description),\n                bot.set_my_short_description(en_short_description, language_code=\"en\"),\n                bot.set_my_short_description(de_short_description, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            bot.get_my_short_description(),\n            bot.get_my_short_description(\"en\"),\n            bot.get_my_short_description(\"de\"),\n        ) == [\n            BotShortDescription(default_short_description),\n            BotShortDescription(en_short_description),\n            BotShortDescription(de_short_description),\n        ]\n\n        # Delete the short_descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_short_description(None),\n                bot.set_my_short_description(None, language_code=\"en\"),\n                bot.set_my_short_description(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            bot.get_my_short_description(),\n            bot.get_my_short_description(\"en\"),\n            bot.get_my_short_description(\"de\"),\n        ) == 3 * [BotShortDescription(\"\")]\n\n    async def test_set_message_reaction(self, bot, chat_id, static_message):\n        assert await bot.set_message_reaction(\n            chat_id, static_message.message_id, ReactionEmoji.THUMBS_DOWN, True\n        )\n\n    @pytest.mark.parametrize(\"bot_class\", [Bot, ExtBot])\n    async def test_do_api_request_warning_known_method(self, bot, bot_class):\n        with pytest.warns(PTBUserWarning, match=\"Please use 'Bot.get_me'\") as record:\n            await bot_class(bot.token).do_api_request(\"get_me\")\n\n        assert record[0].filename == __file__, \"Wrong stack level!\"\n\n    async def test_do_api_request_unknown_method(self, bot):\n        with pytest.raises(EndPointNotFound, match=\"'unknownEndpoint' not found\"):\n            await bot.do_api_request(\"unknown_endpoint\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    async def test_do_api_request_invalid_token(self, bot):\n        # we do not initialize the bot here on purpose b/c that's the case were we actually\n        # do not know for sure if the token is invalid or the method was not found\n        with pytest.raises(\n            InvalidToken, match=\"token was rejected by Telegram or the endpoint 'getMe'\"\n        ):\n            await Bot(\"invalid_token\").do_api_request(\"get_me\")\n\n        # same test, but with a valid token bot and unknown endpoint\n        with pytest.raises(\n            InvalidToken, match=\"token was rejected by Telegram or the endpoint 'unknownEndpoint'\"\n        ):\n            await Bot(bot.token).do_api_request(\"unknown_endpoint\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_basic_and_files(self, bot, chat_id, return_type):\n        result = await bot.do_api_request(\n            \"send_document\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"caption\": \"test_caption\",\n                \"document\": InputFile(data_file(\"telegram.png\").open(\"rb\")),\n            },\n            return_type=return_type,\n        )\n        if return_type is None:\n            assert isinstance(result, dict)\n            result = Message.de_json(result, bot)\n\n        assert isinstance(result, Message)\n        assert result.chat_id == int(chat_id)\n        assert result.caption == \"test_caption\"\n        out = BytesIO()\n        await (await result.document.get_file()).download_to_memory(out)\n        out.seek(0)\n        assert out.read() == data_file(\"telegram.png\").open(\"rb\").read()\n        assert result.document.file_name == \"telegram.png\"\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_list_return_type(self, bot, chat_id, return_type):\n        result = await bot.do_api_request(\n            \"send_media_group\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"media\": [\n                    InputMediaDocument(\n                        InputFile(\n                            data_file(\"text_file.txt\").open(\"rb\"),\n                            attach=True,\n                        )\n                    ),\n                    InputMediaDocument(\n                        InputFile(\n                            data_file(\"local_file.txt\").open(\"rb\"),\n                            attach=True,\n                        )\n                    ),\n                ],\n            },\n            return_type=return_type,\n        )\n        if return_type is None:\n            assert isinstance(result, list)\n            for entry in result:\n                assert isinstance(entry, dict)\n            result = Message.de_list(result, bot)\n\n        for message, file_name in zip(result, (\"text_file.txt\", \"local_file.txt\")):\n            assert isinstance(message, Message)\n            assert message.chat_id == int(chat_id)\n            out = BytesIO()\n            await (await message.document.get_file()).download_to_memory(out)\n            out.seek(0)\n            assert out.read() == data_file(file_name).open(\"rb\").read()\n            assert message.document.file_name == file_name\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_bool_return_type(self, bot, chat_id, return_type):\n        assert await bot.do_api_request(\"delete_my_commands\", return_type=return_type) is True\n\n    async def test_get_star_transactions(self, bot):\n        transactions = await bot.get_star_transactions(limit=1)\n        assert isinstance(transactions, StarTransactions)\n        assert len(transactions.transactions) == 0\n\n    @pytest.mark.parametrize(\"subscription_period\", [2592000, dtm.timedelta(days=30)])\n    async def test_create_edit_chat_subscription_link(\n        self, bot, subscription_channel_id, channel_id, subscription_period\n    ):\n        sub_link = await bot.create_chat_subscription_invite_link(\n            subscription_channel_id,\n            name=\"sub_name\",\n            subscription_period=subscription_period,\n            subscription_price=13,\n        )\n        assert sub_link.name == \"sub_name\"\n        assert sub_link.subscription_period == 2592000\n        assert sub_link.subscription_price == 13\n\n        edited_link = await bot.edit_chat_subscription_invite_link(\n            chat_id=subscription_channel_id, invite_link=sub_link, name=\"sub_name_2\"\n        )\n        assert edited_link.name == \"sub_name_2\"\n        assert sub_link.subscription_period == 2592000\n        assert sub_link.subscription_price == 13\n\n    async def test_get_my_star_balance(self, bot):\n        balance = await bot.get_my_star_balance()\n        assert isinstance(balance, StarAmount)\n        assert balance.amount == 0"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            3201,
                            3216
                        ],
                        "reason": "The test 'test_edit_message_text_default_parse_mode' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct parse mode and text, and if they do not match, it could lead to assertion errors. This is critical for handling default parse modes. Additionally, the test 'test_edit_message_caption_default_parse_mode' could also be affected by similar issues, as it involves editing captions with specific parse modes.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_edit_message_text_entities(self, bot, one_time_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_text(\n            text=test_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            entities=entities,\n        )\n\n        assert message.text == test_string\n        assert message.entities == tuple(entities)"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            3325,
                            3333
                        ],
                        "reason": "The test 'test_edit_message_caption_with_parse_mode' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct caption and parse mode, and if they do not match, it could lead to assertion errors. This is critical for editing message captions with specific parse modes.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_edit_message_caption_with_parse_mode(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new *caption*\",\n            parse_mode=\"Markdown\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n\n        assert message.caption == \"new caption\""
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            3339,
                            3347
                        ],
                        "reason": "The test 'test_edit_reply_markup' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct reply markup, and if it does not match, it could lead to assertion errors. This is critical for editing reply markups in messages.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_edit_reply_markup(self, bot, one_time_message):\n        new_markup = InlineKeyboardMarkup([[InlineKeyboardButton(text=\"test\", callback_data=\"1\")]])\n        message = await bot.edit_message_reply_markup(\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            reply_markup=new_markup,\n        )\n\n        assert message is not True"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            3355,
                            3361
                        ],
                        "reason": "The test 'test_get_updates' may fail if the bot does not handle the updates correctly or if the timeout is not managed properly, leading to assertion errors. This is critical for ensuring that the bot can retrieve updates as expected.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_get_updates(self, bot, timeout):\n        await bot.delete_webhook()  # make sure there is no webhook set if webhook tests failed\n        updates = await bot.get_updates(timeout=timeout)\n\n        assert isinstance(updates, tuple)\n        if updates:\n            assert isinstance(updates[0], Update)"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            3377,
                            3391
                        ],
                        "reason": "The test 'test_get_updates_read_timeout_value_passing' may fail if the read timeout values are not passed correctly or if the bot does not handle the timeouts as expected, leading to assertion errors. This is critical for ensuring that the bot can manage read timeouts effectively.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_get_updates_read_timeout_value_passing(\n        self, bot, read_timeout, timeout, expected, monkeypatch\n    ):\n        caught_read_timeout = None\n\n        async def catch_timeouts(*args, **kwargs):\n            nonlocal caught_read_timeout\n            caught_read_timeout = kwargs.get(\"read_timeout\")\n            return HTTPStatus.OK, b'{\"ok\": \"True\", \"result\": {}}'\n\n        monkeypatch.setattr(HTTPXRequest, \"do_request\", catch_timeouts)\n\n        bot = Bot(get_updates_request=HTTPXRequest(read_timeout=10), token=bot.token)\n        await bot.get_updates(read_timeout=read_timeout, timeout=timeout)\n        assert caught_read_timeout == expected"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            3396,
                            3428
                        ],
                        "reason": "The test 'test_set_webhook_get_webhook_info_and_delete_webhook' may fail if the webhook parameters are not set correctly or if the bot does not handle the webhook setup and deletion as expected, leading to assertion errors. This is critical for ensuring that the bot can manage webhooks effectively.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_set_webhook_get_webhook_info_and_delete_webhook(self, bot, use_ip, file_input):\n        url = \"https://python-telegram-bot.org/test/webhook\"\n        # Get the ip address of the website - dynamically just in case it ever changes\n        ip = socket.gethostbyname(\"python-telegram-bot.org\")\n        max_connections = 7\n        allowed_updates = [\"message\"]\n        file_input = (\n            data_file(\"sslcert.pem\").read_bytes()\n            if file_input == \"bytes\"\n            else data_file(\"sslcert.pem\").open(\"rb\")\n        )\n        await bot.set_webhook(\n            url,\n            max_connections=max_connections,\n            allowed_updates=allowed_updates,\n            ip_address=ip if use_ip else None,\n            certificate=file_input if use_ip else None,\n        )\n\n        await asyncio.sleep(1)\n        live_info = await bot.get_webhook_info()\n        assert live_info.url == url\n        assert live_info.max_connections == max_connections\n        assert live_info.allowed_updates == tuple(allowed_updates)\n        assert live_info.ip_address == ip\n        assert live_info.has_custom_certificate == use_ip\n\n        await bot.delete_webhook()\n        await asyncio.sleep(1)\n        info = await bot.get_webhook_info()\n        assert not info.url\n        assert info.ip_address is None\n        assert info.has_custom_certificate is False"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            3430,
                            3432
                        ],
                        "reason": "The test 'test_get_chat' may fail if the chat ID is not valid or if the bot does not handle the chat retrieval correctly, leading to assertion errors. This is critical for ensuring that the bot can retrieve chat information as expected.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_leave_chat(self, bot):\n        with pytest.raises(BadRequest, match=\"Chat not found\"):\n            await bot.leave_chat(-123456)"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            3440,
                            3445
                        ],
                        "reason": "The test 'test_get_chat_administrators' may fail if the channel ID is not valid or if the bot does not handle the retrieval of chat administrators correctly, leading to assertion errors. This is critical for ensuring that the bot can retrieve chat administrator information as expected.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_get_chat_administrators(self, bot, channel_id):\n        admins = await bot.get_chat_administrators(channel_id)\n        assert isinstance(admins, tuple)\n\n        for a in admins:\n            assert a.status in (\"administrator\", \"creator\")"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            3447,
                            3450
                        ],
                        "reason": "The test 'test_get_chat_member_count' may fail if the channel ID is not valid or if the bot does not handle the retrieval of chat member count correctly, leading to assertion errors. This is critical for ensuring that the bot can retrieve chat member counts as expected.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_get_chat_member_count(self, bot, channel_id):\n        count = await bot.get_chat_member_count(channel_id)\n        assert isinstance(count, int)\n        assert count > 3"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            3452,
                            3457
                        ],
                        "reason": "The test 'test_get_chat_member' may fail if the channel ID or chat ID is not valid or if the bot does not handle the retrieval of chat member information correctly, leading to assertion errors. This is critical for ensuring that the bot can retrieve chat member information as expected.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    async def test_get_chat_member(self, bot, channel_id, chat_id):\n        chat_member = await bot.get_chat_member(channel_id, chat_id)\n\n        assert chat_member.status == \"creator\"\n        assert chat_member.user.first_name == \"PTB\"\n        assert chat_member.user.last_name == \"Test user\""
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2663,
                            4635
                        ],
                        "reason": "Multiple tests failed due to timeout errors, with the message 'Ignoring TimedOut error: Timed out' appearing frequently. This indicates that the tests are not completing within the expected time frame, which could be due to network issues, inefficient code, or other blocking operations. The specific tests 'test_send_edit_message_mutually_exclusive_link_preview' and 'test_rtm_aswr_mutually_exclusive_reply_parameters' are highlighted in the CI logs as failing due to this timeout. Additionally, the test 'test_send_contact_default_protect_content' failed due to flood control being exceeded, with a retry delay of 38679 seconds. This indicates that the bot is attempting to send messages too frequently, violating Telegram's flood control limits, which could lead to further test failures.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "class",
                        "code_snippet": "class TestBotWithRequest:\n    \"\"\"\n    Most are executed on tg.ext.ExtBot, as that class only extends the functionality of tg.bot\n\n    Behavior for init of ExtBot with missing optional dependency cachetools (for CallbackDataCache)\n    is tested in `test_callbackdatacache`\n    \"\"\"\n\n    # get_available_gifts, send_gift are tested in `test_gift`.\n    # No need to duplicate here.\n\n    async def test_invalid_token_server_response(self):\n        with pytest.raises(InvalidToken, match=\"The token `12` was rejected by the server\\\\.\"):\n            async with ExtBot(token=\"12\"):\n                pass\n\n    async def test_multiple_init_cycles(self, bot):\n        # nothing really to assert - this should just not fail\n        test_bot = Bot(bot.token)\n        async with test_bot:\n            await test_bot.get_me()\n        async with test_bot:\n            await test_bot.get_me()\n\n    async def test_forward_message(self, bot, chat_id, static_message):\n        forward_message = await bot.forward_message(\n            chat_id, from_chat_id=chat_id, message_id=static_message.message_id\n        )\n\n        assert forward_message.text == static_message.text\n        assert forward_message.forward_origin.sender_user == static_message.from_user\n        assert isinstance(forward_message.forward_origin.date, dtm.datetime)\n\n    async def test_forward_protected_message(self, bot, chat_id):\n        tasks = asyncio.gather(\n            bot.send_message(chat_id, \"cant forward me\", protect_content=True),\n            bot.send_message(chat_id, \"forward me\", protect_content=False),\n        )\n        to_forward_protected, to_forward_unprotected = await tasks\n\n        assert to_forward_protected.has_protected_content\n        assert not to_forward_unprotected.has_protected_content\n\n        forwarded_but_now_protected = await to_forward_unprotected.forward(\n            chat_id, protect_content=True\n        )\n        assert forwarded_but_now_protected.has_protected_content\n\n        tasks = asyncio.gather(\n            to_forward_protected.forward(chat_id),\n            forwarded_but_now_protected.forward(chat_id),\n            return_exceptions=True,\n        )\n        result = await tasks\n        assert all(\"can't be forwarded\" in str(exc) for exc in result)\n\n    async def test_forward_messages(self, bot, chat_id):\n        # not using gather here to have deteriminically ordered message_ids\n        msg1 = await bot.send_message(chat_id, text=\"will be forwarded\")\n        msg2 = await bot.send_message(chat_id, text=\"will be forwarded\")\n\n        forward_messages = await bot.forward_messages(\n            chat_id, from_chat_id=chat_id, message_ids=(msg1.message_id, msg2.message_id)\n        )\n\n        assert isinstance(forward_messages, tuple)\n\n        tasks = asyncio.gather(\n            bot.send_message(\n                chat_id, \"temp 1\", reply_to_message_id=forward_messages[0].message_id\n            ),\n            bot.send_message(\n                chat_id, \"temp 2\", reply_to_message_id=forward_messages[1].message_id\n            ),\n        )\n\n        temp_msg1, temp_msg2 = await tasks\n        forward_msg1 = temp_msg1.reply_to_message\n        forward_msg2 = temp_msg2.reply_to_message\n\n        assert forward_msg1.text == msg1.text\n        assert forward_msg1.forward_origin.sender_user == msg1.from_user\n        assert isinstance(forward_msg1.forward_origin.date, dtm.datetime)\n\n        assert forward_msg2.text == msg2.text\n        assert forward_msg2.forward_origin.sender_user == msg2.from_user\n        assert isinstance(forward_msg2.forward_origin.date, dtm.datetime)\n\n    async def test_delete_message(self, bot, chat_id):\n        message = await bot.send_message(chat_id, text=\"will be deleted\")\n        assert await bot.delete_message(chat_id=chat_id, message_id=message.message_id) is True\n\n    async def test_delete_message_old_message(self, bot, chat_id):\n        with pytest.raises(BadRequest):\n            # Considering that the first message is old enough\n            await bot.delete_message(chat_id=chat_id, message_id=1)\n\n    # send_photo, send_audio, send_document, send_sticker, send_video, send_voice, send_video_note,\n    # send_media_group, send_animation, get_user_chat_boosts are tested in their respective\n    # test modules. No need to duplicate here.\n\n    async def test_delete_messages(self, bot, chat_id):\n        msg1, msg2 = await asyncio.gather(\n            bot.send_message(chat_id, text=\"will be deleted\"),\n            bot.send_message(chat_id, text=\"will be deleted\"),\n        )\n\n        assert (\n            await bot.delete_messages(chat_id=chat_id, message_ids=sorted((msg1.id, msg2.id)))\n            is True\n        )\n\n    async def test_send_venue(self, bot, chat_id):\n        longitude = -46.788279\n        latitude = -23.691288\n        title = \"title\"\n        address = \"address\"\n        foursquare_id = \"foursquare id\"\n        foursquare_type = \"foursquare type\"\n        google_place_id = \"google_place id\"\n        google_place_type = \"google_place type\"\n\n        tasks = asyncio.gather(\n            *(\n                bot.send_venue(\n                    chat_id=chat_id,\n                    title=title,\n                    address=address,\n                    latitude=latitude,\n                    longitude=longitude,\n                    protect_content=True,\n                    **i,\n                )\n                for i in (\n                    {\"foursquare_id\": foursquare_id, \"foursquare_type\": foursquare_type},\n                    {\"google_place_id\": google_place_id, \"google_place_type\": google_place_type},\n                )\n            ),\n        )\n\n        message, message2 = await tasks\n        assert message.venue\n        assert message.venue.title == title\n        assert message.venue.address == address\n        assert message.venue.location.latitude == latitude\n        assert message.venue.location.longitude == longitude\n        assert message.venue.foursquare_id == foursquare_id\n        assert message.venue.foursquare_type == foursquare_type\n        assert message.venue.google_place_id is None\n        assert message.venue.google_place_type is None\n        assert message.has_protected_content\n\n        assert message2.venue\n        assert message2.venue.title == title\n        assert message2.venue.address == address\n        assert message2.venue.location.latitude == latitude\n        assert message2.venue.location.longitude == longitude\n        assert message2.venue.google_place_id == google_place_id\n        assert message2.venue.google_place_type == google_place_type\n        assert message2.venue.foursquare_id is None\n        assert message2.venue.foursquare_type is None\n        assert message2.has_protected_content\n\n    async def test_send_contact(self, bot, chat_id):\n        phone_number = \"+11234567890\"\n        first_name = \"Leandro\"\n        last_name = \"Toledo\"\n        message = await bot.send_contact(\n            chat_id=chat_id,\n            phone_number=phone_number,\n            first_name=first_name,\n            last_name=last_name,\n            protect_content=True,\n        )\n\n        assert message.contact\n        assert message.contact.phone_number == phone_number\n        assert message.contact.first_name == first_name\n        assert message.contact.last_name == last_name\n        assert message.has_protected_content\n\n    # TODO: Add bot to group to test polls too\n    @pytest.mark.parametrize(\n        \"reply_markup\",\n        [\n            None,\n            InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n            ),\n            InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n            ).to_dict(),\n        ],\n    )\n    async def test_send_and_stop_poll(self, bot, super_group_id, reply_markup):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", InputPollOption(\"No\"), \"Maybe\"]\n        explanation = \"[Here is a link](https://google.com)\"\n        explanation_entities = [\n            MessageEntity(MessageEntity.TEXT_LINK, 0, 14, url=\"https://google.com\")\n        ]\n\n        poll_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                is_anonymous=False,\n                allows_multiple_answers=True,\n                read_timeout=60,\n                protect_content=True,\n            )\n        )\n        quiz_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                type=Poll.QUIZ,\n                correct_option_id=2,\n                is_closed=True,\n                explanation=explanation,\n                explanation_parse_mode=ParseMode.MARKDOWN_V2,\n            )\n        )\n\n        message = await poll_task\n        assert message.poll\n        assert message.poll.question == question\n        assert message.poll.options[0].text == answers[0]\n        assert message.poll.options[1].text == answers[1].text\n        assert message.poll.options[2].text == answers[2]\n        assert not message.poll.is_anonymous\n        assert message.poll.allows_multiple_answers\n        assert not message.poll.is_closed\n        assert message.poll.type == Poll.REGULAR\n        assert message.has_protected_content\n\n        # Since only the poll and not the complete message is returned, we can't check that the\n        # reply_markup is correct. So we just test that sending doesn't give an error.\n        poll = await bot.stop_poll(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert isinstance(poll, Poll)\n        assert poll.is_closed\n        assert poll.options[0].text == answers[0]\n        assert poll.options[0].voter_count == 0\n        assert poll.options[1].text == answers[1].text\n        assert poll.options[1].voter_count == 0\n        assert poll.options[2].text == answers[2]\n        assert poll.options[2].voter_count == 0\n        assert poll.question == question\n        assert poll.total_voter_count == 0\n\n        message_quiz = await quiz_task\n        assert message_quiz.poll.correct_option_id == 2\n        assert message_quiz.poll.type == Poll.QUIZ\n        assert message_quiz.poll.is_closed\n        assert message_quiz.poll.explanation == \"Here is a link\"\n        assert message_quiz.poll.explanation_entities == tuple(explanation_entities)\n        assert poll_task.done()\n        assert quiz_task.done()\n\n    @pytest.mark.parametrize(\n        (\"open_period\", \"close_date\"),\n        [(5, None), (dtm.timedelta(seconds=5), None), (None, True)],\n        ids=[\"open_period\", \"open_period-dtm\", \"close_date\"],\n    )\n    async def test_send_open_period(self, bot, super_group_id, open_period, close_date):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        if close_date:\n            close_date = dtm.datetime.utcnow() + dtm.timedelta(seconds=5.05)\n\n        message = await bot.send_poll(\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            is_anonymous=False,\n            allows_multiple_answers=True,\n            read_timeout=60,\n            open_period=open_period,\n            close_date=close_date,\n        )\n        await asyncio.sleep(5.1)\n        new_message = await bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == message.poll.id\n        assert new_message.poll.is_closed\n\n    async def test_send_close_date_default_tz(self, tz_bot, super_group_id):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        aware_close_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + dtm.timedelta(seconds=5)\n        close_date = aware_close_date.replace(tzinfo=None)\n\n        msg = await tz_bot.send_poll(  # The timezone returned from this is always converted to UTC\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            close_date=close_date,\n            read_timeout=60,\n        )\n        msg.poll._unfreeze()\n        # Sometimes there can be a few seconds delay, so don't let the test fail due to that-\n        msg.poll.close_date = msg.poll.close_date.astimezone(aware_close_date.tzinfo)\n        assert abs(msg.poll.close_date - aware_close_date) <= dtm.timedelta(seconds=5)\n\n        await asyncio.sleep(5.1)\n\n        new_message = await tz_bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=msg.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == msg.poll.id\n        assert new_message.poll.is_closed\n\n    async def test_send_poll_explanation_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.send_poll(\n            chat_id,\n            \"question\",\n            options=[\"a\", \"b\"],\n            correct_option_id=0,\n            type=Poll.QUIZ,\n            explanation=test_string,\n            explanation_entities=entities,\n        )\n\n        assert message.poll.explanation == test_string\n        assert message.poll.explanation_entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_send_poll_default_parse_mode(self, default_bot, super_group_id):\n        explanation = \"Italic Bold Code\"\n        explanation_markdown = \"_Italic_ *Bold* `Code`\"\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_poll(\n                    chat_id=super_group_id,\n                    question=question,\n                    options=answers,\n                    type=Poll.QUIZ,\n                    correct_option_id=2,\n                    is_closed=True,\n                    explanation=explanation_markdown,\n                    **i,\n                )\n                for i in ({}, {\"explanation_parse_mode\": None}, {\"explanation_parse_mode\": \"HTML\"})\n            ),\n        )\n        message1, message2, message3 = await tasks\n        assert message1.poll.explanation == explanation\n        assert message1.poll.explanation_entities == (\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.BOLD, 7, 4),\n            MessageEntity(MessageEntity.CODE, 12, 4),\n        )\n\n        assert message2.poll.explanation == explanation_markdown\n        assert message2.poll.explanation_entities == ()\n\n        assert message3.poll.explanation == explanation_markdown\n        assert message3.poll.explanation_entities == ()\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_poll_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_poll(\n                    chat_id,\n                    question=question,\n                    options=answers,\n                    reply_to_message_id=reply_to_message.message_id,\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_poll_default_protect_content(self, chat_id, default_bot):\n        tasks = asyncio.gather(\n            default_bot.send_poll(chat_id, \"Test\", [\"1\", \"2\"]),\n            default_bot.send_poll(chat_id, \"test\", [\"1\", \"2\"], protect_content=False),\n        )\n        protected_poll, unprotect_poll = await tasks\n        assert protected_poll.has_protected_content\n        assert not unprotect_poll.has_protected_content\n\n    @pytest.mark.parametrize(\"emoji\", [*Dice.ALL_EMOJI, None])\n    async def test_send_dice(self, bot, chat_id, emoji):\n        message = await bot.send_dice(chat_id, emoji=emoji, protect_content=True)\n\n        assert message.dice\n        assert message.has_protected_content\n        if emoji is None:\n            assert message.dice.emoji == Dice.DICE\n        else:\n            assert message.dice.emoji == emoji\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_dice_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_dice(\n                chat_id,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_dice(\n                chat_id,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_dice(\n                    chat_id, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_dice_default_protect_content(self, chat_id, default_bot):\n        tasks = asyncio.gather(\n            default_bot.send_dice(chat_id), default_bot.send_dice(chat_id, protect_content=False)\n        )\n        protected_dice, unprotected_dice = await tasks\n        assert protected_dice.has_protected_content\n        assert not unprotected_dice.has_protected_content\n\n    @pytest.mark.parametrize(\"chat_action\", list(ChatAction))\n    async def test_send_chat_action(self, bot, chat_id, chat_action):\n        assert await bot.send_chat_action(chat_id, chat_action)\n\n    async def test_wrong_chat_action(self, bot, chat_id):\n        with pytest.raises(BadRequest, match=\"Wrong parameter action\"):\n            await bot.send_chat_action(chat_id, \"unknown action\")\n\n    async def test_answer_inline_query_current_offset_error(self, bot, inline_results):\n        with pytest.raises(ValueError, match=\"`current_offset` and `next_offset`\"):\n            await bot.answer_inline_query(\n                1234, results=inline_results, next_offset=42, current_offset=51\n            )\n\n    async def test_save_prepared_inline_message(self, bot, chat_id):\n        # We can't really check that the result is stored correctly, we just ensur ethat we get\n        # a proper return value\n        result = InlineQueryResultArticle(\n            id=\"some_id\", title=\"title\", input_message_content=InputTextMessageContent(\"text\")\n        )\n        out = await bot.save_prepared_inline_message(chat_id, result, True, False, True, False)\n        assert isinstance(out, PreparedInlineMessage)\n\n    async def test_get_user_profile_photos(self, bot, chat_id):\n        user_profile_photos = await bot.get_user_profile_photos(chat_id)\n        assert user_profile_photos.photos[0][0].file_size == 5403\n\n    async def test_get_one_user_profile_photo(self, bot, chat_id):\n        user_profile_photos = await bot.get_user_profile_photos(chat_id, offset=0, limit=1)\n        assert user_profile_photos.total_count == 1\n        assert user_profile_photos.photos[0][0].file_size == 5403\n\n    async def test_edit_message_text(self, bot, one_time_message):\n        message = await bot.edit_message_text(\n            text=\"new_text\",\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            parse_mode=\"HTML\",\n            disable_web_page_preview=True,\n        )\n\n        assert message.text == \"new_text\"\n\n    async def test_edit_message_text_entities(self, bot, one_time_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_text(\n            text=test_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            entities=entities,\n        )\n\n        assert message.text == test_string\n        assert message.entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_edit_message_text_default_parse_mode(\n        self, default_bot, chat_id, one_time_message\n    ):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            disable_web_page_preview=True,\n        )\n        assert message.text_markdown == test_markdown_string\n        assert message.text == test_string\n\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string,\n            chat_id=message.chat_id,\n            message_id=message.message_id,\n            parse_mode=None,\n            disable_web_page_preview=True,\n        )\n        assert message.text == test_markdown_string\n        assert message.text_markdown == escape_markdown(test_markdown_string)\n\n        suffix = \" edited\"\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string + suffix,\n            chat_id=message.chat_id,\n            message_id=message.message_id,\n            parse_mode=\"HTML\",\n            disable_web_page_preview=True,\n        )\n        assert message.text == test_markdown_string + suffix\n        assert message.text_markdown == escape_markdown(test_markdown_string) + suffix\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_message_text_inline(self):\n        pass\n\n    async def test_edit_message_caption(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new_caption\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            show_caption_above_media=False,\n        )\n\n        assert message.caption == \"new_caption\"\n        assert not message.show_caption_above_media\n\n    async def test_edit_message_caption_entities(self, bot, media_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_caption(\n            caption=test_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            caption_entities=entities,\n        )\n\n        assert message.caption == test_string\n        assert message.caption_entities == tuple(entities)\n\n    # edit_message_media is tested in test_inputmedia\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_edit_message_caption_default_parse_mode(self, default_bot, media_message):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n        assert message.caption_markdown == test_markdown_string\n        assert message.caption == test_string\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            parse_mode=None,\n        )\n        assert message.caption == test_markdown_string\n        assert message.caption_markdown == escape_markdown(test_markdown_string)\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            parse_mode=\"HTML\",\n        )\n        assert message.caption == test_markdown_string\n        assert message.caption_markdown == escape_markdown(test_markdown_string)\n\n    async def test_edit_message_caption_with_parse_mode(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new *caption*\",\n            parse_mode=\"Markdown\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n\n        assert message.caption == \"new caption\"\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_message_caption_inline(self):\n        pass\n\n    async def test_edit_reply_markup(self, bot, one_time_message):\n        new_markup = InlineKeyboardMarkup([[InlineKeyboardButton(text=\"test\", callback_data=\"1\")]])\n        message = await bot.edit_message_reply_markup(\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            reply_markup=new_markup,\n        )\n\n        assert message is not True\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_reply_markup_inline(self):\n        pass\n\n    # TODO: Actually send updates to the test bot so this can be tested properly\n    @pytest.mark.parametrize(\"timeout\", [1, dtm.timedelta(seconds=1)])\n    async def test_get_updates(self, bot, timeout):\n        await bot.delete_webhook()  # make sure there is no webhook set if webhook tests failed\n        updates = await bot.get_updates(timeout=timeout)\n\n        assert isinstance(updates, tuple)\n        if updates:\n            assert isinstance(updates[0], Update)\n\n    @pytest.mark.parametrize(\n        (\"read_timeout\", \"timeout\", \"expected\"),\n        [\n            (None, None, 0),\n            (1, None, 1),\n            (None, 1, 1),\n            (None, dtm.timedelta(seconds=1), 1),\n            (DEFAULT_NONE, None, 10),\n            (DEFAULT_NONE, 1, 11),\n            (DEFAULT_NONE, dtm.timedelta(seconds=1), 11),\n            (1, 2, 3),\n            (1, dtm.timedelta(seconds=2), 3),\n        ],\n    )\n    async def test_get_updates_read_timeout_value_passing(\n        self, bot, read_timeout, timeout, expected, monkeypatch\n    ):\n        caught_read_timeout = None\n\n        async def catch_timeouts(*args, **kwargs):\n            nonlocal caught_read_timeout\n            caught_read_timeout = kwargs.get(\"read_timeout\")\n            return HTTPStatus.OK, b'{\"ok\": \"True\", \"result\": {}}'\n\n        monkeypatch.setattr(HTTPXRequest, \"do_request\", catch_timeouts)\n\n        bot = Bot(get_updates_request=HTTPXRequest(read_timeout=10), token=bot.token)\n        await bot.get_updates(read_timeout=read_timeout, timeout=timeout)\n        assert caught_read_timeout == expected\n\n    @pytest.mark.parametrize(\"use_ip\", [True, False])\n    # local file path as file_input is tested below in test_set_webhook_params\n    @pytest.mark.parametrize(\"file_input\", [\"bytes\", \"file_handle\"])\n    async def test_set_webhook_get_webhook_info_and_delete_webhook(self, bot, use_ip, file_input):\n        url = \"https://python-telegram-bot.org/test/webhook\"\n        # Get the ip address of the website - dynamically just in case it ever changes\n        ip = socket.gethostbyname(\"python-telegram-bot.org\")\n        max_connections = 7\n        allowed_updates = [\"message\"]\n        file_input = (\n            data_file(\"sslcert.pem\").read_bytes()\n            if file_input == \"bytes\"\n            else data_file(\"sslcert.pem\").open(\"rb\")\n        )\n        await bot.set_webhook(\n            url,\n            max_connections=max_connections,\n            allowed_updates=allowed_updates,\n            ip_address=ip if use_ip else None,\n            certificate=file_input if use_ip else None,\n        )\n\n        await asyncio.sleep(1)\n        live_info = await bot.get_webhook_info()\n        assert live_info.url == url\n        assert live_info.max_connections == max_connections\n        assert live_info.allowed_updates == tuple(allowed_updates)\n        assert live_info.ip_address == ip\n        assert live_info.has_custom_certificate == use_ip\n\n        await bot.delete_webhook()\n        await asyncio.sleep(1)\n        info = await bot.get_webhook_info()\n        assert not info.url\n        assert info.ip_address is None\n        assert info.has_custom_certificate is False\n\n    async def test_leave_chat(self, bot):\n        with pytest.raises(BadRequest, match=\"Chat not found\"):\n            await bot.leave_chat(-123456)\n\n    async def test_get_chat(self, bot, super_group_id):\n        cfi = await bot.get_chat(super_group_id)\n        assert cfi.type == \"supergroup\"\n        assert cfi.title == f\">>> telegram.Bot(test) @{bot.username}\"\n        assert cfi.id == int(super_group_id)\n\n    async def test_get_chat_administrators(self, bot, channel_id):\n        admins = await bot.get_chat_administrators(channel_id)\n        assert isinstance(admins, tuple)\n\n        for a in admins:\n            assert a.status in (\"administrator\", \"creator\")\n\n    async def test_get_chat_member_count(self, bot, channel_id):\n        count = await bot.get_chat_member_count(channel_id)\n        assert isinstance(count, int)\n        assert count > 3\n\n    async def test_get_chat_member(self, bot, channel_id, chat_id):\n        chat_member = await bot.get_chat_member(channel_id, chat_id)\n\n        assert chat_member.status == \"creator\"\n        assert chat_member.user.first_name == \"PTB\"\n        assert chat_member.user.last_name == \"Test user\"\n\n    @pytest.mark.skip(reason=\"Not implemented since we need a supergroup with many members\")\n    async def test_set_chat_sticker_set(self):\n        pass\n\n    @pytest.mark.skip(reason=\"Not implemented since we need a supergroup with many members\")\n    async def test_delete_chat_sticker_set(self):\n        pass\n\n    async def test_send_game(self, bot, chat_id):\n        game_short_name = \"test_game\"\n        message = await bot.send_game(chat_id, game_short_name, protect_content=True)\n\n        assert message.game\n        assert (\n            message.game.description\n            == \"A no-op test game, for python-telegram-bot bot framework testing.\"\n        )\n        assert message.game.animation.file_id\n        # We added some test bots later and for some reason the file size is not the same for them\n        # so we accept three different sizes here. Shouldn't be too much of\n        assert message.game.photo[0].file_size in [851, 4928, 850]\n        assert message.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        game_short_name = \"test_game\"\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_game(\n                chat_id,\n                game_short_name,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_game(\n                chat_id,\n                game_short_name,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_game(\n                    chat_id, game_short_name, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"val\"),\n        [({\"protect_content\": True}, True), ({\"protect_content\": False}, None)],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_protect_content(self, default_bot, chat_id, val):\n        protected = await default_bot.send_game(chat_id, \"test_game\", protect_content=val)\n        assert protected.has_protected_content is val\n\n    @xfail\n    async def test_set_game_score_and_high_scores(self, bot, chat_id):\n        # First, test setting a score.\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=BASE_GAME_SCORE,  # Score value is relevant for other set_game_score_* tests!\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n        assert message.game.text != game.game.text\n\n        # Test setting a score higher than previous\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        score = BASE_GAME_SCORE + 1\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=score,\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n            disable_edit_message=True,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n        assert message.game.text == game.game.text\n\n        # Test setting a score lower than previous (should raise error)\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        score = BASE_GAME_SCORE  # Even a score equal to previous raises an error.\n\n        with pytest.raises(BadRequest, match=\"Bot_score_not_modified\"):\n            await bot.set_game_score(\n                user_id=chat_id, score=score, chat_id=game.chat_id, message_id=game.message_id\n            )\n\n        # Test force setting a lower score\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n        await asyncio.sleep(1.5)\n\n        score = BASE_GAME_SCORE - 10\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=score,\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n            force=True,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n\n        # For some reason the returned message doesn't contain the updated score. need to fetch\n        # the game again... (the service message is also absent when running the test suite)\n        game2 = await bot.send_game(chat_id, game_short_name)\n        assert str(score) in game2.game.text\n\n        # We need a game to get the scores for\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n        high_scores = await bot.get_game_high_scores(chat_id, game.chat_id, game.message_id)\n        # We assume that the other game score tests ran within 20 sec\n        assert high_scores[0].score == BASE_GAME_SCORE - 10\n\n    # send_invoice and create_invoice_link is tested in test_invoice\n    async def test_promote_chat_member(self, bot, channel_id, monkeypatch):\n        # TODO: Add bot to supergroup so this can be tested properly / give bot perms\n        with pytest.raises(BadRequest, match=\"Not enough rights\"):\n            assert await bot.promote_chat_member(\n                channel_id,\n                1325859552,\n                is_anonymous=True,\n                can_change_info=True,\n                can_post_messages=True,\n                can_edit_messages=True,\n                can_delete_messages=True,\n                can_invite_users=True,\n                can_restrict_members=True,\n                can_pin_messages=True,\n                can_promote_members=True,\n                can_manage_chat=True,\n                can_manage_video_chats=True,\n                can_manage_topics=True,\n                can_post_stories=True,\n                can_edit_stories=True,\n                can_delete_stories=True,\n                can_manage_direct_messages=True,\n            )\n\n        # Test that we pass the correct params to TG\n        async def make_assertion(*args, **_):\n            data = args[1]\n            return (\n                data.get(\"chat_id\") == channel_id\n                and data.get(\"user_id\") == 1325859552\n                and data.get(\"is_anonymous\") == 1\n                and data.get(\"can_change_info\") == 2\n                and data.get(\"can_post_messages\") == 3\n                and data.get(\"can_edit_messages\") == 4\n                and data.get(\"can_delete_messages\") == 5\n                and data.get(\"can_invite_users\") == 6\n                and data.get(\"can_restrict_members\") == 7\n                and data.get(\"can_pin_messages\") == 8\n                and data.get(\"can_promote_members\") == 9\n                and data.get(\"can_manage_chat\") == 10\n                and data.get(\"can_manage_video_chats\") == 11\n                and data.get(\"can_manage_topics\") == 12\n                and data.get(\"can_post_stories\") == 13\n                and data.get(\"can_edit_stories\") == 14\n                and data.get(\"can_delete_stories\") == 15\n                and data.get(\"can_manage_direct_messages\") == 16\n            )\n\n        monkeypatch.setattr(bot, \"_post\", make_assertion)\n        assert await bot.promote_chat_member(\n            channel_id,\n            1325859552,\n            is_anonymous=1,\n            can_change_info=2,\n            can_post_messages=3,\n            can_edit_messages=4,\n            can_delete_messages=5,\n            can_invite_users=6,\n            can_restrict_members=7,\n            can_pin_messages=8,\n            can_promote_members=9,\n            can_manage_chat=10,\n            can_manage_video_chats=11,\n            can_manage_topics=12,\n            can_post_stories=13,\n            can_edit_stories=14,\n            can_delete_stories=15,\n            can_manage_direct_messages=16,\n        )\n\n    async def test_export_chat_invite_link(self, bot, channel_id):\n        # Each link is unique apparently\n        invite_link = await bot.export_chat_invite_link(channel_id)\n        assert isinstance(invite_link, str)\n        assert invite_link\n\n    async def test_edit_revoke_chat_invite_link_passing_link_objects(self, bot, channel_id):\n        invite_link = await bot.create_chat_invite_link(chat_id=channel_id)\n        assert invite_link.name is None\n\n        edited_link = await bot.edit_chat_invite_link(\n            chat_id=channel_id, invite_link=invite_link, name=\"some_name\"\n        )\n        assert edited_link == invite_link\n        assert edited_link.name == \"some_name\"\n\n        revoked_link = await bot.revoke_chat_invite_link(\n            chat_id=channel_id, invite_link=edited_link\n        )\n        assert revoked_link.invite_link == edited_link.invite_link\n        assert revoked_link.is_revoked is True\n        assert revoked_link.name == \"some_name\"\n\n    @pytest.mark.parametrize(\"creates_join_request\", [True, False])\n    @pytest.mark.parametrize(\"name\", [None, \"name\"])\n    async def test_create_chat_invite_link_basics(\n        self, bot, creates_join_request, name, channel_id\n    ):\n        data = {}\n        if creates_join_request:\n            data[\"creates_join_request\"] = True\n        if name:\n            data[\"name\"] = name\n        invite_link = await bot.create_chat_invite_link(chat_id=channel_id, **data)\n\n        assert invite_link.member_limit is None\n        assert invite_link.expire_date is None\n        assert invite_link.creates_join_request == creates_join_request\n        assert invite_link.name == name\n\n        revoked_link = await bot.revoke_chat_invite_link(\n            chat_id=channel_id, invite_link=invite_link.invite_link\n        )\n        assert revoked_link.is_revoked\n\n    @pytest.mark.parametrize(\"datetime\", argvalues=[True, False], ids=[\"datetime\", \"integer\"])\n    async def test_advanced_chat_invite_links(self, bot, channel_id, datetime):\n        # we are testing this all in one function in order to save api calls\n        timestamp = dtm.datetime.utcnow()\n        add_seconds = dtm.timedelta(0, 70)\n        time_in_future = timestamp + add_seconds\n        expire_time = time_in_future if datetime else to_timestamp(time_in_future)\n        aware_time_in_future = localize(time_in_future, UTC)\n\n        invite_link = await bot.create_chat_invite_link(\n            channel_id, expire_date=expire_time, member_limit=10\n        )\n        assert invite_link.invite_link\n        assert not invite_link.invite_link.endswith(\"...\")\n        assert abs(invite_link.expire_date - aware_time_in_future) < dtm.timedelta(seconds=1)\n        assert invite_link.member_limit == 10\n\n        add_seconds = dtm.timedelta(0, 80)\n        time_in_future = timestamp + add_seconds\n        expire_time = time_in_future if datetime else to_timestamp(time_in_future)\n        aware_time_in_future = localize(time_in_future, UTC)\n\n        edited_invite_link = await bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            expire_date=expire_time,\n            member_limit=20,\n            name=\"NewName\",\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert abs(edited_invite_link.expire_date - aware_time_in_future) < dtm.timedelta(\n            seconds=1\n        )\n        assert edited_invite_link.name == \"NewName\"\n        assert edited_invite_link.member_limit == 20\n\n        edited_invite_link = await bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            name=\"EvenNewerName\",\n            creates_join_request=True,\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert not edited_invite_link.expire_date\n        assert edited_invite_link.name == \"EvenNewerName\"\n        assert edited_invite_link.creates_join_request\n        assert edited_invite_link.member_limit is None\n\n        revoked_invite_link = await bot.revoke_chat_invite_link(\n            channel_id, invite_link.invite_link\n        )\n        assert revoked_invite_link.invite_link == invite_link.invite_link\n        assert revoked_invite_link.is_revoked\n\n    async def test_advanced_chat_invite_links_default_tzinfo(self, tz_bot, channel_id):\n        # we are testing this all in one function in order to save api calls\n        add_seconds = dtm.timedelta(0, 70)\n        aware_expire_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + add_seconds\n        time_in_future = aware_expire_date.replace(tzinfo=None)\n\n        invite_link = await tz_bot.create_chat_invite_link(\n            channel_id, expire_date=time_in_future, member_limit=10\n        )\n        assert invite_link.invite_link\n        assert not invite_link.invite_link.endswith(\"...\")\n        assert abs(invite_link.expire_date - aware_expire_date) < dtm.timedelta(seconds=1)\n        assert invite_link.member_limit == 10\n\n        add_seconds = dtm.timedelta(0, 80)\n        aware_expire_date += add_seconds\n        time_in_future = aware_expire_date.replace(tzinfo=None)\n\n        edited_invite_link = await tz_bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            expire_date=time_in_future,\n            member_limit=20,\n            name=\"NewName\",\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert abs(edited_invite_link.expire_date - aware_expire_date) < dtm.timedelta(seconds=1)\n        assert edited_invite_link.name == \"NewName\"\n        assert edited_invite_link.member_limit == 20\n\n        edited_invite_link = await tz_bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            name=\"EvenNewerName\",\n            creates_join_request=True,\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert not edited_invite_link.expire_date\n        assert edited_invite_link.name == \"EvenNewerName\"\n        assert edited_invite_link.creates_join_request\n        assert edited_invite_link.member_limit is None\n\n        revoked_invite_link = await tz_bot.revoke_chat_invite_link(\n            channel_id, invite_link.invite_link\n        )\n        assert revoked_invite_link.invite_link == invite_link.invite_link\n        assert revoked_invite_link.is_revoked\n\n    async def test_approve_chat_join_request(self, bot, chat_id, channel_id):\n        # TODO: Need incoming join request to properly test\n        # Since we can't create join requests on the fly, we just tests the call to TG\n        # by checking that it complains about approving a user who is already in the chat\n        with pytest.raises(BadRequest, match=\"User_already_participant\"):\n            await bot.approve_chat_join_request(chat_id=channel_id, user_id=chat_id)\n\n    async def test_decline_chat_join_request(self, bot, chat_id, channel_id):\n        # TODO: Need incoming join request to properly test\n        # Since we can't create join requests on the fly, we just tests the call to TG\n        # by checking that it complains about declining a user who is already in the chat\n        #\n        # The error message Hide_requester_missing started showing up instead of\n        # User_already_participant. Don't know why \u2026\n        with pytest.raises(BadRequest, match=r\"User_already_participant|Hide_requester_missing\"):\n            await bot.decline_chat_join_request(chat_id=channel_id, user_id=chat_id)\n\n    async def test_set_chat_photo(self, bot, channel_id):\n        async def func():\n            assert await bot.set_chat_photo(channel_id, f)\n\n        with data_file(\"telegram_test_channel.jpg\").open(\"rb\") as f:\n            await expect_bad_request(\n                func, \"Type of file mismatch\", \"Telegram did not accept the file.\"\n            )\n\n    async def test_delete_chat_photo(self, bot, channel_id):\n        async def func():\n            assert await bot.delete_chat_photo(channel_id)\n\n        await expect_bad_request(func, \"Chat_not_modified\", \"Chat photo was not set.\")\n\n    async def test_set_chat_title(self, bot, channel_id):\n        assert await bot.set_chat_title(channel_id, \">>> telegram.Bot() - Tests\")\n\n    async def test_set_chat_description(self, bot, channel_id):\n        assert await bot.set_chat_description(channel_id, \"Time: \" + str(time.time()))\n\n    async def test_pin_and_unpin_message(self, bot, super_group_id):\n        messages = []  # contains the Messages we sent\n        pinned_messages_tasks = set()  # contains the asyncio.Tasks that pin the messages\n\n        # Let's send 3 messages so we can pin them\n        awaitables = {bot.send_message(super_group_id, f\"test_pin_message_{i}\") for i in range(3)}\n\n        # We will pin the messages immediately after sending them\n        for sending_msg in asyncio.as_completed(awaitables):  # as_completed sends the messages\n            msg = await sending_msg\n            coro = bot.pin_chat_message(super_group_id, msg.message_id, True, read_timeout=10)\n            pinned_messages_tasks.add(asyncio.create_task(coro))  # start pinning the message\n            messages.append(msg)\n\n        assert len(messages) == 3  # Check if we sent 3 messages\n\n        # Check if we pinned 3 messages\n        assert all([await i for i in pinned_messages_tasks])\n        assert all(i.done() for i in pinned_messages_tasks)  # Check if all tasks are done\n\n        chat = await bot.get_chat(super_group_id)  # get the chat to check the pinned message\n        assert chat.pinned_message in messages\n\n        # Determine which message is not the most recently pinned\n        for old_pin_msg in messages:\n            if chat.pinned_message != old_pin_msg:\n                break\n\n        # Test unpinning our messages\n        tasks = asyncio.gather(\n            bot.unpin_chat_message(  # unpins any message except the most recent\n                chat_id=super_group_id,  # because we don't want to accidentally unpin the same msg\n                message_id=old_pin_msg.message_id,  # twice\n                read_timeout=10,\n            ),\n            bot.unpin_chat_message(chat_id=super_group_id, read_timeout=10),  # unpins most recent\n        )\n        assert all(await tasks)\n        assert all(i.done() for i in tasks)\n        assert await bot.unpin_all_chat_messages(super_group_id, read_timeout=10)\n\n    # get_sticker_set, upload_sticker_file, create_new_sticker_set, add_sticker_to_set,\n    # set_sticker_position_in_set, delete_sticker_from_set and get_custom_emoji_stickers,\n    # replace_sticker_in_set are tested in the test_sticker module.\n\n    # get_forum_topic_icon_stickers, edit_forum_topic, general_forum etc...\n    # are tested in the test_forum module.\n    async def test_send_message_disable_web_page_preview(self, bot, chat_id):\n        \"\"\"Test that disable_web_page_preview is substituted for link_preview_options and that\n        it still works as expected for backward compatability.\"\"\"\n        msg = await bot.send_message(\n            chat_id,\n            \"https://github.com/python-telegram-bot/python-telegram-bot\",\n            disable_web_page_preview=True,\n        )\n        assert msg.link_preview_options\n        assert msg.link_preview_options.is_disabled\n\n    async def test_send_message_link_preview_options(self, bot, chat_id):\n        \"\"\"Test whether link_preview_options is correctly passed to the API.\"\"\"\n        # btw it is possible to have no url in the text, but set a url for the preview.\n        msg = await bot.send_message(\n            chat_id,\n            \"https://github.com/python-telegram-bot/python-telegram-bot\",\n            link_preview_options=LinkPreviewOptions(prefer_small_media=True, show_above_text=True),\n        )\n        assert msg.link_preview_options\n        assert not msg.link_preview_options.is_disabled\n        # The prefer_* options aren't very consistent on the client side (big pic shown) +\n        # they are not returned by the API.\n        # assert msg.link_preview_options.prefer_small_media\n        assert msg.link_preview_options.show_above_text\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"link_preview_options\": LinkPreviewOptions(show_above_text=True)}],\n        indirect=True,\n    )\n    async def test_send_message_default_link_preview_options(self, default_bot, chat_id):\n        \"\"\"Test whether Defaults.link_preview_options is correctly fused with the passed LPO.\"\"\"\n        github_url = \"https://github.com/python-telegram-bot/python-telegram-bot\"\n        website = \"https://python-telegram-bot.org/\"\n\n        # First test just the default passing:\n        coro1 = default_bot.send_message(chat_id, github_url)\n        # Next test fusion of both LPOs:\n        coro2 = default_bot.send_message(\n            chat_id,\n            github_url,\n            link_preview_options=LinkPreviewOptions(url=website, prefer_large_media=True),\n        )\n        # Now test fusion + overriding of passed LPO:\n        coro3 = default_bot.send_message(\n            chat_id,\n            github_url,\n            link_preview_options=LinkPreviewOptions(show_above_text=False, url=website),\n        )\n        # finally test explicitly setting to None\n        coro4 = default_bot.send_message(chat_id, github_url, link_preview_options=None)\n\n        msgs = asyncio.gather(coro1, coro2, coro3, coro4)\n        msg1, msg2, msg3, msg4 = await msgs\n        assert msg1.link_preview_options\n        assert msg1.link_preview_options.show_above_text\n\n        assert msg2.link_preview_options\n        assert msg2.link_preview_options.show_above_text\n        assert msg2.link_preview_options.url == website\n        assert msg2.link_preview_options.prefer_large_media  # Now works correctly using new url..\n\n        assert msg3.link_preview_options\n        assert not msg3.link_preview_options.show_above_text\n        assert msg3.link_preview_options.url == website\n\n        assert msg4.link_preview_options == LinkPreviewOptions(url=github_url)\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"link_preview_options\": LinkPreviewOptions(show_above_text=True)}],\n        indirect=True,\n    )\n    async def test_edit_message_text_default_link_preview_options(self, default_bot, chat_id):\n        \"\"\"Test whether Defaults.link_preview_options is correctly fused with the passed LPO.\"\"\"\n        github_url = \"https://github.com/python-telegram-bot/python-telegram-bot\"\n        website = \"https://python-telegram-bot.org/\"\n        telegram_url = \"https://telegram.org\"\n        base_1, base_2, base_3, base_4 = await asyncio.gather(\n            *(default_bot.send_message(chat_id, telegram_url) for _ in range(4))\n        )\n\n        # First test just the default passing:\n        coro1 = base_1.edit_text(github_url)\n        # Next test fusion of both LPOs:\n        coro2 = base_2.edit_text(\n            github_url,\n            link_preview_options=LinkPreviewOptions(url=website, prefer_large_media=True),\n        )\n        # Now test fusion + overriding of passed LPO:\n        coro3 = base_3.edit_text(\n            github_url,\n            link_preview_options=LinkPreviewOptions(show_above_text=False, url=website),\n        )\n        # finally test explicitly setting to None\n        coro4 = base_4.edit_text(github_url, link_preview_options=None)\n\n        msgs = asyncio.gather(coro1, coro2, coro3, coro4)\n        msg1, msg2, msg3, msg4 = await msgs\n        assert msg1.link_preview_options\n        assert msg1.link_preview_options.show_above_text\n\n        assert msg2.link_preview_options\n        assert msg2.link_preview_options.show_above_text\n        assert msg2.link_preview_options.url == website\n        assert msg2.link_preview_options.prefer_large_media  # Now works correctly using new url..\n\n        assert msg3.link_preview_options\n        assert not msg3.link_preview_options.show_above_text\n        assert msg3.link_preview_options.url == website\n\n        assert msg4.link_preview_options == LinkPreviewOptions(url=github_url)\n\n    async def test_send_message_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code Spoiler\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n            MessageEntity(MessageEntity.SPOILER, 17, 7),\n        ]\n        message = await bot.send_message(chat_id=chat_id, text=test_string, entities=entities)\n        assert message.text == test_string\n        assert message.entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_send_message_default_parse_mode(self, default_bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_message(chat_id, test_markdown_string, **i)\n                for i in ({}, {\"parse_mode\": None}, {\"parse_mode\": \"HTML\"})\n            )\n        )\n        msg1, msg2, msg3 = await tasks\n        assert msg1.text_markdown == test_markdown_string\n        assert msg1.text == test_string\n\n        assert msg2.text == test_markdown_string\n        assert msg2.text_markdown == escape_markdown(test_markdown_string)\n\n        assert msg3.text == test_markdown_string\n        assert msg3.text_markdown == escape_markdown(test_markdown_string)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_message_default_protect_content(self, default_bot, chat_id):\n        tasks = asyncio.gather(\n            default_bot.send_message(chat_id, \"test\"),\n            default_bot.send_message(chat_id, \"test\", protect_content=False),\n        )\n        to_check, no_protect = await tasks\n        assert to_check.has_protected_content\n        assert not no_protect.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_message_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_message(\n                chat_id,\n                \"test\",\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_message(\n                chat_id, \"test\", reply_to_message_id=reply_to_message.message_id\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_message(\n                    chat_id, \"test\", reply_to_message_id=reply_to_message.message_id\n                )\n\n    async def test_get_set_my_default_administrator_rights(self, bot):\n        # Test that my default administrator rights for group are as all False\n        assert await bot.set_my_default_administrator_rights()  # clear any set rights\n        my_admin_rights_grp = await bot.get_my_default_administrator_rights()\n        assert isinstance(my_admin_rights_grp, ChatAdministratorRights)\n        assert all(not getattr(my_admin_rights_grp, at) for at in my_admin_rights_grp.__slots__)\n\n        # Test setting my default admin rights for channel\n        my_rights = ChatAdministratorRights.all_rights()\n        assert await bot.set_my_default_administrator_rights(my_rights, for_channels=True)\n        my_admin_rights_ch = await bot.get_my_default_administrator_rights(for_channels=True)\n        assert my_admin_rights_ch.can_invite_users is my_rights.can_invite_users\n        # tg bug? is_anonymous is False despite setting it True for channels:\n        assert my_admin_rights_ch.is_anonymous is not my_rights.is_anonymous\n\n        assert my_admin_rights_ch.can_manage_chat is my_rights.can_manage_chat\n        assert my_admin_rights_ch.can_delete_messages is my_rights.can_delete_messages\n        assert my_admin_rights_ch.can_edit_messages is my_rights.can_edit_messages\n        assert my_admin_rights_ch.can_post_messages is my_rights.can_post_messages\n        assert my_admin_rights_ch.can_change_info is my_rights.can_change_info\n        assert my_admin_rights_ch.can_promote_members is my_rights.can_promote_members\n        assert my_admin_rights_ch.can_restrict_members is my_rights.can_restrict_members\n        assert my_admin_rights_ch.can_pin_messages is None  # Not returned for channels\n        assert my_admin_rights_ch.can_manage_topics is None  # Not returned for channels\n\n    async def test_get_set_chat_menu_button(self, bot, chat_id):\n        # Test our chat menu button is commands-\n        menu_button = await bot.get_chat_menu_button()\n        assert isinstance(menu_button, MenuButton)\n        assert isinstance(menu_button, MenuButtonCommands)\n        assert menu_button.type == MenuButtonType.COMMANDS\n\n        # Test setting our chat menu button to Webapp.\n        my_menu = MenuButtonWebApp(\"click me!\", WebAppInfo(\"https://telegram.org/\"))\n        assert await bot.set_chat_menu_button(chat_id=chat_id, menu_button=my_menu)\n        menu_button = await bot.get_chat_menu_button(chat_id)\n        assert isinstance(menu_button, MenuButtonWebApp)\n        assert menu_button.type == MenuButtonType.WEB_APP\n        assert menu_button.text == my_menu.text\n        assert menu_button.web_app.url == my_menu.web_app.url\n\n        assert await bot.set_chat_menu_button(chat_id=chat_id, menu_button=MenuButtonDefault())\n        menu_button = await bot.get_chat_menu_button(chat_id=chat_id)\n        assert isinstance(menu_button, MenuButtonDefault)\n\n    async def test_set_and_get_my_commands(self, bot):\n        commands = [BotCommand(\"cmd1\", \"descr1\"), [\"cmd2\", \"descr2\"]]\n        assert await bot.set_my_commands([])\n        assert await bot.get_my_commands() == ()\n        assert await bot.set_my_commands(commands)\n\n        for i, bc in enumerate(await bot.get_my_commands()):\n            assert bc.command == f\"cmd{i + 1}\"\n            assert bc.description == f\"descr{i + 1}\"\n\n    async def test_get_set_delete_my_commands_with_scope(self, bot, super_group_id, chat_id):\n        group_cmds = [BotCommand(\"group_cmd\", \"visible to this supergroup only\")]\n        private_cmds = [BotCommand(\"private_cmd\", \"visible to this private chat only\")]\n        group_scope = BotCommandScopeChat(super_group_id)\n        private_scope = BotCommandScopeChat(chat_id)\n\n        # Set supergroup command list with lang code and check if the same can be returned from api\n        assert await bot.set_my_commands(group_cmds, scope=group_scope, language_code=\"en\")\n        gotten_group_cmds = await bot.get_my_commands(scope=group_scope, language_code=\"en\")\n\n        assert len(gotten_group_cmds) == len(group_cmds)\n        assert gotten_group_cmds[0].command == group_cmds[0].command\n\n        # Set private command list and check if same can be returned from the api\n        assert await bot.set_my_commands(private_cmds, scope=private_scope)\n        gotten_private_cmd = await bot.get_my_commands(scope=private_scope)\n\n        assert len(gotten_private_cmd) == len(private_cmds)\n        assert gotten_private_cmd[0].command == private_cmds[0].command\n\n        # Delete command list from that supergroup and private chat-\n        tasks = asyncio.gather(\n            bot.delete_my_commands(private_scope),\n            bot.delete_my_commands(group_scope, \"en\"),\n        )\n        assert all(await tasks)\n\n        # Check if its been deleted-\n        tasks = asyncio.gather(\n            bot.get_my_commands(private_scope),\n            bot.get_my_commands(group_scope, \"en\"),\n        )\n        deleted_priv_cmds, deleted_grp_cmds = await tasks\n\n        assert len(deleted_grp_cmds) == 0 == len(group_cmds) - 1\n        assert len(deleted_priv_cmds) == 0 == len(private_cmds) - 1\n\n        await bot.delete_my_commands()  # Delete commands from default scope\n        assert len(await bot.get_my_commands()) == 0\n\n    async def test_copy_message_without_reply(self, bot, chat_id, media_message):\n        keyboard = InlineKeyboardMarkup(\n            [[InlineKeyboardButton(text=\"test\", callback_data=\"test2\")]]\n        )\n\n        returned = await bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=\"<b>Test</b>\",\n            parse_mode=ParseMode.HTML,\n            reply_to_message_id=media_message.message_id,\n            reply_markup=keyboard,\n            show_caption_above_media=False,\n        )\n        # we send a temp message which replies to the returned message id in order to get a\n        # message object\n        temp_message = await bot.send_message(\n            chat_id, \"test\", reply_to_message_id=returned.message_id\n        )\n        message = temp_message.reply_to_message\n        assert message.chat_id == int(chat_id)\n        assert message.caption == \"Test\"\n        assert len(message.caption_entities) == 1\n        assert message.reply_markup == keyboard\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [\n            ({\"parse_mode\": ParseMode.HTML, \"allow_sending_without_reply\": True}),\n            ({\"parse_mode\": None, \"allow_sending_without_reply\": True}),\n            ({\"parse_mode\": None, \"allow_sending_without_reply\": False}),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_copy_message_with_default(self, default_bot, chat_id, media_message):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if not default_bot.defaults.allow_sending_without_reply:\n            with pytest.raises(BadRequest, match=\"not found\"):\n                await default_bot.copy_message(\n                    chat_id,\n                    from_chat_id=chat_id,\n                    message_id=media_message.message_id,\n                    caption=\"<b>Test</b>\",\n                    reply_to_message_id=reply_to_message.message_id,\n                )\n            return\n        returned = await default_bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=\"<b>Test</b>\",\n            reply_to_message_id=reply_to_message.message_id,\n        )\n        # we send a temp message which replies to the returned message id in order to get a\n        # message object\n        temp_message = await default_bot.send_message(\n            chat_id, \"test\", reply_to_message_id=returned.message_id\n        )\n        message = temp_message.reply_to_message\n        if default_bot.defaults.parse_mode:\n            assert len(message.caption_entities) == 1\n        else:\n            assert len(message.caption_entities) == 0\n\n    async def test_copy_messages(self, bot, chat_id):\n        # not using gather here to have deterministically ordered message_ids\n        msg1 = await bot.send_message(chat_id, text=\"will be copied 1\")\n        msg2 = await bot.send_message(chat_id, text=\"will be copied 2\")\n\n        copy_messages = await bot.copy_messages(\n            chat_id, from_chat_id=chat_id, message_ids=(msg1.message_id, msg2.message_id)\n        )\n        assert isinstance(copy_messages, tuple)\n\n        tasks = asyncio.gather(\n            bot.send_message(chat_id, \"temp 1\", reply_to_message_id=copy_messages[0].message_id),\n            bot.send_message(chat_id, \"temp 2\", reply_to_message_id=copy_messages[1].message_id),\n        )\n        temp_msg1, temp_msg2 = await tasks\n\n        forward_msg1 = temp_msg1.reply_to_message\n        forward_msg2 = temp_msg2.reply_to_message\n\n        assert forward_msg1.text == msg1.text\n        assert forward_msg2.text == msg2.text\n\n    # Continue testing arbitrary callback data here with actual requests:\n    async def test_replace_callback_data_send_message(self, cdc_bot, chat_id):\n        bot = cdc_bot\n\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            message = await bot.send_message(\n                chat_id=chat_id, text=\"test\", reply_markup=reply_markup\n            )\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_replace_callback_data_stop_poll_and_repl_to_message(self, cdc_bot, chat_id):\n        bot = cdc_bot\n\n        poll_message = await bot.send_poll(chat_id=chat_id, question=\"test\", options=[\"1\", \"2\"])\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            await poll_message.stop_poll(reply_markup=reply_markup)\n            helper_message = await poll_message.reply_text(\"temp\", do_quote=True)\n            message = helper_message.reply_to_message\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_replace_callback_data_copy_message(self, cdc_bot, chat_id):\n        \"\"\"This also tests that data is inserted into the buttons of message.reply_to_message\n        where message is the return value of a bot method\"\"\"\n        bot = cdc_bot\n\n        original_message = await bot.send_message(chat_id=chat_id, text=\"original\")\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            message_id = await original_message.copy(chat_id=chat_id, reply_markup=reply_markup)\n            helper_message = await bot.send_message(\n                chat_id=chat_id, reply_to_message_id=message_id.message_id, text=\"temp\"\n            )\n            message = helper_message.reply_to_message\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_get_chat_arbitrary_callback_data(self, chat_id, cdc_bot):\n        bot = cdc_bot\n\n        try:\n            reply_markup = InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"callback_data\")\n            )\n\n            message = await bot.send_message(\n                chat_id, text=\"get_chat_arbitrary_callback_data\", reply_markup=reply_markup\n            )\n            await message.pin()\n\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"callback_data\"\n\n            cfi = await bot.get_chat(chat_id)\n\n            if not cfi.pinned_message:\n                pytest.xfail(\"Pinning messages is not always reliable on TG\")\n\n            assert cfi.pinned_message == message\n            assert cfi.pinned_message.reply_markup == reply_markup\n            assert await message.unpin()  # (not placed in finally block since msg can be unbound)\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_arbitrary_callback_data_get_chat_no_pinned_message(\n        self, super_group_id, cdc_bot\n    ):\n        bot = cdc_bot\n        await bot.unpin_all_chat_messages(super_group_id)\n\n        try:\n            cfi = await bot.get_chat(super_group_id)\n\n            assert isinstance(cfi, ChatFullInfo)\n            assert int(cfi.id) == int(super_group_id)\n            assert cfi.pinned_message is None\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_set_get_my_description(self, bot):\n        default_description = f\"{bot.username} - default - {dtm.datetime.utcnow().isoformat()}\"\n        en_description = f\"{bot.username} - en - {dtm.datetime.utcnow().isoformat()}\"\n        de_description = f\"{bot.username} - de - {dtm.datetime.utcnow().isoformat()}\"\n\n        # Set the descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_description(default_description),\n                bot.set_my_description(en_description, language_code=\"en\"),\n                bot.set_my_description(de_description, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            bot.get_my_description(), bot.get_my_description(\"en\"), bot.get_my_description(\"de\")\n        ) == [\n            BotDescription(default_description),\n            BotDescription(en_description),\n            BotDescription(de_description),\n        ]\n\n        # Delete the descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_description(None),\n                bot.set_my_description(None, language_code=\"en\"),\n                bot.set_my_description(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            bot.get_my_description(), bot.get_my_description(\"en\"), bot.get_my_description(\"de\")\n        ) == 3 * [BotDescription(\"\")]\n\n    async def test_set_get_my_short_description(self, bot):\n        default_short_description = (\n            f\"{bot.username} - default - {dtm.datetime.utcnow().isoformat()}\"\n        )\n        en_short_description = f\"{bot.username} - en - {dtm.datetime.utcnow().isoformat()}\"\n        de_short_description = f\"{bot.username} - de - {dtm.datetime.utcnow().isoformat()}\"\n\n        # Set the short_descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_short_description(default_short_description),\n                bot.set_my_short_description(en_short_description, language_code=\"en\"),\n                bot.set_my_short_description(de_short_description, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            bot.get_my_short_description(),\n            bot.get_my_short_description(\"en\"),\n            bot.get_my_short_description(\"de\"),\n        ) == [\n            BotShortDescription(default_short_description),\n            BotShortDescription(en_short_description),\n            BotShortDescription(de_short_description),\n        ]\n\n        # Delete the short_descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_short_description(None),\n                bot.set_my_short_description(None, language_code=\"en\"),\n                bot.set_my_short_description(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            bot.get_my_short_description(),\n            bot.get_my_short_description(\"en\"),\n            bot.get_my_short_description(\"de\"),\n        ) == 3 * [BotShortDescription(\"\")]\n\n    async def test_set_message_reaction(self, bot, chat_id, static_message):\n        assert await bot.set_message_reaction(\n            chat_id, static_message.message_id, ReactionEmoji.THUMBS_DOWN, True\n        )\n\n    @pytest.mark.parametrize(\"bot_class\", [Bot, ExtBot])\n    async def test_do_api_request_warning_known_method(self, bot, bot_class):\n        with pytest.warns(PTBUserWarning, match=\"Please use 'Bot.get_me'\") as record:\n            await bot_class(bot.token).do_api_request(\"get_me\")\n\n        assert record[0].filename == __file__, \"Wrong stack level!\"\n\n    async def test_do_api_request_unknown_method(self, bot):\n        with pytest.raises(EndPointNotFound, match=\"'unknownEndpoint' not found\"):\n            await bot.do_api_request(\"unknown_endpoint\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    async def test_do_api_request_invalid_token(self, bot):\n        # we do not initialize the bot here on purpose b/c that's the case were we actually\n        # do not know for sure if the token is invalid or the method was not found\n        with pytest.raises(\n            InvalidToken, match=\"token was rejected by Telegram or the endpoint 'getMe'\"\n        ):\n            await Bot(\"invalid_token\").do_api_request(\"get_me\")\n\n        # same test, but with a valid token bot and unknown endpoint\n        with pytest.raises(\n            InvalidToken, match=\"token was rejected by Telegram or the endpoint 'unknownEndpoint'\"\n        ):\n            await Bot(bot.token).do_api_request(\"unknown_endpoint\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_basic_and_files(self, bot, chat_id, return_type):\n        result = await bot.do_api_request(\n            \"send_document\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"caption\": \"test_caption\",\n                \"document\": InputFile(data_file(\"telegram.png\").open(\"rb\")),\n            },\n            return_type=return_type,\n        )\n        if return_type is None:\n            assert isinstance(result, dict)\n            result = Message.de_json(result, bot)\n\n        assert isinstance(result, Message)\n        assert result.chat_id == int(chat_id)\n        assert result.caption == \"test_caption\"\n        out = BytesIO()\n        await (await result.document.get_file()).download_to_memory(out)\n        out.seek(0)\n        assert out.read() == data_file(\"telegram.png\").open(\"rb\").read()\n        assert result.document.file_name == \"telegram.png\"\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_list_return_type(self, bot, chat_id, return_type):\n        result = await bot.do_api_request(\n            \"send_media_group\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"media\": [\n                    InputMediaDocument(\n                        InputFile(\n                            data_file(\"text_file.txt\").open(\"rb\"),\n                            attach=True,\n                        )\n                    ),\n                    InputMediaDocument(\n                        InputFile(\n                            data_file(\"local_file.txt\").open(\"rb\"),\n                            attach=True,\n                        )\n                    ),\n                ],\n            },\n            return_type=return_type,\n        )\n        if return_type is None:\n            assert isinstance(result, list)\n            for entry in result:\n                assert isinstance(entry, dict)\n            result = Message.de_list(result, bot)\n\n        for message, file_name in zip(result, (\"text_file.txt\", \"local_file.txt\")):\n            assert isinstance(message, Message)\n            assert message.chat_id == int(chat_id)\n            out = BytesIO()\n            await (await message.document.get_file()).download_to_memory(out)\n            out.seek(0)\n            assert out.read() == data_file(file_name).open(\"rb\").read()\n            assert message.document.file_name == file_name\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_bool_return_type(self, bot, chat_id, return_type):\n        assert await bot.do_api_request(\"delete_my_commands\", return_type=return_type) is True\n\n    async def test_get_star_transactions(self, bot):\n        transactions = await bot.get_star_transactions(limit=1)\n        assert isinstance(transactions, StarTransactions)\n        assert len(transactions.transactions) == 0\n\n    @pytest.mark.parametrize(\"subscription_period\", [2592000, dtm.timedelta(days=30)])\n    async def test_create_edit_chat_subscription_link(\n        self, bot, subscription_channel_id, channel_id, subscription_period\n    ):\n        sub_link = await bot.create_chat_subscription_invite_link(\n            subscription_channel_id,\n            name=\"sub_name\",\n            subscription_period=subscription_period,\n            subscription_price=13,\n        )\n        assert sub_link.name == \"sub_name\"\n        assert sub_link.subscription_period == 2592000\n        assert sub_link.subscription_price == 13\n\n        edited_link = await bot.edit_chat_subscription_invite_link(\n            chat_id=subscription_channel_id, invite_link=sub_link, name=\"sub_name_2\"\n        )\n        assert edited_link.name == \"sub_name_2\"\n        assert sub_link.subscription_period == 2592000\n        assert sub_link.subscription_price == 13\n\n    async def test_get_my_star_balance(self, bot):\n        balance = await bot.get_my_star_balance()\n        assert isinstance(balance, StarAmount)\n        assert balance.amount == 0"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2663,
                            4635
                        ],
                        "reason": "The test 'test_send_message_default_allow_sending_without_reply' may fail if the parameters passed do not match the expected structure. The assertion checks for multiple parameters, and if any of them are incorrect, it could lead to assertion errors. This is critical for sending chat actions functionality. Additionally, the test 'test_send_game_default_allow_sending_without_reply' could also be affected by similar issues, as it involves sending games with specific parameters.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "class",
                        "code_snippet": "class TestBotWithRequest:\n    \"\"\"\n    Most are executed on tg.ext.ExtBot, as that class only extends the functionality of tg.bot\n\n    Behavior for init of ExtBot with missing optional dependency cachetools (for CallbackDataCache)\n    is tested in `test_callbackdatacache`\n    \"\"\"\n\n    # get_available_gifts, send_gift are tested in `test_gift`.\n    # No need to duplicate here.\n\n    async def test_invalid_token_server_response(self):\n        with pytest.raises(InvalidToken, match=\"The token `12` was rejected by the server\\\\.\"):\n            async with ExtBot(token=\"12\"):\n                pass\n\n    async def test_multiple_init_cycles(self, bot):\n        # nothing really to assert - this should just not fail\n        test_bot = Bot(bot.token)\n        async with test_bot:\n            await test_bot.get_me()\n        async with test_bot:\n            await test_bot.get_me()\n\n    async def test_forward_message(self, bot, chat_id, static_message):\n        forward_message = await bot.forward_message(\n            chat_id, from_chat_id=chat_id, message_id=static_message.message_id\n        )\n\n        assert forward_message.text == static_message.text\n        assert forward_message.forward_origin.sender_user == static_message.from_user\n        assert isinstance(forward_message.forward_origin.date, dtm.datetime)\n\n    async def test_forward_protected_message(self, bot, chat_id):\n        tasks = asyncio.gather(\n            bot.send_message(chat_id, \"cant forward me\", protect_content=True),\n            bot.send_message(chat_id, \"forward me\", protect_content=False),\n        )\n        to_forward_protected, to_forward_unprotected = await tasks\n\n        assert to_forward_protected.has_protected_content\n        assert not to_forward_unprotected.has_protected_content\n\n        forwarded_but_now_protected = await to_forward_unprotected.forward(\n            chat_id, protect_content=True\n        )\n        assert forwarded_but_now_protected.has_protected_content\n\n        tasks = asyncio.gather(\n            to_forward_protected.forward(chat_id),\n            forwarded_but_now_protected.forward(chat_id),\n            return_exceptions=True,\n        )\n        result = await tasks\n        assert all(\"can't be forwarded\" in str(exc) for exc in result)\n\n    async def test_forward_messages(self, bot, chat_id):\n        # not using gather here to have deteriminically ordered message_ids\n        msg1 = await bot.send_message(chat_id, text=\"will be forwarded\")\n        msg2 = await bot.send_message(chat_id, text=\"will be forwarded\")\n\n        forward_messages = await bot.forward_messages(\n            chat_id, from_chat_id=chat_id, message_ids=(msg1.message_id, msg2.message_id)\n        )\n\n        assert isinstance(forward_messages, tuple)\n\n        tasks = asyncio.gather(\n            bot.send_message(\n                chat_id, \"temp 1\", reply_to_message_id=forward_messages[0].message_id\n            ),\n            bot.send_message(\n                chat_id, \"temp 2\", reply_to_message_id=forward_messages[1].message_id\n            ),\n        )\n\n        temp_msg1, temp_msg2 = await tasks\n        forward_msg1 = temp_msg1.reply_to_message\n        forward_msg2 = temp_msg2.reply_to_message\n\n        assert forward_msg1.text == msg1.text\n        assert forward_msg1.forward_origin.sender_user == msg1.from_user\n        assert isinstance(forward_msg1.forward_origin.date, dtm.datetime)\n\n        assert forward_msg2.text == msg2.text\n        assert forward_msg2.forward_origin.sender_user == msg2.from_user\n        assert isinstance(forward_msg2.forward_origin.date, dtm.datetime)\n\n    async def test_delete_message(self, bot, chat_id):\n        message = await bot.send_message(chat_id, text=\"will be deleted\")\n        assert await bot.delete_message(chat_id=chat_id, message_id=message.message_id) is True\n\n    async def test_delete_message_old_message(self, bot, chat_id):\n        with pytest.raises(BadRequest):\n            # Considering that the first message is old enough\n            await bot.delete_message(chat_id=chat_id, message_id=1)\n\n    # send_photo, send_audio, send_document, send_sticker, send_video, send_voice, send_video_note,\n    # send_media_group, send_animation, get_user_chat_boosts are tested in their respective\n    # test modules. No need to duplicate here.\n\n    async def test_delete_messages(self, bot, chat_id):\n        msg1, msg2 = await asyncio.gather(\n            bot.send_message(chat_id, text=\"will be deleted\"),\n            bot.send_message(chat_id, text=\"will be deleted\"),\n        )\n\n        assert (\n            await bot.delete_messages(chat_id=chat_id, message_ids=sorted((msg1.id, msg2.id)))\n            is True\n        )\n\n    async def test_send_venue(self, bot, chat_id):\n        longitude = -46.788279\n        latitude = -23.691288\n        title = \"title\"\n        address = \"address\"\n        foursquare_id = \"foursquare id\"\n        foursquare_type = \"foursquare type\"\n        google_place_id = \"google_place id\"\n        google_place_type = \"google_place type\"\n\n        tasks = asyncio.gather(\n            *(\n                bot.send_venue(\n                    chat_id=chat_id,\n                    title=title,\n                    address=address,\n                    latitude=latitude,\n                    longitude=longitude,\n                    protect_content=True,\n                    **i,\n                )\n                for i in (\n                    {\"foursquare_id\": foursquare_id, \"foursquare_type\": foursquare_type},\n                    {\"google_place_id\": google_place_id, \"google_place_type\": google_place_type},\n                )\n            ),\n        )\n\n        message, message2 = await tasks\n        assert message.venue\n        assert message.venue.title == title\n        assert message.venue.address == address\n        assert message.venue.location.latitude == latitude\n        assert message.venue.location.longitude == longitude\n        assert message.venue.foursquare_id == foursquare_id\n        assert message.venue.foursquare_type == foursquare_type\n        assert message.venue.google_place_id is None\n        assert message.venue.google_place_type is None\n        assert message.has_protected_content\n\n        assert message2.venue\n        assert message2.venue.title == title\n        assert message2.venue.address == address\n        assert message2.venue.location.latitude == latitude\n        assert message2.venue.location.longitude == longitude\n        assert message2.venue.google_place_id == google_place_id\n        assert message2.venue.google_place_type == google_place_type\n        assert message2.venue.foursquare_id is None\n        assert message2.venue.foursquare_type is None\n        assert message2.has_protected_content\n\n    async def test_send_contact(self, bot, chat_id):\n        phone_number = \"+11234567890\"\n        first_name = \"Leandro\"\n        last_name = \"Toledo\"\n        message = await bot.send_contact(\n            chat_id=chat_id,\n            phone_number=phone_number,\n            first_name=first_name,\n            last_name=last_name,\n            protect_content=True,\n        )\n\n        assert message.contact\n        assert message.contact.phone_number == phone_number\n        assert message.contact.first_name == first_name\n        assert message.contact.last_name == last_name\n        assert message.has_protected_content\n\n    # TODO: Add bot to group to test polls too\n    @pytest.mark.parametrize(\n        \"reply_markup\",\n        [\n            None,\n            InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n            ),\n            InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n            ).to_dict(),\n        ],\n    )\n    async def test_send_and_stop_poll(self, bot, super_group_id, reply_markup):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", InputPollOption(\"No\"), \"Maybe\"]\n        explanation = \"[Here is a link](https://google.com)\"\n        explanation_entities = [\n            MessageEntity(MessageEntity.TEXT_LINK, 0, 14, url=\"https://google.com\")\n        ]\n\n        poll_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                is_anonymous=False,\n                allows_multiple_answers=True,\n                read_timeout=60,\n                protect_content=True,\n            )\n        )\n        quiz_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                type=Poll.QUIZ,\n                correct_option_id=2,\n                is_closed=True,\n                explanation=explanation,\n                explanation_parse_mode=ParseMode.MARKDOWN_V2,\n            )\n        )\n\n        message = await poll_task\n        assert message.poll\n        assert message.poll.question == question\n        assert message.poll.options[0].text == answers[0]\n        assert message.poll.options[1].text == answers[1].text\n        assert message.poll.options[2].text == answers[2]\n        assert not message.poll.is_anonymous\n        assert message.poll.allows_multiple_answers\n        assert not message.poll.is_closed\n        assert message.poll.type == Poll.REGULAR\n        assert message.has_protected_content\n\n        # Since only the poll and not the complete message is returned, we can't check that the\n        # reply_markup is correct. So we just test that sending doesn't give an error.\n        poll = await bot.stop_poll(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert isinstance(poll, Poll)\n        assert poll.is_closed\n        assert poll.options[0].text == answers[0]\n        assert poll.options[0].voter_count == 0\n        assert poll.options[1].text == answers[1].text\n        assert poll.options[1].voter_count == 0\n        assert poll.options[2].text == answers[2]\n        assert poll.options[2].voter_count == 0\n        assert poll.question == question\n        assert poll.total_voter_count == 0\n\n        message_quiz = await quiz_task\n        assert message_quiz.poll.correct_option_id == 2\n        assert message_quiz.poll.type == Poll.QUIZ\n        assert message_quiz.poll.is_closed\n        assert message_quiz.poll.explanation == \"Here is a link\"\n        assert message_quiz.poll.explanation_entities == tuple(explanation_entities)\n        assert poll_task.done()\n        assert quiz_task.done()\n\n    @pytest.mark.parametrize(\n        (\"open_period\", \"close_date\"),\n        [(5, None), (dtm.timedelta(seconds=5), None), (None, True)],\n        ids=[\"open_period\", \"open_period-dtm\", \"close_date\"],\n    )\n    async def test_send_open_period(self, bot, super_group_id, open_period, close_date):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        if close_date:\n            close_date = dtm.datetime.utcnow() + dtm.timedelta(seconds=5.05)\n\n        message = await bot.send_poll(\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            is_anonymous=False,\n            allows_multiple_answers=True,\n            read_timeout=60,\n            open_period=open_period,\n            close_date=close_date,\n        )\n        await asyncio.sleep(5.1)\n        new_message = await bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == message.poll.id\n        assert new_message.poll.is_closed\n\n    async def test_send_close_date_default_tz(self, tz_bot, super_group_id):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        aware_close_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + dtm.timedelta(seconds=5)\n        close_date = aware_close_date.replace(tzinfo=None)\n\n        msg = await tz_bot.send_poll(  # The timezone returned from this is always converted to UTC\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            close_date=close_date,\n            read_timeout=60,\n        )\n        msg.poll._unfreeze()\n        # Sometimes there can be a few seconds delay, so don't let the test fail due to that-\n        msg.poll.close_date = msg.poll.close_date.astimezone(aware_close_date.tzinfo)\n        assert abs(msg.poll.close_date - aware_close_date) <= dtm.timedelta(seconds=5)\n\n        await asyncio.sleep(5.1)\n\n        new_message = await tz_bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=msg.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == msg.poll.id\n        assert new_message.poll.is_closed\n\n    async def test_send_poll_explanation_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.send_poll(\n            chat_id,\n            \"question\",\n            options=[\"a\", \"b\"],\n            correct_option_id=0,\n            type=Poll.QUIZ,\n            explanation=test_string,\n            explanation_entities=entities,\n        )\n\n        assert message.poll.explanation == test_string\n        assert message.poll.explanation_entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_send_poll_default_parse_mode(self, default_bot, super_group_id):\n        explanation = \"Italic Bold Code\"\n        explanation_markdown = \"_Italic_ *Bold* `Code`\"\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_poll(\n                    chat_id=super_group_id,\n                    question=question,\n                    options=answers,\n                    type=Poll.QUIZ,\n                    correct_option_id=2,\n                    is_closed=True,\n                    explanation=explanation_markdown,\n                    **i,\n                )\n                for i in ({}, {\"explanation_parse_mode\": None}, {\"explanation_parse_mode\": \"HTML\"})\n            ),\n        )\n        message1, message2, message3 = await tasks\n        assert message1.poll.explanation == explanation\n        assert message1.poll.explanation_entities == (\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.BOLD, 7, 4),\n            MessageEntity(MessageEntity.CODE, 12, 4),\n        )\n\n        assert message2.poll.explanation == explanation_markdown\n        assert message2.poll.explanation_entities == ()\n\n        assert message3.poll.explanation == explanation_markdown\n        assert message3.poll.explanation_entities == ()\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_poll_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_poll(\n                    chat_id,\n                    question=question,\n                    options=answers,\n                    reply_to_message_id=reply_to_message.message_id,\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_poll_default_protect_content(self, chat_id, default_bot):\n        tasks = asyncio.gather(\n            default_bot.send_poll(chat_id, \"Test\", [\"1\", \"2\"]),\n            default_bot.send_poll(chat_id, \"test\", [\"1\", \"2\"], protect_content=False),\n        )\n        protected_poll, unprotect_poll = await tasks\n        assert protected_poll.has_protected_content\n        assert not unprotect_poll.has_protected_content\n\n    @pytest.mark.parametrize(\"emoji\", [*Dice.ALL_EMOJI, None])\n    async def test_send_dice(self, bot, chat_id, emoji):\n        message = await bot.send_dice(chat_id, emoji=emoji, protect_content=True)\n\n        assert message.dice\n        assert message.has_protected_content\n        if emoji is None:\n            assert message.dice.emoji == Dice.DICE\n        else:\n            assert message.dice.emoji == emoji\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_dice_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_dice(\n                chat_id,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_dice(\n                chat_id,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_dice(\n                    chat_id, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_dice_default_protect_content(self, chat_id, default_bot):\n        tasks = asyncio.gather(\n            default_bot.send_dice(chat_id), default_bot.send_dice(chat_id, protect_content=False)\n        )\n        protected_dice, unprotected_dice = await tasks\n        assert protected_dice.has_protected_content\n        assert not unprotected_dice.has_protected_content\n\n    @pytest.mark.parametrize(\"chat_action\", list(ChatAction))\n    async def test_send_chat_action(self, bot, chat_id, chat_action):\n        assert await bot.send_chat_action(chat_id, chat_action)\n\n    async def test_wrong_chat_action(self, bot, chat_id):\n        with pytest.raises(BadRequest, match=\"Wrong parameter action\"):\n            await bot.send_chat_action(chat_id, \"unknown action\")\n\n    async def test_answer_inline_query_current_offset_error(self, bot, inline_results):\n        with pytest.raises(ValueError, match=\"`current_offset` and `next_offset`\"):\n            await bot.answer_inline_query(\n                1234, results=inline_results, next_offset=42, current_offset=51\n            )\n\n    async def test_save_prepared_inline_message(self, bot, chat_id):\n        # We can't really check that the result is stored correctly, we just ensur ethat we get\n        # a proper return value\n        result = InlineQueryResultArticle(\n            id=\"some_id\", title=\"title\", input_message_content=InputTextMessageContent(\"text\")\n        )\n        out = await bot.save_prepared_inline_message(chat_id, result, True, False, True, False)\n        assert isinstance(out, PreparedInlineMessage)\n\n    async def test_get_user_profile_photos(self, bot, chat_id):\n        user_profile_photos = await bot.get_user_profile_photos(chat_id)\n        assert user_profile_photos.photos[0][0].file_size == 5403\n\n    async def test_get_one_user_profile_photo(self, bot, chat_id):\n        user_profile_photos = await bot.get_user_profile_photos(chat_id, offset=0, limit=1)\n        assert user_profile_photos.total_count == 1\n        assert user_profile_photos.photos[0][0].file_size == 5403\n\n    async def test_edit_message_text(self, bot, one_time_message):\n        message = await bot.edit_message_text(\n            text=\"new_text\",\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            parse_mode=\"HTML\",\n            disable_web_page_preview=True,\n        )\n\n        assert message.text == \"new_text\"\n\n    async def test_edit_message_text_entities(self, bot, one_time_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_text(\n            text=test_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            entities=entities,\n        )\n\n        assert message.text == test_string\n        assert message.entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_edit_message_text_default_parse_mode(\n        self, default_bot, chat_id, one_time_message\n    ):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            disable_web_page_preview=True,\n        )\n        assert message.text_markdown == test_markdown_string\n        assert message.text == test_string\n\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string,\n            chat_id=message.chat_id,\n            message_id=message.message_id,\n            parse_mode=None,\n            disable_web_page_preview=True,\n        )\n        assert message.text == test_markdown_string\n        assert message.text_markdown == escape_markdown(test_markdown_string)\n\n        suffix = \" edited\"\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string + suffix,\n            chat_id=message.chat_id,\n            message_id=message.message_id,\n            parse_mode=\"HTML\",\n            disable_web_page_preview=True,\n        )\n        assert message.text == test_markdown_string + suffix\n        assert message.text_markdown == escape_markdown(test_markdown_string) + suffix\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_message_text_inline(self):\n        pass\n\n    async def test_edit_message_caption(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new_caption\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            show_caption_above_media=False,\n        )\n\n        assert message.caption == \"new_caption\"\n        assert not message.show_caption_above_media\n\n    async def test_edit_message_caption_entities(self, bot, media_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_caption(\n            caption=test_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            caption_entities=entities,\n        )\n\n        assert message.caption == test_string\n        assert message.caption_entities == tuple(entities)\n\n    # edit_message_media is tested in test_inputmedia\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_edit_message_caption_default_parse_mode(self, default_bot, media_message):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n        assert message.caption_markdown == test_markdown_string\n        assert message.caption == test_string\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            parse_mode=None,\n        )\n        assert message.caption == test_markdown_string\n        assert message.caption_markdown == escape_markdown(test_markdown_string)\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            parse_mode=\"HTML\",\n        )\n        assert message.caption == test_markdown_string\n        assert message.caption_markdown == escape_markdown(test_markdown_string)\n\n    async def test_edit_message_caption_with_parse_mode(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new *caption*\",\n            parse_mode=\"Markdown\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n\n        assert message.caption == \"new caption\"\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_message_caption_inline(self):\n        pass\n\n    async def test_edit_reply_markup(self, bot, one_time_message):\n        new_markup = InlineKeyboardMarkup([[InlineKeyboardButton(text=\"test\", callback_data=\"1\")]])\n        message = await bot.edit_message_reply_markup(\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            reply_markup=new_markup,\n        )\n\n        assert message is not True\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_reply_markup_inline(self):\n        pass\n\n    # TODO: Actually send updates to the test bot so this can be tested properly\n    @pytest.mark.parametrize(\"timeout\", [1, dtm.timedelta(seconds=1)])\n    async def test_get_updates(self, bot, timeout):\n        await bot.delete_webhook()  # make sure there is no webhook set if webhook tests failed\n        updates = await bot.get_updates(timeout=timeout)\n\n        assert isinstance(updates, tuple)\n        if updates:\n            assert isinstance(updates[0], Update)\n\n    @pytest.mark.parametrize(\n        (\"read_timeout\", \"timeout\", \"expected\"),\n        [\n            (None, None, 0),\n            (1, None, 1),\n            (None, 1, 1),\n            (None, dtm.timedelta(seconds=1), 1),\n            (DEFAULT_NONE, None, 10),\n            (DEFAULT_NONE, 1, 11),\n            (DEFAULT_NONE, dtm.timedelta(seconds=1), 11),\n            (1, 2, 3),\n            (1, dtm.timedelta(seconds=2), 3),\n        ],\n    )\n    async def test_get_updates_read_timeout_value_passing(\n        self, bot, read_timeout, timeout, expected, monkeypatch\n    ):\n        caught_read_timeout = None\n\n        async def catch_timeouts(*args, **kwargs):\n            nonlocal caught_read_timeout\n            caught_read_timeout = kwargs.get(\"read_timeout\")\n            return HTTPStatus.OK, b'{\"ok\": \"True\", \"result\": {}}'\n\n        monkeypatch.setattr(HTTPXRequest, \"do_request\", catch_timeouts)\n\n        bot = Bot(get_updates_request=HTTPXRequest(read_timeout=10), token=bot.token)\n        await bot.get_updates(read_timeout=read_timeout, timeout=timeout)\n        assert caught_read_timeout == expected\n\n    @pytest.mark.parametrize(\"use_ip\", [True, False])\n    # local file path as file_input is tested below in test_set_webhook_params\n    @pytest.mark.parametrize(\"file_input\", [\"bytes\", \"file_handle\"])\n    async def test_set_webhook_get_webhook_info_and_delete_webhook(self, bot, use_ip, file_input):\n        url = \"https://python-telegram-bot.org/test/webhook\"\n        # Get the ip address of the website - dynamically just in case it ever changes\n        ip = socket.gethostbyname(\"python-telegram-bot.org\")\n        max_connections = 7\n        allowed_updates = [\"message\"]\n        file_input = (\n            data_file(\"sslcert.pem\").read_bytes()\n            if file_input == \"bytes\"\n            else data_file(\"sslcert.pem\").open(\"rb\")\n        )\n        await bot.set_webhook(\n            url,\n            max_connections=max_connections,\n            allowed_updates=allowed_updates,\n            ip_address=ip if use_ip else None,\n            certificate=file_input if use_ip else None,\n        )\n\n        await asyncio.sleep(1)\n        live_info = await bot.get_webhook_info()\n        assert live_info.url == url\n        assert live_info.max_connections == max_connections\n        assert live_info.allowed_updates == tuple(allowed_updates)\n        assert live_info.ip_address == ip\n        assert live_info.has_custom_certificate == use_ip\n\n        await bot.delete_webhook()\n        await asyncio.sleep(1)\n        info = await bot.get_webhook_info()\n        assert not info.url\n        assert info.ip_address is None\n        assert info.has_custom_certificate is False\n\n    async def test_leave_chat(self, bot):\n        with pytest.raises(BadRequest, match=\"Chat not found\"):\n            await bot.leave_chat(-123456)\n\n    async def test_get_chat(self, bot, super_group_id):\n        cfi = await bot.get_chat(super_group_id)\n        assert cfi.type == \"supergroup\"\n        assert cfi.title == f\">>> telegram.Bot(test) @{bot.username}\"\n        assert cfi.id == int(super_group_id)\n\n    async def test_get_chat_administrators(self, bot, channel_id):\n        admins = await bot.get_chat_administrators(channel_id)\n        assert isinstance(admins, tuple)\n\n        for a in admins:\n            assert a.status in (\"administrator\", \"creator\")\n\n    async def test_get_chat_member_count(self, bot, channel_id):\n        count = await bot.get_chat_member_count(channel_id)\n        assert isinstance(count, int)\n        assert count > 3\n\n    async def test_get_chat_member(self, bot, channel_id, chat_id):\n        chat_member = await bot.get_chat_member(channel_id, chat_id)\n\n        assert chat_member.status == \"creator\"\n        assert chat_member.user.first_name == \"PTB\"\n        assert chat_member.user.last_name == \"Test user\"\n\n    @pytest.mark.skip(reason=\"Not implemented since we need a supergroup with many members\")\n    async def test_set_chat_sticker_set(self):\n        pass\n\n    @pytest.mark.skip(reason=\"Not implemented since we need a supergroup with many members\")\n    async def test_delete_chat_sticker_set(self):\n        pass\n\n    async def test_send_game(self, bot, chat_id):\n        game_short_name = \"test_game\"\n        message = await bot.send_game(chat_id, game_short_name, protect_content=True)\n\n        assert message.game\n        assert (\n            message.game.description\n            == \"A no-op test game, for python-telegram-bot bot framework testing.\"\n        )\n        assert message.game.animation.file_id\n        # We added some test bots later and for some reason the file size is not the same for them\n        # so we accept three different sizes here. Shouldn't be too much of\n        assert message.game.photo[0].file_size in [851, 4928, 850]\n        assert message.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        game_short_name = \"test_game\"\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_game(\n                chat_id,\n                game_short_name,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_game(\n                chat_id,\n                game_short_name,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_game(\n                    chat_id, game_short_name, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"val\"),\n        [({\"protect_content\": True}, True), ({\"protect_content\": False}, None)],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_protect_content(self, default_bot, chat_id, val):\n        protected = await default_bot.send_game(chat_id, \"test_game\", protect_content=val)\n        assert protected.has_protected_content is val\n\n    @xfail\n    async def test_set_game_score_and_high_scores(self, bot, chat_id):\n        # First, test setting a score.\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=BASE_GAME_SCORE,  # Score value is relevant for other set_game_score_* tests!\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n        assert message.game.text != game.game.text\n\n        # Test setting a score higher than previous\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        score = BASE_GAME_SCORE + 1\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=score,\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n            disable_edit_message=True,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n        assert message.game.text == game.game.text\n\n        # Test setting a score lower than previous (should raise error)\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        score = BASE_GAME_SCORE  # Even a score equal to previous raises an error.\n\n        with pytest.raises(BadRequest, match=\"Bot_score_not_modified\"):\n            await bot.set_game_score(\n                user_id=chat_id, score=score, chat_id=game.chat_id, message_id=game.message_id\n            )\n\n        # Test force setting a lower score\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n        await asyncio.sleep(1.5)\n\n        score = BASE_GAME_SCORE - 10\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=score,\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n            force=True,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n\n        # For some reason the returned message doesn't contain the updated score. need to fetch\n        # the game again... (the service message is also absent when running the test suite)\n        game2 = await bot.send_game(chat_id, game_short_name)\n        assert str(score) in game2.game.text\n\n        # We need a game to get the scores for\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n        high_scores = await bot.get_game_high_scores(chat_id, game.chat_id, game.message_id)\n        # We assume that the other game score tests ran within 20 sec\n        assert high_scores[0].score == BASE_GAME_SCORE - 10\n\n    # send_invoice and create_invoice_link is tested in test_invoice\n    async def test_promote_chat_member(self, bot, channel_id, monkeypatch):\n        # TODO: Add bot to supergroup so this can be tested properly / give bot perms\n        with pytest.raises(BadRequest, match=\"Not enough rights\"):\n            assert await bot.promote_chat_member(\n                channel_id,\n                1325859552,\n                is_anonymous=True,\n                can_change_info=True,\n                can_post_messages=True,\n                can_edit_messages=True,\n                can_delete_messages=True,\n                can_invite_users=True,\n                can_restrict_members=True,\n                can_pin_messages=True,\n                can_promote_members=True,\n                can_manage_chat=True,\n                can_manage_video_chats=True,\n                can_manage_topics=True,\n                can_post_stories=True,\n                can_edit_stories=True,\n                can_delete_stories=True,\n                can_manage_direct_messages=True,\n            )\n\n        # Test that we pass the correct params to TG\n        async def make_assertion(*args, **_):\n            data = args[1]\n            return (\n                data.get(\"chat_id\") == channel_id\n                and data.get(\"user_id\") == 1325859552\n                and data.get(\"is_anonymous\") == 1\n                and data.get(\"can_change_info\") == 2\n                and data.get(\"can_post_messages\") == 3\n                and data.get(\"can_edit_messages\") == 4\n                and data.get(\"can_delete_messages\") == 5\n                and data.get(\"can_invite_users\") == 6\n                and data.get(\"can_restrict_members\") == 7\n                and data.get(\"can_pin_messages\") == 8\n                and data.get(\"can_promote_members\") == 9\n                and data.get(\"can_manage_chat\") == 10\n                and data.get(\"can_manage_video_chats\") == 11\n                and data.get(\"can_manage_topics\") == 12\n                and data.get(\"can_post_stories\") == 13\n                and data.get(\"can_edit_stories\") == 14\n                and data.get(\"can_delete_stories\") == 15\n                and data.get(\"can_manage_direct_messages\") == 16\n            )\n\n        monkeypatch.setattr(bot, \"_post\", make_assertion)\n        assert await bot.promote_chat_member(\n            channel_id,\n            1325859552,\n            is_anonymous=1,\n            can_change_info=2,\n            can_post_messages=3,\n            can_edit_messages=4,\n            can_delete_messages=5,\n            can_invite_users=6,\n            can_restrict_members=7,\n            can_pin_messages=8,\n            can_promote_members=9,\n            can_manage_chat=10,\n            can_manage_video_chats=11,\n            can_manage_topics=12,\n            can_post_stories=13,\n            can_edit_stories=14,\n            can_delete_stories=15,\n            can_manage_direct_messages=16,\n        )\n\n    async def test_export_chat_invite_link(self, bot, channel_id):\n        # Each link is unique apparently\n        invite_link = await bot.export_chat_invite_link(channel_id)\n        assert isinstance(invite_link, str)\n        assert invite_link\n\n    async def test_edit_revoke_chat_invite_link_passing_link_objects(self, bot, channel_id):\n        invite_link = await bot.create_chat_invite_link(chat_id=channel_id)\n        assert invite_link.name is None\n\n        edited_link = await bot.edit_chat_invite_link(\n            chat_id=channel_id, invite_link=invite_link, name=\"some_name\"\n        )\n        assert edited_link == invite_link\n        assert edited_link.name == \"some_name\"\n\n        revoked_link = await bot.revoke_chat_invite_link(\n            chat_id=channel_id, invite_link=edited_link\n        )\n        assert revoked_link.invite_link == edited_link.invite_link\n        assert revoked_link.is_revoked is True\n        assert revoked_link.name == \"some_name\"\n\n    @pytest.mark.parametrize(\"creates_join_request\", [True, False])\n    @pytest.mark.parametrize(\"name\", [None, \"name\"])\n    async def test_create_chat_invite_link_basics(\n        self, bot, creates_join_request, name, channel_id\n    ):\n        data = {}\n        if creates_join_request:\n            data[\"creates_join_request\"] = True\n        if name:\n            data[\"name\"] = name\n        invite_link = await bot.create_chat_invite_link(chat_id=channel_id, **data)\n\n        assert invite_link.member_limit is None\n        assert invite_link.expire_date is None\n        assert invite_link.creates_join_request == creates_join_request\n        assert invite_link.name == name\n\n        revoked_link = await bot.revoke_chat_invite_link(\n            chat_id=channel_id, invite_link=invite_link.invite_link\n        )\n        assert revoked_link.is_revoked\n\n    @pytest.mark.parametrize(\"datetime\", argvalues=[True, False], ids=[\"datetime\", \"integer\"])\n    async def test_advanced_chat_invite_links(self, bot, channel_id, datetime):\n        # we are testing this all in one function in order to save api calls\n        timestamp = dtm.datetime.utcnow()\n        add_seconds = dtm.timedelta(0, 70)\n        time_in_future = timestamp + add_seconds\n        expire_time = time_in_future if datetime else to_timestamp(time_in_future)\n        aware_time_in_future = localize(time_in_future, UTC)\n\n        invite_link = await bot.create_chat_invite_link(\n            channel_id, expire_date=expire_time, member_limit=10\n        )\n        assert invite_link.invite_link\n        assert not invite_link.invite_link.endswith(\"...\")\n        assert abs(invite_link.expire_date - aware_time_in_future) < dtm.timedelta(seconds=1)\n        assert invite_link.member_limit == 10\n\n        add_seconds = dtm.timedelta(0, 80)\n        time_in_future = timestamp + add_seconds\n        expire_time = time_in_future if datetime else to_timestamp(time_in_future)\n        aware_time_in_future = localize(time_in_future, UTC)\n\n        edited_invite_link = await bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            expire_date=expire_time,\n            member_limit=20,\n            name=\"NewName\",\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert abs(edited_invite_link.expire_date - aware_time_in_future) < dtm.timedelta(\n            seconds=1\n        )\n        assert edited_invite_link.name == \"NewName\"\n        assert edited_invite_link.member_limit == 20\n\n        edited_invite_link = await bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            name=\"EvenNewerName\",\n            creates_join_request=True,\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert not edited_invite_link.expire_date\n        assert edited_invite_link.name == \"EvenNewerName\"\n        assert edited_invite_link.creates_join_request\n        assert edited_invite_link.member_limit is None\n\n        revoked_invite_link = await bot.revoke_chat_invite_link(\n            channel_id, invite_link.invite_link\n        )\n        assert revoked_invite_link.invite_link == invite_link.invite_link\n        assert revoked_invite_link.is_revoked\n\n    async def test_advanced_chat_invite_links_default_tzinfo(self, tz_bot, channel_id):\n        # we are testing this all in one function in order to save api calls\n        add_seconds = dtm.timedelta(0, 70)\n        aware_expire_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + add_seconds\n        time_in_future = aware_expire_date.replace(tzinfo=None)\n\n        invite_link = await tz_bot.create_chat_invite_link(\n            channel_id, expire_date=time_in_future, member_limit=10\n        )\n        assert invite_link.invite_link\n        assert not invite_link.invite_link.endswith(\"...\")\n        assert abs(invite_link.expire_date - aware_expire_date) < dtm.timedelta(seconds=1)\n        assert invite_link.member_limit == 10\n\n        add_seconds = dtm.timedelta(0, 80)\n        aware_expire_date += add_seconds\n        time_in_future = aware_expire_date.replace(tzinfo=None)\n\n        edited_invite_link = await tz_bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            expire_date=time_in_future,\n            member_limit=20,\n            name=\"NewName\",\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert abs(edited_invite_link.expire_date - aware_expire_date) < dtm.timedelta(seconds=1)\n        assert edited_invite_link.name == \"NewName\"\n        assert edited_invite_link.member_limit == 20\n\n        edited_invite_link = await tz_bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            name=\"EvenNewerName\",\n            creates_join_request=True,\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert not edited_invite_link.expire_date\n        assert edited_invite_link.name == \"EvenNewerName\"\n        assert edited_invite_link.creates_join_request\n        assert edited_invite_link.member_limit is None\n\n        revoked_invite_link = await tz_bot.revoke_chat_invite_link(\n            channel_id, invite_link.invite_link\n        )\n        assert revoked_invite_link.invite_link == invite_link.invite_link\n        assert revoked_invite_link.is_revoked\n\n    async def test_approve_chat_join_request(self, bot, chat_id, channel_id):\n        # TODO: Need incoming join request to properly test\n        # Since we can't create join requests on the fly, we just tests the call to TG\n        # by checking that it complains about approving a user who is already in the chat\n        with pytest.raises(BadRequest, match=\"User_already_participant\"):\n            await bot.approve_chat_join_request(chat_id=channel_id, user_id=chat_id)\n\n    async def test_decline_chat_join_request(self, bot, chat_id, channel_id):\n        # TODO: Need incoming join request to properly test\n        # Since we can't create join requests on the fly, we just tests the call to TG\n        # by checking that it complains about declining a user who is already in the chat\n        #\n        # The error message Hide_requester_missing started showing up instead of\n        # User_already_participant. Don't know why \u2026\n        with pytest.raises(BadRequest, match=r\"User_already_participant|Hide_requester_missing\"):\n            await bot.decline_chat_join_request(chat_id=channel_id, user_id=chat_id)\n\n    async def test_set_chat_photo(self, bot, channel_id):\n        async def func():\n            assert await bot.set_chat_photo(channel_id, f)\n\n        with data_file(\"telegram_test_channel.jpg\").open(\"rb\") as f:\n            await expect_bad_request(\n                func, \"Type of file mismatch\", \"Telegram did not accept the file.\"\n            )\n\n    async def test_delete_chat_photo(self, bot, channel_id):\n        async def func():\n            assert await bot.delete_chat_photo(channel_id)\n\n        await expect_bad_request(func, \"Chat_not_modified\", \"Chat photo was not set.\")\n\n    async def test_set_chat_title(self, bot, channel_id):\n        assert await bot.set_chat_title(channel_id, \">>> telegram.Bot() - Tests\")\n\n    async def test_set_chat_description(self, bot, channel_id):\n        assert await bot.set_chat_description(channel_id, \"Time: \" + str(time.time()))\n\n    async def test_pin_and_unpin_message(self, bot, super_group_id):\n        messages = []  # contains the Messages we sent\n        pinned_messages_tasks = set()  # contains the asyncio.Tasks that pin the messages\n\n        # Let's send 3 messages so we can pin them\n        awaitables = {bot.send_message(super_group_id, f\"test_pin_message_{i}\") for i in range(3)}\n\n        # We will pin the messages immediately after sending them\n        for sending_msg in asyncio.as_completed(awaitables):  # as_completed sends the messages\n            msg = await sending_msg\n            coro = bot.pin_chat_message(super_group_id, msg.message_id, True, read_timeout=10)\n            pinned_messages_tasks.add(asyncio.create_task(coro))  # start pinning the message\n            messages.append(msg)\n\n        assert len(messages) == 3  # Check if we sent 3 messages\n\n        # Check if we pinned 3 messages\n        assert all([await i for i in pinned_messages_tasks])\n        assert all(i.done() for i in pinned_messages_tasks)  # Check if all tasks are done\n\n        chat = await bot.get_chat(super_group_id)  # get the chat to check the pinned message\n        assert chat.pinned_message in messages\n\n        # Determine which message is not the most recently pinned\n        for old_pin_msg in messages:\n            if chat.pinned_message != old_pin_msg:\n                break\n\n        # Test unpinning our messages\n        tasks = asyncio.gather(\n            bot.unpin_chat_message(  # unpins any message except the most recent\n                chat_id=super_group_id,  # because we don't want to accidentally unpin the same msg\n                message_id=old_pin_msg.message_id,  # twice\n                read_timeout=10,\n            ),\n            bot.unpin_chat_message(chat_id=super_group_id, read_timeout=10),  # unpins most recent\n        )\n        assert all(await tasks)\n        assert all(i.done() for i in tasks)\n        assert await bot.unpin_all_chat_messages(super_group_id, read_timeout=10)\n\n    # get_sticker_set, upload_sticker_file, create_new_sticker_set, add_sticker_to_set,\n    # set_sticker_position_in_set, delete_sticker_from_set and get_custom_emoji_stickers,\n    # replace_sticker_in_set are tested in the test_sticker module.\n\n    # get_forum_topic_icon_stickers, edit_forum_topic, general_forum etc...\n    # are tested in the test_forum module.\n    async def test_send_message_disable_web_page_preview(self, bot, chat_id):\n        \"\"\"Test that disable_web_page_preview is substituted for link_preview_options and that\n        it still works as expected for backward compatability.\"\"\"\n        msg = await bot.send_message(\n            chat_id,\n            \"https://github.com/python-telegram-bot/python-telegram-bot\",\n            disable_web_page_preview=True,\n        )\n        assert msg.link_preview_options\n        assert msg.link_preview_options.is_disabled\n\n    async def test_send_message_link_preview_options(self, bot, chat_id):\n        \"\"\"Test whether link_preview_options is correctly passed to the API.\"\"\"\n        # btw it is possible to have no url in the text, but set a url for the preview.\n        msg = await bot.send_message(\n            chat_id,\n            \"https://github.com/python-telegram-bot/python-telegram-bot\",\n            link_preview_options=LinkPreviewOptions(prefer_small_media=True, show_above_text=True),\n        )\n        assert msg.link_preview_options\n        assert not msg.link_preview_options.is_disabled\n        # The prefer_* options aren't very consistent on the client side (big pic shown) +\n        # they are not returned by the API.\n        # assert msg.link_preview_options.prefer_small_media\n        assert msg.link_preview_options.show_above_text\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"link_preview_options\": LinkPreviewOptions(show_above_text=True)}],\n        indirect=True,\n    )\n    async def test_send_message_default_link_preview_options(self, default_bot, chat_id):\n        \"\"\"Test whether Defaults.link_preview_options is correctly fused with the passed LPO.\"\"\"\n        github_url = \"https://github.com/python-telegram-bot/python-telegram-bot\"\n        website = \"https://python-telegram-bot.org/\"\n\n        # First test just the default passing:\n        coro1 = default_bot.send_message(chat_id, github_url)\n        # Next test fusion of both LPOs:\n        coro2 = default_bot.send_message(\n            chat_id,\n            github_url,\n            link_preview_options=LinkPreviewOptions(url=website, prefer_large_media=True),\n        )\n        # Now test fusion + overriding of passed LPO:\n        coro3 = default_bot.send_message(\n            chat_id,\n            github_url,\n            link_preview_options=LinkPreviewOptions(show_above_text=False, url=website),\n        )\n        # finally test explicitly setting to None\n        coro4 = default_bot.send_message(chat_id, github_url, link_preview_options=None)\n\n        msgs = asyncio.gather(coro1, coro2, coro3, coro4)\n        msg1, msg2, msg3, msg4 = await msgs\n        assert msg1.link_preview_options\n        assert msg1.link_preview_options.show_above_text\n\n        assert msg2.link_preview_options\n        assert msg2.link_preview_options.show_above_text\n        assert msg2.link_preview_options.url == website\n        assert msg2.link_preview_options.prefer_large_media  # Now works correctly using new url..\n\n        assert msg3.link_preview_options\n        assert not msg3.link_preview_options.show_above_text\n        assert msg3.link_preview_options.url == website\n\n        assert msg4.link_preview_options == LinkPreviewOptions(url=github_url)\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"link_preview_options\": LinkPreviewOptions(show_above_text=True)}],\n        indirect=True,\n    )\n    async def test_edit_message_text_default_link_preview_options(self, default_bot, chat_id):\n        \"\"\"Test whether Defaults.link_preview_options is correctly fused with the passed LPO.\"\"\"\n        github_url = \"https://github.com/python-telegram-bot/python-telegram-bot\"\n        website = \"https://python-telegram-bot.org/\"\n        telegram_url = \"https://telegram.org\"\n        base_1, base_2, base_3, base_4 = await asyncio.gather(\n            *(default_bot.send_message(chat_id, telegram_url) for _ in range(4))\n        )\n\n        # First test just the default passing:\n        coro1 = base_1.edit_text(github_url)\n        # Next test fusion of both LPOs:\n        coro2 = base_2.edit_text(\n            github_url,\n            link_preview_options=LinkPreviewOptions(url=website, prefer_large_media=True),\n        )\n        # Now test fusion + overriding of passed LPO:\n        coro3 = base_3.edit_text(\n            github_url,\n            link_preview_options=LinkPreviewOptions(show_above_text=False, url=website),\n        )\n        # finally test explicitly setting to None\n        coro4 = base_4.edit_text(github_url, link_preview_options=None)\n\n        msgs = asyncio.gather(coro1, coro2, coro3, coro4)\n        msg1, msg2, msg3, msg4 = await msgs\n        assert msg1.link_preview_options\n        assert msg1.link_preview_options.show_above_text\n\n        assert msg2.link_preview_options\n        assert msg2.link_preview_options.show_above_text\n        assert msg2.link_preview_options.url == website\n        assert msg2.link_preview_options.prefer_large_media  # Now works correctly using new url..\n\n        assert msg3.link_preview_options\n        assert not msg3.link_preview_options.show_above_text\n        assert msg3.link_preview_options.url == website\n\n        assert msg4.link_preview_options == LinkPreviewOptions(url=github_url)\n\n    async def test_send_message_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code Spoiler\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n            MessageEntity(MessageEntity.SPOILER, 17, 7),\n        ]\n        message = await bot.send_message(chat_id=chat_id, text=test_string, entities=entities)\n        assert message.text == test_string\n        assert message.entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_send_message_default_parse_mode(self, default_bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_message(chat_id, test_markdown_string, **i)\n                for i in ({}, {\"parse_mode\": None}, {\"parse_mode\": \"HTML\"})\n            )\n        )\n        msg1, msg2, msg3 = await tasks\n        assert msg1.text_markdown == test_markdown_string\n        assert msg1.text == test_string\n\n        assert msg2.text == test_markdown_string\n        assert msg2.text_markdown == escape_markdown(test_markdown_string)\n\n        assert msg3.text == test_markdown_string\n        assert msg3.text_markdown == escape_markdown(test_markdown_string)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_message_default_protect_content(self, default_bot, chat_id):\n        tasks = asyncio.gather(\n            default_bot.send_message(chat_id, \"test\"),\n            default_bot.send_message(chat_id, \"test\", protect_content=False),\n        )\n        to_check, no_protect = await tasks\n        assert to_check.has_protected_content\n        assert not no_protect.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_message_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_message(\n                chat_id,\n                \"test\",\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_message(\n                chat_id, \"test\", reply_to_message_id=reply_to_message.message_id\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_message(\n                    chat_id, \"test\", reply_to_message_id=reply_to_message.message_id\n                )\n\n    async def test_get_set_my_default_administrator_rights(self, bot):\n        # Test that my default administrator rights for group are as all False\n        assert await bot.set_my_default_administrator_rights()  # clear any set rights\n        my_admin_rights_grp = await bot.get_my_default_administrator_rights()\n        assert isinstance(my_admin_rights_grp, ChatAdministratorRights)\n        assert all(not getattr(my_admin_rights_grp, at) for at in my_admin_rights_grp.__slots__)\n\n        # Test setting my default admin rights for channel\n        my_rights = ChatAdministratorRights.all_rights()\n        assert await bot.set_my_default_administrator_rights(my_rights, for_channels=True)\n        my_admin_rights_ch = await bot.get_my_default_administrator_rights(for_channels=True)\n        assert my_admin_rights_ch.can_invite_users is my_rights.can_invite_users\n        # tg bug? is_anonymous is False despite setting it True for channels:\n        assert my_admin_rights_ch.is_anonymous is not my_rights.is_anonymous\n\n        assert my_admin_rights_ch.can_manage_chat is my_rights.can_manage_chat\n        assert my_admin_rights_ch.can_delete_messages is my_rights.can_delete_messages\n        assert my_admin_rights_ch.can_edit_messages is my_rights.can_edit_messages\n        assert my_admin_rights_ch.can_post_messages is my_rights.can_post_messages\n        assert my_admin_rights_ch.can_change_info is my_rights.can_change_info\n        assert my_admin_rights_ch.can_promote_members is my_rights.can_promote_members\n        assert my_admin_rights_ch.can_restrict_members is my_rights.can_restrict_members\n        assert my_admin_rights_ch.can_pin_messages is None  # Not returned for channels\n        assert my_admin_rights_ch.can_manage_topics is None  # Not returned for channels\n\n    async def test_get_set_chat_menu_button(self, bot, chat_id):\n        # Test our chat menu button is commands-\n        menu_button = await bot.get_chat_menu_button()\n        assert isinstance(menu_button, MenuButton)\n        assert isinstance(menu_button, MenuButtonCommands)\n        assert menu_button.type == MenuButtonType.COMMANDS\n\n        # Test setting our chat menu button to Webapp.\n        my_menu = MenuButtonWebApp(\"click me!\", WebAppInfo(\"https://telegram.org/\"))\n        assert await bot.set_chat_menu_button(chat_id=chat_id, menu_button=my_menu)\n        menu_button = await bot.get_chat_menu_button(chat_id)\n        assert isinstance(menu_button, MenuButtonWebApp)\n        assert menu_button.type == MenuButtonType.WEB_APP\n        assert menu_button.text == my_menu.text\n        assert menu_button.web_app.url == my_menu.web_app.url\n\n        assert await bot.set_chat_menu_button(chat_id=chat_id, menu_button=MenuButtonDefault())\n        menu_button = await bot.get_chat_menu_button(chat_id=chat_id)\n        assert isinstance(menu_button, MenuButtonDefault)\n\n    async def test_set_and_get_my_commands(self, bot):\n        commands = [BotCommand(\"cmd1\", \"descr1\"), [\"cmd2\", \"descr2\"]]\n        assert await bot.set_my_commands([])\n        assert await bot.get_my_commands() == ()\n        assert await bot.set_my_commands(commands)\n\n        for i, bc in enumerate(await bot.get_my_commands()):\n            assert bc.command == f\"cmd{i + 1}\"\n            assert bc.description == f\"descr{i + 1}\"\n\n    async def test_get_set_delete_my_commands_with_scope(self, bot, super_group_id, chat_id):\n        group_cmds = [BotCommand(\"group_cmd\", \"visible to this supergroup only\")]\n        private_cmds = [BotCommand(\"private_cmd\", \"visible to this private chat only\")]\n        group_scope = BotCommandScopeChat(super_group_id)\n        private_scope = BotCommandScopeChat(chat_id)\n\n        # Set supergroup command list with lang code and check if the same can be returned from api\n        assert await bot.set_my_commands(group_cmds, scope=group_scope, language_code=\"en\")\n        gotten_group_cmds = await bot.get_my_commands(scope=group_scope, language_code=\"en\")\n\n        assert len(gotten_group_cmds) == len(group_cmds)\n        assert gotten_group_cmds[0].command == group_cmds[0].command\n\n        # Set private command list and check if same can be returned from the api\n        assert await bot.set_my_commands(private_cmds, scope=private_scope)\n        gotten_private_cmd = await bot.get_my_commands(scope=private_scope)\n\n        assert len(gotten_private_cmd) == len(private_cmds)\n        assert gotten_private_cmd[0].command == private_cmds[0].command\n\n        # Delete command list from that supergroup and private chat-\n        tasks = asyncio.gather(\n            bot.delete_my_commands(private_scope),\n            bot.delete_my_commands(group_scope, \"en\"),\n        )\n        assert all(await tasks)\n\n        # Check if its been deleted-\n        tasks = asyncio.gather(\n            bot.get_my_commands(private_scope),\n            bot.get_my_commands(group_scope, \"en\"),\n        )\n        deleted_priv_cmds, deleted_grp_cmds = await tasks\n\n        assert len(deleted_grp_cmds) == 0 == len(group_cmds) - 1\n        assert len(deleted_priv_cmds) == 0 == len(private_cmds) - 1\n\n        await bot.delete_my_commands()  # Delete commands from default scope\n        assert len(await bot.get_my_commands()) == 0\n\n    async def test_copy_message_without_reply(self, bot, chat_id, media_message):\n        keyboard = InlineKeyboardMarkup(\n            [[InlineKeyboardButton(text=\"test\", callback_data=\"test2\")]]\n        )\n\n        returned = await bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=\"<b>Test</b>\",\n            parse_mode=ParseMode.HTML,\n            reply_to_message_id=media_message.message_id,\n            reply_markup=keyboard,\n            show_caption_above_media=False,\n        )\n        # we send a temp message which replies to the returned message id in order to get a\n        # message object\n        temp_message = await bot.send_message(\n            chat_id, \"test\", reply_to_message_id=returned.message_id\n        )\n        message = temp_message.reply_to_message\n        assert message.chat_id == int(chat_id)\n        assert message.caption == \"Test\"\n        assert len(message.caption_entities) == 1\n        assert message.reply_markup == keyboard\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [\n            ({\"parse_mode\": ParseMode.HTML, \"allow_sending_without_reply\": True}),\n            ({\"parse_mode\": None, \"allow_sending_without_reply\": True}),\n            ({\"parse_mode\": None, \"allow_sending_without_reply\": False}),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_copy_message_with_default(self, default_bot, chat_id, media_message):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if not default_bot.defaults.allow_sending_without_reply:\n            with pytest.raises(BadRequest, match=\"not found\"):\n                await default_bot.copy_message(\n                    chat_id,\n                    from_chat_id=chat_id,\n                    message_id=media_message.message_id,\n                    caption=\"<b>Test</b>\",\n                    reply_to_message_id=reply_to_message.message_id,\n                )\n            return\n        returned = await default_bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=\"<b>Test</b>\",\n            reply_to_message_id=reply_to_message.message_id,\n        )\n        # we send a temp message which replies to the returned message id in order to get a\n        # message object\n        temp_message = await default_bot.send_message(\n            chat_id, \"test\", reply_to_message_id=returned.message_id\n        )\n        message = temp_message.reply_to_message\n        if default_bot.defaults.parse_mode:\n            assert len(message.caption_entities) == 1\n        else:\n            assert len(message.caption_entities) == 0\n\n    async def test_copy_messages(self, bot, chat_id):\n        # not using gather here to have deterministically ordered message_ids\n        msg1 = await bot.send_message(chat_id, text=\"will be copied 1\")\n        msg2 = await bot.send_message(chat_id, text=\"will be copied 2\")\n\n        copy_messages = await bot.copy_messages(\n            chat_id, from_chat_id=chat_id, message_ids=(msg1.message_id, msg2.message_id)\n        )\n        assert isinstance(copy_messages, tuple)\n\n        tasks = asyncio.gather(\n            bot.send_message(chat_id, \"temp 1\", reply_to_message_id=copy_messages[0].message_id),\n            bot.send_message(chat_id, \"temp 2\", reply_to_message_id=copy_messages[1].message_id),\n        )\n        temp_msg1, temp_msg2 = await tasks\n\n        forward_msg1 = temp_msg1.reply_to_message\n        forward_msg2 = temp_msg2.reply_to_message\n\n        assert forward_msg1.text == msg1.text\n        assert forward_msg2.text == msg2.text\n\n    # Continue testing arbitrary callback data here with actual requests:\n    async def test_replace_callback_data_send_message(self, cdc_bot, chat_id):\n        bot = cdc_bot\n\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            message = await bot.send_message(\n                chat_id=chat_id, text=\"test\", reply_markup=reply_markup\n            )\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_replace_callback_data_stop_poll_and_repl_to_message(self, cdc_bot, chat_id):\n        bot = cdc_bot\n\n        poll_message = await bot.send_poll(chat_id=chat_id, question=\"test\", options=[\"1\", \"2\"])\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            await poll_message.stop_poll(reply_markup=reply_markup)\n            helper_message = await poll_message.reply_text(\"temp\", do_quote=True)\n            message = helper_message.reply_to_message\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_replace_callback_data_copy_message(self, cdc_bot, chat_id):\n        \"\"\"This also tests that data is inserted into the buttons of message.reply_to_message\n        where message is the return value of a bot method\"\"\"\n        bot = cdc_bot\n\n        original_message = await bot.send_message(chat_id=chat_id, text=\"original\")\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            message_id = await original_message.copy(chat_id=chat_id, reply_markup=reply_markup)\n            helper_message = await bot.send_message(\n                chat_id=chat_id, reply_to_message_id=message_id.message_id, text=\"temp\"\n            )\n            message = helper_message.reply_to_message\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_get_chat_arbitrary_callback_data(self, chat_id, cdc_bot):\n        bot = cdc_bot\n\n        try:\n            reply_markup = InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"callback_data\")\n            )\n\n            message = await bot.send_message(\n                chat_id, text=\"get_chat_arbitrary_callback_data\", reply_markup=reply_markup\n            )\n            await message.pin()\n\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"callback_data\"\n\n            cfi = await bot.get_chat(chat_id)\n\n            if not cfi.pinned_message:\n                pytest.xfail(\"Pinning messages is not always reliable on TG\")\n\n            assert cfi.pinned_message == message\n            assert cfi.pinned_message.reply_markup == reply_markup\n            assert await message.unpin()  # (not placed in finally block since msg can be unbound)\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_arbitrary_callback_data_get_chat_no_pinned_message(\n        self, super_group_id, cdc_bot\n    ):\n        bot = cdc_bot\n        await bot.unpin_all_chat_messages(super_group_id)\n\n        try:\n            cfi = await bot.get_chat(super_group_id)\n\n            assert isinstance(cfi, ChatFullInfo)\n            assert int(cfi.id) == int(super_group_id)\n            assert cfi.pinned_message is None\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_set_get_my_description(self, bot):\n        default_description = f\"{bot.username} - default - {dtm.datetime.utcnow().isoformat()}\"\n        en_description = f\"{bot.username} - en - {dtm.datetime.utcnow().isoformat()}\"\n        de_description = f\"{bot.username} - de - {dtm.datetime.utcnow().isoformat()}\"\n\n        # Set the descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_description(default_description),\n                bot.set_my_description(en_description, language_code=\"en\"),\n                bot.set_my_description(de_description, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            bot.get_my_description(), bot.get_my_description(\"en\"), bot.get_my_description(\"de\")\n        ) == [\n            BotDescription(default_description),\n            BotDescription(en_description),\n            BotDescription(de_description),\n        ]\n\n        # Delete the descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_description(None),\n                bot.set_my_description(None, language_code=\"en\"),\n                bot.set_my_description(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            bot.get_my_description(), bot.get_my_description(\"en\"), bot.get_my_description(\"de\")\n        ) == 3 * [BotDescription(\"\")]\n\n    async def test_set_get_my_short_description(self, bot):\n        default_short_description = (\n            f\"{bot.username} - default - {dtm.datetime.utcnow().isoformat()}\"\n        )\n        en_short_description = f\"{bot.username} - en - {dtm.datetime.utcnow().isoformat()}\"\n        de_short_description = f\"{bot.username} - de - {dtm.datetime.utcnow().isoformat()}\"\n\n        # Set the short_descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_short_description(default_short_description),\n                bot.set_my_short_description(en_short_description, language_code=\"en\"),\n                bot.set_my_short_description(de_short_description, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            bot.get_my_short_description(),\n            bot.get_my_short_description(\"en\"),\n            bot.get_my_short_description(\"de\"),\n        ) == [\n            BotShortDescription(default_short_description),\n            BotShortDescription(en_short_description),\n            BotShortDescription(de_short_description),\n        ]\n\n        # Delete the short_descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_short_description(None),\n                bot.set_my_short_description(None, language_code=\"en\"),\n                bot.set_my_short_description(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            bot.get_my_short_description(),\n            bot.get_my_short_description(\"en\"),\n            bot.get_my_short_description(\"de\"),\n        ) == 3 * [BotShortDescription(\"\")]\n\n    async def test_set_message_reaction(self, bot, chat_id, static_message):\n        assert await bot.set_message_reaction(\n            chat_id, static_message.message_id, ReactionEmoji.THUMBS_DOWN, True\n        )\n\n    @pytest.mark.parametrize(\"bot_class\", [Bot, ExtBot])\n    async def test_do_api_request_warning_known_method(self, bot, bot_class):\n        with pytest.warns(PTBUserWarning, match=\"Please use 'Bot.get_me'\") as record:\n            await bot_class(bot.token).do_api_request(\"get_me\")\n\n        assert record[0].filename == __file__, \"Wrong stack level!\"\n\n    async def test_do_api_request_unknown_method(self, bot):\n        with pytest.raises(EndPointNotFound, match=\"'unknownEndpoint' not found\"):\n            await bot.do_api_request(\"unknown_endpoint\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    async def test_do_api_request_invalid_token(self, bot):\n        # we do not initialize the bot here on purpose b/c that's the case were we actually\n        # do not know for sure if the token is invalid or the method was not found\n        with pytest.raises(\n            InvalidToken, match=\"token was rejected by Telegram or the endpoint 'getMe'\"\n        ):\n            await Bot(\"invalid_token\").do_api_request(\"get_me\")\n\n        # same test, but with a valid token bot and unknown endpoint\n        with pytest.raises(\n            InvalidToken, match=\"token was rejected by Telegram or the endpoint 'unknownEndpoint'\"\n        ):\n            await Bot(bot.token).do_api_request(\"unknown_endpoint\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_basic_and_files(self, bot, chat_id, return_type):\n        result = await bot.do_api_request(\n            \"send_document\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"caption\": \"test_caption\",\n                \"document\": InputFile(data_file(\"telegram.png\").open(\"rb\")),\n            },\n            return_type=return_type,\n        )\n        if return_type is None:\n            assert isinstance(result, dict)\n            result = Message.de_json(result, bot)\n\n        assert isinstance(result, Message)\n        assert result.chat_id == int(chat_id)\n        assert result.caption == \"test_caption\"\n        out = BytesIO()\n        await (await result.document.get_file()).download_to_memory(out)\n        out.seek(0)\n        assert out.read() == data_file(\"telegram.png\").open(\"rb\").read()\n        assert result.document.file_name == \"telegram.png\"\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_list_return_type(self, bot, chat_id, return_type):\n        result = await bot.do_api_request(\n            \"send_media_group\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"media\": [\n                    InputMediaDocument(\n                        InputFile(\n                            data_file(\"text_file.txt\").open(\"rb\"),\n                            attach=True,\n                        )\n                    ),\n                    InputMediaDocument(\n                        InputFile(\n                            data_file(\"local_file.txt\").open(\"rb\"),\n                            attach=True,\n                        )\n                    ),\n                ],\n            },\n            return_type=return_type,\n        )\n        if return_type is None:\n            assert isinstance(result, list)\n            for entry in result:\n                assert isinstance(entry, dict)\n            result = Message.de_list(result, bot)\n\n        for message, file_name in zip(result, (\"text_file.txt\", \"local_file.txt\")):\n            assert isinstance(message, Message)\n            assert message.chat_id == int(chat_id)\n            out = BytesIO()\n            await (await message.document.get_file()).download_to_memory(out)\n            out.seek(0)\n            assert out.read() == data_file(file_name).open(\"rb\").read()\n            assert message.document.file_name == file_name\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_bool_return_type(self, bot, chat_id, return_type):\n        assert await bot.do_api_request(\"delete_my_commands\", return_type=return_type) is True\n\n    async def test_get_star_transactions(self, bot):\n        transactions = await bot.get_star_transactions(limit=1)\n        assert isinstance(transactions, StarTransactions)\n        assert len(transactions.transactions) == 0\n\n    @pytest.mark.parametrize(\"subscription_period\", [2592000, dtm.timedelta(days=30)])\n    async def test_create_edit_chat_subscription_link(\n        self, bot, subscription_channel_id, channel_id, subscription_period\n    ):\n        sub_link = await bot.create_chat_subscription_invite_link(\n            subscription_channel_id,\n            name=\"sub_name\",\n            subscription_period=subscription_period,\n            subscription_price=13,\n        )\n        assert sub_link.name == \"sub_name\"\n        assert sub_link.subscription_period == 2592000\n        assert sub_link.subscription_price == 13\n\n        edited_link = await bot.edit_chat_subscription_invite_link(\n            chat_id=subscription_channel_id, invite_link=sub_link, name=\"sub_name_2\"\n        )\n        assert edited_link.name == \"sub_name_2\"\n        assert sub_link.subscription_period == 2592000\n        assert sub_link.subscription_price == 13\n\n    async def test_get_my_star_balance(self, bot):\n        balance = await bot.get_my_star_balance()\n        assert isinstance(balance, StarAmount)\n        assert balance.amount == 0"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2663,
                            4635
                        ],
                        "reason": "The test 'test_send_message_link_preview_options' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct link preview options, and if they do not match, it could lead to assertion errors. This is critical for ensuring that the bot can send messages with the correct link preview options.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "class",
                        "code_snippet": "class TestBotWithRequest:\n    \"\"\"\n    Most are executed on tg.ext.ExtBot, as that class only extends the functionality of tg.bot\n\n    Behavior for init of ExtBot with missing optional dependency cachetools (for CallbackDataCache)\n    is tested in `test_callbackdatacache`\n    \"\"\"\n\n    # get_available_gifts, send_gift are tested in `test_gift`.\n    # No need to duplicate here.\n\n    async def test_invalid_token_server_response(self):\n        with pytest.raises(InvalidToken, match=\"The token `12` was rejected by the server\\\\.\"):\n            async with ExtBot(token=\"12\"):\n                pass\n\n    async def test_multiple_init_cycles(self, bot):\n        # nothing really to assert - this should just not fail\n        test_bot = Bot(bot.token)\n        async with test_bot:\n            await test_bot.get_me()\n        async with test_bot:\n            await test_bot.get_me()\n\n    async def test_forward_message(self, bot, chat_id, static_message):\n        forward_message = await bot.forward_message(\n            chat_id, from_chat_id=chat_id, message_id=static_message.message_id\n        )\n\n        assert forward_message.text == static_message.text\n        assert forward_message.forward_origin.sender_user == static_message.from_user\n        assert isinstance(forward_message.forward_origin.date, dtm.datetime)\n\n    async def test_forward_protected_message(self, bot, chat_id):\n        tasks = asyncio.gather(\n            bot.send_message(chat_id, \"cant forward me\", protect_content=True),\n            bot.send_message(chat_id, \"forward me\", protect_content=False),\n        )\n        to_forward_protected, to_forward_unprotected = await tasks\n\n        assert to_forward_protected.has_protected_content\n        assert not to_forward_unprotected.has_protected_content\n\n        forwarded_but_now_protected = await to_forward_unprotected.forward(\n            chat_id, protect_content=True\n        )\n        assert forwarded_but_now_protected.has_protected_content\n\n        tasks = asyncio.gather(\n            to_forward_protected.forward(chat_id),\n            forwarded_but_now_protected.forward(chat_id),\n            return_exceptions=True,\n        )\n        result = await tasks\n        assert all(\"can't be forwarded\" in str(exc) for exc in result)\n\n    async def test_forward_messages(self, bot, chat_id):\n        # not using gather here to have deteriminically ordered message_ids\n        msg1 = await bot.send_message(chat_id, text=\"will be forwarded\")\n        msg2 = await bot.send_message(chat_id, text=\"will be forwarded\")\n\n        forward_messages = await bot.forward_messages(\n            chat_id, from_chat_id=chat_id, message_ids=(msg1.message_id, msg2.message_id)\n        )\n\n        assert isinstance(forward_messages, tuple)\n\n        tasks = asyncio.gather(\n            bot.send_message(\n                chat_id, \"temp 1\", reply_to_message_id=forward_messages[0].message_id\n            ),\n            bot.send_message(\n                chat_id, \"temp 2\", reply_to_message_id=forward_messages[1].message_id\n            ),\n        )\n\n        temp_msg1, temp_msg2 = await tasks\n        forward_msg1 = temp_msg1.reply_to_message\n        forward_msg2 = temp_msg2.reply_to_message\n\n        assert forward_msg1.text == msg1.text\n        assert forward_msg1.forward_origin.sender_user == msg1.from_user\n        assert isinstance(forward_msg1.forward_origin.date, dtm.datetime)\n\n        assert forward_msg2.text == msg2.text\n        assert forward_msg2.forward_origin.sender_user == msg2.from_user\n        assert isinstance(forward_msg2.forward_origin.date, dtm.datetime)\n\n    async def test_delete_message(self, bot, chat_id):\n        message = await bot.send_message(chat_id, text=\"will be deleted\")\n        assert await bot.delete_message(chat_id=chat_id, message_id=message.message_id) is True\n\n    async def test_delete_message_old_message(self, bot, chat_id):\n        with pytest.raises(BadRequest):\n            # Considering that the first message is old enough\n            await bot.delete_message(chat_id=chat_id, message_id=1)\n\n    # send_photo, send_audio, send_document, send_sticker, send_video, send_voice, send_video_note,\n    # send_media_group, send_animation, get_user_chat_boosts are tested in their respective\n    # test modules. No need to duplicate here.\n\n    async def test_delete_messages(self, bot, chat_id):\n        msg1, msg2 = await asyncio.gather(\n            bot.send_message(chat_id, text=\"will be deleted\"),\n            bot.send_message(chat_id, text=\"will be deleted\"),\n        )\n\n        assert (\n            await bot.delete_messages(chat_id=chat_id, message_ids=sorted((msg1.id, msg2.id)))\n            is True\n        )\n\n    async def test_send_venue(self, bot, chat_id):\n        longitude = -46.788279\n        latitude = -23.691288\n        title = \"title\"\n        address = \"address\"\n        foursquare_id = \"foursquare id\"\n        foursquare_type = \"foursquare type\"\n        google_place_id = \"google_place id\"\n        google_place_type = \"google_place type\"\n\n        tasks = asyncio.gather(\n            *(\n                bot.send_venue(\n                    chat_id=chat_id,\n                    title=title,\n                    address=address,\n                    latitude=latitude,\n                    longitude=longitude,\n                    protect_content=True,\n                    **i,\n                )\n                for i in (\n                    {\"foursquare_id\": foursquare_id, \"foursquare_type\": foursquare_type},\n                    {\"google_place_id\": google_place_id, \"google_place_type\": google_place_type},\n                )\n            ),\n        )\n\n        message, message2 = await tasks\n        assert message.venue\n        assert message.venue.title == title\n        assert message.venue.address == address\n        assert message.venue.location.latitude == latitude\n        assert message.venue.location.longitude == longitude\n        assert message.venue.foursquare_id == foursquare_id\n        assert message.venue.foursquare_type == foursquare_type\n        assert message.venue.google_place_id is None\n        assert message.venue.google_place_type is None\n        assert message.has_protected_content\n\n        assert message2.venue\n        assert message2.venue.title == title\n        assert message2.venue.address == address\n        assert message2.venue.location.latitude == latitude\n        assert message2.venue.location.longitude == longitude\n        assert message2.venue.google_place_id == google_place_id\n        assert message2.venue.google_place_type == google_place_type\n        assert message2.venue.foursquare_id is None\n        assert message2.venue.foursquare_type is None\n        assert message2.has_protected_content\n\n    async def test_send_contact(self, bot, chat_id):\n        phone_number = \"+11234567890\"\n        first_name = \"Leandro\"\n        last_name = \"Toledo\"\n        message = await bot.send_contact(\n            chat_id=chat_id,\n            phone_number=phone_number,\n            first_name=first_name,\n            last_name=last_name,\n            protect_content=True,\n        )\n\n        assert message.contact\n        assert message.contact.phone_number == phone_number\n        assert message.contact.first_name == first_name\n        assert message.contact.last_name == last_name\n        assert message.has_protected_content\n\n    # TODO: Add bot to group to test polls too\n    @pytest.mark.parametrize(\n        \"reply_markup\",\n        [\n            None,\n            InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n            ),\n            InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n            ).to_dict(),\n        ],\n    )\n    async def test_send_and_stop_poll(self, bot, super_group_id, reply_markup):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", InputPollOption(\"No\"), \"Maybe\"]\n        explanation = \"[Here is a link](https://google.com)\"\n        explanation_entities = [\n            MessageEntity(MessageEntity.TEXT_LINK, 0, 14, url=\"https://google.com\")\n        ]\n\n        poll_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                is_anonymous=False,\n                allows_multiple_answers=True,\n                read_timeout=60,\n                protect_content=True,\n            )\n        )\n        quiz_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                type=Poll.QUIZ,\n                correct_option_id=2,\n                is_closed=True,\n                explanation=explanation,\n                explanation_parse_mode=ParseMode.MARKDOWN_V2,\n            )\n        )\n\n        message = await poll_task\n        assert message.poll\n        assert message.poll.question == question\n        assert message.poll.options[0].text == answers[0]\n        assert message.poll.options[1].text == answers[1].text\n        assert message.poll.options[2].text == answers[2]\n        assert not message.poll.is_anonymous\n        assert message.poll.allows_multiple_answers\n        assert not message.poll.is_closed\n        assert message.poll.type == Poll.REGULAR\n        assert message.has_protected_content\n\n        # Since only the poll and not the complete message is returned, we can't check that the\n        # reply_markup is correct. So we just test that sending doesn't give an error.\n        poll = await bot.stop_poll(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert isinstance(poll, Poll)\n        assert poll.is_closed\n        assert poll.options[0].text == answers[0]\n        assert poll.options[0].voter_count == 0\n        assert poll.options[1].text == answers[1].text\n        assert poll.options[1].voter_count == 0\n        assert poll.options[2].text == answers[2]\n        assert poll.options[2].voter_count == 0\n        assert poll.question == question\n        assert poll.total_voter_count == 0\n\n        message_quiz = await quiz_task\n        assert message_quiz.poll.correct_option_id == 2\n        assert message_quiz.poll.type == Poll.QUIZ\n        assert message_quiz.poll.is_closed\n        assert message_quiz.poll.explanation == \"Here is a link\"\n        assert message_quiz.poll.explanation_entities == tuple(explanation_entities)\n        assert poll_task.done()\n        assert quiz_task.done()\n\n    @pytest.mark.parametrize(\n        (\"open_period\", \"close_date\"),\n        [(5, None), (dtm.timedelta(seconds=5), None), (None, True)],\n        ids=[\"open_period\", \"open_period-dtm\", \"close_date\"],\n    )\n    async def test_send_open_period(self, bot, super_group_id, open_period, close_date):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        if close_date:\n            close_date = dtm.datetime.utcnow() + dtm.timedelta(seconds=5.05)\n\n        message = await bot.send_poll(\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            is_anonymous=False,\n            allows_multiple_answers=True,\n            read_timeout=60,\n            open_period=open_period,\n            close_date=close_date,\n        )\n        await asyncio.sleep(5.1)\n        new_message = await bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == message.poll.id\n        assert new_message.poll.is_closed\n\n    async def test_send_close_date_default_tz(self, tz_bot, super_group_id):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        aware_close_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + dtm.timedelta(seconds=5)\n        close_date = aware_close_date.replace(tzinfo=None)\n\n        msg = await tz_bot.send_poll(  # The timezone returned from this is always converted to UTC\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            close_date=close_date,\n            read_timeout=60,\n        )\n        msg.poll._unfreeze()\n        # Sometimes there can be a few seconds delay, so don't let the test fail due to that-\n        msg.poll.close_date = msg.poll.close_date.astimezone(aware_close_date.tzinfo)\n        assert abs(msg.poll.close_date - aware_close_date) <= dtm.timedelta(seconds=5)\n\n        await asyncio.sleep(5.1)\n\n        new_message = await tz_bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=msg.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == msg.poll.id\n        assert new_message.poll.is_closed\n\n    async def test_send_poll_explanation_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.send_poll(\n            chat_id,\n            \"question\",\n            options=[\"a\", \"b\"],\n            correct_option_id=0,\n            type=Poll.QUIZ,\n            explanation=test_string,\n            explanation_entities=entities,\n        )\n\n        assert message.poll.explanation == test_string\n        assert message.poll.explanation_entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_send_poll_default_parse_mode(self, default_bot, super_group_id):\n        explanation = \"Italic Bold Code\"\n        explanation_markdown = \"_Italic_ *Bold* `Code`\"\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_poll(\n                    chat_id=super_group_id,\n                    question=question,\n                    options=answers,\n                    type=Poll.QUIZ,\n                    correct_option_id=2,\n                    is_closed=True,\n                    explanation=explanation_markdown,\n                    **i,\n                )\n                for i in ({}, {\"explanation_parse_mode\": None}, {\"explanation_parse_mode\": \"HTML\"})\n            ),\n        )\n        message1, message2, message3 = await tasks\n        assert message1.poll.explanation == explanation\n        assert message1.poll.explanation_entities == (\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.BOLD, 7, 4),\n            MessageEntity(MessageEntity.CODE, 12, 4),\n        )\n\n        assert message2.poll.explanation == explanation_markdown\n        assert message2.poll.explanation_entities == ()\n\n        assert message3.poll.explanation == explanation_markdown\n        assert message3.poll.explanation_entities == ()\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_poll_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_poll(\n                    chat_id,\n                    question=question,\n                    options=answers,\n                    reply_to_message_id=reply_to_message.message_id,\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_poll_default_protect_content(self, chat_id, default_bot):\n        tasks = asyncio.gather(\n            default_bot.send_poll(chat_id, \"Test\", [\"1\", \"2\"]),\n            default_bot.send_poll(chat_id, \"test\", [\"1\", \"2\"], protect_content=False),\n        )\n        protected_poll, unprotect_poll = await tasks\n        assert protected_poll.has_protected_content\n        assert not unprotect_poll.has_protected_content\n\n    @pytest.mark.parametrize(\"emoji\", [*Dice.ALL_EMOJI, None])\n    async def test_send_dice(self, bot, chat_id, emoji):\n        message = await bot.send_dice(chat_id, emoji=emoji, protect_content=True)\n\n        assert message.dice\n        assert message.has_protected_content\n        if emoji is None:\n            assert message.dice.emoji == Dice.DICE\n        else:\n            assert message.dice.emoji == emoji\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_dice_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_dice(\n                chat_id,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_dice(\n                chat_id,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_dice(\n                    chat_id, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_dice_default_protect_content(self, chat_id, default_bot):\n        tasks = asyncio.gather(\n            default_bot.send_dice(chat_id), default_bot.send_dice(chat_id, protect_content=False)\n        )\n        protected_dice, unprotected_dice = await tasks\n        assert protected_dice.has_protected_content\n        assert not unprotected_dice.has_protected_content\n\n    @pytest.mark.parametrize(\"chat_action\", list(ChatAction))\n    async def test_send_chat_action(self, bot, chat_id, chat_action):\n        assert await bot.send_chat_action(chat_id, chat_action)\n\n    async def test_wrong_chat_action(self, bot, chat_id):\n        with pytest.raises(BadRequest, match=\"Wrong parameter action\"):\n            await bot.send_chat_action(chat_id, \"unknown action\")\n\n    async def test_answer_inline_query_current_offset_error(self, bot, inline_results):\n        with pytest.raises(ValueError, match=\"`current_offset` and `next_offset`\"):\n            await bot.answer_inline_query(\n                1234, results=inline_results, next_offset=42, current_offset=51\n            )\n\n    async def test_save_prepared_inline_message(self, bot, chat_id):\n        # We can't really check that the result is stored correctly, we just ensur ethat we get\n        # a proper return value\n        result = InlineQueryResultArticle(\n            id=\"some_id\", title=\"title\", input_message_content=InputTextMessageContent(\"text\")\n        )\n        out = await bot.save_prepared_inline_message(chat_id, result, True, False, True, False)\n        assert isinstance(out, PreparedInlineMessage)\n\n    async def test_get_user_profile_photos(self, bot, chat_id):\n        user_profile_photos = await bot.get_user_profile_photos(chat_id)\n        assert user_profile_photos.photos[0][0].file_size == 5403\n\n    async def test_get_one_user_profile_photo(self, bot, chat_id):\n        user_profile_photos = await bot.get_user_profile_photos(chat_id, offset=0, limit=1)\n        assert user_profile_photos.total_count == 1\n        assert user_profile_photos.photos[0][0].file_size == 5403\n\n    async def test_edit_message_text(self, bot, one_time_message):\n        message = await bot.edit_message_text(\n            text=\"new_text\",\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            parse_mode=\"HTML\",\n            disable_web_page_preview=True,\n        )\n\n        assert message.text == \"new_text\"\n\n    async def test_edit_message_text_entities(self, bot, one_time_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_text(\n            text=test_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            entities=entities,\n        )\n\n        assert message.text == test_string\n        assert message.entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_edit_message_text_default_parse_mode(\n        self, default_bot, chat_id, one_time_message\n    ):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            disable_web_page_preview=True,\n        )\n        assert message.text_markdown == test_markdown_string\n        assert message.text == test_string\n\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string,\n            chat_id=message.chat_id,\n            message_id=message.message_id,\n            parse_mode=None,\n            disable_web_page_preview=True,\n        )\n        assert message.text == test_markdown_string\n        assert message.text_markdown == escape_markdown(test_markdown_string)\n\n        suffix = \" edited\"\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string + suffix,\n            chat_id=message.chat_id,\n            message_id=message.message_id,\n            parse_mode=\"HTML\",\n            disable_web_page_preview=True,\n        )\n        assert message.text == test_markdown_string + suffix\n        assert message.text_markdown == escape_markdown(test_markdown_string) + suffix\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_message_text_inline(self):\n        pass\n\n    async def test_edit_message_caption(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new_caption\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            show_caption_above_media=False,\n        )\n\n        assert message.caption == \"new_caption\"\n        assert not message.show_caption_above_media\n\n    async def test_edit_message_caption_entities(self, bot, media_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_caption(\n            caption=test_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            caption_entities=entities,\n        )\n\n        assert message.caption == test_string\n        assert message.caption_entities == tuple(entities)\n\n    # edit_message_media is tested in test_inputmedia\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_edit_message_caption_default_parse_mode(self, default_bot, media_message):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n        assert message.caption_markdown == test_markdown_string\n        assert message.caption == test_string\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            parse_mode=None,\n        )\n        assert message.caption == test_markdown_string\n        assert message.caption_markdown == escape_markdown(test_markdown_string)\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            parse_mode=\"HTML\",\n        )\n        assert message.caption == test_markdown_string\n        assert message.caption_markdown == escape_markdown(test_markdown_string)\n\n    async def test_edit_message_caption_with_parse_mode(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new *caption*\",\n            parse_mode=\"Markdown\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n\n        assert message.caption == \"new caption\"\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_message_caption_inline(self):\n        pass\n\n    async def test_edit_reply_markup(self, bot, one_time_message):\n        new_markup = InlineKeyboardMarkup([[InlineKeyboardButton(text=\"test\", callback_data=\"1\")]])\n        message = await bot.edit_message_reply_markup(\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            reply_markup=new_markup,\n        )\n\n        assert message is not True\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_reply_markup_inline(self):\n        pass\n\n    # TODO: Actually send updates to the test bot so this can be tested properly\n    @pytest.mark.parametrize(\"timeout\", [1, dtm.timedelta(seconds=1)])\n    async def test_get_updates(self, bot, timeout):\n        await bot.delete_webhook()  # make sure there is no webhook set if webhook tests failed\n        updates = await bot.get_updates(timeout=timeout)\n\n        assert isinstance(updates, tuple)\n        if updates:\n            assert isinstance(updates[0], Update)\n\n    @pytest.mark.parametrize(\n        (\"read_timeout\", \"timeout\", \"expected\"),\n        [\n            (None, None, 0),\n            (1, None, 1),\n            (None, 1, 1),\n            (None, dtm.timedelta(seconds=1), 1),\n            (DEFAULT_NONE, None, 10),\n            (DEFAULT_NONE, 1, 11),\n            (DEFAULT_NONE, dtm.timedelta(seconds=1), 11),\n            (1, 2, 3),\n            (1, dtm.timedelta(seconds=2), 3),\n        ],\n    )\n    async def test_get_updates_read_timeout_value_passing(\n        self, bot, read_timeout, timeout, expected, monkeypatch\n    ):\n        caught_read_timeout = None\n\n        async def catch_timeouts(*args, **kwargs):\n            nonlocal caught_read_timeout\n            caught_read_timeout = kwargs.get(\"read_timeout\")\n            return HTTPStatus.OK, b'{\"ok\": \"True\", \"result\": {}}'\n\n        monkeypatch.setattr(HTTPXRequest, \"do_request\", catch_timeouts)\n\n        bot = Bot(get_updates_request=HTTPXRequest(read_timeout=10), token=bot.token)\n        await bot.get_updates(read_timeout=read_timeout, timeout=timeout)\n        assert caught_read_timeout == expected\n\n    @pytest.mark.parametrize(\"use_ip\", [True, False])\n    # local file path as file_input is tested below in test_set_webhook_params\n    @pytest.mark.parametrize(\"file_input\", [\"bytes\", \"file_handle\"])\n    async def test_set_webhook_get_webhook_info_and_delete_webhook(self, bot, use_ip, file_input):\n        url = \"https://python-telegram-bot.org/test/webhook\"\n        # Get the ip address of the website - dynamically just in case it ever changes\n        ip = socket.gethostbyname(\"python-telegram-bot.org\")\n        max_connections = 7\n        allowed_updates = [\"message\"]\n        file_input = (\n            data_file(\"sslcert.pem\").read_bytes()\n            if file_input == \"bytes\"\n            else data_file(\"sslcert.pem\").open(\"rb\")\n        )\n        await bot.set_webhook(\n            url,\n            max_connections=max_connections,\n            allowed_updates=allowed_updates,\n            ip_address=ip if use_ip else None,\n            certificate=file_input if use_ip else None,\n        )\n\n        await asyncio.sleep(1)\n        live_info = await bot.get_webhook_info()\n        assert live_info.url == url\n        assert live_info.max_connections == max_connections\n        assert live_info.allowed_updates == tuple(allowed_updates)\n        assert live_info.ip_address == ip\n        assert live_info.has_custom_certificate == use_ip\n\n        await bot.delete_webhook()\n        await asyncio.sleep(1)\n        info = await bot.get_webhook_info()\n        assert not info.url\n        assert info.ip_address is None\n        assert info.has_custom_certificate is False\n\n    async def test_leave_chat(self, bot):\n        with pytest.raises(BadRequest, match=\"Chat not found\"):\n            await bot.leave_chat(-123456)\n\n    async def test_get_chat(self, bot, super_group_id):\n        cfi = await bot.get_chat(super_group_id)\n        assert cfi.type == \"supergroup\"\n        assert cfi.title == f\">>> telegram.Bot(test) @{bot.username}\"\n        assert cfi.id == int(super_group_id)\n\n    async def test_get_chat_administrators(self, bot, channel_id):\n        admins = await bot.get_chat_administrators(channel_id)\n        assert isinstance(admins, tuple)\n\n        for a in admins:\n            assert a.status in (\"administrator\", \"creator\")\n\n    async def test_get_chat_member_count(self, bot, channel_id):\n        count = await bot.get_chat_member_count(channel_id)\n        assert isinstance(count, int)\n        assert count > 3\n\n    async def test_get_chat_member(self, bot, channel_id, chat_id):\n        chat_member = await bot.get_chat_member(channel_id, chat_id)\n\n        assert chat_member.status == \"creator\"\n        assert chat_member.user.first_name == \"PTB\"\n        assert chat_member.user.last_name == \"Test user\"\n\n    @pytest.mark.skip(reason=\"Not implemented since we need a supergroup with many members\")\n    async def test_set_chat_sticker_set(self):\n        pass\n\n    @pytest.mark.skip(reason=\"Not implemented since we need a supergroup with many members\")\n    async def test_delete_chat_sticker_set(self):\n        pass\n\n    async def test_send_game(self, bot, chat_id):\n        game_short_name = \"test_game\"\n        message = await bot.send_game(chat_id, game_short_name, protect_content=True)\n\n        assert message.game\n        assert (\n            message.game.description\n            == \"A no-op test game, for python-telegram-bot bot framework testing.\"\n        )\n        assert message.game.animation.file_id\n        # We added some test bots later and for some reason the file size is not the same for them\n        # so we accept three different sizes here. Shouldn't be too much of\n        assert message.game.photo[0].file_size in [851, 4928, 850]\n        assert message.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        game_short_name = \"test_game\"\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_game(\n                chat_id,\n                game_short_name,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_game(\n                chat_id,\n                game_short_name,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_game(\n                    chat_id, game_short_name, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"val\"),\n        [({\"protect_content\": True}, True), ({\"protect_content\": False}, None)],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_protect_content(self, default_bot, chat_id, val):\n        protected = await default_bot.send_game(chat_id, \"test_game\", protect_content=val)\n        assert protected.has_protected_content is val\n\n    @xfail\n    async def test_set_game_score_and_high_scores(self, bot, chat_id):\n        # First, test setting a score.\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=BASE_GAME_SCORE,  # Score value is relevant for other set_game_score_* tests!\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n        assert message.game.text != game.game.text\n\n        # Test setting a score higher than previous\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        score = BASE_GAME_SCORE + 1\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=score,\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n            disable_edit_message=True,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n        assert message.game.text == game.game.text\n\n        # Test setting a score lower than previous (should raise error)\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        score = BASE_GAME_SCORE  # Even a score equal to previous raises an error.\n\n        with pytest.raises(BadRequest, match=\"Bot_score_not_modified\"):\n            await bot.set_game_score(\n                user_id=chat_id, score=score, chat_id=game.chat_id, message_id=game.message_id\n            )\n\n        # Test force setting a lower score\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n        await asyncio.sleep(1.5)\n\n        score = BASE_GAME_SCORE - 10\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=score,\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n            force=True,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n\n        # For some reason the returned message doesn't contain the updated score. need to fetch\n        # the game again... (the service message is also absent when running the test suite)\n        game2 = await bot.send_game(chat_id, game_short_name)\n        assert str(score) in game2.game.text\n\n        # We need a game to get the scores for\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n        high_scores = await bot.get_game_high_scores(chat_id, game.chat_id, game.message_id)\n        # We assume that the other game score tests ran within 20 sec\n        assert high_scores[0].score == BASE_GAME_SCORE - 10\n\n    # send_invoice and create_invoice_link is tested in test_invoice\n    async def test_promote_chat_member(self, bot, channel_id, monkeypatch):\n        # TODO: Add bot to supergroup so this can be tested properly / give bot perms\n        with pytest.raises(BadRequest, match=\"Not enough rights\"):\n            assert await bot.promote_chat_member(\n                channel_id,\n                1325859552,\n                is_anonymous=True,\n                can_change_info=True,\n                can_post_messages=True,\n                can_edit_messages=True,\n                can_delete_messages=True,\n                can_invite_users=True,\n                can_restrict_members=True,\n                can_pin_messages=True,\n                can_promote_members=True,\n                can_manage_chat=True,\n                can_manage_video_chats=True,\n                can_manage_topics=True,\n                can_post_stories=True,\n                can_edit_stories=True,\n                can_delete_stories=True,\n                can_manage_direct_messages=True,\n            )\n\n        # Test that we pass the correct params to TG\n        async def make_assertion(*args, **_):\n            data = args[1]\n            return (\n                data.get(\"chat_id\") == channel_id\n                and data.get(\"user_id\") == 1325859552\n                and data.get(\"is_anonymous\") == 1\n                and data.get(\"can_change_info\") == 2\n                and data.get(\"can_post_messages\") == 3\n                and data.get(\"can_edit_messages\") == 4\n                and data.get(\"can_delete_messages\") == 5\n                and data.get(\"can_invite_users\") == 6\n                and data.get(\"can_restrict_members\") == 7\n                and data.get(\"can_pin_messages\") == 8\n                and data.get(\"can_promote_members\") == 9\n                and data.get(\"can_manage_chat\") == 10\n                and data.get(\"can_manage_video_chats\") == 11\n                and data.get(\"can_manage_topics\") == 12\n                and data.get(\"can_post_stories\") == 13\n                and data.get(\"can_edit_stories\") == 14\n                and data.get(\"can_delete_stories\") == 15\n                and data.get(\"can_manage_direct_messages\") == 16\n            )\n\n        monkeypatch.setattr(bot, \"_post\", make_assertion)\n        assert await bot.promote_chat_member(\n            channel_id,\n            1325859552,\n            is_anonymous=1,\n            can_change_info=2,\n            can_post_messages=3,\n            can_edit_messages=4,\n            can_delete_messages=5,\n            can_invite_users=6,\n            can_restrict_members=7,\n            can_pin_messages=8,\n            can_promote_members=9,\n            can_manage_chat=10,\n            can_manage_video_chats=11,\n            can_manage_topics=12,\n            can_post_stories=13,\n            can_edit_stories=14,\n            can_delete_stories=15,\n            can_manage_direct_messages=16,\n        )\n\n    async def test_export_chat_invite_link(self, bot, channel_id):\n        # Each link is unique apparently\n        invite_link = await bot.export_chat_invite_link(channel_id)\n        assert isinstance(invite_link, str)\n        assert invite_link\n\n    async def test_edit_revoke_chat_invite_link_passing_link_objects(self, bot, channel_id):\n        invite_link = await bot.create_chat_invite_link(chat_id=channel_id)\n        assert invite_link.name is None\n\n        edited_link = await bot.edit_chat_invite_link(\n            chat_id=channel_id, invite_link=invite_link, name=\"some_name\"\n        )\n        assert edited_link == invite_link\n        assert edited_link.name == \"some_name\"\n\n        revoked_link = await bot.revoke_chat_invite_link(\n            chat_id=channel_id, invite_link=edited_link\n        )\n        assert revoked_link.invite_link == edited_link.invite_link\n        assert revoked_link.is_revoked is True\n        assert revoked_link.name == \"some_name\"\n\n    @pytest.mark.parametrize(\"creates_join_request\", [True, False])\n    @pytest.mark.parametrize(\"name\", [None, \"name\"])\n    async def test_create_chat_invite_link_basics(\n        self, bot, creates_join_request, name, channel_id\n    ):\n        data = {}\n        if creates_join_request:\n            data[\"creates_join_request\"] = True\n        if name:\n            data[\"name\"] = name\n        invite_link = await bot.create_chat_invite_link(chat_id=channel_id, **data)\n\n        assert invite_link.member_limit is None\n        assert invite_link.expire_date is None\n        assert invite_link.creates_join_request == creates_join_request\n        assert invite_link.name == name\n\n        revoked_link = await bot.revoke_chat_invite_link(\n            chat_id=channel_id, invite_link=invite_link.invite_link\n        )\n        assert revoked_link.is_revoked\n\n    @pytest.mark.parametrize(\"datetime\", argvalues=[True, False], ids=[\"datetime\", \"integer\"])\n    async def test_advanced_chat_invite_links(self, bot, channel_id, datetime):\n        # we are testing this all in one function in order to save api calls\n        timestamp = dtm.datetime.utcnow()\n        add_seconds = dtm.timedelta(0, 70)\n        time_in_future = timestamp + add_seconds\n        expire_time = time_in_future if datetime else to_timestamp(time_in_future)\n        aware_time_in_future = localize(time_in_future, UTC)\n\n        invite_link = await bot.create_chat_invite_link(\n            channel_id, expire_date=expire_time, member_limit=10\n        )\n        assert invite_link.invite_link\n        assert not invite_link.invite_link.endswith(\"...\")\n        assert abs(invite_link.expire_date - aware_time_in_future) < dtm.timedelta(seconds=1)\n        assert invite_link.member_limit == 10\n\n        add_seconds = dtm.timedelta(0, 80)\n        time_in_future = timestamp + add_seconds\n        expire_time = time_in_future if datetime else to_timestamp(time_in_future)\n        aware_time_in_future = localize(time_in_future, UTC)\n\n        edited_invite_link = await bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            expire_date=expire_time,\n            member_limit=20,\n            name=\"NewName\",\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert abs(edited_invite_link.expire_date - aware_time_in_future) < dtm.timedelta(\n            seconds=1\n        )\n        assert edited_invite_link.name == \"NewName\"\n        assert edited_invite_link.member_limit == 20\n\n        edited_invite_link = await bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            name=\"EvenNewerName\",\n            creates_join_request=True,\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert not edited_invite_link.expire_date\n        assert edited_invite_link.name == \"EvenNewerName\"\n        assert edited_invite_link.creates_join_request\n        assert edited_invite_link.member_limit is None\n\n        revoked_invite_link = await bot.revoke_chat_invite_link(\n            channel_id, invite_link.invite_link\n        )\n        assert revoked_invite_link.invite_link == invite_link.invite_link\n        assert revoked_invite_link.is_revoked\n\n    async def test_advanced_chat_invite_links_default_tzinfo(self, tz_bot, channel_id):\n        # we are testing this all in one function in order to save api calls\n        add_seconds = dtm.timedelta(0, 70)\n        aware_expire_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + add_seconds\n        time_in_future = aware_expire_date.replace(tzinfo=None)\n\n        invite_link = await tz_bot.create_chat_invite_link(\n            channel_id, expire_date=time_in_future, member_limit=10\n        )\n        assert invite_link.invite_link\n        assert not invite_link.invite_link.endswith(\"...\")\n        assert abs(invite_link.expire_date - aware_expire_date) < dtm.timedelta(seconds=1)\n        assert invite_link.member_limit == 10\n\n        add_seconds = dtm.timedelta(0, 80)\n        aware_expire_date += add_seconds\n        time_in_future = aware_expire_date.replace(tzinfo=None)\n\n        edited_invite_link = await tz_bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            expire_date=time_in_future,\n            member_limit=20,\n            name=\"NewName\",\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert abs(edited_invite_link.expire_date - aware_expire_date) < dtm.timedelta(seconds=1)\n        assert edited_invite_link.name == \"NewName\"\n        assert edited_invite_link.member_limit == 20\n\n        edited_invite_link = await tz_bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            name=\"EvenNewerName\",\n            creates_join_request=True,\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert not edited_invite_link.expire_date\n        assert edited_invite_link.name == \"EvenNewerName\"\n        assert edited_invite_link.creates_join_request\n        assert edited_invite_link.member_limit is None\n\n        revoked_invite_link = await tz_bot.revoke_chat_invite_link(\n            channel_id, invite_link.invite_link\n        )\n        assert revoked_invite_link.invite_link == invite_link.invite_link\n        assert revoked_invite_link.is_revoked\n\n    async def test_approve_chat_join_request(self, bot, chat_id, channel_id):\n        # TODO: Need incoming join request to properly test\n        # Since we can't create join requests on the fly, we just tests the call to TG\n        # by checking that it complains about approving a user who is already in the chat\n        with pytest.raises(BadRequest, match=\"User_already_participant\"):\n            await bot.approve_chat_join_request(chat_id=channel_id, user_id=chat_id)\n\n    async def test_decline_chat_join_request(self, bot, chat_id, channel_id):\n        # TODO: Need incoming join request to properly test\n        # Since we can't create join requests on the fly, we just tests the call to TG\n        # by checking that it complains about declining a user who is already in the chat\n        #\n        # The error message Hide_requester_missing started showing up instead of\n        # User_already_participant. Don't know why \u2026\n        with pytest.raises(BadRequest, match=r\"User_already_participant|Hide_requester_missing\"):\n            await bot.decline_chat_join_request(chat_id=channel_id, user_id=chat_id)\n\n    async def test_set_chat_photo(self, bot, channel_id):\n        async def func():\n            assert await bot.set_chat_photo(channel_id, f)\n\n        with data_file(\"telegram_test_channel.jpg\").open(\"rb\") as f:\n            await expect_bad_request(\n                func, \"Type of file mismatch\", \"Telegram did not accept the file.\"\n            )\n\n    async def test_delete_chat_photo(self, bot, channel_id):\n        async def func():\n            assert await bot.delete_chat_photo(channel_id)\n\n        await expect_bad_request(func, \"Chat_not_modified\", \"Chat photo was not set.\")\n\n    async def test_set_chat_title(self, bot, channel_id):\n        assert await bot.set_chat_title(channel_id, \">>> telegram.Bot() - Tests\")\n\n    async def test_set_chat_description(self, bot, channel_id):\n        assert await bot.set_chat_description(channel_id, \"Time: \" + str(time.time()))\n\n    async def test_pin_and_unpin_message(self, bot, super_group_id):\n        messages = []  # contains the Messages we sent\n        pinned_messages_tasks = set()  # contains the asyncio.Tasks that pin the messages\n\n        # Let's send 3 messages so we can pin them\n        awaitables = {bot.send_message(super_group_id, f\"test_pin_message_{i}\") for i in range(3)}\n\n        # We will pin the messages immediately after sending them\n        for sending_msg in asyncio.as_completed(awaitables):  # as_completed sends the messages\n            msg = await sending_msg\n            coro = bot.pin_chat_message(super_group_id, msg.message_id, True, read_timeout=10)\n            pinned_messages_tasks.add(asyncio.create_task(coro))  # start pinning the message\n            messages.append(msg)\n\n        assert len(messages) == 3  # Check if we sent 3 messages\n\n        # Check if we pinned 3 messages\n        assert all([await i for i in pinned_messages_tasks])\n        assert all(i.done() for i in pinned_messages_tasks)  # Check if all tasks are done\n\n        chat = await bot.get_chat(super_group_id)  # get the chat to check the pinned message\n        assert chat.pinned_message in messages\n\n        # Determine which message is not the most recently pinned\n        for old_pin_msg in messages:\n            if chat.pinned_message != old_pin_msg:\n                break\n\n        # Test unpinning our messages\n        tasks = asyncio.gather(\n            bot.unpin_chat_message(  # unpins any message except the most recent\n                chat_id=super_group_id,  # because we don't want to accidentally unpin the same msg\n                message_id=old_pin_msg.message_id,  # twice\n                read_timeout=10,\n            ),\n            bot.unpin_chat_message(chat_id=super_group_id, read_timeout=10),  # unpins most recent\n        )\n        assert all(await tasks)\n        assert all(i.done() for i in tasks)\n        assert await bot.unpin_all_chat_messages(super_group_id, read_timeout=10)\n\n    # get_sticker_set, upload_sticker_file, create_new_sticker_set, add_sticker_to_set,\n    # set_sticker_position_in_set, delete_sticker_from_set and get_custom_emoji_stickers,\n    # replace_sticker_in_set are tested in the test_sticker module.\n\n    # get_forum_topic_icon_stickers, edit_forum_topic, general_forum etc...\n    # are tested in the test_forum module.\n    async def test_send_message_disable_web_page_preview(self, bot, chat_id):\n        \"\"\"Test that disable_web_page_preview is substituted for link_preview_options and that\n        it still works as expected for backward compatability.\"\"\"\n        msg = await bot.send_message(\n            chat_id,\n            \"https://github.com/python-telegram-bot/python-telegram-bot\",\n            disable_web_page_preview=True,\n        )\n        assert msg.link_preview_options\n        assert msg.link_preview_options.is_disabled\n\n    async def test_send_message_link_preview_options(self, bot, chat_id):\n        \"\"\"Test whether link_preview_options is correctly passed to the API.\"\"\"\n        # btw it is possible to have no url in the text, but set a url for the preview.\n        msg = await bot.send_message(\n            chat_id,\n            \"https://github.com/python-telegram-bot/python-telegram-bot\",\n            link_preview_options=LinkPreviewOptions(prefer_small_media=True, show_above_text=True),\n        )\n        assert msg.link_preview_options\n        assert not msg.link_preview_options.is_disabled\n        # The prefer_* options aren't very consistent on the client side (big pic shown) +\n        # they are not returned by the API.\n        # assert msg.link_preview_options.prefer_small_media\n        assert msg.link_preview_options.show_above_text\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"link_preview_options\": LinkPreviewOptions(show_above_text=True)}],\n        indirect=True,\n    )\n    async def test_send_message_default_link_preview_options(self, default_bot, chat_id):\n        \"\"\"Test whether Defaults.link_preview_options is correctly fused with the passed LPO.\"\"\"\n        github_url = \"https://github.com/python-telegram-bot/python-telegram-bot\"\n        website = \"https://python-telegram-bot.org/\"\n\n        # First test just the default passing:\n        coro1 = default_bot.send_message(chat_id, github_url)\n        # Next test fusion of both LPOs:\n        coro2 = default_bot.send_message(\n            chat_id,\n            github_url,\n            link_preview_options=LinkPreviewOptions(url=website, prefer_large_media=True),\n        )\n        # Now test fusion + overriding of passed LPO:\n        coro3 = default_bot.send_message(\n            chat_id,\n            github_url,\n            link_preview_options=LinkPreviewOptions(show_above_text=False, url=website),\n        )\n        # finally test explicitly setting to None\n        coro4 = default_bot.send_message(chat_id, github_url, link_preview_options=None)\n\n        msgs = asyncio.gather(coro1, coro2, coro3, coro4)\n        msg1, msg2, msg3, msg4 = await msgs\n        assert msg1.link_preview_options\n        assert msg1.link_preview_options.show_above_text\n\n        assert msg2.link_preview_options\n        assert msg2.link_preview_options.show_above_text\n        assert msg2.link_preview_options.url == website\n        assert msg2.link_preview_options.prefer_large_media  # Now works correctly using new url..\n\n        assert msg3.link_preview_options\n        assert not msg3.link_preview_options.show_above_text\n        assert msg3.link_preview_options.url == website\n\n        assert msg4.link_preview_options == LinkPreviewOptions(url=github_url)\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"link_preview_options\": LinkPreviewOptions(show_above_text=True)}],\n        indirect=True,\n    )\n    async def test_edit_message_text_default_link_preview_options(self, default_bot, chat_id):\n        \"\"\"Test whether Defaults.link_preview_options is correctly fused with the passed LPO.\"\"\"\n        github_url = \"https://github.com/python-telegram-bot/python-telegram-bot\"\n        website = \"https://python-telegram-bot.org/\"\n        telegram_url = \"https://telegram.org\"\n        base_1, base_2, base_3, base_4 = await asyncio.gather(\n            *(default_bot.send_message(chat_id, telegram_url) for _ in range(4))\n        )\n\n        # First test just the default passing:\n        coro1 = base_1.edit_text(github_url)\n        # Next test fusion of both LPOs:\n        coro2 = base_2.edit_text(\n            github_url,\n            link_preview_options=LinkPreviewOptions(url=website, prefer_large_media=True),\n        )\n        # Now test fusion + overriding of passed LPO:\n        coro3 = base_3.edit_text(\n            github_url,\n            link_preview_options=LinkPreviewOptions(show_above_text=False, url=website),\n        )\n        # finally test explicitly setting to None\n        coro4 = base_4.edit_text(github_url, link_preview_options=None)\n\n        msgs = asyncio.gather(coro1, coro2, coro3, coro4)\n        msg1, msg2, msg3, msg4 = await msgs\n        assert msg1.link_preview_options\n        assert msg1.link_preview_options.show_above_text\n\n        assert msg2.link_preview_options\n        assert msg2.link_preview_options.show_above_text\n        assert msg2.link_preview_options.url == website\n        assert msg2.link_preview_options.prefer_large_media  # Now works correctly using new url..\n\n        assert msg3.link_preview_options\n        assert not msg3.link_preview_options.show_above_text\n        assert msg3.link_preview_options.url == website\n\n        assert msg4.link_preview_options == LinkPreviewOptions(url=github_url)\n\n    async def test_send_message_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code Spoiler\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n            MessageEntity(MessageEntity.SPOILER, 17, 7),\n        ]\n        message = await bot.send_message(chat_id=chat_id, text=test_string, entities=entities)\n        assert message.text == test_string\n        assert message.entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_send_message_default_parse_mode(self, default_bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_message(chat_id, test_markdown_string, **i)\n                for i in ({}, {\"parse_mode\": None}, {\"parse_mode\": \"HTML\"})\n            )\n        )\n        msg1, msg2, msg3 = await tasks\n        assert msg1.text_markdown == test_markdown_string\n        assert msg1.text == test_string\n\n        assert msg2.text == test_markdown_string\n        assert msg2.text_markdown == escape_markdown(test_markdown_string)\n\n        assert msg3.text == test_markdown_string\n        assert msg3.text_markdown == escape_markdown(test_markdown_string)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_message_default_protect_content(self, default_bot, chat_id):\n        tasks = asyncio.gather(\n            default_bot.send_message(chat_id, \"test\"),\n            default_bot.send_message(chat_id, \"test\", protect_content=False),\n        )\n        to_check, no_protect = await tasks\n        assert to_check.has_protected_content\n        assert not no_protect.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_message_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_message(\n                chat_id,\n                \"test\",\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_message(\n                chat_id, \"test\", reply_to_message_id=reply_to_message.message_id\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_message(\n                    chat_id, \"test\", reply_to_message_id=reply_to_message.message_id\n                )\n\n    async def test_get_set_my_default_administrator_rights(self, bot):\n        # Test that my default administrator rights for group are as all False\n        assert await bot.set_my_default_administrator_rights()  # clear any set rights\n        my_admin_rights_grp = await bot.get_my_default_administrator_rights()\n        assert isinstance(my_admin_rights_grp, ChatAdministratorRights)\n        assert all(not getattr(my_admin_rights_grp, at) for at in my_admin_rights_grp.__slots__)\n\n        # Test setting my default admin rights for channel\n        my_rights = ChatAdministratorRights.all_rights()\n        assert await bot.set_my_default_administrator_rights(my_rights, for_channels=True)\n        my_admin_rights_ch = await bot.get_my_default_administrator_rights(for_channels=True)\n        assert my_admin_rights_ch.can_invite_users is my_rights.can_invite_users\n        # tg bug? is_anonymous is False despite setting it True for channels:\n        assert my_admin_rights_ch.is_anonymous is not my_rights.is_anonymous\n\n        assert my_admin_rights_ch.can_manage_chat is my_rights.can_manage_chat\n        assert my_admin_rights_ch.can_delete_messages is my_rights.can_delete_messages\n        assert my_admin_rights_ch.can_edit_messages is my_rights.can_edit_messages\n        assert my_admin_rights_ch.can_post_messages is my_rights.can_post_messages\n        assert my_admin_rights_ch.can_change_info is my_rights.can_change_info\n        assert my_admin_rights_ch.can_promote_members is my_rights.can_promote_members\n        assert my_admin_rights_ch.can_restrict_members is my_rights.can_restrict_members\n        assert my_admin_rights_ch.can_pin_messages is None  # Not returned for channels\n        assert my_admin_rights_ch.can_manage_topics is None  # Not returned for channels\n\n    async def test_get_set_chat_menu_button(self, bot, chat_id):\n        # Test our chat menu button is commands-\n        menu_button = await bot.get_chat_menu_button()\n        assert isinstance(menu_button, MenuButton)\n        assert isinstance(menu_button, MenuButtonCommands)\n        assert menu_button.type == MenuButtonType.COMMANDS\n\n        # Test setting our chat menu button to Webapp.\n        my_menu = MenuButtonWebApp(\"click me!\", WebAppInfo(\"https://telegram.org/\"))\n        assert await bot.set_chat_menu_button(chat_id=chat_id, menu_button=my_menu)\n        menu_button = await bot.get_chat_menu_button(chat_id)\n        assert isinstance(menu_button, MenuButtonWebApp)\n        assert menu_button.type == MenuButtonType.WEB_APP\n        assert menu_button.text == my_menu.text\n        assert menu_button.web_app.url == my_menu.web_app.url\n\n        assert await bot.set_chat_menu_button(chat_id=chat_id, menu_button=MenuButtonDefault())\n        menu_button = await bot.get_chat_menu_button(chat_id=chat_id)\n        assert isinstance(menu_button, MenuButtonDefault)\n\n    async def test_set_and_get_my_commands(self, bot):\n        commands = [BotCommand(\"cmd1\", \"descr1\"), [\"cmd2\", \"descr2\"]]\n        assert await bot.set_my_commands([])\n        assert await bot.get_my_commands() == ()\n        assert await bot.set_my_commands(commands)\n\n        for i, bc in enumerate(await bot.get_my_commands()):\n            assert bc.command == f\"cmd{i + 1}\"\n            assert bc.description == f\"descr{i + 1}\"\n\n    async def test_get_set_delete_my_commands_with_scope(self, bot, super_group_id, chat_id):\n        group_cmds = [BotCommand(\"group_cmd\", \"visible to this supergroup only\")]\n        private_cmds = [BotCommand(\"private_cmd\", \"visible to this private chat only\")]\n        group_scope = BotCommandScopeChat(super_group_id)\n        private_scope = BotCommandScopeChat(chat_id)\n\n        # Set supergroup command list with lang code and check if the same can be returned from api\n        assert await bot.set_my_commands(group_cmds, scope=group_scope, language_code=\"en\")\n        gotten_group_cmds = await bot.get_my_commands(scope=group_scope, language_code=\"en\")\n\n        assert len(gotten_group_cmds) == len(group_cmds)\n        assert gotten_group_cmds[0].command == group_cmds[0].command\n\n        # Set private command list and check if same can be returned from the api\n        assert await bot.set_my_commands(private_cmds, scope=private_scope)\n        gotten_private_cmd = await bot.get_my_commands(scope=private_scope)\n\n        assert len(gotten_private_cmd) == len(private_cmds)\n        assert gotten_private_cmd[0].command == private_cmds[0].command\n\n        # Delete command list from that supergroup and private chat-\n        tasks = asyncio.gather(\n            bot.delete_my_commands(private_scope),\n            bot.delete_my_commands(group_scope, \"en\"),\n        )\n        assert all(await tasks)\n\n        # Check if its been deleted-\n        tasks = asyncio.gather(\n            bot.get_my_commands(private_scope),\n            bot.get_my_commands(group_scope, \"en\"),\n        )\n        deleted_priv_cmds, deleted_grp_cmds = await tasks\n\n        assert len(deleted_grp_cmds) == 0 == len(group_cmds) - 1\n        assert len(deleted_priv_cmds) == 0 == len(private_cmds) - 1\n\n        await bot.delete_my_commands()  # Delete commands from default scope\n        assert len(await bot.get_my_commands()) == 0\n\n    async def test_copy_message_without_reply(self, bot, chat_id, media_message):\n        keyboard = InlineKeyboardMarkup(\n            [[InlineKeyboardButton(text=\"test\", callback_data=\"test2\")]]\n        )\n\n        returned = await bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=\"<b>Test</b>\",\n            parse_mode=ParseMode.HTML,\n            reply_to_message_id=media_message.message_id,\n            reply_markup=keyboard,\n            show_caption_above_media=False,\n        )\n        # we send a temp message which replies to the returned message id in order to get a\n        # message object\n        temp_message = await bot.send_message(\n            chat_id, \"test\", reply_to_message_id=returned.message_id\n        )\n        message = temp_message.reply_to_message\n        assert message.chat_id == int(chat_id)\n        assert message.caption == \"Test\"\n        assert len(message.caption_entities) == 1\n        assert message.reply_markup == keyboard\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [\n            ({\"parse_mode\": ParseMode.HTML, \"allow_sending_without_reply\": True}),\n            ({\"parse_mode\": None, \"allow_sending_without_reply\": True}),\n            ({\"parse_mode\": None, \"allow_sending_without_reply\": False}),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_copy_message_with_default(self, default_bot, chat_id, media_message):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if not default_bot.defaults.allow_sending_without_reply:\n            with pytest.raises(BadRequest, match=\"not found\"):\n                await default_bot.copy_message(\n                    chat_id,\n                    from_chat_id=chat_id,\n                    message_id=media_message.message_id,\n                    caption=\"<b>Test</b>\",\n                    reply_to_message_id=reply_to_message.message_id,\n                )\n            return\n        returned = await default_bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=\"<b>Test</b>\",\n            reply_to_message_id=reply_to_message.message_id,\n        )\n        # we send a temp message which replies to the returned message id in order to get a\n        # message object\n        temp_message = await default_bot.send_message(\n            chat_id, \"test\", reply_to_message_id=returned.message_id\n        )\n        message = temp_message.reply_to_message\n        if default_bot.defaults.parse_mode:\n            assert len(message.caption_entities) == 1\n        else:\n            assert len(message.caption_entities) == 0\n\n    async def test_copy_messages(self, bot, chat_id):\n        # not using gather here to have deterministically ordered message_ids\n        msg1 = await bot.send_message(chat_id, text=\"will be copied 1\")\n        msg2 = await bot.send_message(chat_id, text=\"will be copied 2\")\n\n        copy_messages = await bot.copy_messages(\n            chat_id, from_chat_id=chat_id, message_ids=(msg1.message_id, msg2.message_id)\n        )\n        assert isinstance(copy_messages, tuple)\n\n        tasks = asyncio.gather(\n            bot.send_message(chat_id, \"temp 1\", reply_to_message_id=copy_messages[0].message_id),\n            bot.send_message(chat_id, \"temp 2\", reply_to_message_id=copy_messages[1].message_id),\n        )\n        temp_msg1, temp_msg2 = await tasks\n\n        forward_msg1 = temp_msg1.reply_to_message\n        forward_msg2 = temp_msg2.reply_to_message\n\n        assert forward_msg1.text == msg1.text\n        assert forward_msg2.text == msg2.text\n\n    # Continue testing arbitrary callback data here with actual requests:\n    async def test_replace_callback_data_send_message(self, cdc_bot, chat_id):\n        bot = cdc_bot\n\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            message = await bot.send_message(\n                chat_id=chat_id, text=\"test\", reply_markup=reply_markup\n            )\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_replace_callback_data_stop_poll_and_repl_to_message(self, cdc_bot, chat_id):\n        bot = cdc_bot\n\n        poll_message = await bot.send_poll(chat_id=chat_id, question=\"test\", options=[\"1\", \"2\"])\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            await poll_message.stop_poll(reply_markup=reply_markup)\n            helper_message = await poll_message.reply_text(\"temp\", do_quote=True)\n            message = helper_message.reply_to_message\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_replace_callback_data_copy_message(self, cdc_bot, chat_id):\n        \"\"\"This also tests that data is inserted into the buttons of message.reply_to_message\n        where message is the return value of a bot method\"\"\"\n        bot = cdc_bot\n\n        original_message = await bot.send_message(chat_id=chat_id, text=\"original\")\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            message_id = await original_message.copy(chat_id=chat_id, reply_markup=reply_markup)\n            helper_message = await bot.send_message(\n                chat_id=chat_id, reply_to_message_id=message_id.message_id, text=\"temp\"\n            )\n            message = helper_message.reply_to_message\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_get_chat_arbitrary_callback_data(self, chat_id, cdc_bot):\n        bot = cdc_bot\n\n        try:\n            reply_markup = InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"callback_data\")\n            )\n\n            message = await bot.send_message(\n                chat_id, text=\"get_chat_arbitrary_callback_data\", reply_markup=reply_markup\n            )\n            await message.pin()\n\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"callback_data\"\n\n            cfi = await bot.get_chat(chat_id)\n\n            if not cfi.pinned_message:\n                pytest.xfail(\"Pinning messages is not always reliable on TG\")\n\n            assert cfi.pinned_message == message\n            assert cfi.pinned_message.reply_markup == reply_markup\n            assert await message.unpin()  # (not placed in finally block since msg can be unbound)\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_arbitrary_callback_data_get_chat_no_pinned_message(\n        self, super_group_id, cdc_bot\n    ):\n        bot = cdc_bot\n        await bot.unpin_all_chat_messages(super_group_id)\n\n        try:\n            cfi = await bot.get_chat(super_group_id)\n\n            assert isinstance(cfi, ChatFullInfo)\n            assert int(cfi.id) == int(super_group_id)\n            assert cfi.pinned_message is None\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_set_get_my_description(self, bot):\n        default_description = f\"{bot.username} - default - {dtm.datetime.utcnow().isoformat()}\"\n        en_description = f\"{bot.username} - en - {dtm.datetime.utcnow().isoformat()}\"\n        de_description = f\"{bot.username} - de - {dtm.datetime.utcnow().isoformat()}\"\n\n        # Set the descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_description(default_description),\n                bot.set_my_description(en_description, language_code=\"en\"),\n                bot.set_my_description(de_description, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            bot.get_my_description(), bot.get_my_description(\"en\"), bot.get_my_description(\"de\")\n        ) == [\n            BotDescription(default_description),\n            BotDescription(en_description),\n            BotDescription(de_description),\n        ]\n\n        # Delete the descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_description(None),\n                bot.set_my_description(None, language_code=\"en\"),\n                bot.set_my_description(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            bot.get_my_description(), bot.get_my_description(\"en\"), bot.get_my_description(\"de\")\n        ) == 3 * [BotDescription(\"\")]\n\n    async def test_set_get_my_short_description(self, bot):\n        default_short_description = (\n            f\"{bot.username} - default - {dtm.datetime.utcnow().isoformat()}\"\n        )\n        en_short_description = f\"{bot.username} - en - {dtm.datetime.utcnow().isoformat()}\"\n        de_short_description = f\"{bot.username} - de - {dtm.datetime.utcnow().isoformat()}\"\n\n        # Set the short_descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_short_description(default_short_description),\n                bot.set_my_short_description(en_short_description, language_code=\"en\"),\n                bot.set_my_short_description(de_short_description, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            bot.get_my_short_description(),\n            bot.get_my_short_description(\"en\"),\n            bot.get_my_short_description(\"de\"),\n        ) == [\n            BotShortDescription(default_short_description),\n            BotShortDescription(en_short_description),\n            BotShortDescription(de_short_description),\n        ]\n\n        # Delete the short_descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_short_description(None),\n                bot.set_my_short_description(None, language_code=\"en\"),\n                bot.set_my_short_description(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            bot.get_my_short_description(),\n            bot.get_my_short_description(\"en\"),\n            bot.get_my_short_description(\"de\"),\n        ) == 3 * [BotShortDescription(\"\")]\n\n    async def test_set_message_reaction(self, bot, chat_id, static_message):\n        assert await bot.set_message_reaction(\n            chat_id, static_message.message_id, ReactionEmoji.THUMBS_DOWN, True\n        )\n\n    @pytest.mark.parametrize(\"bot_class\", [Bot, ExtBot])\n    async def test_do_api_request_warning_known_method(self, bot, bot_class):\n        with pytest.warns(PTBUserWarning, match=\"Please use 'Bot.get_me'\") as record:\n            await bot_class(bot.token).do_api_request(\"get_me\")\n\n        assert record[0].filename == __file__, \"Wrong stack level!\"\n\n    async def test_do_api_request_unknown_method(self, bot):\n        with pytest.raises(EndPointNotFound, match=\"'unknownEndpoint' not found\"):\n            await bot.do_api_request(\"unknown_endpoint\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    async def test_do_api_request_invalid_token(self, bot):\n        # we do not initialize the bot here on purpose b/c that's the case were we actually\n        # do not know for sure if the token is invalid or the method was not found\n        with pytest.raises(\n            InvalidToken, match=\"token was rejected by Telegram or the endpoint 'getMe'\"\n        ):\n            await Bot(\"invalid_token\").do_api_request(\"get_me\")\n\n        # same test, but with a valid token bot and unknown endpoint\n        with pytest.raises(\n            InvalidToken, match=\"token was rejected by Telegram or the endpoint 'unknownEndpoint'\"\n        ):\n            await Bot(bot.token).do_api_request(\"unknown_endpoint\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_basic_and_files(self, bot, chat_id, return_type):\n        result = await bot.do_api_request(\n            \"send_document\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"caption\": \"test_caption\",\n                \"document\": InputFile(data_file(\"telegram.png\").open(\"rb\")),\n            },\n            return_type=return_type,\n        )\n        if return_type is None:\n            assert isinstance(result, dict)\n            result = Message.de_json(result, bot)\n\n        assert isinstance(result, Message)\n        assert result.chat_id == int(chat_id)\n        assert result.caption == \"test_caption\"\n        out = BytesIO()\n        await (await result.document.get_file()).download_to_memory(out)\n        out.seek(0)\n        assert out.read() == data_file(\"telegram.png\").open(\"rb\").read()\n        assert result.document.file_name == \"telegram.png\"\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_list_return_type(self, bot, chat_id, return_type):\n        result = await bot.do_api_request(\n            \"send_media_group\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"media\": [\n                    InputMediaDocument(\n                        InputFile(\n                            data_file(\"text_file.txt\").open(\"rb\"),\n                            attach=True,\n                        )\n                    ),\n                    InputMediaDocument(\n                        InputFile(\n                            data_file(\"local_file.txt\").open(\"rb\"),\n                            attach=True,\n                        )\n                    ),\n                ],\n            },\n            return_type=return_type,\n        )\n        if return_type is None:\n            assert isinstance(result, list)\n            for entry in result:\n                assert isinstance(entry, dict)\n            result = Message.de_list(result, bot)\n\n        for message, file_name in zip(result, (\"text_file.txt\", \"local_file.txt\")):\n            assert isinstance(message, Message)\n            assert message.chat_id == int(chat_id)\n            out = BytesIO()\n            await (await message.document.get_file()).download_to_memory(out)\n            out.seek(0)\n            assert out.read() == data_file(file_name).open(\"rb\").read()\n            assert message.document.file_name == file_name\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_bool_return_type(self, bot, chat_id, return_type):\n        assert await bot.do_api_request(\"delete_my_commands\", return_type=return_type) is True\n\n    async def test_get_star_transactions(self, bot):\n        transactions = await bot.get_star_transactions(limit=1)\n        assert isinstance(transactions, StarTransactions)\n        assert len(transactions.transactions) == 0\n\n    @pytest.mark.parametrize(\"subscription_period\", [2592000, dtm.timedelta(days=30)])\n    async def test_create_edit_chat_subscription_link(\n        self, bot, subscription_channel_id, channel_id, subscription_period\n    ):\n        sub_link = await bot.create_chat_subscription_invite_link(\n            subscription_channel_id,\n            name=\"sub_name\",\n            subscription_period=subscription_period,\n            subscription_price=13,\n        )\n        assert sub_link.name == \"sub_name\"\n        assert sub_link.subscription_period == 2592000\n        assert sub_link.subscription_price == 13\n\n        edited_link = await bot.edit_chat_subscription_invite_link(\n            chat_id=subscription_channel_id, invite_link=sub_link, name=\"sub_name_2\"\n        )\n        assert edited_link.name == \"sub_name_2\"\n        assert sub_link.subscription_period == 2592000\n        assert sub_link.subscription_price == 13\n\n    async def test_get_my_star_balance(self, bot):\n        balance = await bot.get_my_star_balance()\n        assert isinstance(balance, StarAmount)\n        assert balance.amount == 0"
                    },
                    {
                        "file_path": "tests/test_bot.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_bot.py",
                        "line_range": [
                            2663,
                            4635
                        ],
                        "reason": "The test 'test_send_message_disable_web_page_preview' may fail if the parameters passed do not match the expected structure. The assertion checks for the correct handling of the disable web page preview option, and if it does not match, it could lead to assertion errors. This is critical for ensuring that the bot can send messages with the correct web page preview settings.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "class",
                        "code_snippet": "class TestBotWithRequest:\n    \"\"\"\n    Most are executed on tg.ext.ExtBot, as that class only extends the functionality of tg.bot\n\n    Behavior for init of ExtBot with missing optional dependency cachetools (for CallbackDataCache)\n    is tested in `test_callbackdatacache`\n    \"\"\"\n\n    # get_available_gifts, send_gift are tested in `test_gift`.\n    # No need to duplicate here.\n\n    async def test_invalid_token_server_response(self):\n        with pytest.raises(InvalidToken, match=\"The token `12` was rejected by the server\\\\.\"):\n            async with ExtBot(token=\"12\"):\n                pass\n\n    async def test_multiple_init_cycles(self, bot):\n        # nothing really to assert - this should just not fail\n        test_bot = Bot(bot.token)\n        async with test_bot:\n            await test_bot.get_me()\n        async with test_bot:\n            await test_bot.get_me()\n\n    async def test_forward_message(self, bot, chat_id, static_message):\n        forward_message = await bot.forward_message(\n            chat_id, from_chat_id=chat_id, message_id=static_message.message_id\n        )\n\n        assert forward_message.text == static_message.text\n        assert forward_message.forward_origin.sender_user == static_message.from_user\n        assert isinstance(forward_message.forward_origin.date, dtm.datetime)\n\n    async def test_forward_protected_message(self, bot, chat_id):\n        tasks = asyncio.gather(\n            bot.send_message(chat_id, \"cant forward me\", protect_content=True),\n            bot.send_message(chat_id, \"forward me\", protect_content=False),\n        )\n        to_forward_protected, to_forward_unprotected = await tasks\n\n        assert to_forward_protected.has_protected_content\n        assert not to_forward_unprotected.has_protected_content\n\n        forwarded_but_now_protected = await to_forward_unprotected.forward(\n            chat_id, protect_content=True\n        )\n        assert forwarded_but_now_protected.has_protected_content\n\n        tasks = asyncio.gather(\n            to_forward_protected.forward(chat_id),\n            forwarded_but_now_protected.forward(chat_id),\n            return_exceptions=True,\n        )\n        result = await tasks\n        assert all(\"can't be forwarded\" in str(exc) for exc in result)\n\n    async def test_forward_messages(self, bot, chat_id):\n        # not using gather here to have deteriminically ordered message_ids\n        msg1 = await bot.send_message(chat_id, text=\"will be forwarded\")\n        msg2 = await bot.send_message(chat_id, text=\"will be forwarded\")\n\n        forward_messages = await bot.forward_messages(\n            chat_id, from_chat_id=chat_id, message_ids=(msg1.message_id, msg2.message_id)\n        )\n\n        assert isinstance(forward_messages, tuple)\n\n        tasks = asyncio.gather(\n            bot.send_message(\n                chat_id, \"temp 1\", reply_to_message_id=forward_messages[0].message_id\n            ),\n            bot.send_message(\n                chat_id, \"temp 2\", reply_to_message_id=forward_messages[1].message_id\n            ),\n        )\n\n        temp_msg1, temp_msg2 = await tasks\n        forward_msg1 = temp_msg1.reply_to_message\n        forward_msg2 = temp_msg2.reply_to_message\n\n        assert forward_msg1.text == msg1.text\n        assert forward_msg1.forward_origin.sender_user == msg1.from_user\n        assert isinstance(forward_msg1.forward_origin.date, dtm.datetime)\n\n        assert forward_msg2.text == msg2.text\n        assert forward_msg2.forward_origin.sender_user == msg2.from_user\n        assert isinstance(forward_msg2.forward_origin.date, dtm.datetime)\n\n    async def test_delete_message(self, bot, chat_id):\n        message = await bot.send_message(chat_id, text=\"will be deleted\")\n        assert await bot.delete_message(chat_id=chat_id, message_id=message.message_id) is True\n\n    async def test_delete_message_old_message(self, bot, chat_id):\n        with pytest.raises(BadRequest):\n            # Considering that the first message is old enough\n            await bot.delete_message(chat_id=chat_id, message_id=1)\n\n    # send_photo, send_audio, send_document, send_sticker, send_video, send_voice, send_video_note,\n    # send_media_group, send_animation, get_user_chat_boosts are tested in their respective\n    # test modules. No need to duplicate here.\n\n    async def test_delete_messages(self, bot, chat_id):\n        msg1, msg2 = await asyncio.gather(\n            bot.send_message(chat_id, text=\"will be deleted\"),\n            bot.send_message(chat_id, text=\"will be deleted\"),\n        )\n\n        assert (\n            await bot.delete_messages(chat_id=chat_id, message_ids=sorted((msg1.id, msg2.id)))\n            is True\n        )\n\n    async def test_send_venue(self, bot, chat_id):\n        longitude = -46.788279\n        latitude = -23.691288\n        title = \"title\"\n        address = \"address\"\n        foursquare_id = \"foursquare id\"\n        foursquare_type = \"foursquare type\"\n        google_place_id = \"google_place id\"\n        google_place_type = \"google_place type\"\n\n        tasks = asyncio.gather(\n            *(\n                bot.send_venue(\n                    chat_id=chat_id,\n                    title=title,\n                    address=address,\n                    latitude=latitude,\n                    longitude=longitude,\n                    protect_content=True,\n                    **i,\n                )\n                for i in (\n                    {\"foursquare_id\": foursquare_id, \"foursquare_type\": foursquare_type},\n                    {\"google_place_id\": google_place_id, \"google_place_type\": google_place_type},\n                )\n            ),\n        )\n\n        message, message2 = await tasks\n        assert message.venue\n        assert message.venue.title == title\n        assert message.venue.address == address\n        assert message.venue.location.latitude == latitude\n        assert message.venue.location.longitude == longitude\n        assert message.venue.foursquare_id == foursquare_id\n        assert message.venue.foursquare_type == foursquare_type\n        assert message.venue.google_place_id is None\n        assert message.venue.google_place_type is None\n        assert message.has_protected_content\n\n        assert message2.venue\n        assert message2.venue.title == title\n        assert message2.venue.address == address\n        assert message2.venue.location.latitude == latitude\n        assert message2.venue.location.longitude == longitude\n        assert message2.venue.google_place_id == google_place_id\n        assert message2.venue.google_place_type == google_place_type\n        assert message2.venue.foursquare_id is None\n        assert message2.venue.foursquare_type is None\n        assert message2.has_protected_content\n\n    async def test_send_contact(self, bot, chat_id):\n        phone_number = \"+11234567890\"\n        first_name = \"Leandro\"\n        last_name = \"Toledo\"\n        message = await bot.send_contact(\n            chat_id=chat_id,\n            phone_number=phone_number,\n            first_name=first_name,\n            last_name=last_name,\n            protect_content=True,\n        )\n\n        assert message.contact\n        assert message.contact.phone_number == phone_number\n        assert message.contact.first_name == first_name\n        assert message.contact.last_name == last_name\n        assert message.has_protected_content\n\n    # TODO: Add bot to group to test polls too\n    @pytest.mark.parametrize(\n        \"reply_markup\",\n        [\n            None,\n            InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n            ),\n            InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n            ).to_dict(),\n        ],\n    )\n    async def test_send_and_stop_poll(self, bot, super_group_id, reply_markup):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", InputPollOption(\"No\"), \"Maybe\"]\n        explanation = \"[Here is a link](https://google.com)\"\n        explanation_entities = [\n            MessageEntity(MessageEntity.TEXT_LINK, 0, 14, url=\"https://google.com\")\n        ]\n\n        poll_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                is_anonymous=False,\n                allows_multiple_answers=True,\n                read_timeout=60,\n                protect_content=True,\n            )\n        )\n        quiz_task = asyncio.create_task(\n            bot.send_poll(\n                chat_id=super_group_id,\n                question=question,\n                options=answers,\n                type=Poll.QUIZ,\n                correct_option_id=2,\n                is_closed=True,\n                explanation=explanation,\n                explanation_parse_mode=ParseMode.MARKDOWN_V2,\n            )\n        )\n\n        message = await poll_task\n        assert message.poll\n        assert message.poll.question == question\n        assert message.poll.options[0].text == answers[0]\n        assert message.poll.options[1].text == answers[1].text\n        assert message.poll.options[2].text == answers[2]\n        assert not message.poll.is_anonymous\n        assert message.poll.allows_multiple_answers\n        assert not message.poll.is_closed\n        assert message.poll.type == Poll.REGULAR\n        assert message.has_protected_content\n\n        # Since only the poll and not the complete message is returned, we can't check that the\n        # reply_markup is correct. So we just test that sending doesn't give an error.\n        poll = await bot.stop_poll(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert isinstance(poll, Poll)\n        assert poll.is_closed\n        assert poll.options[0].text == answers[0]\n        assert poll.options[0].voter_count == 0\n        assert poll.options[1].text == answers[1].text\n        assert poll.options[1].voter_count == 0\n        assert poll.options[2].text == answers[2]\n        assert poll.options[2].voter_count == 0\n        assert poll.question == question\n        assert poll.total_voter_count == 0\n\n        message_quiz = await quiz_task\n        assert message_quiz.poll.correct_option_id == 2\n        assert message_quiz.poll.type == Poll.QUIZ\n        assert message_quiz.poll.is_closed\n        assert message_quiz.poll.explanation == \"Here is a link\"\n        assert message_quiz.poll.explanation_entities == tuple(explanation_entities)\n        assert poll_task.done()\n        assert quiz_task.done()\n\n    @pytest.mark.parametrize(\n        (\"open_period\", \"close_date\"),\n        [(5, None), (dtm.timedelta(seconds=5), None), (None, True)],\n        ids=[\"open_period\", \"open_period-dtm\", \"close_date\"],\n    )\n    async def test_send_open_period(self, bot, super_group_id, open_period, close_date):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        if close_date:\n            close_date = dtm.datetime.utcnow() + dtm.timedelta(seconds=5.05)\n\n        message = await bot.send_poll(\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            is_anonymous=False,\n            allows_multiple_answers=True,\n            read_timeout=60,\n            open_period=open_period,\n            close_date=close_date,\n        )\n        await asyncio.sleep(5.1)\n        new_message = await bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=message.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == message.poll.id\n        assert new_message.poll.is_closed\n\n    async def test_send_close_date_default_tz(self, tz_bot, super_group_id):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_markup = InlineKeyboardMarkup.from_button(\n            InlineKeyboardButton(text=\"text\", callback_data=\"data\")\n        )\n\n        aware_close_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + dtm.timedelta(seconds=5)\n        close_date = aware_close_date.replace(tzinfo=None)\n\n        msg = await tz_bot.send_poll(  # The timezone returned from this is always converted to UTC\n            chat_id=super_group_id,\n            question=question,\n            options=answers,\n            close_date=close_date,\n            read_timeout=60,\n        )\n        msg.poll._unfreeze()\n        # Sometimes there can be a few seconds delay, so don't let the test fail due to that-\n        msg.poll.close_date = msg.poll.close_date.astimezone(aware_close_date.tzinfo)\n        assert abs(msg.poll.close_date - aware_close_date) <= dtm.timedelta(seconds=5)\n\n        await asyncio.sleep(5.1)\n\n        new_message = await tz_bot.edit_message_reply_markup(\n            chat_id=super_group_id,\n            message_id=msg.message_id,\n            reply_markup=reply_markup,\n            read_timeout=60,\n        )\n        assert new_message.poll.id == msg.poll.id\n        assert new_message.poll.is_closed\n\n    async def test_send_poll_explanation_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.send_poll(\n            chat_id,\n            \"question\",\n            options=[\"a\", \"b\"],\n            correct_option_id=0,\n            type=Poll.QUIZ,\n            explanation=test_string,\n            explanation_entities=entities,\n        )\n\n        assert message.poll.explanation == test_string\n        assert message.poll.explanation_entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_send_poll_default_parse_mode(self, default_bot, super_group_id):\n        explanation = \"Italic Bold Code\"\n        explanation_markdown = \"_Italic_ *Bold* `Code`\"\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_poll(\n                    chat_id=super_group_id,\n                    question=question,\n                    options=answers,\n                    type=Poll.QUIZ,\n                    correct_option_id=2,\n                    is_closed=True,\n                    explanation=explanation_markdown,\n                    **i,\n                )\n                for i in ({}, {\"explanation_parse_mode\": None}, {\"explanation_parse_mode\": \"HTML\"})\n            ),\n        )\n        message1, message2, message3 = await tasks\n        assert message1.poll.explanation == explanation\n        assert message1.poll.explanation_entities == (\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.BOLD, 7, 4),\n            MessageEntity(MessageEntity.CODE, 12, 4),\n        )\n\n        assert message2.poll.explanation == explanation_markdown\n        assert message2.poll.explanation_entities == ()\n\n        assert message3.poll.explanation == explanation_markdown\n        assert message3.poll.explanation_entities == ()\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_poll_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        question = \"Is this a test?\"\n        answers = [\"Yes\", \"No\", \"Maybe\"]\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_poll(\n                chat_id,\n                question=question,\n                options=answers,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_poll(\n                    chat_id,\n                    question=question,\n                    options=answers,\n                    reply_to_message_id=reply_to_message.message_id,\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_poll_default_protect_content(self, chat_id, default_bot):\n        tasks = asyncio.gather(\n            default_bot.send_poll(chat_id, \"Test\", [\"1\", \"2\"]),\n            default_bot.send_poll(chat_id, \"test\", [\"1\", \"2\"], protect_content=False),\n        )\n        protected_poll, unprotect_poll = await tasks\n        assert protected_poll.has_protected_content\n        assert not unprotect_poll.has_protected_content\n\n    @pytest.mark.parametrize(\"emoji\", [*Dice.ALL_EMOJI, None])\n    async def test_send_dice(self, bot, chat_id, emoji):\n        message = await bot.send_dice(chat_id, emoji=emoji, protect_content=True)\n\n        assert message.dice\n        assert message.has_protected_content\n        if emoji is None:\n            assert message.dice.emoji == Dice.DICE\n        else:\n            assert message.dice.emoji == emoji\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_dice_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_dice(\n                chat_id,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_dice(\n                chat_id,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_dice(\n                    chat_id, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_dice_default_protect_content(self, chat_id, default_bot):\n        tasks = asyncio.gather(\n            default_bot.send_dice(chat_id), default_bot.send_dice(chat_id, protect_content=False)\n        )\n        protected_dice, unprotected_dice = await tasks\n        assert protected_dice.has_protected_content\n        assert not unprotected_dice.has_protected_content\n\n    @pytest.mark.parametrize(\"chat_action\", list(ChatAction))\n    async def test_send_chat_action(self, bot, chat_id, chat_action):\n        assert await bot.send_chat_action(chat_id, chat_action)\n\n    async def test_wrong_chat_action(self, bot, chat_id):\n        with pytest.raises(BadRequest, match=\"Wrong parameter action\"):\n            await bot.send_chat_action(chat_id, \"unknown action\")\n\n    async def test_answer_inline_query_current_offset_error(self, bot, inline_results):\n        with pytest.raises(ValueError, match=\"`current_offset` and `next_offset`\"):\n            await bot.answer_inline_query(\n                1234, results=inline_results, next_offset=42, current_offset=51\n            )\n\n    async def test_save_prepared_inline_message(self, bot, chat_id):\n        # We can't really check that the result is stored correctly, we just ensur ethat we get\n        # a proper return value\n        result = InlineQueryResultArticle(\n            id=\"some_id\", title=\"title\", input_message_content=InputTextMessageContent(\"text\")\n        )\n        out = await bot.save_prepared_inline_message(chat_id, result, True, False, True, False)\n        assert isinstance(out, PreparedInlineMessage)\n\n    async def test_get_user_profile_photos(self, bot, chat_id):\n        user_profile_photos = await bot.get_user_profile_photos(chat_id)\n        assert user_profile_photos.photos[0][0].file_size == 5403\n\n    async def test_get_one_user_profile_photo(self, bot, chat_id):\n        user_profile_photos = await bot.get_user_profile_photos(chat_id, offset=0, limit=1)\n        assert user_profile_photos.total_count == 1\n        assert user_profile_photos.photos[0][0].file_size == 5403\n\n    async def test_edit_message_text(self, bot, one_time_message):\n        message = await bot.edit_message_text(\n            text=\"new_text\",\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            parse_mode=\"HTML\",\n            disable_web_page_preview=True,\n        )\n\n        assert message.text == \"new_text\"\n\n    async def test_edit_message_text_entities(self, bot, one_time_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_text(\n            text=test_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            entities=entities,\n        )\n\n        assert message.text == test_string\n        assert message.entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_edit_message_text_default_parse_mode(\n        self, default_bot, chat_id, one_time_message\n    ):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string,\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            disable_web_page_preview=True,\n        )\n        assert message.text_markdown == test_markdown_string\n        assert message.text == test_string\n\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string,\n            chat_id=message.chat_id,\n            message_id=message.message_id,\n            parse_mode=None,\n            disable_web_page_preview=True,\n        )\n        assert message.text == test_markdown_string\n        assert message.text_markdown == escape_markdown(test_markdown_string)\n\n        suffix = \" edited\"\n        message = await default_bot.edit_message_text(\n            text=test_markdown_string + suffix,\n            chat_id=message.chat_id,\n            message_id=message.message_id,\n            parse_mode=\"HTML\",\n            disable_web_page_preview=True,\n        )\n        assert message.text == test_markdown_string + suffix\n        assert message.text_markdown == escape_markdown(test_markdown_string) + suffix\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_message_text_inline(self):\n        pass\n\n    async def test_edit_message_caption(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new_caption\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            show_caption_above_media=False,\n        )\n\n        assert message.caption == \"new_caption\"\n        assert not message.show_caption_above_media\n\n    async def test_edit_message_caption_entities(self, bot, media_message):\n        test_string = \"Italic Bold Code\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n        ]\n        message = await bot.edit_message_caption(\n            caption=test_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            caption_entities=entities,\n        )\n\n        assert message.caption == test_string\n        assert message.caption_entities == tuple(entities)\n\n    # edit_message_media is tested in test_inputmedia\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_edit_message_caption_default_parse_mode(self, default_bot, media_message):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n        assert message.caption_markdown == test_markdown_string\n        assert message.caption == test_string\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            parse_mode=None,\n        )\n        assert message.caption == test_markdown_string\n        assert message.caption_markdown == escape_markdown(test_markdown_string)\n\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n        message = await default_bot.edit_message_caption(\n            caption=test_markdown_string,\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n            parse_mode=\"HTML\",\n        )\n        assert message.caption == test_markdown_string\n        assert message.caption_markdown == escape_markdown(test_markdown_string)\n\n    async def test_edit_message_caption_with_parse_mode(self, bot, media_message):\n        message = await bot.edit_message_caption(\n            caption=\"new *caption*\",\n            parse_mode=\"Markdown\",\n            chat_id=media_message.chat_id,\n            message_id=media_message.message_id,\n        )\n\n        assert message.caption == \"new caption\"\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_message_caption_inline(self):\n        pass\n\n    async def test_edit_reply_markup(self, bot, one_time_message):\n        new_markup = InlineKeyboardMarkup([[InlineKeyboardButton(text=\"test\", callback_data=\"1\")]])\n        message = await bot.edit_message_reply_markup(\n            chat_id=one_time_message.chat_id,\n            message_id=one_time_message.message_id,\n            reply_markup=new_markup,\n        )\n\n        assert message is not True\n\n    @pytest.mark.skip(reason=\"need reference to an inline message\")\n    async def test_edit_reply_markup_inline(self):\n        pass\n\n    # TODO: Actually send updates to the test bot so this can be tested properly\n    @pytest.mark.parametrize(\"timeout\", [1, dtm.timedelta(seconds=1)])\n    async def test_get_updates(self, bot, timeout):\n        await bot.delete_webhook()  # make sure there is no webhook set if webhook tests failed\n        updates = await bot.get_updates(timeout=timeout)\n\n        assert isinstance(updates, tuple)\n        if updates:\n            assert isinstance(updates[0], Update)\n\n    @pytest.mark.parametrize(\n        (\"read_timeout\", \"timeout\", \"expected\"),\n        [\n            (None, None, 0),\n            (1, None, 1),\n            (None, 1, 1),\n            (None, dtm.timedelta(seconds=1), 1),\n            (DEFAULT_NONE, None, 10),\n            (DEFAULT_NONE, 1, 11),\n            (DEFAULT_NONE, dtm.timedelta(seconds=1), 11),\n            (1, 2, 3),\n            (1, dtm.timedelta(seconds=2), 3),\n        ],\n    )\n    async def test_get_updates_read_timeout_value_passing(\n        self, bot, read_timeout, timeout, expected, monkeypatch\n    ):\n        caught_read_timeout = None\n\n        async def catch_timeouts(*args, **kwargs):\n            nonlocal caught_read_timeout\n            caught_read_timeout = kwargs.get(\"read_timeout\")\n            return HTTPStatus.OK, b'{\"ok\": \"True\", \"result\": {}}'\n\n        monkeypatch.setattr(HTTPXRequest, \"do_request\", catch_timeouts)\n\n        bot = Bot(get_updates_request=HTTPXRequest(read_timeout=10), token=bot.token)\n        await bot.get_updates(read_timeout=read_timeout, timeout=timeout)\n        assert caught_read_timeout == expected\n\n    @pytest.mark.parametrize(\"use_ip\", [True, False])\n    # local file path as file_input is tested below in test_set_webhook_params\n    @pytest.mark.parametrize(\"file_input\", [\"bytes\", \"file_handle\"])\n    async def test_set_webhook_get_webhook_info_and_delete_webhook(self, bot, use_ip, file_input):\n        url = \"https://python-telegram-bot.org/test/webhook\"\n        # Get the ip address of the website - dynamically just in case it ever changes\n        ip = socket.gethostbyname(\"python-telegram-bot.org\")\n        max_connections = 7\n        allowed_updates = [\"message\"]\n        file_input = (\n            data_file(\"sslcert.pem\").read_bytes()\n            if file_input == \"bytes\"\n            else data_file(\"sslcert.pem\").open(\"rb\")\n        )\n        await bot.set_webhook(\n            url,\n            max_connections=max_connections,\n            allowed_updates=allowed_updates,\n            ip_address=ip if use_ip else None,\n            certificate=file_input if use_ip else None,\n        )\n\n        await asyncio.sleep(1)\n        live_info = await bot.get_webhook_info()\n        assert live_info.url == url\n        assert live_info.max_connections == max_connections\n        assert live_info.allowed_updates == tuple(allowed_updates)\n        assert live_info.ip_address == ip\n        assert live_info.has_custom_certificate == use_ip\n\n        await bot.delete_webhook()\n        await asyncio.sleep(1)\n        info = await bot.get_webhook_info()\n        assert not info.url\n        assert info.ip_address is None\n        assert info.has_custom_certificate is False\n\n    async def test_leave_chat(self, bot):\n        with pytest.raises(BadRequest, match=\"Chat not found\"):\n            await bot.leave_chat(-123456)\n\n    async def test_get_chat(self, bot, super_group_id):\n        cfi = await bot.get_chat(super_group_id)\n        assert cfi.type == \"supergroup\"\n        assert cfi.title == f\">>> telegram.Bot(test) @{bot.username}\"\n        assert cfi.id == int(super_group_id)\n\n    async def test_get_chat_administrators(self, bot, channel_id):\n        admins = await bot.get_chat_administrators(channel_id)\n        assert isinstance(admins, tuple)\n\n        for a in admins:\n            assert a.status in (\"administrator\", \"creator\")\n\n    async def test_get_chat_member_count(self, bot, channel_id):\n        count = await bot.get_chat_member_count(channel_id)\n        assert isinstance(count, int)\n        assert count > 3\n\n    async def test_get_chat_member(self, bot, channel_id, chat_id):\n        chat_member = await bot.get_chat_member(channel_id, chat_id)\n\n        assert chat_member.status == \"creator\"\n        assert chat_member.user.first_name == \"PTB\"\n        assert chat_member.user.last_name == \"Test user\"\n\n    @pytest.mark.skip(reason=\"Not implemented since we need a supergroup with many members\")\n    async def test_set_chat_sticker_set(self):\n        pass\n\n    @pytest.mark.skip(reason=\"Not implemented since we need a supergroup with many members\")\n    async def test_delete_chat_sticker_set(self):\n        pass\n\n    async def test_send_game(self, bot, chat_id):\n        game_short_name = \"test_game\"\n        message = await bot.send_game(chat_id, game_short_name, protect_content=True)\n\n        assert message.game\n        assert (\n            message.game.description\n            == \"A no-op test game, for python-telegram-bot bot framework testing.\"\n        )\n        assert message.game.animation.file_id\n        # We added some test bots later and for some reason the file size is not the same for them\n        # so we accept three different sizes here. Shouldn't be too much of\n        assert message.game.photo[0].file_size in [851, 4928, 850]\n        assert message.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        game_short_name = \"test_game\"\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_game(\n                chat_id,\n                game_short_name,\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_game(\n                chat_id,\n                game_short_name,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_game(\n                    chat_id, game_short_name, reply_to_message_id=reply_to_message.message_id\n                )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"val\"),\n        [({\"protect_content\": True}, True), ({\"protect_content\": False}, None)],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_game_default_protect_content(self, default_bot, chat_id, val):\n        protected = await default_bot.send_game(chat_id, \"test_game\", protect_content=val)\n        assert protected.has_protected_content is val\n\n    @xfail\n    async def test_set_game_score_and_high_scores(self, bot, chat_id):\n        # First, test setting a score.\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=BASE_GAME_SCORE,  # Score value is relevant for other set_game_score_* tests!\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n        assert message.game.text != game.game.text\n\n        # Test setting a score higher than previous\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        score = BASE_GAME_SCORE + 1\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=score,\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n            disable_edit_message=True,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n        assert message.game.text == game.game.text\n\n        # Test setting a score lower than previous (should raise error)\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n\n        score = BASE_GAME_SCORE  # Even a score equal to previous raises an error.\n\n        with pytest.raises(BadRequest, match=\"Bot_score_not_modified\"):\n            await bot.set_game_score(\n                user_id=chat_id, score=score, chat_id=game.chat_id, message_id=game.message_id\n            )\n\n        # Test force setting a lower score\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n        await asyncio.sleep(1.5)\n\n        score = BASE_GAME_SCORE - 10\n\n        message = await bot.set_game_score(\n            user_id=chat_id,\n            score=score,\n            chat_id=game.chat_id,\n            message_id=game.message_id,\n            force=True,\n        )\n\n        assert message.game.description == game.game.description\n        assert message.game.photo[0].file_size == game.game.photo[0].file_size\n        assert message.game.animation.file_unique_id == game.game.animation.file_unique_id\n\n        # For some reason the returned message doesn't contain the updated score. need to fetch\n        # the game again... (the service message is also absent when running the test suite)\n        game2 = await bot.send_game(chat_id, game_short_name)\n        assert str(score) in game2.game.text\n\n        # We need a game to get the scores for\n        game_short_name = \"test_game\"\n        game = await bot.send_game(chat_id, game_short_name)\n        high_scores = await bot.get_game_high_scores(chat_id, game.chat_id, game.message_id)\n        # We assume that the other game score tests ran within 20 sec\n        assert high_scores[0].score == BASE_GAME_SCORE - 10\n\n    # send_invoice and create_invoice_link is tested in test_invoice\n    async def test_promote_chat_member(self, bot, channel_id, monkeypatch):\n        # TODO: Add bot to supergroup so this can be tested properly / give bot perms\n        with pytest.raises(BadRequest, match=\"Not enough rights\"):\n            assert await bot.promote_chat_member(\n                channel_id,\n                1325859552,\n                is_anonymous=True,\n                can_change_info=True,\n                can_post_messages=True,\n                can_edit_messages=True,\n                can_delete_messages=True,\n                can_invite_users=True,\n                can_restrict_members=True,\n                can_pin_messages=True,\n                can_promote_members=True,\n                can_manage_chat=True,\n                can_manage_video_chats=True,\n                can_manage_topics=True,\n                can_post_stories=True,\n                can_edit_stories=True,\n                can_delete_stories=True,\n                can_manage_direct_messages=True,\n            )\n\n        # Test that we pass the correct params to TG\n        async def make_assertion(*args, **_):\n            data = args[1]\n            return (\n                data.get(\"chat_id\") == channel_id\n                and data.get(\"user_id\") == 1325859552\n                and data.get(\"is_anonymous\") == 1\n                and data.get(\"can_change_info\") == 2\n                and data.get(\"can_post_messages\") == 3\n                and data.get(\"can_edit_messages\") == 4\n                and data.get(\"can_delete_messages\") == 5\n                and data.get(\"can_invite_users\") == 6\n                and data.get(\"can_restrict_members\") == 7\n                and data.get(\"can_pin_messages\") == 8\n                and data.get(\"can_promote_members\") == 9\n                and data.get(\"can_manage_chat\") == 10\n                and data.get(\"can_manage_video_chats\") == 11\n                and data.get(\"can_manage_topics\") == 12\n                and data.get(\"can_post_stories\") == 13\n                and data.get(\"can_edit_stories\") == 14\n                and data.get(\"can_delete_stories\") == 15\n                and data.get(\"can_manage_direct_messages\") == 16\n            )\n\n        monkeypatch.setattr(bot, \"_post\", make_assertion)\n        assert await bot.promote_chat_member(\n            channel_id,\n            1325859552,\n            is_anonymous=1,\n            can_change_info=2,\n            can_post_messages=3,\n            can_edit_messages=4,\n            can_delete_messages=5,\n            can_invite_users=6,\n            can_restrict_members=7,\n            can_pin_messages=8,\n            can_promote_members=9,\n            can_manage_chat=10,\n            can_manage_video_chats=11,\n            can_manage_topics=12,\n            can_post_stories=13,\n            can_edit_stories=14,\n            can_delete_stories=15,\n            can_manage_direct_messages=16,\n        )\n\n    async def test_export_chat_invite_link(self, bot, channel_id):\n        # Each link is unique apparently\n        invite_link = await bot.export_chat_invite_link(channel_id)\n        assert isinstance(invite_link, str)\n        assert invite_link\n\n    async def test_edit_revoke_chat_invite_link_passing_link_objects(self, bot, channel_id):\n        invite_link = await bot.create_chat_invite_link(chat_id=channel_id)\n        assert invite_link.name is None\n\n        edited_link = await bot.edit_chat_invite_link(\n            chat_id=channel_id, invite_link=invite_link, name=\"some_name\"\n        )\n        assert edited_link == invite_link\n        assert edited_link.name == \"some_name\"\n\n        revoked_link = await bot.revoke_chat_invite_link(\n            chat_id=channel_id, invite_link=edited_link\n        )\n        assert revoked_link.invite_link == edited_link.invite_link\n        assert revoked_link.is_revoked is True\n        assert revoked_link.name == \"some_name\"\n\n    @pytest.mark.parametrize(\"creates_join_request\", [True, False])\n    @pytest.mark.parametrize(\"name\", [None, \"name\"])\n    async def test_create_chat_invite_link_basics(\n        self, bot, creates_join_request, name, channel_id\n    ):\n        data = {}\n        if creates_join_request:\n            data[\"creates_join_request\"] = True\n        if name:\n            data[\"name\"] = name\n        invite_link = await bot.create_chat_invite_link(chat_id=channel_id, **data)\n\n        assert invite_link.member_limit is None\n        assert invite_link.expire_date is None\n        assert invite_link.creates_join_request == creates_join_request\n        assert invite_link.name == name\n\n        revoked_link = await bot.revoke_chat_invite_link(\n            chat_id=channel_id, invite_link=invite_link.invite_link\n        )\n        assert revoked_link.is_revoked\n\n    @pytest.mark.parametrize(\"datetime\", argvalues=[True, False], ids=[\"datetime\", \"integer\"])\n    async def test_advanced_chat_invite_links(self, bot, channel_id, datetime):\n        # we are testing this all in one function in order to save api calls\n        timestamp = dtm.datetime.utcnow()\n        add_seconds = dtm.timedelta(0, 70)\n        time_in_future = timestamp + add_seconds\n        expire_time = time_in_future if datetime else to_timestamp(time_in_future)\n        aware_time_in_future = localize(time_in_future, UTC)\n\n        invite_link = await bot.create_chat_invite_link(\n            channel_id, expire_date=expire_time, member_limit=10\n        )\n        assert invite_link.invite_link\n        assert not invite_link.invite_link.endswith(\"...\")\n        assert abs(invite_link.expire_date - aware_time_in_future) < dtm.timedelta(seconds=1)\n        assert invite_link.member_limit == 10\n\n        add_seconds = dtm.timedelta(0, 80)\n        time_in_future = timestamp + add_seconds\n        expire_time = time_in_future if datetime else to_timestamp(time_in_future)\n        aware_time_in_future = localize(time_in_future, UTC)\n\n        edited_invite_link = await bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            expire_date=expire_time,\n            member_limit=20,\n            name=\"NewName\",\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert abs(edited_invite_link.expire_date - aware_time_in_future) < dtm.timedelta(\n            seconds=1\n        )\n        assert edited_invite_link.name == \"NewName\"\n        assert edited_invite_link.member_limit == 20\n\n        edited_invite_link = await bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            name=\"EvenNewerName\",\n            creates_join_request=True,\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert not edited_invite_link.expire_date\n        assert edited_invite_link.name == \"EvenNewerName\"\n        assert edited_invite_link.creates_join_request\n        assert edited_invite_link.member_limit is None\n\n        revoked_invite_link = await bot.revoke_chat_invite_link(\n            channel_id, invite_link.invite_link\n        )\n        assert revoked_invite_link.invite_link == invite_link.invite_link\n        assert revoked_invite_link.is_revoked\n\n    async def test_advanced_chat_invite_links_default_tzinfo(self, tz_bot, channel_id):\n        # we are testing this all in one function in order to save api calls\n        add_seconds = dtm.timedelta(0, 70)\n        aware_expire_date = dtm.datetime.now(tz=tz_bot.defaults.tzinfo) + add_seconds\n        time_in_future = aware_expire_date.replace(tzinfo=None)\n\n        invite_link = await tz_bot.create_chat_invite_link(\n            channel_id, expire_date=time_in_future, member_limit=10\n        )\n        assert invite_link.invite_link\n        assert not invite_link.invite_link.endswith(\"...\")\n        assert abs(invite_link.expire_date - aware_expire_date) < dtm.timedelta(seconds=1)\n        assert invite_link.member_limit == 10\n\n        add_seconds = dtm.timedelta(0, 80)\n        aware_expire_date += add_seconds\n        time_in_future = aware_expire_date.replace(tzinfo=None)\n\n        edited_invite_link = await tz_bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            expire_date=time_in_future,\n            member_limit=20,\n            name=\"NewName\",\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert abs(edited_invite_link.expire_date - aware_expire_date) < dtm.timedelta(seconds=1)\n        assert edited_invite_link.name == \"NewName\"\n        assert edited_invite_link.member_limit == 20\n\n        edited_invite_link = await tz_bot.edit_chat_invite_link(\n            channel_id,\n            invite_link.invite_link,\n            name=\"EvenNewerName\",\n            creates_join_request=True,\n        )\n        assert edited_invite_link.invite_link == invite_link.invite_link\n        assert not edited_invite_link.expire_date\n        assert edited_invite_link.name == \"EvenNewerName\"\n        assert edited_invite_link.creates_join_request\n        assert edited_invite_link.member_limit is None\n\n        revoked_invite_link = await tz_bot.revoke_chat_invite_link(\n            channel_id, invite_link.invite_link\n        )\n        assert revoked_invite_link.invite_link == invite_link.invite_link\n        assert revoked_invite_link.is_revoked\n\n    async def test_approve_chat_join_request(self, bot, chat_id, channel_id):\n        # TODO: Need incoming join request to properly test\n        # Since we can't create join requests on the fly, we just tests the call to TG\n        # by checking that it complains about approving a user who is already in the chat\n        with pytest.raises(BadRequest, match=\"User_already_participant\"):\n            await bot.approve_chat_join_request(chat_id=channel_id, user_id=chat_id)\n\n    async def test_decline_chat_join_request(self, bot, chat_id, channel_id):\n        # TODO: Need incoming join request to properly test\n        # Since we can't create join requests on the fly, we just tests the call to TG\n        # by checking that it complains about declining a user who is already in the chat\n        #\n        # The error message Hide_requester_missing started showing up instead of\n        # User_already_participant. Don't know why \u2026\n        with pytest.raises(BadRequest, match=r\"User_already_participant|Hide_requester_missing\"):\n            await bot.decline_chat_join_request(chat_id=channel_id, user_id=chat_id)\n\n    async def test_set_chat_photo(self, bot, channel_id):\n        async def func():\n            assert await bot.set_chat_photo(channel_id, f)\n\n        with data_file(\"telegram_test_channel.jpg\").open(\"rb\") as f:\n            await expect_bad_request(\n                func, \"Type of file mismatch\", \"Telegram did not accept the file.\"\n            )\n\n    async def test_delete_chat_photo(self, bot, channel_id):\n        async def func():\n            assert await bot.delete_chat_photo(channel_id)\n\n        await expect_bad_request(func, \"Chat_not_modified\", \"Chat photo was not set.\")\n\n    async def test_set_chat_title(self, bot, channel_id):\n        assert await bot.set_chat_title(channel_id, \">>> telegram.Bot() - Tests\")\n\n    async def test_set_chat_description(self, bot, channel_id):\n        assert await bot.set_chat_description(channel_id, \"Time: \" + str(time.time()))\n\n    async def test_pin_and_unpin_message(self, bot, super_group_id):\n        messages = []  # contains the Messages we sent\n        pinned_messages_tasks = set()  # contains the asyncio.Tasks that pin the messages\n\n        # Let's send 3 messages so we can pin them\n        awaitables = {bot.send_message(super_group_id, f\"test_pin_message_{i}\") for i in range(3)}\n\n        # We will pin the messages immediately after sending them\n        for sending_msg in asyncio.as_completed(awaitables):  # as_completed sends the messages\n            msg = await sending_msg\n            coro = bot.pin_chat_message(super_group_id, msg.message_id, True, read_timeout=10)\n            pinned_messages_tasks.add(asyncio.create_task(coro))  # start pinning the message\n            messages.append(msg)\n\n        assert len(messages) == 3  # Check if we sent 3 messages\n\n        # Check if we pinned 3 messages\n        assert all([await i for i in pinned_messages_tasks])\n        assert all(i.done() for i in pinned_messages_tasks)  # Check if all tasks are done\n\n        chat = await bot.get_chat(super_group_id)  # get the chat to check the pinned message\n        assert chat.pinned_message in messages\n\n        # Determine which message is not the most recently pinned\n        for old_pin_msg in messages:\n            if chat.pinned_message != old_pin_msg:\n                break\n\n        # Test unpinning our messages\n        tasks = asyncio.gather(\n            bot.unpin_chat_message(  # unpins any message except the most recent\n                chat_id=super_group_id,  # because we don't want to accidentally unpin the same msg\n                message_id=old_pin_msg.message_id,  # twice\n                read_timeout=10,\n            ),\n            bot.unpin_chat_message(chat_id=super_group_id, read_timeout=10),  # unpins most recent\n        )\n        assert all(await tasks)\n        assert all(i.done() for i in tasks)\n        assert await bot.unpin_all_chat_messages(super_group_id, read_timeout=10)\n\n    # get_sticker_set, upload_sticker_file, create_new_sticker_set, add_sticker_to_set,\n    # set_sticker_position_in_set, delete_sticker_from_set and get_custom_emoji_stickers,\n    # replace_sticker_in_set are tested in the test_sticker module.\n\n    # get_forum_topic_icon_stickers, edit_forum_topic, general_forum etc...\n    # are tested in the test_forum module.\n    async def test_send_message_disable_web_page_preview(self, bot, chat_id):\n        \"\"\"Test that disable_web_page_preview is substituted for link_preview_options and that\n        it still works as expected for backward compatability.\"\"\"\n        msg = await bot.send_message(\n            chat_id,\n            \"https://github.com/python-telegram-bot/python-telegram-bot\",\n            disable_web_page_preview=True,\n        )\n        assert msg.link_preview_options\n        assert msg.link_preview_options.is_disabled\n\n    async def test_send_message_link_preview_options(self, bot, chat_id):\n        \"\"\"Test whether link_preview_options is correctly passed to the API.\"\"\"\n        # btw it is possible to have no url in the text, but set a url for the preview.\n        msg = await bot.send_message(\n            chat_id,\n            \"https://github.com/python-telegram-bot/python-telegram-bot\",\n            link_preview_options=LinkPreviewOptions(prefer_small_media=True, show_above_text=True),\n        )\n        assert msg.link_preview_options\n        assert not msg.link_preview_options.is_disabled\n        # The prefer_* options aren't very consistent on the client side (big pic shown) +\n        # they are not returned by the API.\n        # assert msg.link_preview_options.prefer_small_media\n        assert msg.link_preview_options.show_above_text\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"link_preview_options\": LinkPreviewOptions(show_above_text=True)}],\n        indirect=True,\n    )\n    async def test_send_message_default_link_preview_options(self, default_bot, chat_id):\n        \"\"\"Test whether Defaults.link_preview_options is correctly fused with the passed LPO.\"\"\"\n        github_url = \"https://github.com/python-telegram-bot/python-telegram-bot\"\n        website = \"https://python-telegram-bot.org/\"\n\n        # First test just the default passing:\n        coro1 = default_bot.send_message(chat_id, github_url)\n        # Next test fusion of both LPOs:\n        coro2 = default_bot.send_message(\n            chat_id,\n            github_url,\n            link_preview_options=LinkPreviewOptions(url=website, prefer_large_media=True),\n        )\n        # Now test fusion + overriding of passed LPO:\n        coro3 = default_bot.send_message(\n            chat_id,\n            github_url,\n            link_preview_options=LinkPreviewOptions(show_above_text=False, url=website),\n        )\n        # finally test explicitly setting to None\n        coro4 = default_bot.send_message(chat_id, github_url, link_preview_options=None)\n\n        msgs = asyncio.gather(coro1, coro2, coro3, coro4)\n        msg1, msg2, msg3, msg4 = await msgs\n        assert msg1.link_preview_options\n        assert msg1.link_preview_options.show_above_text\n\n        assert msg2.link_preview_options\n        assert msg2.link_preview_options.show_above_text\n        assert msg2.link_preview_options.url == website\n        assert msg2.link_preview_options.prefer_large_media  # Now works correctly using new url..\n\n        assert msg3.link_preview_options\n        assert not msg3.link_preview_options.show_above_text\n        assert msg3.link_preview_options.url == website\n\n        assert msg4.link_preview_options == LinkPreviewOptions(url=github_url)\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [{\"link_preview_options\": LinkPreviewOptions(show_above_text=True)}],\n        indirect=True,\n    )\n    async def test_edit_message_text_default_link_preview_options(self, default_bot, chat_id):\n        \"\"\"Test whether Defaults.link_preview_options is correctly fused with the passed LPO.\"\"\"\n        github_url = \"https://github.com/python-telegram-bot/python-telegram-bot\"\n        website = \"https://python-telegram-bot.org/\"\n        telegram_url = \"https://telegram.org\"\n        base_1, base_2, base_3, base_4 = await asyncio.gather(\n            *(default_bot.send_message(chat_id, telegram_url) for _ in range(4))\n        )\n\n        # First test just the default passing:\n        coro1 = base_1.edit_text(github_url)\n        # Next test fusion of both LPOs:\n        coro2 = base_2.edit_text(\n            github_url,\n            link_preview_options=LinkPreviewOptions(url=website, prefer_large_media=True),\n        )\n        # Now test fusion + overriding of passed LPO:\n        coro3 = base_3.edit_text(\n            github_url,\n            link_preview_options=LinkPreviewOptions(show_above_text=False, url=website),\n        )\n        # finally test explicitly setting to None\n        coro4 = base_4.edit_text(github_url, link_preview_options=None)\n\n        msgs = asyncio.gather(coro1, coro2, coro3, coro4)\n        msg1, msg2, msg3, msg4 = await msgs\n        assert msg1.link_preview_options\n        assert msg1.link_preview_options.show_above_text\n\n        assert msg2.link_preview_options\n        assert msg2.link_preview_options.show_above_text\n        assert msg2.link_preview_options.url == website\n        assert msg2.link_preview_options.prefer_large_media  # Now works correctly using new url..\n\n        assert msg3.link_preview_options\n        assert not msg3.link_preview_options.show_above_text\n        assert msg3.link_preview_options.url == website\n\n        assert msg4.link_preview_options == LinkPreviewOptions(url=github_url)\n\n    async def test_send_message_entities(self, bot, chat_id):\n        test_string = \"Italic Bold Code Spoiler\"\n        entities = [\n            MessageEntity(MessageEntity.ITALIC, 0, 6),\n            MessageEntity(MessageEntity.ITALIC, 7, 4),\n            MessageEntity(MessageEntity.ITALIC, 12, 4),\n            MessageEntity(MessageEntity.SPOILER, 17, 7),\n        ]\n        message = await bot.send_message(chat_id=chat_id, text=test_string, entities=entities)\n        assert message.text == test_string\n        assert message.entities == tuple(entities)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"parse_mode\": \"Markdown\"}], indirect=True)\n    async def test_send_message_default_parse_mode(self, default_bot, chat_id):\n        test_string = \"Italic Bold Code\"\n        test_markdown_string = \"_Italic_ *Bold* `Code`\"\n\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_message(chat_id, test_markdown_string, **i)\n                for i in ({}, {\"parse_mode\": None}, {\"parse_mode\": \"HTML\"})\n            )\n        )\n        msg1, msg2, msg3 = await tasks\n        assert msg1.text_markdown == test_markdown_string\n        assert msg1.text == test_string\n\n        assert msg2.text == test_markdown_string\n        assert msg2.text_markdown == escape_markdown(test_markdown_string)\n\n        assert msg3.text == test_markdown_string\n        assert msg3.text_markdown == escape_markdown(test_markdown_string)\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_message_default_protect_content(self, default_bot, chat_id):\n        tasks = asyncio.gather(\n            default_bot.send_message(chat_id, \"test\"),\n            default_bot.send_message(chat_id, \"test\", protect_content=False),\n        )\n        to_check, no_protect = await tasks\n        assert to_check.has_protected_content\n        assert not no_protect.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_message_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_message(\n                chat_id,\n                \"test\",\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_message(\n                chat_id, \"test\", reply_to_message_id=reply_to_message.message_id\n            )\n            assert message.reply_to_message is None\n        else:\n            with pytest.raises(BadRequest, match=\"Message to be replied not found\"):\n                await default_bot.send_message(\n                    chat_id, \"test\", reply_to_message_id=reply_to_message.message_id\n                )\n\n    async def test_get_set_my_default_administrator_rights(self, bot):\n        # Test that my default administrator rights for group are as all False\n        assert await bot.set_my_default_administrator_rights()  # clear any set rights\n        my_admin_rights_grp = await bot.get_my_default_administrator_rights()\n        assert isinstance(my_admin_rights_grp, ChatAdministratorRights)\n        assert all(not getattr(my_admin_rights_grp, at) for at in my_admin_rights_grp.__slots__)\n\n        # Test setting my default admin rights for channel\n        my_rights = ChatAdministratorRights.all_rights()\n        assert await bot.set_my_default_administrator_rights(my_rights, for_channels=True)\n        my_admin_rights_ch = await bot.get_my_default_administrator_rights(for_channels=True)\n        assert my_admin_rights_ch.can_invite_users is my_rights.can_invite_users\n        # tg bug? is_anonymous is False despite setting it True for channels:\n        assert my_admin_rights_ch.is_anonymous is not my_rights.is_anonymous\n\n        assert my_admin_rights_ch.can_manage_chat is my_rights.can_manage_chat\n        assert my_admin_rights_ch.can_delete_messages is my_rights.can_delete_messages\n        assert my_admin_rights_ch.can_edit_messages is my_rights.can_edit_messages\n        assert my_admin_rights_ch.can_post_messages is my_rights.can_post_messages\n        assert my_admin_rights_ch.can_change_info is my_rights.can_change_info\n        assert my_admin_rights_ch.can_promote_members is my_rights.can_promote_members\n        assert my_admin_rights_ch.can_restrict_members is my_rights.can_restrict_members\n        assert my_admin_rights_ch.can_pin_messages is None  # Not returned for channels\n        assert my_admin_rights_ch.can_manage_topics is None  # Not returned for channels\n\n    async def test_get_set_chat_menu_button(self, bot, chat_id):\n        # Test our chat menu button is commands-\n        menu_button = await bot.get_chat_menu_button()\n        assert isinstance(menu_button, MenuButton)\n        assert isinstance(menu_button, MenuButtonCommands)\n        assert menu_button.type == MenuButtonType.COMMANDS\n\n        # Test setting our chat menu button to Webapp.\n        my_menu = MenuButtonWebApp(\"click me!\", WebAppInfo(\"https://telegram.org/\"))\n        assert await bot.set_chat_menu_button(chat_id=chat_id, menu_button=my_menu)\n        menu_button = await bot.get_chat_menu_button(chat_id)\n        assert isinstance(menu_button, MenuButtonWebApp)\n        assert menu_button.type == MenuButtonType.WEB_APP\n        assert menu_button.text == my_menu.text\n        assert menu_button.web_app.url == my_menu.web_app.url\n\n        assert await bot.set_chat_menu_button(chat_id=chat_id, menu_button=MenuButtonDefault())\n        menu_button = await bot.get_chat_menu_button(chat_id=chat_id)\n        assert isinstance(menu_button, MenuButtonDefault)\n\n    async def test_set_and_get_my_commands(self, bot):\n        commands = [BotCommand(\"cmd1\", \"descr1\"), [\"cmd2\", \"descr2\"]]\n        assert await bot.set_my_commands([])\n        assert await bot.get_my_commands() == ()\n        assert await bot.set_my_commands(commands)\n\n        for i, bc in enumerate(await bot.get_my_commands()):\n            assert bc.command == f\"cmd{i + 1}\"\n            assert bc.description == f\"descr{i + 1}\"\n\n    async def test_get_set_delete_my_commands_with_scope(self, bot, super_group_id, chat_id):\n        group_cmds = [BotCommand(\"group_cmd\", \"visible to this supergroup only\")]\n        private_cmds = [BotCommand(\"private_cmd\", \"visible to this private chat only\")]\n        group_scope = BotCommandScopeChat(super_group_id)\n        private_scope = BotCommandScopeChat(chat_id)\n\n        # Set supergroup command list with lang code and check if the same can be returned from api\n        assert await bot.set_my_commands(group_cmds, scope=group_scope, language_code=\"en\")\n        gotten_group_cmds = await bot.get_my_commands(scope=group_scope, language_code=\"en\")\n\n        assert len(gotten_group_cmds) == len(group_cmds)\n        assert gotten_group_cmds[0].command == group_cmds[0].command\n\n        # Set private command list and check if same can be returned from the api\n        assert await bot.set_my_commands(private_cmds, scope=private_scope)\n        gotten_private_cmd = await bot.get_my_commands(scope=private_scope)\n\n        assert len(gotten_private_cmd) == len(private_cmds)\n        assert gotten_private_cmd[0].command == private_cmds[0].command\n\n        # Delete command list from that supergroup and private chat-\n        tasks = asyncio.gather(\n            bot.delete_my_commands(private_scope),\n            bot.delete_my_commands(group_scope, \"en\"),\n        )\n        assert all(await tasks)\n\n        # Check if its been deleted-\n        tasks = asyncio.gather(\n            bot.get_my_commands(private_scope),\n            bot.get_my_commands(group_scope, \"en\"),\n        )\n        deleted_priv_cmds, deleted_grp_cmds = await tasks\n\n        assert len(deleted_grp_cmds) == 0 == len(group_cmds) - 1\n        assert len(deleted_priv_cmds) == 0 == len(private_cmds) - 1\n\n        await bot.delete_my_commands()  # Delete commands from default scope\n        assert len(await bot.get_my_commands()) == 0\n\n    async def test_copy_message_without_reply(self, bot, chat_id, media_message):\n        keyboard = InlineKeyboardMarkup(\n            [[InlineKeyboardButton(text=\"test\", callback_data=\"test2\")]]\n        )\n\n        returned = await bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=\"<b>Test</b>\",\n            parse_mode=ParseMode.HTML,\n            reply_to_message_id=media_message.message_id,\n            reply_markup=keyboard,\n            show_caption_above_media=False,\n        )\n        # we send a temp message which replies to the returned message id in order to get a\n        # message object\n        temp_message = await bot.send_message(\n            chat_id, \"test\", reply_to_message_id=returned.message_id\n        )\n        message = temp_message.reply_to_message\n        assert message.chat_id == int(chat_id)\n        assert message.caption == \"Test\"\n        assert len(message.caption_entities) == 1\n        assert message.reply_markup == keyboard\n\n    @pytest.mark.parametrize(\n        \"default_bot\",\n        [\n            ({\"parse_mode\": ParseMode.HTML, \"allow_sending_without_reply\": True}),\n            ({\"parse_mode\": None, \"allow_sending_without_reply\": True}),\n            ({\"parse_mode\": None, \"allow_sending_without_reply\": False}),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_copy_message_with_default(self, default_bot, chat_id, media_message):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if not default_bot.defaults.allow_sending_without_reply:\n            with pytest.raises(BadRequest, match=\"not found\"):\n                await default_bot.copy_message(\n                    chat_id,\n                    from_chat_id=chat_id,\n                    message_id=media_message.message_id,\n                    caption=\"<b>Test</b>\",\n                    reply_to_message_id=reply_to_message.message_id,\n                )\n            return\n        returned = await default_bot.copy_message(\n            chat_id,\n            from_chat_id=chat_id,\n            message_id=media_message.message_id,\n            caption=\"<b>Test</b>\",\n            reply_to_message_id=reply_to_message.message_id,\n        )\n        # we send a temp message which replies to the returned message id in order to get a\n        # message object\n        temp_message = await default_bot.send_message(\n            chat_id, \"test\", reply_to_message_id=returned.message_id\n        )\n        message = temp_message.reply_to_message\n        if default_bot.defaults.parse_mode:\n            assert len(message.caption_entities) == 1\n        else:\n            assert len(message.caption_entities) == 0\n\n    async def test_copy_messages(self, bot, chat_id):\n        # not using gather here to have deterministically ordered message_ids\n        msg1 = await bot.send_message(chat_id, text=\"will be copied 1\")\n        msg2 = await bot.send_message(chat_id, text=\"will be copied 2\")\n\n        copy_messages = await bot.copy_messages(\n            chat_id, from_chat_id=chat_id, message_ids=(msg1.message_id, msg2.message_id)\n        )\n        assert isinstance(copy_messages, tuple)\n\n        tasks = asyncio.gather(\n            bot.send_message(chat_id, \"temp 1\", reply_to_message_id=copy_messages[0].message_id),\n            bot.send_message(chat_id, \"temp 2\", reply_to_message_id=copy_messages[1].message_id),\n        )\n        temp_msg1, temp_msg2 = await tasks\n\n        forward_msg1 = temp_msg1.reply_to_message\n        forward_msg2 = temp_msg2.reply_to_message\n\n        assert forward_msg1.text == msg1.text\n        assert forward_msg2.text == msg2.text\n\n    # Continue testing arbitrary callback data here with actual requests:\n    async def test_replace_callback_data_send_message(self, cdc_bot, chat_id):\n        bot = cdc_bot\n\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            message = await bot.send_message(\n                chat_id=chat_id, text=\"test\", reply_markup=reply_markup\n            )\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_replace_callback_data_stop_poll_and_repl_to_message(self, cdc_bot, chat_id):\n        bot = cdc_bot\n\n        poll_message = await bot.send_poll(chat_id=chat_id, question=\"test\", options=[\"1\", \"2\"])\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            await poll_message.stop_poll(reply_markup=reply_markup)\n            helper_message = await poll_message.reply_text(\"temp\", do_quote=True)\n            message = helper_message.reply_to_message\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_replace_callback_data_copy_message(self, cdc_bot, chat_id):\n        \"\"\"This also tests that data is inserted into the buttons of message.reply_to_message\n        where message is the return value of a bot method\"\"\"\n        bot = cdc_bot\n\n        original_message = await bot.send_message(chat_id=chat_id, text=\"original\")\n        try:\n            replace_button = InlineKeyboardButton(text=\"replace\", callback_data=\"replace_test\")\n            no_replace_button = InlineKeyboardButton(\n                text=\"no_replace\", url=\"http://python-telegram-bot.org/\"\n            )\n            reply_markup = InlineKeyboardMarkup.from_row(\n                [\n                    replace_button,\n                    no_replace_button,\n                ]\n            )\n            message_id = await original_message.copy(chat_id=chat_id, reply_markup=reply_markup)\n            helper_message = await bot.send_message(\n                chat_id=chat_id, reply_to_message_id=message_id.message_id, text=\"temp\"\n            )\n            message = helper_message.reply_to_message\n            inline_keyboard = message.reply_markup.inline_keyboard\n\n            assert inline_keyboard[0][1] == no_replace_button\n            assert inline_keyboard[0][0] == replace_button\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"replace_test\"\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_get_chat_arbitrary_callback_data(self, chat_id, cdc_bot):\n        bot = cdc_bot\n\n        try:\n            reply_markup = InlineKeyboardMarkup.from_button(\n                InlineKeyboardButton(text=\"text\", callback_data=\"callback_data\")\n            )\n\n            message = await bot.send_message(\n                chat_id, text=\"get_chat_arbitrary_callback_data\", reply_markup=reply_markup\n            )\n            await message.pin()\n\n            keyboard = next(iter(bot.callback_data_cache._keyboard_data))\n            data = next(\n                iter(bot.callback_data_cache._keyboard_data[keyboard].button_data.values())\n            )\n            assert data == \"callback_data\"\n\n            cfi = await bot.get_chat(chat_id)\n\n            if not cfi.pinned_message:\n                pytest.xfail(\"Pinning messages is not always reliable on TG\")\n\n            assert cfi.pinned_message == message\n            assert cfi.pinned_message.reply_markup == reply_markup\n            assert await message.unpin()  # (not placed in finally block since msg can be unbound)\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_arbitrary_callback_data_get_chat_no_pinned_message(\n        self, super_group_id, cdc_bot\n    ):\n        bot = cdc_bot\n        await bot.unpin_all_chat_messages(super_group_id)\n\n        try:\n            cfi = await bot.get_chat(super_group_id)\n\n            assert isinstance(cfi, ChatFullInfo)\n            assert int(cfi.id) == int(super_group_id)\n            assert cfi.pinned_message is None\n        finally:\n            bot.callback_data_cache.clear_callback_data()\n            bot.callback_data_cache.clear_callback_queries()\n\n    async def test_set_get_my_description(self, bot):\n        default_description = f\"{bot.username} - default - {dtm.datetime.utcnow().isoformat()}\"\n        en_description = f\"{bot.username} - en - {dtm.datetime.utcnow().isoformat()}\"\n        de_description = f\"{bot.username} - de - {dtm.datetime.utcnow().isoformat()}\"\n\n        # Set the descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_description(default_description),\n                bot.set_my_description(en_description, language_code=\"en\"),\n                bot.set_my_description(de_description, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            bot.get_my_description(), bot.get_my_description(\"en\"), bot.get_my_description(\"de\")\n        ) == [\n            BotDescription(default_description),\n            BotDescription(en_description),\n            BotDescription(de_description),\n        ]\n\n        # Delete the descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_description(None),\n                bot.set_my_description(None, language_code=\"en\"),\n                bot.set_my_description(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            bot.get_my_description(), bot.get_my_description(\"en\"), bot.get_my_description(\"de\")\n        ) == 3 * [BotDescription(\"\")]\n\n    async def test_set_get_my_short_description(self, bot):\n        default_short_description = (\n            f\"{bot.username} - default - {dtm.datetime.utcnow().isoformat()}\"\n        )\n        en_short_description = f\"{bot.username} - en - {dtm.datetime.utcnow().isoformat()}\"\n        de_short_description = f\"{bot.username} - de - {dtm.datetime.utcnow().isoformat()}\"\n\n        # Set the short_descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_short_description(default_short_description),\n                bot.set_my_short_description(en_short_description, language_code=\"en\"),\n                bot.set_my_short_description(de_short_description, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were set correctly\n        assert await asyncio.gather(\n            bot.get_my_short_description(),\n            bot.get_my_short_description(\"en\"),\n            bot.get_my_short_description(\"de\"),\n        ) == [\n            BotShortDescription(default_short_description),\n            BotShortDescription(en_short_description),\n            BotShortDescription(de_short_description),\n        ]\n\n        # Delete the short_descriptions\n        assert all(\n            await asyncio.gather(\n                bot.set_my_short_description(None),\n                bot.set_my_short_description(None, language_code=\"en\"),\n                bot.set_my_short_description(None, language_code=\"de\"),\n            )\n        )\n\n        # Check that they were deleted correctly\n        assert await asyncio.gather(\n            bot.get_my_short_description(),\n            bot.get_my_short_description(\"en\"),\n            bot.get_my_short_description(\"de\"),\n        ) == 3 * [BotShortDescription(\"\")]\n\n    async def test_set_message_reaction(self, bot, chat_id, static_message):\n        assert await bot.set_message_reaction(\n            chat_id, static_message.message_id, ReactionEmoji.THUMBS_DOWN, True\n        )\n\n    @pytest.mark.parametrize(\"bot_class\", [Bot, ExtBot])\n    async def test_do_api_request_warning_known_method(self, bot, bot_class):\n        with pytest.warns(PTBUserWarning, match=\"Please use 'Bot.get_me'\") as record:\n            await bot_class(bot.token).do_api_request(\"get_me\")\n\n        assert record[0].filename == __file__, \"Wrong stack level!\"\n\n    async def test_do_api_request_unknown_method(self, bot):\n        with pytest.raises(EndPointNotFound, match=\"'unknownEndpoint' not found\"):\n            await bot.do_api_request(\"unknown_endpoint\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    async def test_do_api_request_invalid_token(self, bot):\n        # we do not initialize the bot here on purpose b/c that's the case were we actually\n        # do not know for sure if the token is invalid or the method was not found\n        with pytest.raises(\n            InvalidToken, match=\"token was rejected by Telegram or the endpoint 'getMe'\"\n        ):\n            await Bot(\"invalid_token\").do_api_request(\"get_me\")\n\n        # same test, but with a valid token bot and unknown endpoint\n        with pytest.raises(\n            InvalidToken, match=\"token was rejected by Telegram or the endpoint 'unknownEndpoint'\"\n        ):\n            await Bot(bot.token).do_api_request(\"unknown_endpoint\")\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_basic_and_files(self, bot, chat_id, return_type):\n        result = await bot.do_api_request(\n            \"send_document\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"caption\": \"test_caption\",\n                \"document\": InputFile(data_file(\"telegram.png\").open(\"rb\")),\n            },\n            return_type=return_type,\n        )\n        if return_type is None:\n            assert isinstance(result, dict)\n            result = Message.de_json(result, bot)\n\n        assert isinstance(result, Message)\n        assert result.chat_id == int(chat_id)\n        assert result.caption == \"test_caption\"\n        out = BytesIO()\n        await (await result.document.get_file()).download_to_memory(out)\n        out.seek(0)\n        assert out.read() == data_file(\"telegram.png\").open(\"rb\").read()\n        assert result.document.file_name == \"telegram.png\"\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_list_return_type(self, bot, chat_id, return_type):\n        result = await bot.do_api_request(\n            \"send_media_group\",\n            api_kwargs={\n                \"chat_id\": chat_id,\n                \"media\": [\n                    InputMediaDocument(\n                        InputFile(\n                            data_file(\"text_file.txt\").open(\"rb\"),\n                            attach=True,\n                        )\n                    ),\n                    InputMediaDocument(\n                        InputFile(\n                            data_file(\"local_file.txt\").open(\"rb\"),\n                            attach=True,\n                        )\n                    ),\n                ],\n            },\n            return_type=return_type,\n        )\n        if return_type is None:\n            assert isinstance(result, list)\n            for entry in result:\n                assert isinstance(entry, dict)\n            result = Message.de_list(result, bot)\n\n        for message, file_name in zip(result, (\"text_file.txt\", \"local_file.txt\")):\n            assert isinstance(message, Message)\n            assert message.chat_id == int(chat_id)\n            out = BytesIO()\n            await (await message.document.get_file()).download_to_memory(out)\n            out.seek(0)\n            assert out.read() == data_file(file_name).open(\"rb\").read()\n            assert message.document.file_name == file_name\n\n    @pytest.mark.filterwarnings(\"ignore::telegram.warnings.PTBUserWarning\")\n    @pytest.mark.parametrize(\"return_type\", [Message, None])\n    async def test_do_api_request_bool_return_type(self, bot, chat_id, return_type):\n        assert await bot.do_api_request(\"delete_my_commands\", return_type=return_type) is True\n\n    async def test_get_star_transactions(self, bot):\n        transactions = await bot.get_star_transactions(limit=1)\n        assert isinstance(transactions, StarTransactions)\n        assert len(transactions.transactions) == 0\n\n    @pytest.mark.parametrize(\"subscription_period\", [2592000, dtm.timedelta(days=30)])\n    async def test_create_edit_chat_subscription_link(\n        self, bot, subscription_channel_id, channel_id, subscription_period\n    ):\n        sub_link = await bot.create_chat_subscription_invite_link(\n            subscription_channel_id,\n            name=\"sub_name\",\n            subscription_period=subscription_period,\n            subscription_price=13,\n        )\n        assert sub_link.name == \"sub_name\"\n        assert sub_link.subscription_period == 2592000\n        assert sub_link.subscription_price == 13\n\n        edited_link = await bot.edit_chat_subscription_invite_link(\n            chat_id=subscription_channel_id, invite_link=sub_link, name=\"sub_name_2\"\n        )\n        assert edited_link.name == \"sub_name_2\"\n        assert sub_link.subscription_period == 2592000\n        assert sub_link.subscription_price == 13\n\n    async def test_get_my_star_balance(self, bot):\n        balance = await bot.get_my_star_balance()\n        assert isinstance(balance, StarAmount)\n        assert balance.amount == 0"
                    }
                ]
            },
            {
                "file_path": "tests/test_forum.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_forum.py",
                "faults": [
                    {
                        "file_path": "tests/test_forum.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_forum.py",
                        "line_range": [
                            127,
                            287
                        ],
                        "reason": "The test 'test_send_contact_default_protect_content' failed due to flood control being exceeded, indicating that the bot is sending messages too frequently. This is likely related to the implementation of the methods in the 'TestForumMethodsWithRequest' class, particularly those that send messages. Additionally, multiple tests failed due to timeout errors, suggesting that the methods may not be handling asynchronous operations correctly or are being blocked by excessive message sending. Lines 181-190 and 209-225 are particularly relevant as they involve sending messages and unpinning messages, which could contribute to the flood control issue.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "class",
                        "code_snippet": "class TestForumMethodsWithRequest:\n    async def test_create_forum_topic(self, real_topic):\n        result = real_topic\n        assert isinstance(result, ForumTopic)\n        assert result.name == TEST_TOPIC_NAME\n        assert result.message_thread_id\n        assert isinstance(result.icon_color, int)\n        assert isinstance(result.icon_custom_emoji_id, str)\n\n    async def test_create_forum_topic_with_only_required_args(self, bot, forum_group_id):\n        result = await bot.create_forum_topic(chat_id=forum_group_id, name=TEST_TOPIC_NAME)\n        assert isinstance(result, ForumTopic)\n        assert result.name == TEST_TOPIC_NAME\n        assert result.message_thread_id\n        assert isinstance(result.icon_color, int)  # color is still there though it was not passed\n        assert result.icon_custom_emoji_id is None\n\n        result = await bot.delete_forum_topic(\n            chat_id=forum_group_id, message_thread_id=result.message_thread_id\n        )\n        assert result is True, \"Failed to delete forum topic\"\n\n    async def test_get_forum_topic_icon_stickers(self, bot):\n        emoji_sticker_list = await bot.get_forum_topic_icon_stickers()\n        first_sticker = emoji_sticker_list[0]\n\n        assert first_sticker.emoji == \"\ud83d\udcf0\"\n        assert first_sticker.height == 512\n        assert first_sticker.width == 512\n        assert first_sticker.is_animated\n        assert not first_sticker.is_video\n        assert first_sticker.set_name == \"Topics\"\n        assert first_sticker.type == Sticker.CUSTOM_EMOJI\n        assert first_sticker.thumbnail.width == 128\n        assert first_sticker.thumbnail.height == 128\n\n        # The following data of first item returned has changed in the past already,\n        # so check sizes loosely and ID's only by length of string\n        assert first_sticker.thumbnail.file_size in range(2000, 7000)\n        assert first_sticker.file_size in range(20000, 70000)\n        assert len(first_sticker.custom_emoji_id) == 19\n        assert len(first_sticker.thumbnail.file_unique_id) == 16\n        assert len(first_sticker.file_unique_id) == 15\n\n    async def test_edit_forum_topic(self, emoji_id, forum_group_id, bot, real_topic):\n        result = await bot.edit_forum_topic(\n            chat_id=forum_group_id,\n            message_thread_id=real_topic.message_thread_id,\n            name=f\"{TEST_TOPIC_NAME}_EDITED\",\n            icon_custom_emoji_id=emoji_id,\n        )\n        assert result is True, \"Failed to edit forum topic\"\n        # no way of checking the edited name, just the boolean result\n\n    async def test_send_message_to_topic(self, bot, forum_group_id, real_topic):\n        message_thread_id = real_topic.message_thread_id\n\n        message = await bot.send_message(\n            chat_id=forum_group_id, text=TEST_MSG_TEXT, message_thread_id=message_thread_id\n        )\n\n        assert message.text == TEST_MSG_TEXT\n        assert message.is_topic_message is True\n        assert message.message_thread_id == message_thread_id\n\n    async def test_close_and_reopen_forum_topic(self, bot, forum_group_id, real_topic):\n        message_thread_id = real_topic.message_thread_id\n\n        result = await bot.close_forum_topic(\n            chat_id=forum_group_id,\n            message_thread_id=message_thread_id,\n        )\n        assert result is True, \"Failed to close forum topic\"\n        # bot will still be able to send a message to a closed topic, so can't test anything like\n        # the inability to post to the topic\n\n        result = await bot.reopen_forum_topic(\n            chat_id=forum_group_id,\n            message_thread_id=message_thread_id,\n        )\n        assert result is True, \"Failed to reopen forum topic\"\n\n    async def test_unpin_all_forum_topic_messages(self, bot, forum_group_id, real_topic):\n        # We need 2 or more pinned msgs for this to work, else we get Chat_not_modified error\n        message_thread_id = real_topic.message_thread_id\n        pin_msg_tasks = set()\n\n        awaitables = {\n            bot.send_message(forum_group_id, TEST_MSG_TEXT, message_thread_id=message_thread_id)\n            for _ in range(2)\n        }\n        for coro in asyncio.as_completed(awaitables):\n            msg = await coro\n            pin_msg_tasks.add(asyncio.create_task(msg.pin()))\n\n        assert all([await task for task in pin_msg_tasks]) is True, \"Message(s) were not pinned\"\n\n        result = await bot.unpin_all_forum_topic_messages(forum_group_id, message_thread_id)\n        assert result is True, \"Failed to unpin all the messages in forum topic\"\n\n    async def test_unpin_all_general_forum_topic_messages(self, bot, forum_group_id):\n        # We need 2 or more pinned msgs for this to work, else we get Chat_not_modified error\n        pin_msg_tasks = set()\n\n        awaitables = {bot.send_message(forum_group_id, TEST_MSG_TEXT) for _ in range(2)}\n        for coro in asyncio.as_completed(awaitables):\n            msg = await coro\n            pin_msg_tasks.add(asyncio.create_task(msg.pin()))\n\n        assert all([await task for task in pin_msg_tasks]) is True, \"Message(s) were not pinned\"\n\n        result = await bot.unpin_all_general_forum_topic_messages(forum_group_id)\n        assert result is True, \"Failed to unpin all the messages in forum topic\"\n\n    async def test_edit_general_forum_topic(self, bot, forum_group_id):\n        result = await bot.edit_general_forum_topic(\n            chat_id=forum_group_id,\n            name=f\"GENERAL_{dtm.datetime.now().timestamp()}\",\n        )\n        assert result is True, \"Failed to edit general forum topic\"\n        # no way of checking the edited name, just the boolean result\n\n    async def test_close_reopen_hide_unhide_general_forum_topic(self, bot, forum_group_id):\n        \"\"\"Since reopening also unhides and hiding also closes, testing (un)hiding and\n        closing/reopening in different tests would mean that the tests have to be executed in\n        a specific order. For stability, we instead test all of them in one test.\"\"\"\n\n        # We first ensure that the topic is open and visible\n        # Otherwise the tests below will fail\n        try:\n            await bot.reopen_general_forum_topic(chat_id=forum_group_id)\n        except BadRequest as exc:\n            # If the topic is already open, we get BadRequest: Topic_not_modified\n            if \"Topic_not_modified\" not in exc.message:\n                raise exc\n\n        # first just close, bot don't hide\n        result = await bot.close_general_forum_topic(\n            chat_id=forum_group_id,\n        )\n        assert result is True, \"Failed to close general forum topic\"\n\n        # then hide\n        result = await bot.hide_general_forum_topic(\n            chat_id=forum_group_id,\n        )\n        assert result is True, \"Failed to hide general forum topic\"\n\n        # then unhide, but don't reopen\n        result = await bot.unhide_general_forum_topic(\n            chat_id=forum_group_id,\n        )\n        assert result is True, \"Failed to unhide general forum topic\"\n\n        # finally, reopen\n        # as this also unhides, this should ensure that the topic is open and visible\n        # for the next test run\n        result = await bot.reopen_general_forum_topic(\n            chat_id=forum_group_id,\n        )\n        assert result is True, \"Failed to reopen general forum topic\""
                    },
                    {
                        "file_path": "tests/test_forum.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_forum.py",
                        "line_range": [
                            49,
                            124
                        ],
                        "reason": "The test 'test_get_set_my_default_administrator_rights' failed due to an assertion error: 'assert False is True'. This indicates that there is a logical error in the assertions made in the tests within the 'TestForumTopicWithoutRequest' class. The specific lines of code that may be causing this issue are related to the expected values being asserted in the tests, particularly in 'test_expected_values' (lines 56-60) and 'test_equality' (lines 86-124). The failure suggests that the expected values do not match the actual values returned by the methods being tested.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "class",
                        "code_snippet": "class TestForumTopicWithoutRequest:\n    def test_slot_behaviour(self, forum_topic_object):\n        inst = forum_topic_object\n        for attr in inst.__slots__:\n            assert getattr(inst, attr, \"err\") != \"err\", f\"got extra slot '{attr}'\"\n        assert len(mro_slots(inst)) == len(set(mro_slots(inst))), \"duplicate slot\"\n\n    async def test_expected_values(self, emoji_id, forum_group_id, forum_topic_object):\n        assert forum_topic_object.message_thread_id == forum_group_id\n        assert forum_topic_object.icon_color == TEST_TOPIC_ICON_COLOR\n        assert forum_topic_object.name == TEST_TOPIC_NAME\n        assert forum_topic_object.icon_custom_emoji_id == emoji_id\n\n    def test_de_json(self, offline_bot, emoji_id, forum_group_id):\n        json_dict = {\n            \"message_thread_id\": forum_group_id,\n            \"name\": TEST_TOPIC_NAME,\n            \"icon_color\": TEST_TOPIC_ICON_COLOR,\n            \"icon_custom_emoji_id\": emoji_id,\n        }\n        topic = ForumTopic.de_json(json_dict, offline_bot)\n        assert topic.api_kwargs == {}\n\n        assert topic.message_thread_id == forum_group_id\n        assert topic.icon_color == TEST_TOPIC_ICON_COLOR\n        assert topic.name == TEST_TOPIC_NAME\n        assert topic.icon_custom_emoji_id == emoji_id\n\n    def test_to_dict(self, emoji_id, forum_group_id, forum_topic_object):\n        topic_dict = forum_topic_object.to_dict()\n\n        assert isinstance(topic_dict, dict)\n        assert topic_dict[\"message_thread_id\"] == forum_group_id\n        assert topic_dict[\"name\"] == TEST_TOPIC_NAME\n        assert topic_dict[\"icon_color\"] == TEST_TOPIC_ICON_COLOR\n        assert topic_dict[\"icon_custom_emoji_id\"] == emoji_id\n\n    def test_equality(self, emoji_id, forum_group_id):\n        a = ForumTopic(\n            message_thread_id=forum_group_id,\n            name=TEST_TOPIC_NAME,\n            icon_color=TEST_TOPIC_ICON_COLOR,\n        )\n        b = ForumTopic(\n            message_thread_id=forum_group_id,\n            name=TEST_TOPIC_NAME,\n            icon_color=TEST_TOPIC_ICON_COLOR,\n            icon_custom_emoji_id=emoji_id,\n        )\n        c = ForumTopic(\n            message_thread_id=forum_group_id,\n            name=f\"{TEST_TOPIC_NAME}!\",\n            icon_color=TEST_TOPIC_ICON_COLOR,\n        )\n        d = ForumTopic(\n            message_thread_id=forum_group_id + 1,\n            name=TEST_TOPIC_NAME,\n            icon_color=TEST_TOPIC_ICON_COLOR,\n        )\n        e = ForumTopic(\n            message_thread_id=forum_group_id,\n            name=TEST_TOPIC_NAME,\n            icon_color=0xFFD67E,\n        )\n\n        assert a == b\n        assert hash(a) == hash(b)\n\n        assert a != c\n        assert hash(a) != hash(c)\n\n        assert a != d\n        assert hash(a) != hash(d)\n\n        assert a != e\n        assert hash(a) != hash(e)"
                    },
                    {
                        "file_path": "tests/test_forum.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/test_forum.py",
                        "line_range": [
                            432,
                            447
                        ],
                        "reason": "The test failures in the 'TestGeneralForumTopicHidden' and 'TestGeneralForumTopicUnhidden' classes indicate that the tests are not correctly validating the behavior of the 'GeneralForumTopicHidden' and 'GeneralForumTopicUnhidden' classes. Specifically, the assertions in 'test_de_json' (lines 439-441 and 457-460) may not be correctly validating the expected outcomes, leading to assertion errors. This suggests that the implementation of these classes may not be returning the expected values.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "class",
                        "code_snippet": "class TestGeneralForumTopicHidden:\n    def test_slot_behaviour(self):\n        action = GeneralForumTopicHidden()\n        for attr in action.__slots__:\n            assert getattr(action, attr, \"err\") != \"err\", f\"got extra slot '{attr}'\"\n        assert len(mro_slots(action)) == len(set(mro_slots(action))), \"duplicate slot\"\n\n    def test_de_json(self):\n        action = GeneralForumTopicHidden.de_json({}, None)\n        assert action.api_kwargs == {}\n        assert isinstance(action, GeneralForumTopicHidden)\n\n    def test_to_dict(self):\n        action = GeneralForumTopicHidden()\n        action_dict = action.to_dict()\n        assert action_dict == {}"
                    }
                ]
            },
            {
                "file_path": "tests/test_invoice.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/_payment/test_invoice.py",
                "faults": [
                    {
                        "file_path": "tests/test_invoice.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/python-telegram-bot/tests/_payment/test_invoice.py",
                        "line_range": [
                            1,
                            319
                        ],
                        "reason": "The CI run failed primarily due to multiple test failures during the execution of pytest. Specific tests such as 'test_get_set_my_default_administrator_rights' failed due to an assertion error indicating a mismatch in expected values (assert False is True). Additionally, multiple tests encountered timeout issues, and others failed due to flood control being exceeded, leading to retries being delayed. These issues suggest potential problems in the test implementations or the handling of asynchronous operations. The tests related to sending messages and handling media are particularly affected, indicating a need for review in those areas.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "file",
                        "code_snippet": "#!/usr/bin/env python\n#\n# A library that provides a Python interface to the Telegram Bot API\n# Copyright (C) 2015-2025\n# Leandro Toledo de Souza <devs@python-telegram-bot.org>\n#\n# This program is free software: you can redistribute it and/or modify\n# it under the terms of the GNU Lesser Public License as published by\n# the Free Software Foundation, either version 3 of the License, or\n# (at your option) any later version.\n#\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY; without even the implied warranty of\n# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n# GNU Lesser Public License for more details.\n#\n# You should have received a copy of the GNU Lesser Public License\n# along with this program.  If not, see [http://www.gnu.org/licenses/].\nimport asyncio\nimport datetime as dtm\n\nimport pytest\n\nfrom telegram import Invoice, LabeledPrice, ReplyParameters\nfrom telegram.constants import ParseMode\nfrom telegram.error import BadRequest\nfrom telegram.request import RequestData\nfrom tests.auxil.build_messages import make_message\nfrom tests.auxil.slots import mro_slots\n\n\n@pytest.fixture(scope=\"module\")\ndef invoice():\n    return Invoice(\n        InvoiceTestBase.title,\n        InvoiceTestBase.description,\n        InvoiceTestBase.start_parameter,\n        InvoiceTestBase.currency,\n        InvoiceTestBase.total_amount,\n    )\n\n\nclass InvoiceTestBase:\n    payload = \"payload\"\n    prices = [LabeledPrice(\"Fish\", 100), LabeledPrice(\"Fish Tax\", 1000)]\n    provider_data = \"\"\"{\"test\":\"test\"}\"\"\"\n    title = \"title\"\n    description = \"description\"\n    start_parameter = \"start_parameter\"\n    currency = \"EUR\"\n    total_amount = sum(p.amount for p in prices)\n    max_tip_amount = 42\n    suggested_tip_amounts = [13, 42]\n\n\nclass TestInvoiceWithoutRequest(InvoiceTestBase):\n    def test_slot_behaviour(self, invoice):\n        for attr in invoice.__slots__:\n            assert getattr(invoice, attr, \"err\") != \"err\", f\"got extra slot '{attr}'\"\n        assert len(mro_slots(invoice)) == len(set(mro_slots(invoice))), \"duplicate slot\"\n\n    def test_de_json(self, offline_bot):\n        invoice_json = Invoice.de_json(\n            {\n                \"title\": self.title,\n                \"description\": self.description,\n                \"start_parameter\": self.start_parameter,\n                \"currency\": self.currency,\n                \"total_amount\": self.total_amount,\n            },\n            offline_bot,\n        )\n        assert invoice_json.api_kwargs == {}\n\n        assert invoice_json.title == self.title\n        assert invoice_json.description == self.description\n        assert invoice_json.start_parameter == self.start_parameter\n        assert invoice_json.currency == self.currency\n        assert invoice_json.total_amount == self.total_amount\n\n    def test_to_dict(self, invoice):\n        invoice_dict = invoice.to_dict()\n\n        assert isinstance(invoice_dict, dict)\n        assert invoice_dict[\"title\"] == invoice.title\n        assert invoice_dict[\"description\"] == invoice.description\n        assert invoice_dict[\"start_parameter\"] == invoice.start_parameter\n        assert invoice_dict[\"currency\"] == invoice.currency\n        assert invoice_dict[\"total_amount\"] == invoice.total_amount\n\n    async def test_send_invoice_all_args_mock(self, offline_bot, monkeypatch):\n        # We do this one as safety guard to make sure that we pass all of the optional\n        # parameters correctly because #2526 went unnoticed for 3 years \u2026\n        async def make_assertion(*args, **_):\n            kwargs = args[1]\n            return all(kwargs[key] == key for key in kwargs)\n\n        monkeypatch.setattr(offline_bot, \"_send_message\", make_assertion)\n        assert await offline_bot.send_invoice(\n            chat_id=\"chat_id\",\n            title=\"title\",\n            description=\"description\",\n            payload=\"payload\",\n            provider_token=\"provider_token\",\n            currency=\"currency\",\n            prices=\"prices\",\n            max_tip_amount=\"max_tip_amount\",\n            suggested_tip_amounts=\"suggested_tip_amounts\",\n            start_parameter=\"start_parameter\",\n            provider_data=\"provider_data\",\n            photo_url=\"photo_url\",\n            photo_size=\"photo_size\",\n            photo_width=\"photo_width\",\n            photo_height=\"photo_height\",\n            need_name=\"need_name\",\n            need_phone_number=\"need_phone_number\",\n            need_email=\"need_email\",\n            need_shipping_address=\"need_shipping_address\",\n            send_phone_number_to_provider=\"send_phone_number_to_provider\",\n            send_email_to_provider=\"send_email_to_provider\",\n            is_flexible=\"is_flexible\",\n            disable_notification=True,\n            protect_content=True,\n        )\n\n    @pytest.mark.parametrize(\"subscription_period\", [42, dtm.timedelta(seconds=42)])\n    async def test_send_all_args_create_invoice_link(\n        self, offline_bot, monkeypatch, subscription_period\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            kwargs = request_data.parameters\n            sp = kwargs.pop(\"subscription_period\") == 42\n            return all(kwargs[i] == i for i in kwargs) and sp\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n        assert await offline_bot.create_invoice_link(\n            title=\"title\",\n            description=\"description\",\n            payload=\"payload\",\n            provider_token=\"provider_token\",\n            currency=\"currency\",\n            prices=\"prices\",\n            max_tip_amount=\"max_tip_amount\",\n            suggested_tip_amounts=\"suggested_tip_amounts\",\n            provider_data=\"provider_data\",\n            photo_url=\"photo_url\",\n            photo_size=\"photo_size\",\n            photo_width=\"photo_width\",\n            photo_height=\"photo_height\",\n            need_name=\"need_name\",\n            need_phone_number=\"need_phone_number\",\n            need_email=\"need_email\",\n            need_shipping_address=\"need_shipping_address\",\n            send_phone_number_to_provider=\"send_phone_number_to_provider\",\n            send_email_to_provider=\"send_email_to_provider\",\n            is_flexible=\"is_flexible\",\n            business_connection_id=\"business_connection_id\",\n            subscription_period=subscription_period,\n        )\n\n    async def test_send_object_as_provider_data(\n        self, monkeypatch, offline_bot, chat_id, provider_token\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            return request_data.json_parameters[\"provider_data\"] == '{\"test_data\": 123456789}'\n\n        monkeypatch.setattr(offline_bot.request, \"post\", make_assertion)\n\n        assert await offline_bot.send_invoice(\n            chat_id,\n            self.title,\n            self.description,\n            self.payload,\n            provider_token,\n            self.currency,\n            self.prices,\n            provider_data={\"test_data\": 123456789},\n            start_parameter=self.start_parameter,\n        )\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"parse_mode\": ParseMode.HTML}, None),\n            ({\"parse_mode\": ParseMode.HTML}, ParseMode.MARKDOWN_V2),\n            ({\"parse_mode\": None}, ParseMode.MARKDOWN_V2),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_invoice_default_quote_parse_mode(\n        self, default_bot, chat_id, invoice, custom, monkeypatch, provider_token\n    ):\n        async def make_assertion(url, request_data: RequestData, *args, **kwargs):\n            assert request_data.parameters[\"reply_parameters\"].get(\"quote_parse_mode\") == (\n                custom or default_bot.defaults.quote_parse_mode\n            )\n            return make_message(\"dummy reply\").to_dict()\n\n        kwargs = {\"message_id\": 1}\n        if custom is not None:\n            kwargs[\"quote_parse_mode\"] = custom\n\n        monkeypatch.setattr(default_bot.request, \"post\", make_assertion)\n        await default_bot.send_invoice(\n            chat_id,\n            self.title,\n            self.description,\n            self.payload,\n            provider_token,\n            self.currency,\n            self.prices,\n            reply_parameters=ReplyParameters(**kwargs),\n        )\n\n    def test_equality(self):\n        a = Invoice(\"invoice\", \"desc\", \"start\", \"EUR\", 7)\n        b = Invoice(\"invoice\", \"desc\", \"start\", \"EUR\", 7)\n        c = Invoice(\"invoices\", \"description\", \"stop\", \"USD\", 8)\n        d = LabeledPrice(\"label\", 5)\n\n        assert a == b\n        assert hash(a) == hash(b)\n\n        assert a != c\n        assert hash(a) != hash(c)\n\n        assert a != d\n        assert hash(a) != hash(d)\n\n\nclass TestInvoiceWithRequest(InvoiceTestBase):\n    async def test_send_required_args_only(self, bot, chat_id, provider_token):\n        message = await bot.send_invoice(\n            chat_id=chat_id,\n            title=self.title,\n            description=self.description,\n            payload=self.payload,\n            provider_token=provider_token,\n            currency=self.currency,\n            prices=self.prices,\n        )\n\n        assert message.invoice.currency == self.currency\n        assert not message.invoice.start_parameter\n        assert message.invoice.description == self.description\n        assert message.invoice.title == self.title\n        assert message.invoice.total_amount == self.total_amount\n\n        link = await bot.create_invoice_link(\n            title=self.title,\n            description=self.description,\n            payload=self.payload,\n            provider_token=provider_token,\n            currency=self.currency,\n            prices=self.prices,\n        )\n\n        assert isinstance(link, str)\n        assert link\n\n    @pytest.mark.parametrize(\"default_bot\", [{\"protect_content\": True}], indirect=True)\n    async def test_send_invoice_default_protect_content(\n        self, chat_id, default_bot, provider_token\n    ):\n        tasks = asyncio.gather(\n            *(\n                default_bot.send_invoice(\n                    chat_id,\n                    self.title,\n                    self.description,\n                    self.payload,\n                    self.currency,\n                    self.prices,\n                    provider_token,\n                    **kwargs,\n                )\n                for kwargs in ({}, {\"protect_content\": False})\n            )\n        )\n        protected, unprotected = await tasks\n        assert protected.has_protected_content\n        assert not unprotected.has_protected_content\n\n    @pytest.mark.parametrize(\n        (\"default_bot\", \"custom\"),\n        [\n            ({\"allow_sending_without_reply\": True}, None),\n            ({\"allow_sending_without_reply\": False}, None),\n            ({\"allow_sending_without_reply\": False}, True),\n        ],\n        indirect=[\"default_bot\"],\n    )\n    async def test_send_invoice_default_allow_sending_without_reply(\n        self, default_bot, chat_id, custom, provider_token\n    ):\n        reply_to_message = await default_bot.send_message(chat_id, \"test\")\n        await reply_to_message.delete()\n        if custom is not None:\n            message = await default_bot.send_invoice(\n                chat_id,\n                self.title,\n                self.description,\n                self.payload,\n                \"XTR\",\n                [self.prices[0]],\n                allow_sending_without_reply=custom,\n                reply_to_message_id=reply_to_message.message_id,\n            )\n            assert message.reply_to_message is None\n            assert message.invoice.currency == \"XTR\"\n        elif default_bot.defaults.allow_sending_without_reply:\n            message = await default_bot.send_invoice(\n                chat_id,\n                self.title,\n                self.description,\n                self.payload,\n                self.currency,\n                self.prices,\n                provider_token,"
                    }
                ]
            }
        ]
    },
    {
        "sha_fail": "6066f06de3275801b19af5f23ccb5e3940991e60",
        "fault_localization_data": [
            {
                "file_path": "Lib/pathlib/types.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/cpython/Lib/pathlib/types.py",
                "faults": [
                    {
                        "file_path": "Lib/pathlib/types.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/cpython/Lib/pathlib/types.py",
                        "line_range": [
                            1,
                            400
                        ],
                        "reason": "The CI run failed during the 'lint' step due to a failure in the trailing whitespace check. The linting process indicated that files were modified by the hook to fix the trailing whitespace issue, but the initial failure was sufficient to mark the CI run as unsuccessful. This issue is related to code formatting and is evidenced by the message '- hook id: trailing-whitespace - exit code: 1 - files were modified by this hook'.",
                        "issue_type": "formatting",
                        "fault_localization_level": "file",
                        "code_snippet": "\"\"\"\nProtocols for supporting classes in pathlib.\n\"\"\"\n\n# This module also provides abstract base classes for rich path objects.\n# These ABCs are a *private* part of the Python standard library, but they're\n# made available as a PyPI package called \"pathlib-abc\". It's possible they'll\n# become an official part of the standard library in future.\n#\n# Three ABCs are provided -- _JoinablePath, _ReadablePath and _WritablePath\n\n\nfrom abc import ABC, abstractmethod\nfrom glob import _GlobberBase\nfrom io import text_encoding\nfrom pathlib._os import (vfsopen, vfspath, ensure_distinct_paths,\n                         ensure_different_files, copyfileobj)\nfrom pathlib import PurePath, Path\nfrom typing import Optional, Protocol, runtime_checkable\n\n\ndef _explode_path(path, split):\n    \"\"\"\n    Split the path into a 2-tuple (anchor, parts), where *anchor* is the\n    uppermost parent of the path (equivalent to path.parents[-1]), and\n    *parts* is a reversed list of parts following the anchor.\n    \"\"\"\n    parent, name = split(path)\n    names = []\n    while path != parent:\n        names.append(name)\n        path = parent\n        parent, name = split(path)\n    return path, names\n\n\n@runtime_checkable\nclass _PathParser(Protocol):\n    \"\"\"Protocol for path parsers, which do low-level path manipulation.\n\n    Path parsers provide a subset of the os.path API, specifically those\n    functions needed to provide JoinablePath functionality. Each JoinablePath\n    subclass references its path parser via a 'parser' class attribute.\n    \"\"\"\n\n    sep: str\n    altsep: Optional[str]\n    def split(self, path: str) -> tuple[str, str]: ...\n    def splitext(self, path: str) -> tuple[str, str]: ...\n    def normcase(self, path: str) -> str: ...\n\n\n@runtime_checkable\nclass PathInfo(Protocol):\n    \"\"\"Protocol for path info objects, which support querying the file type.\n    Methods may return cached results.\n    \"\"\"\n    def exists(self, *, follow_symlinks: bool = True) -> bool: ...\n    def is_dir(self, *, follow_symlinks: bool = True) -> bool: ...\n    def is_file(self, *, follow_symlinks: bool = True) -> bool: ...\n    def is_symlink(self) -> bool: ...\n\n\nclass _PathGlobber(_GlobberBase):\n    \"\"\"Provides shell-style pattern matching and globbing for ReadablePath.\n    \"\"\"\n\n    @staticmethod\n    def lexists(path):\n        return path.info.exists(follow_symlinks=False)\n\n    @staticmethod\n    def scandir(path):\n        return ((child.info, child.name, child) for child in path.iterdir())\n\n    @staticmethod\n    def concat_path(path, text):\n        return path.with_segments(vfspath(path) + text)\n\n    stringify_path = staticmethod(vfspath)\n\n\nclass _JoinablePath(ABC):\n    \"\"\"Abstract base class for pure path objects.\n\n    This class *does not* provide several magic methods that are defined in\n    its implementation PurePath. They are: __init__, __fspath__, __bytes__,\n    __reduce__, __hash__, __eq__, __lt__, __le__, __gt__, __ge__.\n    \"\"\"\n    __slots__ = ()\n\n    @property\n    @abstractmethod\n    def parser(self):\n        \"\"\"Implementation of pathlib._types.Parser used for low-level path\n        parsing and manipulation.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def with_segments(self, *pathsegments):\n        \"\"\"Construct a new path object from any number of path-like objects.\n        Subclasses may override this method to customize how new path objects\n        are created from methods like `iterdir()`.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def __vfspath__(self):\n        \"\"\"Return the string representation of the path.\"\"\"\n        raise NotImplementedError\n\n    @property\n    def anchor(self):\n        \"\"\"The concatenation of the drive and root, or ''.\"\"\"\n        return _explode_path(vfspath(self), self.parser.split)[0]\n\n    @property\n    def name(self):\n        \"\"\"The final path component, if any.\"\"\"\n        return self.parser.split(vfspath(self))[1]\n\n    @property\n    def suffix(self):\n        \"\"\"\n        The final component's last suffix, if any.\n\n        This includes the leading period. For example: '.txt'\n        \"\"\"\n        return self.parser.splitext(self.name)[1]\n\n    @property\n    def suffixes(self):\n        \"\"\"\n        A list of the final component's suffixes, if any.\n\n        These include the leading periods. For example: ['.tar', '.gz']\n        \"\"\"\n        split = self.parser.splitext\n        stem, suffix = split(self.name)\n        suffixes = []\n        while suffix:\n            suffixes.append(suffix)\n            stem, suffix = split(stem)\n        return suffixes[::-1]\n\n    @property\n    def stem(self):\n        \"\"\"The final path component, minus its last suffix.\"\"\"\n        return self.parser.splitext(self.name)[0]\n\n    def with_name(self, name):\n        \"\"\"Return a new path with the file name changed.\"\"\"\n        split = self.parser.split\n        if split(name)[0]:\n            raise ValueError(f\"Invalid name {name!r}\")\n        path = vfspath(self)\n        path = path.removesuffix(split(path)[1]) + name\n        return self.with_segments(path)\n\n    def with_stem(self, stem):\n        \"\"\"Return a new path with the stem changed.\"\"\"\n        suffix = self.suffix\n        if not suffix:\n            return self.with_name(stem)\n        elif not stem:\n            # If the suffix is non-empty, we can't make the stem empty.\n            raise ValueError(f\"{self!r} has a non-empty suffix\")\n        else:\n            return self.with_name(stem + suffix)\n\n    def with_suffix(self, suffix):\n        \"\"\"Return a new path with the file suffix changed.  If the path\n        has no suffix, add given suffix.  If the given suffix is an empty\n        string, remove the suffix from the path.\n        \"\"\"\n        stem = self.stem\n        if not stem:\n            # If the stem is empty, we can't make the suffix non-empty.\n            raise ValueError(f\"{self!r} has an empty name\")\n        elif suffix and not suffix.startswith('.'):\n            raise ValueError(f\"Invalid suffix {suffix!r}\")\n        else:\n            return self.with_name(stem + suffix)\n\n    def without_suffix(self):\n        \"\"\"Return a new path without the file suffix.  Readable alternative \n        for providing empty string to with_suffix.\n        \"\"\"\n        return self.with_suffix('')\n    \n    @property\n    def parts(self):\n        \"\"\"An object providing sequence-like access to the\n        components in the filesystem path.\"\"\"\n        anchor, parts = _explode_path(vfspath(self), self.parser.split)\n        if anchor:\n            parts.append(anchor)\n        return tuple(reversed(parts))\n\n    def joinpath(self, *pathsegments):\n        \"\"\"Combine this path with one or several arguments, and return a\n        new path representing either a subpath (if all arguments are relative\n        paths) or a totally different path (if one of the arguments is\n        anchored).\n        \"\"\"\n        return self.with_segments(vfspath(self), *pathsegments)\n\n    def __truediv__(self, key):\n        try:\n            return self.with_segments(vfspath(self), key)\n        except TypeError:\n            return NotImplemented\n\n    def __rtruediv__(self, key):\n        try:\n            return self.with_segments(key, vfspath(self))\n        except TypeError:\n            return NotImplemented\n\n    @property\n    def parent(self):\n        \"\"\"The logical parent of the path.\"\"\"\n        path = vfspath(self)\n        parent = self.parser.split(path)[0]\n        if path != parent:\n            return self.with_segments(parent)\n        return self\n\n    @property\n    def parents(self):\n        \"\"\"A sequence of this path's logical parents.\"\"\"\n        split = self.parser.split\n        path = vfspath(self)\n        parent = split(path)[0]\n        parents = []\n        while path != parent:\n            parents.append(self.with_segments(parent))\n            path = parent\n            parent = split(path)[0]\n        return tuple(parents)\n\n    def full_match(self, pattern):\n        \"\"\"\n        Return True if this path matches the given glob-style pattern. The\n        pattern is matched against the entire path.\n        \"\"\"\n        case_sensitive = self.parser.normcase('Aa') == 'Aa'\n        globber = _PathGlobber(self.parser.sep, case_sensitive, recursive=True)\n        match = globber.compile(pattern, altsep=self.parser.altsep)\n        return match(vfspath(self)) is not None\n\n\nclass _ReadablePath(_JoinablePath):\n    \"\"\"Abstract base class for readable path objects.\n\n    The Path class implements this ABC for local filesystem paths. Users may\n    create subclasses to implement readable virtual filesystem paths, such as\n    paths in archive files or on remote storage systems.\n    \"\"\"\n    __slots__ = ()\n\n    @property\n    @abstractmethod\n    def info(self):\n        \"\"\"\n        A PathInfo object that exposes the file type and other file attributes\n        of this path.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def __open_reader__(self):\n        \"\"\"\n        Open the file pointed to by this path for reading in binary mode and\n        return a file object.\n        \"\"\"\n        raise NotImplementedError\n\n    def read_bytes(self):\n        \"\"\"\n        Open the file in bytes mode, read it, and close the file.\n        \"\"\"\n        with vfsopen(self, mode='rb') as f:\n            return f.read()\n\n    def read_text(self, encoding=None, errors=None, newline=None):\n        \"\"\"\n        Open the file in text mode, read it, and close the file.\n        \"\"\"\n        # Call io.text_encoding() here to ensure any warning is raised at an\n        # appropriate stack level.\n        encoding = text_encoding(encoding)\n        with vfsopen(self, mode='r', encoding=encoding, errors=errors, newline=newline) as f:\n            return f.read()\n\n    @abstractmethod\n    def iterdir(self):\n        \"\"\"Yield path objects of the directory contents.\n\n        The children are yielded in arbitrary order, and the\n        special entries '.' and '..' are not included.\n        \"\"\"\n        raise NotImplementedError\n\n    def glob(self, pattern, *, recurse_symlinks=True):\n        \"\"\"Iterate over this subtree and yield all existing files (of any\n        kind, including directories) matching the given relative pattern.\n        \"\"\"\n        anchor, parts = _explode_path(pattern, self.parser.split)\n        if anchor:\n            raise NotImplementedError(\"Non-relative patterns are unsupported\")\n        elif not parts:\n            raise ValueError(f\"Unacceptable pattern: {pattern!r}\")\n        elif not recurse_symlinks:\n            raise NotImplementedError(\"recurse_symlinks=False is unsupported\")\n        case_sensitive = self.parser.normcase('Aa') == 'Aa'\n        globber = _PathGlobber(self.parser.sep, case_sensitive, recursive=True)\n        select = globber.selector(parts)\n        return select(self.joinpath(''))\n\n    def walk(self, top_down=True, on_error=None, follow_symlinks=False):\n        \"\"\"Walk the directory tree from this directory, similar to os.walk().\"\"\"\n        paths = [self]\n        while paths:\n            path = paths.pop()\n            if isinstance(path, tuple):\n                yield path\n                continue\n            dirnames = []\n            filenames = []\n            if not top_down:\n                paths.append((path, dirnames, filenames))\n            try:\n                for child in path.iterdir():\n                    if child.info.is_dir(follow_symlinks=follow_symlinks):\n                        if not top_down:\n                            paths.append(child)\n                        dirnames.append(child.name)\n                    else:\n                        filenames.append(child.name)\n            except OSError as error:\n                if on_error is not None:\n                    on_error(error)\n                if not top_down:\n                    while not isinstance(paths.pop(), tuple):\n                        pass\n                continue\n            if top_down:\n                yield path, dirnames, filenames\n                paths += [path.joinpath(d) for d in reversed(dirnames)]\n\n    @abstractmethod\n    def readlink(self):\n        \"\"\"\n        Return the path to which the symbolic link points.\n        \"\"\"\n        raise NotImplementedError\n\n    def copy(self, target, **kwargs):\n        \"\"\"\n        Recursively copy this file or directory tree to the given destination.\n        \"\"\"\n        ensure_distinct_paths(self, target)\n        target._copy_from(self, **kwargs)\n        return target.joinpath()  # Empty join to ensure fresh metadata.\n\n    def copy_into(self, target_dir, **kwargs):\n        \"\"\"\n        Copy this file or directory tree into the given existing directory.\n        \"\"\"\n        name = self.name\n        if not name:\n            raise ValueError(f\"{self!r} has an empty name\")\n        return self.copy(target_dir / name, **kwargs)\n\n\nclass _WritablePath(_JoinablePath):\n    \"\"\"Abstract base class for writable path objects.\n\n    The Path class implements this ABC for local filesystem paths. Users may\n    create subclasses to implement writable virtual filesystem paths, such as\n    paths in archive files or on remote storage systems.\n    \"\"\"\n    __slots__ = ()\n\n    @abstractmethod\n    def symlink_to(self, target, target_is_directory=False):\n        \"\"\"\n        Make this path a symlink pointing to the target path.\n        Note the order of arguments (link, target) is the reverse of os.symlink.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def mkdir(self):\n        \"\"\"\n        Create a new directory at this given path.\n        \"\"\"\n        raise NotImplementedError"
                    },
                    {
                        "file_path": "Lib/pathlib/types.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/cpython/Lib/pathlib/types.py",
                        "line_range": [
                            378,
                            450
                        ],
                        "reason": "The CI run failed during the 'lint' step due to a failure in the trailing whitespace check. The linting process indicated that files were modified by the hook to fix the trailing whitespace issue, but the initial failure was sufficient to mark the CI run as unsuccessful. This issue is related to code formatting and is evidenced by the message '- hook id: trailing-whitespace - exit code: 1 - files were modified by this hook'.",
                        "issue_type": "formatting",
                        "fault_localization_level": "class",
                        "code_snippet": "class _WritablePath(_JoinablePath):\n    \"\"\"Abstract base class for writable path objects.\n\n    The Path class implements this ABC for local filesystem paths. Users may\n    create subclasses to implement writable virtual filesystem paths, such as\n    paths in archive files or on remote storage systems.\n    \"\"\"\n    __slots__ = ()\n\n    @abstractmethod\n    def symlink_to(self, target, target_is_directory=False):\n        \"\"\"\n        Make this path a symlink pointing to the target path.\n        Note the order of arguments (link, target) is the reverse of os.symlink.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def mkdir(self):\n        \"\"\"\n        Create a new directory at this given path.\n        \"\"\"\n        raise NotImplementedError\n\n    @abstractmethod\n    def __open_writer__(self, mode):\n        \"\"\"\n        Open the file pointed to by this path for writing in binary mode and\n        return a file object.\n        \"\"\"\n        raise NotImplementedError\n\n    def write_bytes(self, data):\n        \"\"\"\n        Open the file in bytes mode, write to it, and close the file.\n        \"\"\"\n        # type-check for the buffer interface before truncating the file\n        view = memoryview(data)\n        with vfsopen(self, mode='wb') as f:\n            return f.write(view)\n\n    def write_text(self, data, encoding=None, errors=None, newline=None):\n        \"\"\"\n        Open the file in text mode, write to it, and close the file.\n        \"\"\"\n        # Call io.text_encoding() here to ensure any warning is raised at an\n        # appropriate stack level.\n        encoding = text_encoding(encoding)\n        if not isinstance(data, str):\n            raise TypeError('data must be str, not %s' %\n                            data.__class__.__name__)\n        with vfsopen(self, mode='w', encoding=encoding, errors=errors, newline=newline) as f:\n            return f.write(data)\n\n    def _copy_from(self, source, follow_symlinks=True):\n        \"\"\"\n        Recursively copy the given path to this path.\n        \"\"\"\n        stack = [(source, self)]\n        while stack:\n            src, dst = stack.pop()\n            if not follow_symlinks and src.info.is_symlink():\n                dst.symlink_to(vfspath(src.readlink()), src.info.is_dir())\n            elif src.info.is_dir():\n                children = src.iterdir()\n                dst.mkdir()\n                for child in children:\n                    stack.append((child, dst.joinpath(child.name)))\n            else:\n                ensure_different_files(src, dst)\n                with vfsopen(src, 'rb') as source_f:\n                    with vfsopen(dst, 'wb') as target_f:\n                        copyfileobj(source_f, target_f)"
                    }
                ]
            }
        ]
    },
    {
        "sha_fail": "b828018b142c3297f962643eea8c07ce460072ab",
        "fault_localization_data": [
            {
                "file_path": "llama_index/pyproject.toml",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/llama_index/llama-index-integrations/readers/llama-index-readers-mangadex/pyproject.toml",
                "faults": [
                    {
                        "file_path": "llama_index/pyproject.toml",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/llama_index/llama-index-integrations/readers/llama-index-readers-mangadex/pyproject.toml",
                        "line_range": [
                            1,
                            66
                        ],
                        "reason": "The CI run failed due to two configuration errors: 1) A missing configuration file 'uv.toml' which is required for the 'Install uv and set the Python version' step, indicating a potential misconfiguration or missing file. 2) An empty '--base-ref' option in the command for 'Run tests with coverage', which is required for the command to execute properly. These issues are critical for the testing process and need to be addressed.",
                        "issue_type": "configuration_error",
                        "fault_localization_level": "file",
                        "code_snippet": "[build-system]\nrequires = [\"hatchling\"]\nbuild-backend = \"hatchling.build\"\n\n[dependency-groups]\ndev = [\n    \"ipython==8.10.0\",\n    \"jupyter>=1.0.0,<2\",\n    \"mypy==0.991\",\n    \"pre-commit==3.2.0\",\n    \"pylint==2.15.10\",\n    \"pytest==7.2.1\",\n    \"pytest-mock==3.11.1\",\n    \"ruff==0.11.11\",\n    \"types-Deprecated>=0.1.0\",\n    \"types-PyYAML>=6.0.12.12,<7\",\n    \"types-protobuf>=4.24.0.4,<5\",\n    \"types-redis==4.5.5.0\",\n    \"types-requests==2.28.11.8\",\n    \"types-setuptools==67.1.0.0\",\n    \"black[jupyter]<=23.9.1,>=23.7.0\",\n    \"codespell[toml]>=v2.2.6\",\n    \"diff-cover>=9.2.0\",\n    \"pytest-cov>=6.1.1\",\n]\n\n[project]\nname = \"llama-index-readers-mangadex\"\nversion = \"0.4.1\"\ndescription = \"llama-index readers mangadex integration\"\nauthors = [{name = \"Your Name\", email = \"you@example.com\"}]\nrequires-python = \">=3.9,<4.0\"\nreadme = \"README.md\"\nlicense = \"MIT\"\nmaintainers = [{name = \"choombaa\"}]\nkeywords = [\n    \"anime\",\n    \"manga\",\n]\ndependencies = [\"llama-index-core>=0.13.0,<0.15\"]\n\n[tool.codespell]\ncheck-filenames = true\ncheck-hidden = true\nskip = \"*.csv,*.html,*.json,*.jsonl,*.pdf,*.txt,*.ipynb\"\n\n[tool.hatch.build.targets.sdist]\ninclude = [\"llama_index/\"]\nexclude = [\"**/BUILD\"]\n\n[tool.hatch.build.targets.wheel]\ninclude = [\"llama_index/\"]\nexclude = [\"**/BUILD\"]\n\n[tool.llamahub]\ncontains_example = false\nimport_path = \"llama_index.readers.mangadex\"\n\n[tool.llamahub.class_authors]\nMangaDexReader = \"choombaa\"\n\n[tool.mypy]\ndisallow_untyped_defs = true\nexclude = [\"_static\", \"build\", \"examples\", \"notebooks\", \"venv\"]\nignore_missing_imports = true\npython_version = \"3.8\""
                    }
                ]
            }
        ]
    },
    {
        "sha_fail": "d01a6ec49f1aac932816c81c0354de64c0183373",
        "fault_localization_data": [
            {
                "file_path": "lib/core/ncgui.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlmap/lib/core/ncgui.py",
                "faults": [
                    {
                        "file_path": "lib/core/ncgui.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlmap/lib/core/ncgui.py",
                        "line_range": [
                            8,
                            23
                        ],
                        "reason": "The CI run failed during the 'Smoke test' step due to an ImportError when attempting to import the module 'lib.core.ncgui'. The error message indicated 'No module named '_curses'', which suggests that the required '_curses' module is not available in the Python environment. This is directly related to the import statement for the 'curses' module, which is essential for the functionality of the NcursesUI class. Lines 8-23 contain the import statements, including the missing '_curses' module.",
                        "issue_type": "dependency_error",
                        "fault_localization_level": "import_block",
                        "code_snippet": "import curses\nimport os\nimport subprocess\nimport sys\nimport tempfile\n\nfrom lib.core.common import getSafeExString\nfrom lib.core.common import saveConfig\nfrom lib.core.data import paths\nfrom lib.core.defaults import defaults\nfrom lib.core.enums import MKSTEMP_PREFIX\nfrom lib.core.exception import SqlmapMissingDependence\nfrom lib.core.exception import SqlmapSystemException\nfrom lib.core.settings import IS_WIN\nfrom thirdparty.six.moves import queue as _queue\nfrom thirdparty.six.moves import configparser as _configparser"
                    }
                ]
            }
        ]
    },
    {
        "sha_fail": "71b7fd4a926acb2c018af855f325502bfe03d417",
        "fault_localization_data": [
            {
                "file_path": "dspy/teleprompt/grpo.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/dspy/dspy/teleprompt/grpo.py",
                "faults": [
                    {
                        "file_path": "dspy/teleprompt/grpo.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/dspy/dspy/teleprompt/grpo.py",
                        "line_range": [
                            1,
                            19
                        ],
                        "reason": "Ruff found issues related to import order. The imports should be organized according to PEP 8 guidelines, which typically suggest grouping standard library imports, related third-party imports, and local application/library specific imports. The specific rule code for this issue is related to import order violations.",
                        "issue_type": "formatting",
                        "fault_localization_level": "import_block",
                        "code_snippet": "import logging\nimport random\nfrom collections import Counter\nfrom typing import Any, Callable, Literal\n\nfrom dspy.adapters.base import Adapter\nfrom dspy.adapters.chat_adapter import ChatAdapter\nfrom dspy.clients.lm import LM\nfrom dspy.clients.utils_finetune import GRPOGroup, TrainDataFormat, MultiGPUConfig\nfrom dspy.dsp.utils.settings import settings\nfrom dspy.evaluate.evaluate import Evaluate\nfrom dspy.primitives.example import Example\nfrom dspy.primitives.module import Module\nfrom dspy.teleprompt.bootstrap_finetune import (\n    FinetuneTeleprompter,\n    all_predictors_have_lms,\n    assert_structural_equivalency,\n)\nfrom dspy.teleprompt.bootstrap_trace import FailedPrediction, bootstrap_trace_data"
                    }
                ]
            },
            {
                "file_path": "dspy/clients/lm.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/dspy/dspy/clients/lm.py",
                "faults": [
                    {
                        "file_path": "dspy/clients/lm.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/dspy/dspy/clients/lm.py",
                        "line_range": [
                            1,
                            20
                        ],
                        "reason": "Ruff found issues with import order. The imports should be organized according to PEP 8 guidelines, which typically suggest grouping standard library imports, related third-party imports, and local application/library specific imports. The current order does not adhere to this standard, leading to formatting issues. Lines 1-20 contain the import statements that need reordering.",
                        "issue_type": "formatting",
                        "fault_localization_level": "import_block",
                        "code_snippet": "import logging\nimport os\nimport re\nimport threading\nimport warnings\nfrom typing import Any, Literal, cast\n\nimport litellm\nfrom anyio.streams.memory import MemoryObjectSendStream\nfrom asyncer import syncify\n\nimport dspy\nfrom dspy.clients.cache import request_cache\nfrom dspy.clients.openai import OpenAIProvider\nfrom dspy.clients.provider import Provider, ReinforceJob, TrainingJob\nfrom dspy.clients.utils_finetune import TrainDataFormat, MultiGPUConfig\nfrom dspy.dsp.utils.settings import settings\nfrom dspy.utils.callback import BaseCallback\n\nfrom .base_lm import BaseLM"
                    },
                    {
                        "file_path": "dspy/clients/lm.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/dspy/dspy/clients/lm.py",
                        "line_range": [
                            401,
                            465
                        ],
                        "reason": "Ruff found issues with import order. The imports should be organized according to PEP 8 guidelines, which typically suggest grouping standard library imports, related third-party imports, and local application/library specific imports. The current order does not adhere to this standard, leading to formatting issues. Lines 1-20 contain the import statements that need reordering. Additionally, there are potential issues with type hints in the function signatures, specifically the use of 'dict[str, Any]' and 'dict[str, Any] | None', which may not be compatible with all Python versions. This could lead to type errors in certain environments. Lines 358-465 contain function definitions that may require type hint adjustments.",
                        "issue_type": "formatting | type_error",
                        "fault_localization_level": "class",
                        "code_snippet": "\nasync def alitellm_text_completion(request: dict[str, Any], num_retries: int, cache: dict[str, Any] | None = None):\n    cache = cache or {\"no-cache\": True, \"no-store\": True}\n    request = dict(request)\n    request.pop(\"rollout_id\", None)\n    model = request.pop(\"model\").split(\"/\", 1)\n    provider, model = model[0] if len(model) > 1 else \"openai\", model[-1]\n\n    # Use the API key and base from the request, or from the environment.\n    api_key = request.pop(\"api_key\", None) or os.getenv(f\"{provider}_API_KEY\")\n    api_base = request.pop(\"api_base\", None) or os.getenv(f\"{provider}_API_BASE\")\n\n    # Build the prompt from the messages.\n    prompt = \"\\n\\n\".join([x[\"content\"] for x in request.pop(\"messages\")] + [\"BEGIN RESPONSE:\"])\n\n    return await litellm.atext_completion(\n        cache=cache,\n        model=f\"text-completion-openai/{model}\",\n        api_key=api_key,\n        api_base=api_base,\n        prompt=prompt,\n        num_retries=num_retries,\n        retry_strategy=\"exponential_backoff_retry\",\n        **request,\n    )\n\ndef litellm_responses_completion(request: dict[str, Any], num_retries: int, cache: dict[str, Any] | None = None):\n    cache = cache or {\"no-cache\": True, \"no-store\": True}\n    request = dict(request)\n    request.pop(\"rollout_id\", None)\n    request = _convert_chat_request_to_responses_request(request)\n\n    return litellm.responses(\n        cache=cache,\n        num_retries=num_retries,\n        retry_strategy=\"exponential_backoff_retry\",\n        **request,\n    )\n\n\nasync def alitellm_responses_completion(request: dict[str, Any], num_retries: int, cache: dict[str, Any] | None = None):\n    cache = cache or {\"no-cache\": True, \"no-store\": True}\n    request = dict(request)\n    request.pop(\"rollout_id\", None)\n    request = _convert_chat_request_to_responses_request(request)\n\n    return await litellm.aresponses(\n        cache=cache,\n        num_retries=num_retries,\n        retry_strategy=\"exponential_backoff_retry\",\n        **request,\n    )\n\ndef _convert_chat_request_to_responses_request(request: dict[str, Any]):\n    request = dict(request)\n    if \"messages\" in request:\n        content_blocks = []\n        for msg in request.pop(\"messages\"):\n            c = msg.get(\"content\")\n            if isinstance(c, str):\n                content_blocks.append({\"type\": \"input_text\", \"text\": c})\n            elif isinstance(c, list):\n                content_blocks.extend(c)\n        request[\"input\"] = [{\"role\": msg.get(\"role\", \"user\"), \"content\": content_blocks}]\n    return request"
                    }
                ]
            },
            {
                "file_path": "dspy/clients/provider.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/dspy/dspy/clients/provider.py",
                "faults": [
                    {
                        "file_path": "dspy/clients/provider.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/dspy/dspy/clients/provider.py",
                        "line_range": [
                            1,
                            6
                        ],
                        "reason": "Ruff found issues with import order. The imports should be organized according to PEP 8 guidelines, which typically suggest standard library imports first, followed by third-party imports, and then local application/library specific imports. Lines 1-6 contain import statements that may not adhere to this order.",
                        "issue_type": "formatting",
                        "fault_localization_level": "import_block",
                        "code_snippet": "from abc import abstractmethod\nfrom concurrent.futures import Future\nfrom threading import Thread\nfrom typing import TYPE_CHECKING, Any\n\nfrom dspy.clients.utils_finetune import TrainDataFormat, MultiGPUConfig"
                    },
                    {
                        "file_path": "dspy/clients/provider.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/dspy/dspy/clients/provider.py",
                        "line_range": [
                            12,
                            35
                        ],
                        "reason": "The class 'TrainingJob' inherits from 'Future' but does not implement all abstract methods required by 'Future'. This could lead to runtime errors when instances of 'TrainingJob' are created. Specifically, the 'cancel' method is overridden but not implemented correctly, and the 'status' method is abstract. Lines 12-35 define the class and its methods.",
                        "issue_type": "runtime_error",
                        "fault_localization_level": "class",
                        "code_snippet": "class TrainingJob(Future):\n    def __init__(\n        self,\n        thread: Thread | None = None,\n        model: str | None = None,\n        train_data: list[dict[str, Any]] | None = None,\n        train_data_format: TrainDataFormat | None = None,\n        train_kwargs: dict[str, Any] | None = None,\n    ):\n        self.thread = thread\n        self.model = model\n        self.train_data = train_data\n        self.train_data_format = train_data_format\n        self.train_kwargs = train_kwargs or {}\n        super().__init__()\n\n    # Subclasses should override the cancel method to cancel the job; then call\n    # the super's cancel method so that the future can be cancelled.\n    def cancel(self):\n        super().cancel()\n\n    @abstractmethod\n    def status(self):\n        raise NotImplementedError"
                    },
                    {
                        "file_path": "dspy/clients/provider.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/dspy/dspy/clients/provider.py",
                        "line_range": [
                            38,
                            72
                        ],
                        "reason": "The class 'ReinforceJob' contains multiple abstract methods that are not implemented. This will cause runtime errors when attempting to instantiate 'ReinforceJob'. The methods 'initialize', 'step', 'terminate', 'update_model', and 'save_checkpoint' are all abstract and must be implemented in subclasses. Lines 38-72 define the class and its methods.",
                        "issue_type": "runtime_error",
                        "fault_localization_level": "class",
                        "code_snippet": "class ReinforceJob:\n    def __init__(self, lm: \"LM\", train_kwargs: dict[str, Any] | None = None, gpu_config: MultiGPUConfig = MultiGPUConfig(num_inference_gpus=1, num_training_gpus=1)):\n        self.lm = lm\n        self.train_kwargs = train_kwargs or {}\n        self.gpu_config = gpu_config\n        self.checkpoints = {}\n        self.last_checkpoint = None\n        self.gpu_config = gpu_config\n\n\n    @abstractmethod\n    def initialize(self):\n        raise NotImplementedError\n\n    @abstractmethod\n    def step(self, train_data: list[dict[str, Any]], train_data_format: TrainDataFormat | str | None = None):\n        raise NotImplementedError\n\n    @abstractmethod\n    def terminate(self):\n        raise NotImplementedError\n\n    @abstractmethod\n    def update_model(self):\n        raise NotImplementedError\n\n    @abstractmethod\n    def save_checkpoint(self, checkpoint_name: str):\n        raise NotImplementedError\n\n    def cancel(self):\n        raise NotImplementedError\n\n    def status(self):\n        raise NotImplementedError"
                    },
                    {
                        "file_path": "dspy/clients/provider.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/dspy/dspy/clients/provider.py",
                        "line_range": [
                            75,
                            111
                        ],
                        "reason": "The class 'Provider' contains a method 'finetune' that raises NotImplementedError. This indicates that the method is not implemented, which will lead to runtime errors if called. Lines 75-111 define the class and its methods.",
                        "issue_type": "runtime_error",
                        "fault_localization_level": "class",
                        "code_snippet": "class Provider:\n    def __init__(self):\n        self.finetunable = False\n        self.reinforceable = False\n        self.TrainingJob = TrainingJob\n        self.ReinforceJob = ReinforceJob\n\n    @staticmethod\n    def is_provider_model(model: str) -> bool:\n        # Subclasses should actually check whether a model is supported if they\n        # want to have the model provider auto-discovered.\n        return False\n\n    @staticmethod\n    def launch(lm: \"LM\", launch_kwargs: dict[str, Any] | None = None):\n        # Note that \"launch\" and \"kill\" methods might be called even if there\n        # is a launched LM or no launched LM to kill. These methods should be\n        # resillient to such cases.\n        pass\n\n    @staticmethod\n    def kill(lm: \"LM\", launch_kwargs: dict[str, Any] | None = None):\n        # We assume that LM.launch_kwargs dictionary will contain the necessary\n        # information for a provider to launch and/or kill an LM. This is the\n        # reeason why the argument here is named launch_kwargs and not\n        # kill_kwargs.\n        pass\n\n    @staticmethod\n    def finetune(\n        job: TrainingJob,\n        model: str,\n        train_data: list[dict[str, Any]],\n        train_data_format: TrainDataFormat | str | None,\n        train_kwargs: dict[str, Any] | None = None,\n    ) -> str:\n        raise NotImplementedError"
                    }
                ]
            },
            {
                "file_path": "dspy/clients/lm_local_arbor.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/dspy/dspy/clients/lm_local_arbor.py",
                "faults": [
                    {
                        "file_path": "dspy/clients/lm_local_arbor.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/dspy/dspy/clients/lm_local_arbor.py",
                        "line_range": [
                            1,
                            11
                        ],
                        "reason": "Ruff found issues that can be fixed automatically related to import order. The imports should be organized according to PEP 8 guidelines, which typically suggest standard library imports first, followed by third-party imports, and then local application/library specific imports. Lines 1-11 contain the import statements that need reordering.",
                        "issue_type": "formatting",
                        "fault_localization_level": "import_block",
                        "code_snippet": "import time\nfrom datetime import datetime\nfrom typing import TYPE_CHECKING, Any, TypedDict\nfrom urllib.parse import urljoin\n\nimport openai\nimport requests\n\nimport dspy\nfrom dspy.clients.provider import Provider, ReinforceJob, TrainingJob\nfrom dspy.clients.utils_finetune import GRPOGroup, TrainDataFormat, TrainingStatus, save_data, MultiGPUConfig"
                    }
                ]
            }
        ]
    },
    {
        "sha_fail": "a7b902770d8b2769920794cf4e2016525e3ea1d9",
        "fault_localization_data": [
            {
                "file_path": "sqlglot/tests/dialects/test_clickhouse.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_clickhouse.py",
                "faults": [
                    {
                        "file_path": "sqlglot/tests/dialects/test_clickhouse.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_clickhouse.py",
                        "line_range": [
                            14,
                            643
                        ],
                        "reason": "The test failed due to an assertion error indicating a mismatch between the expected SQL query output and the actual output. The expected output was 'SELECT EXTRACT(YEAR FROM CAST('2023-02-01' AS Nullable(DateTime)))' but the actual output was 'SELECT EXTRACT(YEAR FROM toDateTime('2023-02-01'))'. This discrepancy is found in the 'test_clickhouse' method, specifically in the validate_identity calls. The issue arises from the handling of the date type in the SQL query, which is not being cast to Nullable as expected.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    def test_clickhouse(self):\n        expr = quote_identifiers(self.parse_one(\"{start_date:String}\"), dialect=\"clickhouse\")\n        self.assertEqual(expr.sql(\"clickhouse\"), \"{start_date: String}\")\n\n        for string_type_enum in ClickHouse.Generator.STRING_TYPE_MAPPING:\n            self.validate_identity(f\"CAST(x AS {string_type_enum.value})\", \"CAST(x AS String)\")\n\n        # Arrays, maps and tuples can't be Nullable in ClickHouse\n        for non_nullable_type in (\"ARRAY<INT>\", \"MAP<INT, INT>\", \"STRUCT(a: INT)\"):\n            try_cast = parse_one(f\"TRY_CAST(x AS {non_nullable_type})\")\n            target_type = try_cast.to.sql(\"clickhouse\")\n            self.assertEqual(try_cast.sql(\"clickhouse\"), f\"CAST(x AS {target_type})\")\n\n        for nullable_type in (\"INT\", \"UINT\", \"BIGINT\", \"FLOAT\", \"DOUBLE\", \"TEXT\", \"DATE\", \"UUID\"):\n            try_cast = parse_one(f\"TRY_CAST(x AS {nullable_type})\")\n            target_type = exp.DataType.build(nullable_type, dialect=\"clickhouse\").sql(\"clickhouse\")\n            self.assertEqual(try_cast.sql(\"clickhouse\"), f\"CAST(x AS Nullable({target_type}))\")\n\n        expr = parse_one(\"count(x)\")\n        self.assertEqual(expr.sql(dialect=\"clickhouse\"), \"COUNT(x)\")\n        self.assertIsNone(expr._meta)\n\n        self.validate_identity('SELECT DISTINCT ON (\"id\") * FROM t')\n        self.validate_identity(\"SELECT 1 OR (1 = 2)\")\n        self.validate_identity(\"SELECT 1 AND (1 = 2)\")\n        self.validate_identity(\"SELECT json.a.:Int64\")\n        self.validate_identity(\"SELECT json.a.:JSON.b.:Int64\")\n        self.validate_identity(\"WITH arrayJoin([(1, [2, 3])]) AS arr SELECT arr\")\n        self.validate_identity(\"CAST(1 AS Bool)\")\n        self.validate_identity(\"SELECT toString(CHAR(104.1, 101, 108.9, 108.9, 111, 32))\")\n        self.validate_identity(\"@macro\").assert_is(exp.Parameter).this.assert_is(exp.Var)\n        self.validate_identity(\"SELECT toFloat(like)\")\n        self.validate_identity(\"SELECT like\")\n        self.validate_identity(\"SELECT STR_TO_DATE(str, fmt, tz)\")\n        self.validate_identity(\"SELECT STR_TO_DATE('05 12 2000', '%d %m %Y')\")\n        self.validate_identity(\"SELECT EXTRACT(YEAR FROM toDateTime('2023-02-01'))\")\n        self.validate_identity(\"extract(haystack, pattern)\")\n        self.validate_identity(\"SELECT * FROM x LIMIT 1 UNION ALL SELECT * FROM y\")\n        self.validate_identity(\"SELECT CAST(x AS Tuple(String, Array(Nullable(Float64))))\")\n        self.validate_identity(\"countIf(x, y)\")\n        self.validate_identity(\"x = y\")\n        self.validate_identity(\"x <> y\")\n        self.validate_identity(\"SELECT * FROM (SELECT a FROM b SAMPLE 0.01)\")\n        self.validate_identity(\"SELECT * FROM (SELECT a FROM b SAMPLE 1 / 10 OFFSET 1 / 2)\")\n        self.validate_identity(\"SELECT sum(foo * bar) FROM bla SAMPLE 10000000\")\n        self.validate_identity(\"CAST(x AS Nested(ID UInt32, Serial UInt32, EventTime DateTime))\")\n        self.validate_identity(\"CAST(x AS Enum('hello' = 1, 'world' = 2))\")\n        self.validate_identity(\"CAST(x AS Enum('hello', 'world'))\")\n        self.validate_identity(\"CAST(x AS Enum('hello' = 1, 'world'))\")\n        self.validate_identity(\"CAST(x AS Enum8('hello' = -123, 'world'))\")\n        self.validate_identity(\"CAST(x AS FixedString(1))\")\n        self.validate_identity(\"CAST(x AS LowCardinality(FixedString))\")\n        self.validate_identity(\"SELECT isNaN(1.0)\")\n        self.validate_identity(\"SELECT startsWith('Spider-Man', 'Spi')\")\n        self.validate_identity(\"SELECT xor(TRUE, FALSE)\")\n        self.validate_identity(\"CAST(['hello'], 'Array(Enum8(''hello'' = 1))')\")\n        self.validate_identity(\"SELECT x, COUNT() FROM y GROUP BY x WITH TOTALS\")\n        self.validate_identity(\"SELECT INTERVAL t.days DAY\")\n        self.validate_identity(\"SELECT match('abc', '([a-z]+)')\")\n        self.validate_identity(\"dictGet(x, 'y')\")\n        self.validate_identity(\"WITH final AS (SELECT 1) SELECT * FROM final\")\n        self.validate_identity(\"SELECT * FROM x FINAL\")\n        self.validate_identity(\"SELECT * FROM x AS y FINAL\")\n        self.validate_identity(\"'a' IN mapKeys(map('a', 1, 'b', 2))\")\n        self.validate_identity(\"CAST((1, 2) AS Tuple(a Int8, b Int16))\")\n        self.validate_identity(\"SELECT * FROM foo LEFT ANY JOIN bla\")\n        self.validate_identity(\"SELECT * FROM foo LEFT ASOF JOIN bla\")\n        self.validate_identity(\"SELECT * FROM foo ASOF JOIN bla\")\n        self.validate_identity(\"SELECT * FROM foo ANY JOIN bla\")\n        self.validate_identity(\"SELECT * FROM foo GLOBAL ANY JOIN bla\")\n        self.validate_identity(\"SELECT * FROM foo GLOBAL LEFT ANY JOIN bla\")\n        self.validate_identity(\"SELECT quantile(0.5)(a)\")\n        self.validate_identity(\"SELECT quantiles(0.5)(a) AS x FROM t\")\n        self.validate_identity(\"SELECT quantilesIf(0.5)(a, a > 1) AS x FROM t\")\n        self.validate_identity(\"SELECT quantileState(0.5)(a) AS x FROM t\")\n        self.validate_identity(\"SELECT deltaSumMerge(a) AS x FROM t\")\n        self.validate_identity(\"SELECT quantiles(0.1, 0.2, 0.3)(a)\")\n        self.validate_identity(\"SELECT quantileTiming(0.5)(RANGE(100))\")\n        self.validate_identity(\"SELECT histogram(5)(a)\")\n        self.validate_identity(\"SELECT groupUniqArray(2)(a)\")\n        self.validate_identity(\"SELECT exponentialTimeDecayedAvg(60)(a, b)\")\n        self.validate_identity(\"levenshteinDistance(col1, col2)\", \"editDistance(col1, col2)\")\n        self.validate_identity(\"SELECT * FROM foo WHERE x GLOBAL IN (SELECT * FROM bar)\")\n        self.validate_identity(\"SELECT * FROM foo WHERE x GLOBAL NOT IN (SELECT * FROM bar)\")\n        self.validate_identity(\"POSITION(haystack, needle)\")\n        self.validate_identity(\"POSITION(haystack, needle, position)\")\n        self.validate_identity(\"CAST(x AS DATETIME)\", \"CAST(x AS DateTime)\")\n        self.validate_identity(\"CAST(x AS TIMESTAMPTZ)\", \"CAST(x AS DateTime)\")\n        self.validate_identity(\"CAST(x as MEDIUMINT)\", \"CAST(x AS Int32)\")\n        self.validate_identity(\"CAST(x AS DECIMAL(38, 2))\", \"CAST(x AS Decimal(38, 2))\")\n        self.validate_identity(\"SELECT arrayJoin([1, 2, 3] AS src) AS dst, 'Hello', src\")\n        self.validate_identity(\"\"\"SELECT JSONExtractString('{\"x\": {\"y\": 1}}', 'x', 'y')\"\"\")\n        self.validate_identity(\"SELECT * FROM table LIMIT 1 BY a, b\")\n        self.validate_identity(\"SELECT * FROM table LIMIT 2 OFFSET 1 BY a, b\")\n        self.validate_identity(\"TRUNCATE TABLE t1 ON CLUSTER test_cluster\")\n        self.validate_identity(\"TRUNCATE TABLE t1 ON CLUSTER '{cluster}'\")\n        self.validate_identity(\"TRUNCATE DATABASE db\")\n        self.validate_identity(\"TRUNCATE DATABASE db ON CLUSTER test_cluster\")\n        self.validate_identity(\"TRUNCATE DATABASE db ON CLUSTER '{cluster}'\")\n        self.validate_identity(\"EXCHANGE TABLES x.a AND y.b\", check_command_warning=True)\n        self.validate_identity(\"CREATE TABLE test (id UInt8) ENGINE=Null()\")\n        self.validate_identity(\n            \"SELECT * FROM foo ORDER BY bar OFFSET 0 ROWS FETCH NEXT 10 ROWS WITH TIES\"\n        )\n        self.validate_identity(\n            \"SELECT DATE_BIN(toDateTime('2023-01-01 14:45:00'), INTERVAL '1' MINUTE, toDateTime('2023-01-01 14:35:30'), 'UTC')\",\n        )\n        self.validate_identity(\n            \"SELECT CAST(1730098800 AS DateTime64) AS DATETIME, 'test' AS interp ORDER BY DATETIME WITH FILL FROM toDateTime64(1730098800, 3) - INTERVAL '7' HOUR TO toDateTime64(1730185140, 3) - INTERVAL '7' HOUR STEP toIntervalSecond(900) INTERPOLATE (interp)\"\n        )\n        self.validate_identity(\n            \"SELECT number, COUNT() OVER (PARTITION BY number % 3) AS partition_count FROM numbers(10) WINDOW window_name AS (PARTITION BY number) QUALIFY partition_count = 4 ORDER BY number\"\n        )\n        self.validate_identity(\n            \"SELECT id, quantileGK(100, 0.95)(reading) OVER (PARTITION BY id ORDER BY id RANGE BETWEEN 30000 PRECEDING AND CURRENT ROW) AS window FROM table\"\n        )\n        self.validate_identity(\n            \"SELECT * FROM table LIMIT 1 BY CONCAT(datalayerVariantNo, datalayerProductId, warehouse)\"\n        )\n        self.validate_identity(\n            \"\"\"SELECT JSONExtractString('{\"a\": \"hello\", \"b\": [-100, 200.0, 300]}', 'a')\"\"\"\n        )\n        self.validate_identity(\n            \"ATTACH DATABASE DEFAULT ENGINE = ORDINARY\", check_command_warning=True\n        )\n        self.validate_identity(\n            \"SELECT n, source FROM (SELECT toFloat32(number % 10) AS n, 'original' AS source FROM numbers(10) WHERE number % 3 = 1) ORDER BY n WITH FILL\"\n        )\n        self.validate_identity(\n            \"SELECT n, source FROM (SELECT toFloat32(number % 10) AS n, 'original' AS source FROM numbers(10) WHERE number % 3 = 1) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5\"\n        )\n        self.validate_identity(\n            \"SELECT toDate((number * 10) * 86400) AS d1, toDate(number * 86400) AS d2, 'original' AS source FROM numbers(10) WHERE (number % 3) = 1 ORDER BY d2 WITH FILL, d1 WITH FILL STEP 5\"\n        )\n        self.validate_identity(\n            \"SELECT n, source, inter FROM (SELECT toFloat32(number % 10) AS n, 'original' AS source, number AS inter FROM numbers(10) WHERE number % 3 = 1) ORDER BY n WITH FILL FROM 0 TO 5.51 STEP 0.5 INTERPOLATE (inter AS inter + 1)\"\n        )\n        self.validate_identity(\n            \"SELECT SUM(1) AS impressions, arrayJoin(cities) AS city, arrayJoin(browsers) AS browser FROM (SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities, ['Firefox', 'Chrome', 'Chrome'] AS browsers) GROUP BY 2, 3\"\n        )\n        self.validate_identity(\n            \"SELECT sum(1) AS impressions, (arrayJoin(arrayZip(cities, browsers)) AS t).1 AS city, t.2 AS browser FROM (SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities, ['Firefox', 'Chrome', 'Chrome'] AS browsers) GROUP BY 2, 3\"\n        )\n        self.validate_identity(\n            'SELECT CAST(tuple(1 AS \"a\", 2 AS \"b\", 3.0 AS \"c\").2 AS Nullable(String))'\n        )\n        self.validate_identity(\n            \"CREATE TABLE test (id UInt8) ENGINE=AggregatingMergeTree() ORDER BY tuple()\"\n        )\n        self.validate_identity(\n            \"CREATE TABLE test ON CLUSTER default (id UInt8) ENGINE=AggregatingMergeTree() ORDER BY tuple()\"\n        )\n        self.validate_identity(\n            \"CREATE TABLE test ON CLUSTER '{cluster}' (id UInt8) ENGINE=AggregatingMergeTree() ORDER BY tuple()\"\n        )\n        self.validate_identity(\n            \"CREATE MATERIALIZED VIEW test_view ON CLUSTER cl1 (id UInt8) ENGINE=AggregatingMergeTree() ORDER BY tuple() AS SELECT * FROM test_data\"\n        )\n        self.validate_identity(\n            \"CREATE MATERIALIZED VIEW test_view ON CLUSTER '{cluster}' (id UInt8) ENGINE=AggregatingMergeTree() ORDER BY tuple() AS SELECT * FROM test_data\"\n        )\n        self.validate_identity(\n            \"CREATE MATERIALIZED VIEW test_view ON CLUSTER cl1 TO table1 AS SELECT * FROM test_data\"\n        )\n        self.validate_identity(\n            \"CREATE MATERIALIZED VIEW test_view ON CLUSTER '{cluster}' TO table1 AS SELECT * FROM test_data\"\n        )\n        self.validate_identity(\n            \"CREATE MATERIALIZED VIEW test_view TO db.table1 (id UInt8) AS SELECT * FROM test_data\"\n        )\n        self.validate_identity(\n            \"CREATE TABLE t (foo String CODEC(LZ4HC(9), ZSTD, DELTA), size String ALIAS formatReadableSize(size_bytes), INDEX idx1 a TYPE bloom_filter(0.001) GRANULARITY 1, INDEX idx2 a TYPE set(100) GRANULARITY 2, INDEX idx3 a TYPE minmax GRANULARITY 3)\"\n        )\n        self.validate_identity(\n            \"SELECT generate_series FROM generate_series(0, 10) AS g(x)\",\n        )\n        self.validate_identity(\n            \"SELECT * FROM t1, t2\",\n            \"SELECT * FROM t1 CROSS JOIN t2\",\n        )\n        self.validate_identity(\n            \"SELECT and(1, 2)\",\n            \"SELECT 1 AND 2\",\n        )\n        self.validate_identity(\n            \"SELECT or(1, 2)\",\n            \"SELECT 1 OR 2\",\n        )\n        self.validate_identity(\n            \"SELECT generate_series FROM generate_series(0, 10) AS g\",\n            \"SELECT generate_series FROM generate_series(0, 10) AS g(generate_series)\",\n        )\n        self.validate_identity(\n            \"INSERT INTO tab VALUES ({'key1': 1, 'key2': 10}), ({'key1': 2, 'key2': 20}), ({'key1': 3, 'key2': 30})\",\n            \"INSERT INTO tab VALUES ((map('key1', 1, 'key2', 10))), ((map('key1', 2, 'key2', 20))), ((map('key1', 3, 'key2', 30)))\",\n        )\n        self.validate_identity(\n            \"SELECT (toUInt8('1') + toUInt8('2')) IS NOT NULL\",\n            \"SELECT NOT ((toUInt8('1') + toUInt8('2')) IS NULL)\",\n        )\n        self.validate_identity(\n            \"SELECT $1$foo$1$\",\n            \"SELECT 'foo'\",\n        )\n        self.validate_identity(\n            \"SELECT * FROM table LIMIT 1, 2 BY a, b\",\n            \"SELECT * FROM table LIMIT 2 OFFSET 1 BY a, b\",\n        )\n        self.validate_identity(\n            \"SELECT SUM(1) AS impressions FROM (SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities) WHERE arrayJoin(cities) IN ['Istanbul', 'Berlin']\",\n            \"SELECT SUM(1) AS impressions FROM (SELECT ['Istanbul', 'Berlin', 'Bobruisk'] AS cities) WHERE arrayJoin(cities) IN ('Istanbul', 'Berlin')\",\n        )\n\n        self.validate_identity(\"SELECT SUBSTRING_INDEX(str, delim, count)\")\n        self.validate_identity(\"SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)\")\n        self.validate_identity(\"SELECT SUBSTRING_INDEX('a.b.c.d', '.', -2)\")\n\n        self.validate_all(\n            \"SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)\",\n            write={\n                \"databricks\": \"SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)\",\n                \"spark\": \"SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)\",\n                \"mysql\": \"SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)\",\n            },\n        )\n\n        self.validate_all(\n            \"SELECT substringIndex('a.b.c.d', '.', 2)\",\n            write={\n                \"databricks\": \"SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)\",\n                \"spark\": \"SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)\",\n                \"mysql\": \"SELECT SUBSTRING_INDEX('a.b.c.d', '.', 2)\",\n                \"clickhouse\": \"SELECT substringIndex('a.b.c.d', '.', 2)\",\n            },\n        )\n\n        self.validate_all(\n            \"SELECT CAST(STR_TO_DATE(SUBSTRING(a.eta, 1, 10), '%Y-%m-%d') AS Nullable(DATE))\",\n            read={\n                \"clickhouse\": \"SELECT CAST(STR_TO_DATE(SUBSTRING(a.eta, 1, 10), '%Y-%m-%d') AS Nullable(DATE))\",\n                \"oracle\": \"SELECT to_date(substr(a.eta, 1,10), 'YYYY-MM-DD')\",\n            },\n        )\n\n        self.validate_all(\n            \"CHAR(67) || CHAR(65) || CHAR(84)\",\n            read={\n                \"clickhouse\": \"CHAR(67) || CHAR(65) || CHAR(84)\",\n                \"oracle\": \"CHR(67) || CHR(65) || CHR(84)\",\n            },\n        )\n        self.validate_all(\n            \"SELECT lagInFrame(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees\",\n            read={\n                \"clickhouse\": \"SELECT lagInFrame(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees\",\n                \"oracle\": \"SELECT LAG(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees\",\n            },\n        )\n        self.validate_all(\n            \"SELECT leadInFrame(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees\",\n            read={\n                \"clickhouse\": \"SELECT leadInFrame(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees\",\n                \"oracle\": \"SELECT LEAD(salary, 1, 0) OVER (ORDER BY hire_date) AS prev_sal FROM employees\",\n            },\n        )\n        self.validate_all(\n            \"SELECT CAST(STR_TO_DATE('05 12 2000', '%d %m %Y') AS Nullable(DATE))\",\n            read={\n                \"clickhouse\": \"SELECT CAST(STR_TO_DATE('05 12 2000', '%d %m %Y') AS Nullable(DATE))\",\n                \"postgres\": \"SELECT TO_DATE('05 12 2000', 'DD MM YYYY')\",\n            },\n            write={\n                \"clickhouse\": \"SELECT CAST(STR_TO_DATE('05 12 2000', '%d %m %Y') AS Nullable(DATE))\",\n                \"postgres\": \"SELECT CAST(CAST(TO_DATE('05 12 2000', 'DD MM YYYY') AS TIMESTAMP) AS DATE)\",\n            },\n        )\n        self.validate_all(\n            \"SELECT * FROM x PREWHERE y = 1 WHERE z = 2\",\n            write={\n                \"\": \"SELECT * FROM x WHERE z = 2\",\n                \"clickhouse\": \"SELECT * FROM x PREWHERE y = 1 WHERE z = 2\",\n            },\n        )\n        self.validate_all(\n            \"SELECT * FROM x AS prewhere\",\n            read={\n                \"clickhouse\": \"SELECT * FROM x AS prewhere\",\n                \"duckdb\": \"SELECT * FROM x prewhere\",\n            },\n        )\n        self.validate_all(\n            \"SELECT a, b FROM (SELECT * FROM x) AS t(a, b)\",\n            read={\n                \"clickhouse\": \"SELECT a, b FROM (SELECT * FROM x) AS t(a, b)\",\n                \"duckdb\": \"SELECT a, b FROM (SELECT * FROM x) AS t(a, b)\",\n            },\n        )\n        self.validate_all(\n            \"SELECT arrayJoin([1,2,3])\",\n            write={\n                \"clickhouse\": \"SELECT arrayJoin([1, 2, 3])\",\n                \"postgres\": \"SELECT UNNEST(ARRAY[1, 2, 3])\",\n            },\n        )\n        self.validate_all(\n            \"has([1], x)\",\n            read={\n                \"postgres\": \"x = any(array[1])\",\n            },\n        )\n        self.validate_all(\n            \"NOT has([1], x)\",\n            read={\n                \"postgres\": \"any(array[1]) <> x\",\n            },\n        )\n        self.validate_all(\n            \"SELECT CAST('2020-01-01' AS Nullable(DateTime)) + INTERVAL '500' MICROSECOND\",\n            read={\n                \"duckdb\": \"SELECT TIMESTAMP '2020-01-01' + INTERVAL '500 us'\",\n                \"postgres\": \"SELECT TIMESTAMP '2020-01-01' + INTERVAL '500 us'\",\n            },\n            write={\n                \"clickhouse\": \"SELECT CAST('2020-01-01' AS Nullable(DateTime)) + INTERVAL '500' MICROSECOND\",\n                \"duckdb\": \"SELECT CAST('2020-01-01' AS TIMESTAMP) + INTERVAL '500' MICROSECOND\",\n                \"postgres\": \"SELECT CAST('2020-01-01' AS TIMESTAMP) + INTERVAL '500 MICROSECOND'\",\n            },\n        )\n        self.validate_all(\n            \"SELECT CURRENT_DATE()\",\n            read={\n                \"clickhouse\": \"SELECT CURRENT_DATE()\",\n                \"postgres\": \"SELECT CURRENT_DATE\",\n            },\n        )\n        self.validate_all(\n            \"SELECT CURRENT_TIMESTAMP()\",\n            read={\n                \"clickhouse\": \"SELECT CURRENT_TIMESTAMP()\",\n                \"postgres\": \"SELECT CURRENT_TIMESTAMP\",\n            },\n        )\n        self.validate_all(\n            \"SELECT match('ThOmAs', CONCAT('(?i)', 'thomas'))\",\n            read={\n                \"postgres\": \"SELECT 'ThOmAs' ~* 'thomas'\",\n            },\n        )\n        self.validate_all(\n            \"SELECT match('ThOmAs', CONCAT('(?i)', x)) FROM t\",\n            read={\n                \"postgres\": \"SELECT 'ThOmAs' ~* x FROM t\",\n            },\n        )\n        self.validate_all(\n            \"SELECT '\\\\0'\",\n            read={\n                \"mysql\": \"SELECT '\\0'\",\n            },\n            write={\n                \"clickhouse\": \"SELECT '\\\\0'\",\n                \"mysql\": \"SELECT '\\0'\",\n            },\n        )\n        self.validate_all(\n            \"DATE_ADD(DAY, 1, x)\",\n            read={\n                \"clickhouse\": \"dateAdd(DAY, 1, x)\",\n                \"presto\": \"DATE_ADD('DAY', 1, x)\",\n            },\n            write={\n                \"clickhouse\": \"DATE_ADD(DAY, 1, x)\",\n                \"presto\": \"DATE_ADD('DAY', 1, x)\",\n                \"\": \"DATE_ADD(x, 1, 'DAY')\",\n            },\n        )\n        self.validate_all(\n            \"DATE_DIFF(DAY, a, b)\",\n            read={\n                \"clickhouse\": \"dateDiff(DAY, a, b)\",\n                \"presto\": \"DATE_DIFF('DAY', a, b)\",\n            },\n            write={\n                \"clickhouse\": \"DATE_DIFF(DAY, a, b)\",\n                \"presto\": \"DATE_DIFF('DAY', a, b)\",\n                \"\": \"DATEDIFF(b, a, DAY)\",\n            },\n        )\n        self.validate_all(\n            \"SELECT xor(1, 0)\",\n            read={\n                \"clickhouse\": \"SELECT xor(1, 0)\",\n                \"mysql\": \"SELECT 1 XOR 0\",\n            },\n            write={\n                \"mysql\": \"SELECT 1 XOR 0\",\n            },\n        )\n        self.validate_all(\n            \"SELECT xor(0, 1, xor(1, 0, 0))\",\n            write={\n                \"clickhouse\": \"SELECT xor(0, 1, xor(1, 0, 0))\",\n                \"mysql\": \"SELECT 0 XOR 1 XOR 1 XOR 0 XOR 0\",\n            },\n        )\n        self.validate_all(\n            \"SELECT xor(xor(1, 0), 1)\",\n            read={\n                \"clickhouse\": \"SELECT xor(xor(1, 0), 1)\",\n                \"mysql\": \"SELECT 1 XOR 0 XOR 1\",\n            },\n            write={\n                \"clickhouse\": \"SELECT xor(xor(1, 0), 1)\",\n                \"mysql\": \"SELECT 1 XOR 0 XOR 1\",\n            },\n        )\n        self.validate_all(\n            \"CONCAT(a, b)\",\n            read={\n                \"clickhouse\": \"CONCAT(a, b)\",\n                \"mysql\": \"CONCAT(a, b)\",\n            },\n            write={\n                \"mysql\": \"CONCAT(a, b)\",\n                \"postgres\": \"CONCAT(a, b)\",\n            },\n        )\n        self.validate_all(\n            r\"'Enum8(\\'Sunday\\' = 0)'\", write={\"clickhouse\": \"'Enum8(''Sunday'' = 0)'\"}\n        )\n        self.validate_all(\n            \"SELECT uniq(x) FROM (SELECT any(y) AS x FROM (SELECT 1 AS y))\",\n            read={\n                \"bigquery\": \"SELECT APPROX_COUNT_DISTINCT(x) FROM (SELECT ANY_VALUE(y) x FROM (SELECT 1 y))\",\n            },\n            write={\n                \"bigquery\": \"SELECT APPROX_COUNT_DISTINCT(x) FROM (SELECT ANY_VALUE(y) AS x FROM (SELECT 1 AS y))\",\n            },\n        )\n        self.validate_all(\n            \"SELECT fname, lname, age FROM person ORDER BY age DESC NULLS FIRST, fname ASC NULLS LAST, lname\",\n            write={\n                \"clickhouse\": \"SELECT fname, lname, age FROM person ORDER BY age DESC NULLS FIRST, fname ASC, lname\",\n                \"spark\": \"SELECT fname, lname, age FROM person ORDER BY age DESC NULLS FIRST, fname ASC NULLS LAST, lname NULLS LAST\",\n            },\n        )\n        self.validate_all(\n            \"CAST(1 AS NULLABLE(Int64))\",\n            write={\n                \"clickhouse\": \"CAST(1 AS Nullable(Int64))\",\n            },\n        )\n        self.validate_all(\n            \"CAST(1 AS Nullable(DateTime64(6, 'UTC')))\",\n            write={\"clickhouse\": \"CAST(1 AS Nullable(DateTime64(6, 'UTC')))\"},\n        )\n        self.validate_all(\n            \"SELECT x #! comment\",\n            write={\"\": \"SELECT x /* comment */\"},\n        )\n        self.validate_all(\n            \"SELECT quantileIf(0.5)(a, true)\",\n            write={\n                \"clickhouse\": \"SELECT quantileIf(0.5)(a, TRUE)\",\n            },\n        )\n        self.validate_identity(\n            \"SELECT POSITION(needle IN haystack)\", \"SELECT POSITION(haystack, needle)\"\n        )\n        self.validate_identity(\n            \"SELECT * FROM x LIMIT 10 SETTINGS max_results = 100, result = 'break'\"\n        )\n        self.validate_identity(\"SELECT * FROM x LIMIT 10 SETTINGS max_results = 100, result_\")\n        self.validate_identity(\"SELECT * FROM x FORMAT PrettyCompact\")\n        self.validate_identity(\n            \"SELECT * FROM x LIMIT 10 SETTINGS max_results = 100, result_ FORMAT PrettyCompact\"\n        )\n        self.validate_all(\n            \"SELECT * FROM foo JOIN bar USING id, name\",\n            write={\"clickhouse\": \"SELECT * FROM foo JOIN bar USING (id, name)\"},\n        )\n        self.validate_all(\n            \"SELECT * FROM foo ANY LEFT JOIN bla ON foo.c1 = bla.c2\",\n            write={\"clickhouse\": \"SELECT * FROM foo LEFT ANY JOIN bla ON foo.c1 = bla.c2\"},\n        )\n        self.validate_all(\n            \"SELECT * FROM foo GLOBAL ANY LEFT JOIN bla ON foo.c1 = bla.c2\",\n            write={\"clickhouse\": \"SELECT * FROM foo GLOBAL LEFT ANY JOIN bla ON foo.c1 = bla.c2\"},\n        )\n        self.validate_all(\n            \"\"\"\n            SELECT\n                loyalty,\n                count()\n            FROM hits SEMI LEFT JOIN users USING (UserID)\n            GROUP BY loyalty\n            ORDER BY loyalty ASC\n            \"\"\",\n            write={\n                \"clickhouse\": \"SELECT loyalty, count() FROM hits LEFT SEMI JOIN users USING (UserID)\"\n                \" GROUP BY loyalty ORDER BY loyalty ASC\"\n            },\n        )\n        self.validate_all(\n            \"SELECT quantile(0.5)(a)\",\n            read={\n                \"duckdb\": \"SELECT quantile(a, 0.5)\",\n                \"clickhouse\": \"SELECT median(a)\",\n            },\n            write={\n                \"clickhouse\": \"SELECT quantile(0.5)(a)\",\n            },\n        )\n        self.validate_all(\n            \"SELECT quantiles(0.5, 0.4)(a)\",\n            read={\"duckdb\": \"SELECT quantile(a, [0.5, 0.4])\"},\n            write={\"clickhouse\": \"SELECT quantiles(0.5, 0.4)(a)\"},\n        )\n        self.validate_all(\n            \"SELECT quantiles(0.5)(a)\",\n            read={\"duckdb\": \"SELECT quantile(a, [0.5])\"},\n            write={\"clickhouse\": \"SELECT quantiles(0.5)(a)\"},\n        )\n\n        self.validate_identity(\"SELECT isNaN(x)\")\n        self.validate_all(\n            \"SELECT IS_NAN(x), ISNAN(x)\",\n            write={\"clickhouse\": \"SELECT isNaN(x), isNaN(x)\"},\n        )\n\n        self.validate_identity(\"SELECT startsWith('a', 'b')\")\n        self.validate_all(\n            \"SELECT STARTS_WITH('a', 'b'), STARTSWITH('a', 'b')\",\n            write={\"clickhouse\": \"SELECT startsWith('a', 'b'), startsWith('a', 'b')\"},\n        )\n        self.validate_identity(\"SYSTEM STOP MERGES foo.bar\", check_command_warning=True)\n\n        self.validate_identity(\n            \"INSERT INTO FUNCTION s3('url', 'CSV', 'name String, value UInt32', 'gzip') SELECT name, value FROM existing_table\"\n        )\n        self.validate_identity(\n            \"INSERT INTO FUNCTION remote('localhost', default.simple_table) VALUES (100, 'inserted via remote()')\",\n            \"INSERT INTO FUNCTION remote('localhost', default.simple_table) VALUES ((100), ('inserted via remote()'))\",\n        )\n        self.validate_identity(\n            \"\"\"INSERT INTO TABLE FUNCTION hdfs('hdfs://hdfs1:9000/test', 'TSV', 'name String, column2 UInt32, column3 UInt32') VALUES ('test', 1, 2)\"\"\",\n            \"\"\"INSERT INTO FUNCTION hdfs('hdfs://hdfs1:9000/test', 'TSV', 'name String, column2 UInt32, column3 UInt32') VALUES (('test'), (1), (2))\"\"\",\n        )\n\n        self.validate_identity(\"SELECT 1 FORMAT TabSeparated\")\n        self.validate_identity(\"SELECT * FROM t FORMAT TabSeparated\")\n        self.validate_identity(\"SELECT FORMAT\")\n        self.validate_identity(\"1 AS FORMAT\").assert_is(exp.Alias)\n\n        self.validate_identity(\"SELECT formatDateTime(NOW(), '%Y-%m-%d', '%T')\")\n        self.validate_all(\n            \"SELECT formatDateTime(NOW(), '%Y-%m-%d')\",\n            read={\n                \"clickhouse\": \"SELECT formatDateTime(NOW(), '%Y-%m-%d')\",\n                \"mysql\": \"SELECT DATE_FORMAT(NOW(), '%Y-%m-%d')\",\n            },\n            write={\n                \"clickhouse\": \"SELECT formatDateTime(NOW(), '%Y-%m-%d')\",\n                \"mysql\": \"SELECT DATE_FORMAT(NOW(), '%Y-%m-%d')\",\n            },\n        )\n\n        self.validate_identity(\"ALTER TABLE visits DROP PARTITION 201901\")\n        self.validate_identity(\"ALTER TABLE visits DROP PARTITION ALL\")\n        self.validate_identity(\n            \"ALTER TABLE visits DROP PARTITION tuple(toYYYYMM(toDate('2019-01-25')))\"\n        )\n        self.validate_identity(\"ALTER TABLE visits DROP PARTITION ID '201901'\")\n\n        self.validate_identity(\"ALTER TABLE visits REPLACE PARTITION 201901 FROM visits_tmp\")\n        self.validate_identity(\"ALTER TABLE visits REPLACE PARTITION ALL FROM visits_tmp\")\n        self.validate_identity(\n            \"ALTER TABLE visits REPLACE PARTITION tuple(toYYYYMM(toDate('2019-01-25'))) FROM visits_tmp\"\n        )\n        self.validate_identity(\"ALTER TABLE visits REPLACE PARTITION ID '201901' FROM visits_tmp\")\n        self.validate_identity(\"ALTER TABLE visits ON CLUSTER test_cluster DROP COLUMN col1\")\n        self.validate_identity(\"ALTER TABLE visits ON CLUSTER '{cluster}' DROP COLUMN col1\")\n        self.validate_identity(\"DELETE FROM tbl ON CLUSTER test_cluster WHERE date = '2019-01-01'\")\n        self.validate_identity(\"DELETE FROM tbl ON CLUSTER '{cluster}' WHERE date = '2019-01-01'\")\n\n        self.assertIsInstance(\n            parse_one(\"Tuple(select Int64)\", into=exp.DataType, read=\"clickhouse\"), exp.DataType\n        )\n\n        self.validate_identity(\n            \"INSERT INTO t (col1, col2) VALUES ('abcd', 1234)\",\n            \"INSERT INTO t (col1, col2) VALUES (('abcd'), (1234))\",\n        )\n        self.validate_all(\n            \"INSERT INTO t (col1, col2) VALUES ('abcd', 1234)\",\n            write={\n                \"clickhouse\": \"INSERT INTO t (col1, col2) VALUES (('abcd'), (1234))\",\n                \"postgres\": \"INSERT INTO t (col1, col2) VALUES (('abcd'), (1234))\",\n            },\n        )\n        self.validate_identity(\"SELECT TRIM(TRAILING ')' FROM '(   Hello, world!   )')\")\n        self.validate_identity(\"SELECT TRIM(LEADING '(' FROM '(   Hello, world!   )')\")\n        self.validate_identity(\"current_timestamp\").assert_is(exp.Column)\n\n        self.validate_identity(\"SELECT * APPLY(sum) FROM columns_transformers\")\n        self.validate_identity(\"SELECT COLUMNS('[jk]') APPLY(toString) FROM columns_transformers\")\n        self.validate_identity(\n            \"SELECT COLUMNS('[jk]') APPLY(toString) APPLY(length) APPLY(max) FROM columns_transformers\"\n        )\n        self.validate_identity(\"SELECT * APPLY(sum), COLUMNS('col') APPLY(sum) APPLY(avg) FROM t\")\n        self.validate_identity(\n            \"SELECT * FROM ABC WHERE hasAny(COLUMNS('.*field') APPLY(toUInt64) APPLY(to), (SELECT groupUniqArray(toUInt64(field))))\"\n        )\n        self.validate_identity(\"SELECT col apply\", \"SELECT col AS apply\")\n        self.validate_identity(\n            \"SELECT name FROM data WHERE (SELECT DISTINCT name FROM data) IS NOT NULL\",\n            \"SELECT name FROM data WHERE NOT ((SELECT DISTINCT name FROM data) IS NULL)\",\n        )\n\n        self.validate_identity(\"SELECT 1_2_3_4_5\", \"SELECT 12345\")\n        self.validate_identity(\"SELECT 1_b\", \"SELECT 1_b\")\n        self.validate_identity(\n            \"SELECT COUNT(1) FROM table SETTINGS additional_table_filters = {'a': 'b', 'c': 'd'}\"\n        )\n        self.validate_identity(\"SELECT arrayConcat([1, 2], [3, 4])\")\n\n        self.validate_identity(\"SELECT parseDateTime('2021-01-04+23:00:00', '%Y-%m-%d+%H:%i:%s')\")\n        self.validate_identity(\n            \"SELECT parseDateTime('2021-01-04+23:00:00', '%Y-%m-%d+%H:%i:%s', 'Asia/Istanbul')\"\n        )"
                    },
                    {
                        "file_path": "sqlglot/tests/dialects/test_clickhouse.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_clickhouse.py",
                        "line_range": [
                            1,
                            8
                        ],
                        "reason": "There is a deprecation warning related to the use of fork() in a multi-threaded context, which may lead to deadlocks. This warning is not directly causing a test failure but indicates potential issues in the code's execution environment. It is important to address this to ensure stability in multi-threaded operations.",
                        "issue_type": "runtime_error",
                        "fault_localization_level": "import_block",
                        "code_snippet": "from datetime import date, datetime, timezone\nfrom sqlglot import exp, parse_one\nfrom sqlglot.dialects import ClickHouse\nfrom sqlglot.expressions import convert\nfrom sqlglot.optimizer import traverse_scope\nfrom sqlglot.optimizer.qualify_columns import quote_identifiers\nfrom tests.dialects.test_dialect import Validator\nfrom sqlglot.errors import ErrorLevel"
                    }
                ]
            },
            {
                "file_path": "sqlglot/tests/dialects/test_dialect.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_dialect.py",
                "faults": [
                    {
                        "file_path": "sqlglot/tests/dialects/test_dialect.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_dialect.py",
                        "line_range": [
                            18,
                            80
                        ],
                        "reason": "The test failed due to an AssertionError indicating a mismatch between the expected SQL output and the actual output in the 'validate_identity' method. Specifically, the expected output was 'SELECT EXTRACT(YEAR FROM toDateTime('2023-02-01'))' while the actual output was 'SELECT EXTRACT(YEAR FROM CAST('2023-02-01' AS Nullable(DateTime)))'. This suggests that the SQL generation logic in the 'validate_identity' method may not be handling the CAST operation correctly. Lines 24-37 contain the 'validate_identity' method where this logic is implemented.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "class Validator(unittest.TestCase):\n    dialect = None\n\n    def parse_one(self, sql, **kwargs):\n        return parse_one(sql, read=self.dialect, **kwargs)\n\n    def validate_identity(\n        self, sql, write_sql=None, pretty=False, check_command_warning=False, identify=False\n    ):\n        if check_command_warning:\n            with self.assertLogs(parser_logger) as cm:\n                expression = self.parse_one(sql)\n                assert f\"'{sql[:100]}' contains unsupported syntax\" in cm.output[0]\n        else:\n            expression = self.parse_one(sql)\n\n        self.assertEqual(\n            write_sql or sql, expression.sql(dialect=self.dialect, pretty=pretty, identify=identify)\n        )\n        return expression\n\n    def validate_all(self, sql, read=None, write=None, pretty=False, identify=False):\n        \"\"\"\n        Validate that:\n        1. Everything in `read` transpiles to `sql`\n        2. `sql` transpiles to everything in `write`\n\n        Args:\n            sql (str): Main SQL expression\n            read (dict): Mapping of dialect -> SQL\n            write (dict): Mapping of dialect -> SQL\n            pretty (bool): prettify both read and write\n            identify (bool): quote identifiers in both read and write\n        \"\"\"\n        expression = self.parse_one(sql)\n\n        for read_dialect, read_sql in (read or {}).items():\n            with self.subTest(f\"{read_dialect} -> {sql}\"):\n                self.assertEqual(\n                    parse_one(read_sql, read_dialect).sql(\n                        self.dialect,\n                        unsupported_level=ErrorLevel.IGNORE,\n                        pretty=pretty,\n                        identify=identify,\n                    ),\n                    sql,\n                )\n\n        for write_dialect, write_sql in (write or {}).items():\n            with self.subTest(f\"{sql} -> {write_dialect}\"):\n                if write_sql is UnsupportedError:\n                    with self.assertRaises(UnsupportedError):\n                        expression.sql(write_dialect, unsupported_level=ErrorLevel.RAISE)\n                else:\n                    self.assertEqual(\n                        expression.sql(\n                            write_dialect,\n                            unsupported_level=ErrorLevel.IGNORE,\n                            pretty=pretty,\n                            identify=identify,\n                        ),\n                        write_sql,\n                    )"
                    },
                    {
                        "file_path": "sqlglot/tests/dialects/test_dialect.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_dialect.py",
                        "line_range": [
                            1,
                            15
                        ],
                        "reason": "There is a DeprecationWarning related to the use of fork() in a multi-threaded context, which may lead to deadlocks. This warning is likely triggered by the subprocess call in the 'test_lazy_load' method. The warning indicates that the current implementation may not be safe for multi-threaded environments. Lines 1-15 contain the import statements, which may need to include a warning filter or alternative handling for subprocesses to avoid this issue.",
                        "issue_type": "runtime_error",
                        "fault_localization_level": "import_block",
                        "code_snippet": "import unittest\n\nfrom sqlglot import (\n    Dialect,\n    Dialects,\n    ErrorLevel,\n    ParseError,\n    TokenError,\n    UnsupportedError,\n    exp,\n    parse_one,\n)\nfrom sqlglot.dialects import BigQuery, Hive, Snowflake\nfrom sqlglot.dialects.dialect import Version\nfrom sqlglot.parser import logger as parser_logger"
                    },
                    {
                        "file_path": "sqlglot/tests/dialects/test_dialect.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_dialect.py",
                        "line_range": [
                            476,
                            499
                        ],
                        "reason": "The test 'test_ddl' may be failing due to an assertion error related to the SQL generation logic in the 'validate_all' method. The method is expected to validate the SQL syntax across different dialects, but if the SQL generated does not match the expected output, it could lead to a test failure. Lines 476-499 contain the 'test_ddl' method where this logic is implemented.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    def test_ddl(self):\n        self.validate_all(\n            \"CREATE TABLE a LIKE b\",\n            write={\n                \"\": \"CREATE TABLE a LIKE b\",\n                \"bigquery\": \"CREATE TABLE a LIKE b\",\n                \"clickhouse\": \"CREATE TABLE a AS b\",\n                \"databricks\": \"CREATE TABLE a LIKE b\",\n                \"doris\": \"CREATE TABLE a LIKE b\",\n                \"drill\": \"CREATE TABLE a AS SELECT * FROM b LIMIT 0\",\n                \"duckdb\": \"CREATE TABLE a AS SELECT * FROM b LIMIT 0\",\n                \"hive\": \"CREATE TABLE a LIKE b\",\n                \"mysql\": \"CREATE TABLE a LIKE b\",\n                \"oracle\": \"CREATE TABLE a LIKE b\",\n                \"postgres\": \"CREATE TABLE a (LIKE b)\",\n                \"presto\": \"CREATE TABLE a (LIKE b)\",\n                \"redshift\": \"CREATE TABLE a (LIKE b)\",\n                \"snowflake\": \"CREATE TABLE a LIKE b\",\n                \"spark\": \"CREATE TABLE a LIKE b\",\n                \"sqlite\": \"CREATE TABLE a AS SELECT * FROM b LIMIT 0\",\n                \"trino\": \"CREATE TABLE a (LIKE b)\",\n                \"tsql\": \"SELECT TOP 0 * INTO a FROM b AS temp\",\n            },\n        )"
                    },
                    {
                        "file_path": "sqlglot/tests/dialects/test_dialect.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_dialect.py",
                        "line_range": [
                            501,
                            537
                        ],
                        "reason": "The test 'test_heredoc_strings' may be failing due to an assertion error related to the handling of heredoc strings in the SQL generation logic. The test checks for invalid matching tags and unmatched tags, which could lead to a failure if the SQL parser does not handle these cases correctly. Lines 501-537 contain the 'test_heredoc_strings' method where this logic is implemented.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    def test_heredoc_strings(self):\n        for dialect in (\"clickhouse\", \"postgres\", \"redshift\"):\n            # Invalid matching tag\n            with self.assertRaises(TokenError):\n                parse_one(\"SELECT $tag1$invalid heredoc string$tag2$\", dialect=dialect)\n\n            # Unmatched tag\n            with self.assertRaises(TokenError):\n                parse_one(\"SELECT $tag1$invalid heredoc string\", dialect=dialect)\n\n            # Without tag\n            self.validate_all(\n                \"SELECT 'this is a heredoc string'\",\n                read={\n                    dialect: \"SELECT $$this is a heredoc string$$\",\n                },\n            )\n            self.validate_all(\n                \"SELECT ''\",\n                read={\n                    dialect: \"SELECT $$$$\",\n                },\n            )\n\n            # With tag\n            self.validate_all(\n                \"SELECT 'this is also a heredoc string'\",\n                read={\n                    dialect: \"SELECT $foo$this is also a heredoc string$foo$\",\n                },\n            )\n            self.validate_all(\n                \"SELECT ''\",\n                read={\n                    dialect: \"SELECT $foo$$foo$\",\n                },\n            )"
                    },
                    {
                        "file_path": "sqlglot/tests/dialects/test_dialect.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_dialect.py",
                        "line_range": [
                            539,
                            596
                        ],
                        "reason": "The test 'test_decode' may be failing due to an assertion error related to the SQL generation logic in the 'validate_all' method. The method is expected to validate the SQL syntax across different dialects, but if the SQL generated does not match the expected output, it could lead to a test failure. Lines 539-596 contain the 'test_decode' method where this logic is implemented.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    def test_decode(self):\n        self.validate_identity(\"DECODE(bin, charset)\")\n\n        self.validate_all(\n            \"SELECT DECODE(a, 1, 'one')\",\n            write={\n                \"\": \"SELECT DECODE(a, 1, 'one')\",\n                \"duckdb\": \"SELECT CASE WHEN a = 1 THEN 'one' END\",\n                \"oracle\": \"SELECT DECODE(a, 1, 'one')\",\n                \"redshift\": \"SELECT DECODE(a, 1, 'one')\",\n                \"snowflake\": \"SELECT DECODE(a, 1, 'one')\",\n                \"spark\": \"SELECT DECODE(a, 1, 'one')\",\n            },\n        )\n        self.validate_all(\n            \"SELECT DECODE(a, 1, 'one', 'default')\",\n            write={\n                \"\": \"SELECT DECODE(a, 1, 'one', 'default')\",\n                \"duckdb\": \"SELECT CASE WHEN a = 1 THEN 'one' ELSE 'default' END\",\n                \"oracle\": \"SELECT DECODE(a, 1, 'one', 'default')\",\n                \"redshift\": \"SELECT DECODE(a, 1, 'one', 'default')\",\n                \"snowflake\": \"SELECT DECODE(a, 1, 'one', 'default')\",\n                \"spark\": \"SELECT DECODE(a, 1, 'one', 'default')\",\n            },\n        )\n        self.validate_all(\n            \"SELECT DECODE(a, NULL, 'null')\",\n            write={\n                \"\": \"SELECT DECODE(a, NULL, 'null')\",\n                \"duckdb\": \"SELECT CASE WHEN a IS NULL THEN 'null' END\",\n                \"oracle\": \"SELECT DECODE(a, NULL, 'null')\",\n                \"redshift\": \"SELECT DECODE(a, NULL, 'null')\",\n                \"snowflake\": \"SELECT DECODE(a, NULL, 'null')\",\n                \"spark\": \"SELECT DECODE(a, NULL, 'null')\",\n            },\n        )\n        self.validate_all(\n            \"SELECT DECODE(a, b, c)\",\n            write={\n                \"\": \"SELECT DECODE(a, b, c)\",\n                \"duckdb\": \"SELECT CASE WHEN a = b OR (a IS NULL AND b IS NULL) THEN c END\",\n                \"oracle\": \"SELECT DECODE(a, b, c)\",\n                \"redshift\": \"SELECT DECODE(a, b, c)\",\n                \"snowflake\": \"SELECT DECODE(a, b, c)\",\n                \"spark\": \"SELECT DECODE(a, b, c)\",\n            },\n        )\n        self.validate_all(\n            \"SELECT DECODE(tbl.col, 'some_string', 'foo')\",\n            write={\n                \"\": \"SELECT DECODE(tbl.col, 'some_string', 'foo')\",\n                \"duckdb\": \"SELECT CASE WHEN tbl.col = 'some_string' THEN 'foo' END\",\n                \"oracle\": \"SELECT DECODE(tbl.col, 'some_string', 'foo')\",\n                \"redshift\": \"SELECT DECODE(tbl.col, 'some_string', 'foo')\",\n                \"snowflake\": \"SELECT DECODE(tbl.col, 'some_string', 'foo')\",\n                \"spark\": \"SELECT DECODE(tbl.col, 'some_string', 'foo')\",\n            },\n        )"
                    },
                    {
                        "file_path": "sqlglot/tests/dialects/test_dialect.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_dialect.py",
                        "line_range": [
                            598,
                            611
                        ],
                        "reason": "The test 'test_if_null' may be failing due to an assertion error related to the SQL generation logic in the 'validate_all' method. The method is expected to validate the SQL syntax across different dialects, but if the SQL generated does not match the expected output, it could lead to a test failure. Lines 598-611 contain the 'test_if_null' method where this logic is implemented.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    def test_if_null(self):\n        self.validate_all(\n            \"SELECT IFNULL(1, NULL) FROM foo\",\n            write={\n                \"\": \"SELECT COALESCE(1, NULL) FROM foo\",\n                \"redshift\": \"SELECT COALESCE(1, NULL) FROM foo\",\n                \"postgres\": \"SELECT COALESCE(1, NULL) FROM foo\",\n                \"mysql\": \"SELECT COALESCE(1, NULL) FROM foo\",\n                \"duckdb\": \"SELECT COALESCE(1, NULL) FROM foo\",\n                \"spark\": \"SELECT COALESCE(1, NULL) FROM foo\",\n                \"bigquery\": \"SELECT COALESCE(1, NULL) FROM foo\",\n                \"presto\": \"SELECT COALESCE(1, NULL) FROM foo\",\n            },\n        )"
                    },
                    {
                        "file_path": "sqlglot/tests/dialects/test_dialect.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_dialect.py",
                        "line_range": [
                            613,
                            624
                        ],
                        "reason": "The test 'test_is_ascii' may be failing due to an assertion error related to the SQL generation logic in the 'validate_all' method. The method is expected to validate the SQL syntax across different dialects, but if the SQL generated does not match the expected output, it could lead to a test failure. Lines 613-624 contain the 'test_is_ascii' method where this logic is implemented.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    def test_is_ascii(self):\n        self.validate_all(\n            \"SELECT IS_ASCII(x)\",\n            write={\n                \"\": \"SELECT IS_ASCII(x)\",\n                \"sqlite\": \"SELECT (NOT x GLOB CAST(x'2a5b5e012d7f5d2a' AS TEXT))\",\n                \"mysql\": \"SELECT REGEXP_LIKE(x, '^[[:ascii:]]*$')\",\n                \"postgres\": \"SELECT (x ~ '^[[:ascii:]]*$')\",\n                \"tsql\": \"SELECT (PATINDEX(CONVERT(VARCHAR(MAX), 0x255b5e002d7f5d25) COLLATE Latin1_General_BIN, x) = 0)\",\n                \"oracle\": \"SELECT NVL(REGEXP_LIKE(x, '^[' || CHR(1) || '-' || CHR(127) || ']*$'), TRUE)\",\n            },\n        )"
                    },
                    {
                        "file_path": "sqlglot/tests/dialects/test_dialect.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_dialect.py",
                        "line_range": [
                            626,
                            680
                        ],
                        "reason": "The test 'test_nvl2' may be failing due to an assertion error related to the SQL generation logic in the 'validate_all' method. The method is expected to validate the SQL syntax across different dialects, but if the SQL generated does not match the expected output, it could lead to a test failure. Lines 626-680 contain the 'test_nvl2' method where this logic is implemented.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    def test_nvl2(self):\n        self.validate_all(\n            \"SELECT NVL2(a, b, c)\",\n            write={\n                \"\": \"SELECT NVL2(a, b, c)\",\n                \"bigquery\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n                \"clickhouse\": \"SELECT CASE WHEN NOT (a IS NULL) THEN b ELSE c END\",\n                \"databricks\": \"SELECT NVL2(a, b, c)\",\n                \"doris\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n                \"dremio\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n                \"drill\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n                \"duckdb\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n                \"hive\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n                \"mysql\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n                \"oracle\": \"SELECT NVL2(a, b, c)\",\n                \"postgres\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n                \"presto\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n                \"redshift\": \"SELECT NVL2(a, b, c)\",\n                \"snowflake\": \"SELECT NVL2(a, b, c)\",\n                \"spark\": \"SELECT NVL2(a, b, c)\",\n                \"spark2\": \"SELECT NVL2(a, b, c)\",\n                \"sqlite\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n                \"starrocks\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n                \"teradata\": \"SELECT NVL2(a, b, c)\",\n                \"trino\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n                \"tsql\": \"SELECT CASE WHEN NOT a IS NULL THEN b ELSE c END\",\n            },\n        )\n        self.validate_all(\n            \"SELECT NVL2(a, b)\",\n            write={\n                \"\": \"SELECT NVL2(a, b)\",\n                \"bigquery\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n                \"clickhouse\": \"SELECT CASE WHEN NOT (a IS NULL) THEN b END\",\n                \"databricks\": \"SELECT NVL2(a, b)\",\n                \"doris\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n                \"dremio\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n                \"drill\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n                \"duckdb\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n                \"hive\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n                \"mysql\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n                \"oracle\": \"SELECT NVL2(a, b)\",\n                \"postgres\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n                \"presto\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n                \"redshift\": \"SELECT NVL2(a, b)\",\n                \"snowflake\": \"SELECT NVL2(a, b)\",\n                \"spark\": \"SELECT NVL2(a, b)\",\n                \"spark2\": \"SELECT NVL2(a, b)\",\n                \"sqlite\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n                \"starrocks\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n                \"teradata\": \"SELECT NVL2(a, b)\",\n                \"trino\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n                \"tsql\": \"SELECT CASE WHEN NOT a IS NULL THEN b END\",\n            },\n        )"
                    },
                    {
                        "file_path": "sqlglot/tests/dialects/test_dialect.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_dialect.py",
                        "line_range": [
                            1811,
                            2299
                        ],
                        "reason": "The test 'test_typeddiv' may be failing due to an assertion error related to the SQL generation logic in the 'validate_all' method. The method is expected to validate the SQL syntax across different dialects, but if the SQL generated does not match the expected output, it could lead to a test failure. Lines 2001-2350 contain the 'test_typeddiv' and 'test_safediv' methods where this logic is implemented. Additionally, the 'test_limit' method may also be failing due to similar reasons related to SQL generation validation across dialects. The CI run failed during the 'Run tests and linter checks' step due to a test failure in 'test_clickhouse', indicating a mismatch between expected and actual SQL outputs.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    def test_operators(self):\n        self.validate_identity(\"some.column LIKE 'foo' || another.column || 'bar' || LOWER(x)\")\n        self.validate_identity(\"some.column LIKE 'foo' + another.column + 'bar'\")\n\n        self.validate_all(\"LIKE(x, 'z')\", write={\"\": \"'z' LIKE x\"})\n        self.validate_all(\n            \"CONCAT(a, b, c)\",\n            write={\n                \"\": \"CONCAT(a, b, c)\",\n                \"redshift\": \"a || b || c\",\n                \"sqlite\": \"a || b || c\",\n            },\n        )\n        self.validate_all(\n            \"x ILIKE '%y'\",\n            read={\n                \"clickhouse\": \"x ILIKE '%y'\",\n                \"duckdb\": \"x ILIKE '%y'\",\n                \"postgres\": \"x ILIKE '%y'\",\n                \"snowflake\": \"x ILIKE '%y'\",\n            },\n            write={\n                \"bigquery\": \"LOWER(x) LIKE LOWER('%y')\",\n                \"clickhouse\": \"x ILIKE '%y'\",\n                \"drill\": \"x `ILIKE` '%y'\",\n                \"duckdb\": \"x ILIKE '%y'\",\n                \"hive\": \"LOWER(x) LIKE LOWER('%y')\",\n                \"mysql\": \"LOWER(x) LIKE LOWER('%y')\",\n                \"oracle\": \"LOWER(x) LIKE LOWER('%y')\",\n                \"postgres\": \"x ILIKE '%y'\",\n                \"presto\": \"LOWER(x) LIKE LOWER('%y')\",\n                \"snowflake\": \"x ILIKE '%y'\",\n                \"spark\": \"x ILIKE '%y'\",\n                \"sqlite\": \"LOWER(x) LIKE LOWER('%y')\",\n                \"starrocks\": \"LOWER(x) LIKE LOWER('%y')\",\n                \"trino\": \"LOWER(x) LIKE LOWER('%y')\",\n                \"doris\": \"LOWER(x) LIKE LOWER('%y')\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle)\",\n            read={\n                \"athena\": \"POSITION(needle in haystack)\",\n                \"clickhouse\": \"POSITION(needle in haystack)\",\n                \"databricks\": \"POSITION(needle in haystack)\",\n                \"drill\": \"POSITION(needle in haystack)\",\n                \"duckdb\": \"POSITION(needle in haystack)\",\n                \"materialize\": \"POSITION(needle in haystack)\",\n                \"mysql\": \"POSITION(needle in haystack)\",\n                \"postgres\": \"POSITION(needle in haystack)\",\n                \"presto\": \"POSITION(needle in haystack)\",\n                \"redshift\": \"POSITION(needle in haystack)\",\n                \"risingwave\": \"POSITION(needle in haystack)\",\n                \"snowflake\": \"POSITION(needle in haystack)\",\n                \"spark\": \"POSITION(needle in haystack)\",\n                \"spark2\": \"POSITION(needle in haystack)\",\n                \"teradata\": \"POSITION(needle in haystack)\",\n                \"trino\": \"POSITION(needle in haystack)\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle)\",\n            read={\n                \"clickhouse\": \"POSITION(haystack, needle)\",\n                \"databricks\": \"POSITION(needle, haystack)\",\n                \"snowflake\": \"POSITION(needle, haystack)\",\n                \"spark2\": \"POSITION(needle, haystack)\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle)\",\n            read={\n                \"athena\": \"STRPOS(haystack, needle)\",\n                \"bigquery\": \"STRPOS(haystack, needle)\",\n                \"drill\": \"STRPOS(haystack, needle)\",\n                \"duckdb\": \"STRPOS(haystack, needle)\",\n                \"postgres\": \"STRPOS(haystack, needle)\",\n                \"presto\": \"STRPOS(haystack, needle)\",\n                \"redshift\": \"STRPOS(haystack, needle)\",\n                \"trino\": \"STRPOS(haystack, needle)\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle)\",\n            read={\n                \"bigquery\": \"INSTR(haystack, needle)\",\n                \"databricks\": \"INSTR(haystack, needle)\",\n                \"doris\": \"INSTR(haystack, needle)\",\n                \"duckdb\": \"INSTR(haystack, needle)\",\n                \"hive\": \"INSTR(haystack, needle)\",\n                \"mysql\": \"INSTR(haystack, needle)\",\n                \"oracle\": \"INSTR(haystack, needle)\",\n                \"spark\": \"INSTR(haystack, needle)\",\n                \"spark2\": \"INSTR(haystack, needle)\",\n                \"sqlite\": \"INSTR(haystack, needle)\",\n                \"starrocks\": \"INSTR(haystack, needle)\",\n                \"teradata\": \"INSTR(haystack, needle)\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle)\",\n            read={\n                \"clickhouse\": \"LOCATE(needle, haystack)\",\n                \"databricks\": \"LOCATE(needle, haystack)\",\n                \"doris\": \"LOCATE(needle, haystack)\",\n                \"hive\": \"LOCATE(needle, haystack)\",\n                \"mysql\": \"LOCATE(needle, haystack)\",\n                \"spark\": \"LOCATE(needle, haystack)\",\n                \"spark2\": \"LOCATE(needle, haystack)\",\n                \"starrocks\": \"LOCATE(needle, haystack)\",\n                \"teradata\": \"LOCATE(needle, haystack)\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle)\",\n            read={\n                \"athena\": \"CHARINDEX(needle, haystack)\",\n                \"databricks\": \"CHARINDEX(needle, haystack)\",\n                \"snowflake\": \"CHARINDEX(needle, haystack)\",\n                \"tsql\": \"CHARINDEX(needle, haystack)\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle)\",\n            read={\n                \"tableau\": \"FIND(haystack, needle)\",\n            },\n            write={\n                \"athena\": \"STRPOS(haystack, needle)\",\n                \"bigquery\": \"INSTR(haystack, needle)\",\n                \"clickhouse\": \"POSITION(haystack, needle)\",\n                \"databricks\": \"LOCATE(needle, haystack)\",\n                \"doris\": \"LOCATE(needle, haystack)\",\n                \"drill\": \"STRPOS(haystack, needle)\",\n                \"duckdb\": \"STRPOS(haystack, needle)\",\n                \"hive\": \"LOCATE(needle, haystack)\",\n                \"materialize\": \"POSITION(needle IN haystack)\",\n                \"mysql\": \"LOCATE(needle, haystack)\",\n                \"oracle\": \"INSTR(haystack, needle)\",\n                \"postgres\": \"POSITION(needle IN haystack)\",\n                \"presto\": \"STRPOS(haystack, needle)\",\n                \"redshift\": \"POSITION(needle IN haystack)\",\n                \"risingwave\": \"POSITION(needle IN haystack)\",\n                \"snowflake\": \"CHARINDEX(needle, haystack)\",\n                \"spark\": \"LOCATE(needle, haystack)\",\n                \"spark2\": \"LOCATE(needle, haystack)\",\n                \"sqlite\": \"INSTR(haystack, needle)\",\n                \"tableau\": \"FIND(haystack, needle)\",\n                \"teradata\": \"INSTR(haystack, needle)\",\n                \"trino\": \"STRPOS(haystack, needle)\",\n                \"tsql\": \"CHARINDEX(needle, haystack)\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle, position)\",\n            read={\n                \"clickhouse\": \"POSITION(haystack, needle, position)\",\n                \"databricks\": \"POSITION(needle, haystack, position)\",\n                \"snowflake\": \"POSITION(needle, haystack, position)\",\n                \"spark\": \"POSITION(needle, haystack, position)\",\n                \"spark2\": \"POSITION(needle, haystack, position)\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle, position)\",\n            read={\n                \"doris\": \"LOCATE(needle, haystack, position)\",\n                \"hive\": \"LOCATE(needle, haystack, position)\",\n                \"mysql\": \"LOCATE(needle, haystack, position)\",\n                \"spark\": \"LOCATE(needle, haystack, position)\",\n                \"spark2\": \"LOCATE(needle, haystack, position)\",\n                \"starrocks\": \"LOCATE(needle, haystack, position)\",\n                \"teradata\": \"LOCATE(needle, haystack, position)\",\n                \"clickhouse\": \"LOCATE(needle, haystack, position)\",\n                \"databricks\": \"LOCATE(needle, haystack, position)\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle, position)\",\n            read={\n                \"bigquery\": \"INSTR(haystack, needle, position)\",\n                \"doris\": \"INSTR(haystack, needle, position)\",\n                \"oracle\": \"INSTR(haystack, needle, position)\",\n                \"teradata\": \"INSTR(haystack, needle, position)\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle, position)\",\n            read={\n                \"databricks\": \"CHARINDEX(needle, haystack, position)\",\n                \"snowflake\": \"CHARINDEX(needle, haystack, position)\",\n                \"tsql\": \"CHARINDEX(needle, haystack, position)\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle, position)\",\n            write={\n                \"athena\": \"IF(STRPOS(SUBSTRING(haystack, position), needle) = 0, 0, STRPOS(SUBSTRING(haystack, position), needle) + position - 1)\",\n                \"bigquery\": \"INSTR(haystack, needle, position)\",\n                \"clickhouse\": \"POSITION(haystack, needle, position)\",\n                \"databricks\": \"LOCATE(needle, haystack, position)\",\n                \"doris\": \"LOCATE(needle, haystack, position)\",\n                \"drill\": \"`IF`(STRPOS(SUBSTRING(haystack, position), needle) = 0, 0, STRPOS(SUBSTRING(haystack, position), needle) + position - 1)\",\n                \"duckdb\": \"CASE WHEN STRPOS(SUBSTRING(haystack, position), needle) = 0 THEN 0 ELSE STRPOS(SUBSTRING(haystack, position), needle) + position - 1 END\",\n                \"hive\": \"LOCATE(needle, haystack, position)\",\n                \"materialize\": \"CASE WHEN POSITION(needle IN SUBSTRING(haystack FROM position)) = 0 THEN 0 ELSE POSITION(needle IN SUBSTRING(haystack FROM position)) + position - 1 END\",\n                \"mysql\": \"LOCATE(needle, haystack, position)\",\n                \"oracle\": \"INSTR(haystack, needle, position)\",\n                \"postgres\": \"CASE WHEN POSITION(needle IN SUBSTRING(haystack FROM position)) = 0 THEN 0 ELSE POSITION(needle IN SUBSTRING(haystack FROM position)) + position - 1 END\",\n                \"presto\": \"IF(STRPOS(SUBSTRING(haystack, position), needle) = 0, 0, STRPOS(SUBSTRING(haystack, position), needle) + position - 1)\",\n                \"redshift\": \"CASE WHEN POSITION(needle IN SUBSTRING(haystack FROM position)) = 0 THEN 0 ELSE POSITION(needle IN SUBSTRING(haystack FROM position)) + position - 1 END\",\n                \"risingwave\": \"CASE WHEN POSITION(needle IN SUBSTRING(haystack FROM position)) = 0 THEN 0 ELSE POSITION(needle IN SUBSTRING(haystack FROM position)) + position - 1 END\",\n                \"snowflake\": \"CHARINDEX(needle, haystack, position)\",\n                \"spark\": \"LOCATE(needle, haystack, position)\",\n                \"spark2\": \"LOCATE(needle, haystack, position)\",\n                \"sqlite\": \"IIF(INSTR(SUBSTRING(haystack, position), needle) = 0, 0, INSTR(SUBSTRING(haystack, position), needle) + position - 1)\",\n                \"tableau\": \"IF FIND(SUBSTRING(haystack, position), needle) = 0 THEN 0 ELSE FIND(SUBSTRING(haystack, position), needle) + position - 1 END\",\n                \"teradata\": \"INSTR(haystack, needle, position)\",\n                \"trino\": \"IF(STRPOS(SUBSTRING(haystack, position), needle) = 0, 0, STRPOS(SUBSTRING(haystack, position), needle) + position - 1)\",\n                \"tsql\": \"CHARINDEX(needle, haystack, position)\",\n            },\n        )\n        self.validate_all(\n            \"STR_POSITION(haystack, needle, position, occurrence)\",\n            read={\n                \"bigquery\": \"INSTR(haystack, needle, position, occurrence)\",\n                \"oracle\": \"INSTR(haystack, needle, position, occurrence)\",\n                \"teradata\": \"INSTR(haystack, needle, position, occurrence)\",\n            },\n            write={\n                \"bigquery\": \"INSTR(haystack, needle, position, occurrence)\",\n                \"oracle\": \"INSTR(haystack, needle, position, occurrence)\",\n                \"presto\": \"IF(STRPOS(SUBSTRING(haystack, position), needle, occurrence) = 0, 0, STRPOS(SUBSTRING(haystack, position), needle, occurrence) + position - 1)\",\n                \"tableau\": \"IF FINDNTH(SUBSTRING(haystack, position), needle, occurrence) = 0 THEN 0 ELSE FINDNTH(SUBSTRING(haystack, position), needle, occurrence) + position - 1 END\",\n                \"teradata\": \"INSTR(haystack, needle, position, occurrence)\",\n                \"trino\": \"IF(STRPOS(SUBSTRING(haystack, position), needle, occurrence) = 0, 0, STRPOS(SUBSTRING(haystack, position), needle, occurrence) + position - 1)\",\n            },\n        )\n        self.validate_all(\n            \"CONCAT_WS('-', 'a', 'b')\",\n            write={\n                \"clickhouse\": \"CONCAT_WS('-', 'a', 'b')\",\n                \"duckdb\": \"CONCAT_WS('-', 'a', 'b')\",\n                \"presto\": \"CONCAT_WS('-', CAST('a' AS VARCHAR), CAST('b' AS VARCHAR))\",\n                \"hive\": \"CONCAT_WS('-', 'a', 'b')\",\n                \"spark\": \"CONCAT_WS('-', 'a', 'b')\",\n                \"trino\": \"CONCAT_WS('-', CAST('a' AS VARCHAR), CAST('b' AS VARCHAR))\",\n            },\n        )\n\n        self.validate_all(\n            \"CONCAT_WS('-', x)\",\n            write={\n                \"clickhouse\": \"CONCAT_WS('-', x)\",\n                \"duckdb\": \"CONCAT_WS('-', x)\",\n                \"hive\": \"CONCAT_WS('-', x)\",\n                \"presto\": \"CONCAT_WS('-', CAST(x AS VARCHAR))\",\n                \"spark\": \"CONCAT_WS('-', x)\",\n                \"trino\": \"CONCAT_WS('-', CAST(x AS VARCHAR))\",\n            },\n        )\n        self.validate_all(\n            \"CONCAT(a)\",\n            write={\n                \"clickhouse\": \"CONCAT(a)\",\n                \"presto\": \"CAST(a AS VARCHAR)\",\n                \"trino\": \"CAST(a AS VARCHAR)\",\n                \"tsql\": \"a\",\n            },\n        )\n        self.validate_all(\n            \"CONCAT(COALESCE(a, ''))\",\n            read={\n                \"drill\": \"CONCAT(a)\",\n                \"duckdb\": \"CONCAT(a)\",\n                \"postgres\": \"CONCAT(a)\",\n                \"tsql\": \"CONCAT(a)\",\n            },\n        )\n        self.validate_all(\n            \"IF(x > 1, 1, 0)\",\n            write={\n                \"drill\": \"`IF`(x > 1, 1, 0)\",\n                \"duckdb\": \"CASE WHEN x > 1 THEN 1 ELSE 0 END\",\n                \"presto\": \"IF(x > 1, 1, 0)\",\n                \"hive\": \"IF(x > 1, 1, 0)\",\n                \"spark\": \"IF(x > 1, 1, 0)\",\n                \"tableau\": \"IF x > 1 THEN 1 ELSE 0 END\",\n            },\n        )\n        self.validate_all(\n            \"CASE WHEN 1 THEN x ELSE 0 END\",\n            write={\n                \"drill\": \"CASE WHEN 1 THEN x ELSE 0 END\",\n                \"duckdb\": \"CASE WHEN 1 THEN x ELSE 0 END\",\n                \"presto\": \"CASE WHEN 1 THEN x ELSE 0 END\",\n                \"hive\": \"CASE WHEN 1 THEN x ELSE 0 END\",\n                \"spark\": \"CASE WHEN 1 THEN x ELSE 0 END\",\n                \"tableau\": \"CASE WHEN 1 THEN x ELSE 0 END\",\n            },\n        )\n        self.validate_all(\n            \"x[y]\",\n            write={\n                \"drill\": \"x[y]\",\n                \"duckdb\": \"x[y]\",\n                \"presto\": \"x[y]\",\n                \"hive\": \"x[y]\",\n                \"spark\": \"x[y]\",\n            },\n        )\n        self.validate_all(\n            \"\"\"'[\"x\"]'\"\"\",\n            write={\n                \"duckdb\": \"\"\"'[\"x\"]'\"\"\",\n                \"presto\": \"\"\"'[\"x\"]'\"\"\",\n                \"hive\": \"\"\"'[\"x\"]'\"\"\",\n                \"spark\": \"\"\"'[\"x\"]'\"\"\",\n            },\n        )\n\n        self.validate_all(\n            'true or null as \"foo\"',\n            write={\n                \"bigquery\": \"TRUE OR NULL AS `foo`\",\n                \"drill\": \"TRUE OR NULL AS `foo`\",\n                \"duckdb\": 'TRUE OR NULL AS \"foo\"',\n                \"presto\": 'TRUE OR NULL AS \"foo\"',\n                \"hive\": \"TRUE OR NULL AS `foo`\",\n                \"spark\": \"TRUE OR NULL AS `foo`\",\n            },\n        )\n        self.validate_all(\n            \"SELECT IF(COALESCE(bar, 0) = 1, TRUE, FALSE) as foo FROM baz\",\n            write={\n                \"bigquery\": \"SELECT IF(COALESCE(bar, 0) = 1, TRUE, FALSE) AS foo FROM baz\",\n                \"duckdb\": \"SELECT CASE WHEN COALESCE(bar, 0) = 1 THEN TRUE ELSE FALSE END AS foo FROM baz\",\n                \"presto\": \"SELECT IF(COALESCE(bar, 0) = 1, TRUE, FALSE) AS foo FROM baz\",\n                \"hive\": \"SELECT IF(COALESCE(bar, 0) = 1, TRUE, FALSE) AS foo FROM baz\",\n                \"spark\": \"SELECT IF(COALESCE(bar, 0) = 1, TRUE, FALSE) AS foo FROM baz\",\n            },\n        )\n        self.validate_all(\n            \"LEVENSHTEIN(col1, col2)\",\n            read={\n                \"bigquery\": \"EDIT_DISTANCE(col1, col2)\",\n                \"clickhouse\": \"editDistance(col1, col2)\",\n                \"drill\": \"LEVENSHTEIN_DISTANCE(col1, col2)\",\n                \"duckdb\": \"LEVENSHTEIN(col1, col2)\",\n                \"hive\": \"LEVENSHTEIN(col1, col2)\",\n                \"spark\": \"LEVENSHTEIN(col1, col2)\",\n                \"postgres\": \"LEVENSHTEIN(col1, col2)\",\n                \"presto\": \"LEVENSHTEIN_DISTANCE(col1, col2)\",\n                \"snowflake\": \"EDITDISTANCE(col1, col2)\",\n                \"sqlite\": \"EDITDIST3(col1, col2)\",\n                \"trino\": \"LEVENSHTEIN_DISTANCE(col1, col2)\",\n            },\n            write={\n                \"bigquery\": \"EDIT_DISTANCE(col1, col2)\",\n                \"clickhouse\": \"editDistance(col1, col2)\",\n                \"drill\": \"LEVENSHTEIN_DISTANCE(col1, col2)\",\n                \"duckdb\": \"LEVENSHTEIN(col1, col2)\",\n                \"hive\": \"LEVENSHTEIN(col1, col2)\",\n                \"spark\": \"LEVENSHTEIN(col1, col2)\",\n                \"postgres\": \"LEVENSHTEIN(col1, col2)\",\n                \"presto\": \"LEVENSHTEIN_DISTANCE(col1, col2)\",\n                \"snowflake\": \"EDITDISTANCE(col1, col2)\",\n                \"sqlite\": \"EDITDIST3(col1, col2)\",\n                \"trino\": \"LEVENSHTEIN_DISTANCE(col1, col2)\",\n            },\n        )\n\n        self.validate_all(\n            \"LEVENSHTEIN(col1, col2, 1, 2, 3)\",\n            write={\n                \"bigquery\": UnsupportedError,\n                \"clickhouse\": UnsupportedError,\n                \"drill\": UnsupportedError,\n                \"duckdb\": UnsupportedError,\n                \"hive\": UnsupportedError,\n                \"spark\": UnsupportedError,\n                \"postgres\": \"LEVENSHTEIN(col1, col2, 1, 2, 3)\",\n                \"presto\": UnsupportedError,\n                \"snowflake\": UnsupportedError,\n                \"sqlite\": UnsupportedError,\n                \"trino\": UnsupportedError,\n            },\n        )\n        self.validate_all(\n            \"LEVENSHTEIN(col1, col2, 1, 2, 3, 4)\",\n            write={\n                \"bigquery\": UnsupportedError,\n                \"clickhouse\": UnsupportedError,\n                \"drill\": UnsupportedError,\n                \"duckdb\": UnsupportedError,\n                \"hive\": UnsupportedError,\n                \"spark\": UnsupportedError,\n                \"postgres\": \"LEVENSHTEIN_LESS_EQUAL(col1, col2, 1, 2, 3, 4)\",\n                \"presto\": UnsupportedError,\n                \"snowflake\": UnsupportedError,\n                \"sqlite\": UnsupportedError,\n                \"trino\": UnsupportedError,\n            },\n        )\n\n        self.validate_all(\n            \"LEVENSHTEIN(coalesce(col1, col2), coalesce(col2, col1))\",\n            write={\n                \"bigquery\": \"EDIT_DISTANCE(COALESCE(col1, col2), COALESCE(col2, col1))\",\n                \"duckdb\": \"LEVENSHTEIN(COALESCE(col1, col2), COALESCE(col2, col1))\",\n                \"drill\": \"LEVENSHTEIN_DISTANCE(COALESCE(col1, col2), COALESCE(col2, col1))\",\n                \"presto\": \"LEVENSHTEIN_DISTANCE(COALESCE(col1, col2), COALESCE(col2, col1))\",\n                \"hive\": \"LEVENSHTEIN(COALESCE(col1, col2), COALESCE(col2, col1))\",\n                \"spark\": \"LEVENSHTEIN(COALESCE(col1, col2), COALESCE(col2, col1))\",\n            },\n        )\n        self.validate_all(\n            \"ARRAY_FILTER(the_array, x -> x > 0)\",\n            write={\n                \"presto\": \"FILTER(the_array, x -> x > 0)\",\n                \"hive\": \"FILTER(the_array, x -> x > 0)\",\n                \"spark\": \"FILTER(the_array, x -> x > 0)\",\n            },\n        )\n        self.validate_all(\n            \"FILTER(the_array, x -> x > 0)\",\n            write={\n                \"presto\": \"FILTER(the_array, x -> x > 0)\",\n                \"starrocks\": \"ARRAY_FILTER(the_array, x -> x > 0)\",\n            },\n        )\n        self.validate_all(\n            \"a / b\",\n            write={\n                \"bigquery\": \"a / b\",\n                \"clickhouse\": \"a / b\",\n                \"databricks\": \"a / b\",\n                \"duckdb\": \"a / b\",\n                \"hive\": \"a / b\",\n                \"mysql\": \"a / b\",\n                \"oracle\": \"a / b\",\n                \"snowflake\": \"a / b\",\n                \"spark\": \"a / b\",\n                \"starrocks\": \"a / b\",\n                \"drill\": \"CAST(a AS DOUBLE) / b\",\n                \"postgres\": \"CAST(a AS DOUBLE PRECISION) / b\",\n                \"presto\": \"CAST(a AS DOUBLE) / b\",\n                \"redshift\": \"CAST(a AS DOUBLE PRECISION) / b\",\n                \"sqlite\": \"CAST(a AS REAL) / b\",\n                \"teradata\": \"CAST(a AS DOUBLE PRECISION) / b\",\n                \"trino\": \"CAST(a AS DOUBLE) / b\",\n                \"tsql\": \"CAST(a AS FLOAT) / b\",\n            },\n        )\n        self.validate_all(\n            \"MOD(8 - 1 + 7, 7)\",\n            write={\n                \"\": \"(8 - 1 + 7) % 7\",\n                \"hive\": \"(8 - 1 + 7) % 7\",\n                \"presto\": \"(8 - 1 + 7) % 7\",\n                \"snowflake\": \"(8 - 1 + 7) % 7\",\n                \"bigquery\": \"MOD(8 - 1 + 7, 7)\",\n            },\n        )\n        self.validate_all(\n            \"MOD(a, b + 1)\",\n            write={\n                \"\": \"a % (b + 1)\",\n                \"hive\": \"a % (b + 1)\",\n                \"presto\": \"a % (b + 1)\",\n                \"snowflake\": \"a % (b + 1)\",\n                \"bigquery\": \"MOD(a, b + 1)\",\n            },\n        )\n        self.validate_all(\n            \"ARRAY_REMOVE(the_array, target)\",\n            write={\n                \"\": \"ARRAY_REMOVE(the_array, target)\",\n                \"clickhouse\": \"arrayFilter(_u -> _u <> target, the_array)\",\n                \"duckdb\": \"LIST_FILTER(the_array, _u -> _u <> target)\",\n                \"bigquery\": \"ARRAY(SELECT _u FROM UNNEST(the_array) AS _u WHERE _u <> target)\",\n                \"hive\": \"ARRAY_REMOVE(the_array, target)\",\n                \"postgres\": \"ARRAY_REMOVE(the_array, target)\",\n                \"presto\": \"ARRAY_REMOVE(the_array, target)\",\n                \"starrocks\": \"ARRAY_REMOVE(the_array, target)\",\n                \"databricks\": \"ARRAY_REMOVE(the_array, target)\",\n                \"snowflake\": \"ARRAY_REMOVE(the_array, target)\",\n            },\n        )"
                    },
                    {
                        "file_path": "sqlglot/tests/dialects/test_dialect.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/dialects/test_dialect.py",
                        "line_range": [
                            2726,
                            2811
                        ],
                        "reason": "The test 'test_count_if' may be failing due to an assertion error related to the SQL generation logic in the 'validate_all' method. The method is expected to validate the SQL syntax across different dialects, but if the SQL generated does not match the expected output, it could lead to a test failure. Lines 2801-3150 contain the 'test_count_if', 'test_cast_to_user_defined_type', 'test_qualify', 'test_window_exclude', 'test_nested_ctes', 'test_unsupported_null_ordering', 'test_random', 'test_array_any', 'test_truncate', 'test_create_sequence', and 'test_reserved_keywords' methods where this logic is implemented.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "    def test_logarithm(self):\n        for base in (2, 10):\n            with self.subTest(f\"Transpiling LOG base {base}\"):\n                self.validate_all(\n                    f\"LOG({base}, a)\",\n                    read={\n                        \"\": f\"LOG{base}(a)\",\n                        \"bigquery\": f\"LOG{base}(a)\",\n                        \"clickhouse\": f\"LOG{base}(a)\",\n                        \"databricks\": f\"LOG{base}(a)\",\n                        \"dremio\": f\"LOG{base}(a)\",\n                        \"duckdb\": f\"LOG{base}(a)\",\n                        \"mysql\": f\"LOG{base}(a)\",\n                        \"postgres\": f\"LOG{base}(a)\",\n                        \"presto\": f\"LOG{base}(a)\",\n                        \"spark\": f\"LOG{base}(a)\",\n                        \"sqlite\": f\"LOG{base}(a)\",\n                        \"trino\": f\"LOG{base}(a)\",\n                        \"tsql\": f\"LOG{base}(a)\",\n                    },\n                    write={\n                        \"bigquery\": f\"LOG(a, {base})\",\n                        \"clickhouse\": f\"LOG{base}(a)\",\n                        \"dremio\": f\"LOG({base}, a)\",\n                        \"duckdb\": f\"LOG({base}, a)\",\n                        \"mysql\": f\"LOG({base}, a)\",\n                        \"oracle\": f\"LOG({base}, a)\",\n                        \"postgres\": f\"LOG({base}, a)\",\n                        \"presto\": f\"LOG{base}(a)\",\n                        \"redshift\": f\"LOG({base}, a)\",\n                        \"snowflake\": f\"LOG({base}, a)\",\n                        \"spark2\": f\"LOG({base}, a)\",\n                        \"spark\": f\"LOG({base}, a)\",\n                        \"sqlite\": f\"LOG({base}, a)\",\n                        \"starrocks\": f\"LOG({base}, a)\",\n                        \"tableau\": f\"LOG(a, {base})\",\n                        \"trino\": f\"LOG({base}, a)\",\n                        \"tsql\": f\"LOG(a, {base})\",\n                    },\n                )\n\n        self.validate_all(\n            \"LOG(x)\",\n            read={\n                \"duckdb\": \"LOG(x)\",\n                \"postgres\": \"LOG(x)\",\n                \"redshift\": \"LOG(x)\",\n                \"sqlite\": \"LOG(x)\",\n                \"teradata\": \"LOG(x)\",\n            },\n        )\n        self.validate_all(\n            \"LN(x)\",\n            read={\n                \"dremio\": \"LOG(x)\",\n                \"bigquery\": \"LOG(x)\",\n                \"clickhouse\": \"LOG(x)\",\n                \"databricks\": \"LOG(x)\",\n                \"drill\": \"LOG(x)\",\n                \"hive\": \"LOG(x)\",\n                \"mysql\": \"LOG(x)\",\n                \"tsql\": \"LOG(x)\",\n            },\n        )\n        self.validate_all(\n            \"LOG(b, n)\",\n            read={\n                \"bigquery\": \"LOG(n, b)\",\n                \"databricks\": \"LOG(b, n)\",\n                \"drill\": \"LOG(b, n)\",\n                \"duckdb\": \"LOG(b, n)\",\n                \"hive\": \"LOG(b, n)\",\n                \"mysql\": \"LOG(b, n)\",\n                \"oracle\": \"LOG(b, n)\",\n                \"postgres\": \"LOG(b, n)\",\n                \"snowflake\": \"LOG(b, n)\",\n                \"spark\": \"LOG(b, n)\",\n                \"sqlite\": \"LOG(b, n)\",\n                \"trino\": \"LOG(b, n)\",\n                \"tsql\": \"LOG(n, b)\",\n            },\n            write={\n                \"clickhouse\": UnsupportedError,\n                \"presto\": UnsupportedError,\n            },\n        )"
                    }
                ]
            }
        ]
    },
    {
        "sha_fail": "5df3ea92f59125955124ea1883b777b489db3042",
        "fault_localization_data": [
            {
                "file_path": "tests/test_optimizer.py",
                "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/test_optimizer.py",
                "faults": [
                    {
                        "file_path": "tests/test_optimizer.py",
                        "full_file_path": "/Users/rabeyakhatunmuna/Documents/CI-REPAIR-BENCH/baselines/repo_cloned/sqlglot/tests/test_optimizer.py",
                        "line_range": [
                            68,
                            1642
                        ],
                        "reason": "The unit test 'test_annotate_funcs' failed due to an assertion error where the expected output 'BINARY' did not match the actual output 'UNKNOWN'. This indicates a failure in the logic being tested, specifically in the type annotation process. The failure is directly linked to the assertion on line 878, which checks for the expected type against the actual type returned by the function being tested.",
                        "issue_type": "test_failure",
                        "fault_localization_level": "method",
                        "code_snippet": "class TestOptimizer(unittest.TestCase):\n    maxDiff = None\n\n    @classmethod\n    def setUpClass(cls):\n        sqlglot.schema = MappingSchema()\n        cls.conn = duckdb.connect()\n        cls.conn.execute(\n            \"\"\"\n        CREATE TABLE x (a INT, b INT);\n        CREATE TABLE y (b INT, c INT);\n        CREATE TABLE z (b INT, c INT);\n        CREATE TABLE w (d TEXT, e TEXT);\n\n        INSERT INTO x VALUES (1, 1);\n        INSERT INTO x VALUES (2, 2);\n        INSERT INTO x VALUES (2, 2);\n        INSERT INTO x VALUES (3, 3);\n        INSERT INTO x VALUES (null, null);\n\n        INSERT INTO y VALUES (2, 2);\n        INSERT INTO y VALUES (2, 2);\n        INSERT INTO y VALUES (3, 3);\n        INSERT INTO y VALUES (4, 4);\n        INSERT INTO y VALUES (null, null);\n\n        INSERT INTO y VALUES (3, 3);\n        INSERT INTO y VALUES (3, 3);\n        INSERT INTO y VALUES (4, 4);\n        INSERT INTO y VALUES (5, 5);\n        INSERT INTO y VALUES (null, null);\n\n        INSERT INTO w VALUES ('a', 'b');\n        \"\"\"\n        )\n\n    def setUp(self):\n        self.schema = {\n            \"x\": {\n                \"a\": \"INT\",\n                \"b\": \"INT\",\n            },\n            \"y\": {\n                \"b\": \"INT\",\n                \"c\": \"INT\",\n            },\n            \"z\": {\n                \"b\": \"INT\",\n                \"c\": \"INT\",\n            },\n            \"w\": {\n                \"d\": \"TEXT\",\n                \"e\": \"TEXT\",\n            },\n            \"temporal\": {\n                \"d\": \"DATE\",\n                \"t\": \"DATETIME\",\n            },\n            \"structs\": {\n                \"one\": \"STRUCT<a_1 INT, b_1 VARCHAR>\",\n                \"nested_0\": \"STRUCT<a_1 INT, nested_1 STRUCT<a_2 INT, nested_2 STRUCT<a_3 INT>>>\",\n                \"quoted\": 'STRUCT<\"foo bar\" INT>',\n            },\n        }\n\n    def check_file(\n        self,\n        file,\n        func,\n        pretty=False,\n        execute=False,\n        only=None,\n        **kwargs,\n    ):\n        with ProcessPoolExecutor() as pool:\n            results = {}\n\n            for i, (meta, sql, expected) in enumerate(\n                load_sql_fixture_pairs(f\"optimizer/{file}.sql\"), start=1\n            ):\n                title = meta.get(\"title\") or f\"{i}, {sql}\"\n                if only and title != only:\n                    continue\n                dialect = meta.get(\"dialect\")\n                leave_tables_isolated = meta.get(\"leave_tables_isolated\")\n                validate_qualify_columns = meta.get(\"validate_qualify_columns\")\n\n                func_kwargs = {**kwargs}\n                if leave_tables_isolated is not None:\n                    func_kwargs[\"leave_tables_isolated\"] = string_to_bool(leave_tables_isolated)\n\n                if validate_qualify_columns is not None:\n                    func_kwargs[\"validate_qualify_columns\"] = string_to_bool(\n                        validate_qualify_columns\n                    )\n\n                if dialect:\n                    func_kwargs[\"dialect\"] = dialect\n\n                future = pool.submit(parse_and_optimize, func, sql, dialect, **func_kwargs)\n                results[future] = (\n                    sql,\n                    title,\n                    expected,\n                    dialect,\n                    execute if meta.get(\"execute\") is None else False,\n                )\n\n        for future in as_completed(results):\n            sql, title, expected, dialect, execute = results[future]\n\n            with self.subTest(title):\n                optimized = future.result()\n                actual = optimized.sql(pretty=pretty, dialect=dialect)\n                self.assertEqual(\n                    expected,\n                    actual,\n                )\n                for expression in optimized.walk():\n                    for arg_key, arg in expression.args.items():\n                        if isinstance(arg, exp.Expression):\n                            self.assertEqual(arg_key, arg.arg_key)\n                            self.assertIs(arg.parent, expression)\n\n                if string_to_bool(execute):\n                    with self.subTest(f\"(execute) {title}\"):\n                        df1 = self.conn.execute(\n                            sqlglot.transpile(sql, read=dialect, write=\"duckdb\")[0]\n                        ).df()\n                        df2 = self.conn.execute(optimized.sql(dialect=\"duckdb\")).df()\n                        assert_frame_equal(df1, df2)\n\n    @patch(\"sqlglot.generator.logger\")\n    def test_optimize(self, logger):\n        self.assertEqual(optimizer.optimize(\"x = 1 + 1\", identify=None).sql(), \"x = 2\")\n\n        schema = {\n            \"x\": {\"a\": \"INT\", \"b\": \"INT\"},\n            \"y\": {\"b\": \"INT\", \"c\": \"INT\"},\n            \"z\": {\"a\": \"INT\", \"c\": \"INT\"},\n            \"u\": {\"f\": \"INT\", \"g\": \"INT\", \"h\": \"TEXT\"},\n        }\n\n        self.check_file(\n            \"optimizer\",\n            optimizer.optimize,\n            infer_schema=True,\n            pretty=True,\n            execute=True,\n            schema=schema,\n        )\n\n    def test_isolate_table_selects(self):\n        self.check_file(\n            \"isolate_table_selects\",\n            optimizer.isolate_table_selects.isolate_table_selects,\n            schema=self.schema,\n        )\n\n    def test_qualify_tables(self):\n        self.assertEqual(\n            optimizer.qualify_tables.qualify_tables(\n                parse_one(\n                    \"WITH cte AS (SELECT * FROM t) SELECT * FROM cte PIVOT(SUM(c) FOR v IN ('x', 'y'))\"\n                ),\n                db=\"db\",\n                catalog=\"catalog\",\n            ).sql(),\n            \"WITH cte AS (SELECT * FROM catalog.db.t AS t) SELECT * FROM cte AS cte PIVOT(SUM(c) FOR v IN ('x', 'y')) AS _q_0\",\n        )\n\n        self.assertEqual(\n            optimizer.qualify_tables.qualify_tables(\n                parse_one(\n                    \"WITH cte AS (SELECT * FROM t) SELECT * FROM cte PIVOT(SUM(c) FOR v IN ('x', 'y')) AS pivot_alias\"\n                ),\n                db=\"db\",\n                catalog=\"catalog\",\n            ).sql(),\n            \"WITH cte AS (SELECT * FROM catalog.db.t AS t) SELECT * FROM cte AS cte PIVOT(SUM(c) FOR v IN ('x', 'y')) AS pivot_alias\",\n        )\n\n        self.assertEqual(\n            optimizer.qualify_tables.qualify_tables(\n                parse_one(\"select a from b\"), catalog=\"catalog\"\n            ).sql(),\n            \"SELECT a FROM b AS b\",\n        )\n\n        self.assertEqual(\n            optimizer.qualify_tables.qualify_tables(parse_one(\"select a from b\"), db='\"DB\"').sql(),\n            'SELECT a FROM \"DB\".b AS b',\n        )\n\n        self.check_file(\n            \"qualify_tables\",\n            optimizer.qualify_tables.qualify_tables,\n            db=\"db\",\n            catalog=\"c\",\n        )\n\n    def test_normalize(self):\n        self.assertEqual(\n            optimizer.normalize.normalize(\n                parse_one(\"x AND (y OR z)\"),\n                dnf=True,\n            ).sql(),\n            \"(x AND y) OR (x AND z)\",\n        )\n\n        self.assertEqual(\n            optimizer.normalize.normalize(\n                parse_one(\"x AND (y OR z)\"),\n            ).sql(),\n            \"x AND (y OR z)\",\n        )\n\n        self.check_file(\"normalize\", normalize)\n\n    @patch(\"sqlglot.generator.logger\")\n    def test_qualify_columns(self, logger):\n        self.assertEqual(\n            optimizer.qualify.qualify(\n                parse_one(\n                    \"\"\"\n                    SELECT Teams.Name, count(*)\n                    FROM raw.TeamMemberships as TeamMemberships\n                    join raw.Teams\n                        on Teams.Id = TeamMemberships.TeamId\n                    GROUP BY 1\n                    \"\"\",\n                    read=\"bigquery\",\n                ),\n                schema={\n                    \"raw\": {\n                        \"TeamMemberships\": {\n                            \"Id\": \"INTEGER\",\n                            \"UserId\": \"INTEGER\",\n                            \"TeamId\": \"INTEGER\",\n                        },\n                        \"Teams\": {\n                            \"Id\": \"INTEGER\",\n                            \"Name\": \"STRING\",\n                        },\n                    }\n                },\n                dialect=\"bigquery\",\n            ).sql(dialect=\"bigquery\"),\n            \"SELECT `teams`.`name` AS `name`, count(*) AS `_col_1` FROM `raw`.`TeamMemberships` AS `teammemberships` JOIN `raw`.`Teams` AS `teams` ON `teams`.`id` = `teammemberships`.`teamid` GROUP BY `teams`.`name`\",\n        )\n        self.assertEqual(\n            optimizer.qualify.qualify(\n                parse_one(\n                    \"SELECT `my_db.my_table`.`my_column` FROM `my_db.my_table`\",\n                    read=\"bigquery\",\n                ),\n                dialect=\"bigquery\",\n            ).sql(dialect=\"bigquery\"),\n            \"SELECT `my_table`.`my_column` AS `my_column` FROM `my_db.my_table` AS `my_table`\",\n        )\n\n        self.assertEqual(\n            optimizer.qualify_columns.qualify_columns(\n                parse_one(\n                    \"WITH RECURSIVE t AS (SELECT 1 AS x UNION ALL SELECT x + 1 FROM t AS child WHERE x < 10) SELECT * FROM t\"\n                ),\n                schema={},\n                infer_schema=False,\n            ).sql(),\n            \"WITH RECURSIVE t AS (SELECT 1 AS x UNION ALL SELECT child.x + 1 AS _col_0 FROM t AS child WHERE child.x < 10) SELECT t.x AS x FROM t\",\n        )\n\n        self.assertEqual(\n            optimizer.qualify_columns.qualify_columns(\n                parse_one(\"WITH x AS (SELECT a FROM db.y) SELECT * FROM db.x\"),\n                schema={\"db\": {\"x\": {\"z\": \"int\"}, \"y\": {\"a\": \"int\"}}},\n                expand_stars=False,\n            ).sql(),\n            \"WITH x AS (SELECT y.a AS a FROM db.y) SELECT * FROM db.x\",\n        )\n\n        self.assertEqual(\n            optimizer.qualify_columns.qualify_columns(\n                parse_one(\"WITH x AS (SELECT a FROM db.y) SELECT z FROM db.x\"),\n                schema={\"db\": {\"x\": {\"z\": \"int\"}, \"y\": {\"a\": \"int\"}}},\n                infer_schema=False,\n            ).sql(),\n            \"WITH x AS (SELECT y.a AS a FROM db.y) SELECT x.z AS z FROM db.x\",\n        )\n\n        self.assertEqual(\n            optimizer.qualify_columns.qualify_columns(\n                parse_one(\"select y from x\"),\n                schema={},\n                infer_schema=False,\n            ).sql(),\n            \"SELECT y AS y FROM x\",\n        )\n\n        self.assertEqual(\n            optimizer.qualify.qualify(\n                parse_one(\n                    \"WITH X AS (SELECT Y.A FROM DB.y CROSS JOIN a.b.INFORMATION_SCHEMA.COLUMNS) SELECT `A` FROM X\",\n                    read=\"bigquery\",\n                ),\n                dialect=\"bigquery\",\n            ).sql(),\n            'WITH \"x\" AS (SELECT \"y\".\"a\" AS \"a\" FROM \"DB\".\"y\" AS \"y\" CROSS JOIN \"a\".\"b\".\"INFORMATION_SCHEMA.COLUMNS\" AS \"columns\") SELECT \"x\".\"a\" AS \"a\" FROM \"x\" AS \"x\"',\n        )\n\n        self.assertEqual(\n            optimizer.qualify.qualify(\n                parse_one(\n                    \"CREATE FUNCTION udfs.`myTest`(`x` FLOAT64) AS (1)\",\n                    read=\"bigquery\",\n                ),\n                dialect=\"bigquery\",\n            ).sql(dialect=\"bigquery\"),\n            \"CREATE FUNCTION `udfs`.`myTest`(`x` FLOAT64) AS (1)\",\n        )\n\n        self.assertEqual(\n            optimizer.qualify.qualify(\n                parse_one(\"SELECT `bar_bazfoo_$id` FROM test\", read=\"spark\"),\n                schema={\"test\": {\"bar_bazFoo_$id\": \"BIGINT\"}},\n                dialect=\"spark\",\n            ).sql(dialect=\"spark\"),\n            \"SELECT `test`.`bar_bazfoo_$id` AS `bar_bazfoo_$id` FROM `test` AS `test`\",\n        )\n\n        qualified = optimizer.qualify.qualify(\n            parse_one(\"WITH t AS (SELECT 1 AS c) (SELECT c FROM t)\")\n        )\n        self.assertIs(qualified.selects[0].parent, qualified.this)\n        self.assertEqual(\n            qualified.sql(),\n            'WITH \"t\" AS (SELECT 1 AS \"c\") (SELECT \"t\".\"c\" AS \"c\" FROM \"t\" AS \"t\")',\n        )\n\n        # can't coalesce USING columns because they don't exist in every already-joined table\n        self.assertEqual(\n            optimizer.qualify_columns.qualify_columns(\n                parse_one(\n                    \"SELECT id, dt, v FROM (SELECT t1.id, t1.dt, sum(coalesce(t2.v, 0)) AS v FROM t1 AS t1 LEFT JOIN lkp AS lkp USING (id) LEFT JOIN t2 AS t2 USING (other_id, dt, common) WHERE t1.id > 10 GROUP BY 1, 2) AS _q_0\",\n                    dialect=\"bigquery\",\n                ),\n                schema=MappingSchema(\n                    schema={\n                        \"t1\": {\"id\": \"int64\", \"dt\": \"date\", \"common\": \"int64\"},\n                        \"lkp\": {\"id\": \"int64\", \"other_id\": \"int64\", \"common\": \"int64\"},\n                        \"t2\": {\"other_id\": \"int64\", \"dt\": \"date\", \"v\": \"int64\", \"common\": \"int64\"},\n                    },\n                    dialect=\"bigquery\",\n                ),\n            ).sql(dialect=\"bigquery\"),\n            \"SELECT _q_0.id AS id, _q_0.dt AS dt, _q_0.v AS v FROM (SELECT t1.id AS id, t1.dt AS dt, sum(coalesce(t2.v, 0)) AS v FROM t1 AS t1 LEFT JOIN lkp AS lkp ON t1.id = lkp.id LEFT JOIN t2 AS t2 ON lkp.other_id = t2.other_id AND t1.dt = t2.dt AND COALESCE(t1.common, lkp.common) = t2.common WHERE t1.id > 10 GROUP BY t1.id, t1.dt) AS _q_0\",\n        )\n\n        # Detection of correlation where columns are referenced in derived tables nested within subqueries\n        self.assertEqual(\n            optimizer.qualify.qualify(\n                parse_one(\n                    \"SELECT a.g FROM a WHERE a.e < (SELECT MAX(u) FROM (SELECT SUM(c.b) AS u FROM c WHERE  c.d = f GROUP BY c.e) w)\"\n                ),\n                schema={\n                    \"a\": {\"g\": \"INT\", \"e\": \"INT\", \"f\": \"INT\"},\n                    \"c\": {\"d\": \"INT\", \"e\": \"INT\", \"b\": \"INT\"},\n                },\n                quote_identifiers=False,\n            ).sql(),\n            \"SELECT a.g AS g FROM a AS a WHERE a.e < (SELECT MAX(w.u) AS _col_0 FROM (SELECT SUM(c.b) AS u FROM c AS c WHERE c.d = a.f GROUP BY c.e) AS w)\",\n        )\n\n        # Detection of correlation where columns are referenced in derived tables nested within lateral joins\n        self.assertEqual(\n            optimizer.qualify.qualify(\n                parse_one(\n                    \"SELECT u.user_id, l.log_date FROM users AS u CROSS JOIN LATERAL (SELECT l1.log_date FROM (SELECT l.log_date FROM logs AS l WHERE l.user_id = u.user_id AND l.log_date <= 100 ORDER BY l.log_date LIMIT 1) AS l1) AS l\",\n                    dialect=\"postgres\",\n                ),\n                schema={\n                    \"users\": {\"user_id\": \"text\", \"log_date\": \"date\"},\n                    \"logs\": {\"user_id\": \"text\", \"log_date\": \"date\"},\n                },\n                quote_identifiers=False,\n            ).sql(\"postgres\"),\n            \"SELECT u.user_id AS user_id, l.log_date AS log_date FROM users AS u CROSS JOIN LATERAL (SELECT l1.log_date AS log_date FROM (SELECT l.log_date AS log_date FROM logs AS l WHERE l.user_id = u.user_id AND l.log_date <= 100 ORDER BY l.log_date LIMIT 1) AS l1) AS l\",\n        )\n\n        self.assertEqual(\n            optimizer.qualify.qualify(\n                parse_one(\n                    \"SELECT A.b_id FROM A JOIN B ON A.b_id=B.b_id JOIN C USING(c_id)\",\n                    dialect=\"postgres\",\n                ),\n                schema={\n                    \"A\": {\"b_id\": \"int\"},\n                    \"B\": {\"b_id\": \"int\", \"c_id\": \"int\"},\n                    \"C\": {\"c_id\": \"int\"},\n                },\n                quote_identifiers=False,\n            ).sql(\"postgres\"),\n            \"SELECT a.b_id AS b_id FROM a AS a JOIN b AS b ON a.b_id = b.b_id JOIN c AS c ON b.c_id = c.c_id\",\n        )\n        self.assertEqual(\n            optimizer.qualify.qualify(\n                parse_one(\n                    \"SELECT A.b_id FROM A JOIN B ON A.b_id=B.b_id JOIN C ON B.b_id = C.b_id JOIN D USING(d_id)\",\n                    dialect=\"postgres\",\n                ),\n                schema={\n                    \"A\": {\"b_id\": \"int\"},\n                    \"B\": {\"b_id\": \"int\", \"d_id\": \"int\"},\n                    \"C\": {\"b_id\": \"int\"},\n                    \"D\": {\"d_id\": \"int\"},\n                },\n                quote_identifiers=False,\n            ).sql(\"postgres\"),\n            \"SELECT a.b_id AS b_id FROM a AS a JOIN b AS b ON a.b_id = b.b_id JOIN c AS c ON b.b_id = c.b_id JOIN d AS d ON b.d_id = d.d_id\",\n        )\n\n        self.check_file(\n            \"qualify_columns\",\n            qualify_columns,\n            execute=True,\n            schema=self.schema,\n        )\n        self.check_file(\"qualify_columns_ddl\", qualify_columns, schema=self.schema)\n\n    def test_qualify_columns__with_invisible(self):\n        schema = MappingSchema(self.schema, {\"x\": {\"a\"}, \"y\": {\"b\"}, \"z\": {\"b\"}})\n        self.check_file(\"qualify_columns__with_invisible\", qualify_columns, schema=schema)\n\n    def test_pushdown_cte_alias_columns(self):\n        self.check_file(\n            \"pushdown_cte_alias_columns\",\n            optimizer.qualify_columns.pushdown_cte_alias_columns,\n        )\n\n    def test_qualify_columns__invalid(self):\n        for sql in load_sql_fixtures(\"optimizer/qualify_columns__invalid.sql\"):\n            with self.subTest(sql):\n                with self.assertRaises((OptimizeError, SchemaError)):\n                    expression = optimizer.qualify_columns.qualify_columns(\n                        parse_one(sql), schema=self.schema\n                    )\n                    optimizer.qualify_columns.validate_qualify_columns(expression)\n\n    def test_normalize_identifiers(self):\n        self.check_file(\n            \"normalize_identifiers\",\n            optimizer.normalize_identifiers.normalize_identifiers,\n        )\n\n        self.assertEqual(optimizer.normalize_identifiers.normalize_identifiers(\"a%\").sql(), '\"a%\"')\n\n    def test_quote_identifiers(self):\n        self.check_file(\n            \"quote_identifiers\",\n            optimizer.qualify_columns.quote_identifiers,\n        )\n\n    def test_pushdown_projection(self):\n        self.check_file(\"pushdown_projections\", pushdown_projections, schema=self.schema)\n\n    def test_simplify(self):\n        self.check_file(\"simplify\", simplify)\n\n        # Stress test with huge union query\n        union_sql = \"SELECT 1 UNION ALL \" * 1000 + \"SELECT 1\"\n        expression = parse_one(union_sql)\n        self.assertEqual(simplify(expression).sql(), union_sql)\n\n        # Ensure simplify mutates the AST properly\n        expression = parse_one(\"SELECT 1 + 2\")\n        simplify(expression.selects[0])\n        self.assertEqual(expression.sql(), \"SELECT 3\")\n\n        expression = parse_one(\"SELECT a, c, b FROM table1 WHERE 1 = 1\")\n        self.assertEqual(simplify(simplify(expression.find(exp.Where))).sql(), \"WHERE TRUE\")\n\n        expression = parse_one(\"TRUE AND TRUE AND TRUE\")\n        self.assertEqual(exp.true(), optimizer.simplify.simplify(expression))\n        self.assertEqual(exp.true(), optimizer.simplify.simplify(expression.this))\n\n        # CONCAT in (e.g.) Presto is parsed as Concat instead of SafeConcat which is the default type\n        # This test checks that simplify_concat preserves the corresponding expression types.\n        concat = parse_one(\"CONCAT('a', x, 'b', 'c')\", read=\"presto\")\n        simplified_concat = optimizer.simplify.simplify(concat)\n\n        safe_concat = parse_one(\"CONCAT('a', x, 'b', 'c')\")\n        simplified_safe_concat = optimizer.simplify.simplify(safe_concat)\n\n        self.assertEqual(simplified_concat.args[\"safe\"], False)\n        self.assertEqual(simplified_safe_concat.args[\"safe\"], True)\n\n        self.assertEqual(\"CONCAT('a', x, 'bc')\", simplified_concat.sql(dialect=\"presto\"))\n        self.assertEqual(\"CONCAT('a', x, 'bc')\", simplified_safe_concat.sql())\n\n        anon_unquoted_str = parse_one(\"anonymous(x, y)\")\n        self.assertEqual(optimizer.simplify.gen(anon_unquoted_str), \"ANONYMOUS(x,y)\")\n\n        query = parse_one(\"SELECT x FROM t\")\n        self.assertEqual(optimizer.simplify.gen(query), optimizer.simplify.gen(query.copy()))\n\n        anon_unquoted_identifier = exp.Anonymous(\n            this=exp.to_identifier(\"anonymous\"),\n            expressions=[exp.column(\"x\"), exp.column(\"y\")],\n        )\n        self.assertEqual(optimizer.simplify.gen(anon_unquoted_identifier), \"ANONYMOUS(x,y)\")\n\n        anon_quoted = parse_one('\"anonymous\"(x, y)')\n        self.assertEqual(optimizer.simplify.gen(anon_quoted), '\"anonymous\"(x,y)')\n\n        with self.assertRaises(ValueError) as e:\n            anon_invalid = exp.Anonymous(this=5)\n            optimizer.simplify.gen(anon_invalid)\n\n        self.assertIn(\n            \"Anonymous.this expects a str or an Identifier, got 'int'.\",\n            str(e.exception),\n        )\n\n        sql = parse_one(\n            \"\"\"\n        WITH cte AS (select 1 union select 2), cte2 AS (\n            SELECT ROW() OVER (PARTITION BY y) FROM (\n                (select 1) limit 10\n            )\n        )\n        SELECT\n          *,\n          a + 1,\n          a div 1,\n          filter(\"B\", (x, y) -> x + y)\n          FROM (z AS z CROSS JOIN z) AS f(a) LEFT JOIN a.b.c.d.e.f.g USING(n) ORDER BY 1\n        \"\"\"\n        )\n        self.assertEqual(\n            optimizer.simplify.gen(sql),\n            \"\"\"\nSELECT :with,WITH :expressions,CTE :this,UNION :this,SELECT :expressions,1,:expression,SELECT :expressions,2,:distinct,True,:alias, AS cte,CTE :this,SELECT :expressions,WINDOW :this,ROW(),:partition_by,y,:over,OVER,:from,FROM ((SELECT :expressions,1):limit,LIMIT :expression,10),:alias, AS cte2,:expressions,STAR,a + 1,a DIV 1,FILTER(\"B\",LAMBDA :this,x + y,:expressions,x,y),:from,FROM (z AS z:joins,JOIN :this,z,:kind,CROSS) AS f(a),:joins,JOIN :this,a.b.c.d.e.f.g,:side,LEFT,:using,n,:order,ORDER :expressions,ORDERED :this,1,:nulls_first,True\n\"\"\".strip(),\n        )\n        self.assertEqual(\n            optimizer.simplify.gen(parse_one(\"select item_id /* description */\"), comments=True),\n            \"SELECT :expressions,item_id /* description */\",\n        )\n\n    def test_unnest_subqueries(self):\n        self.check_file(\"unnest_subqueries\", optimizer.unnest_subqueries.unnest_subqueries)\n\n    def test_pushdown_predicates(self):\n        self.check_file(\"pushdown_predicates\", optimizer.pushdown_predicates.pushdown_predicates)\n\n    def test_expand_alias_refs(self):\n        # check order of lateral expansion with no schema\n        self.assertEqual(\n            optimizer.optimize(\"SELECT a + 1 AS d, d + 1 AS e FROM x WHERE e > 1 GROUP BY e\").sql(),\n            'SELECT \"x\".\"a\" + 1 AS \"d\", \"x\".\"a\" + 1 + 1 AS \"e\" FROM \"x\" AS \"x\" WHERE (\"x\".\"a\" + 2) > 1 GROUP BY \"x\".\"a\" + 1 + 1',\n        )\n\n        unused_schema = {\"l\": {\"c\": \"int\"}}\n        self.assertEqual(\n            optimizer.qualify_columns.qualify_columns(\n                parse_one(\"SELECT CAST(x AS INT) AS y FROM z AS z\"),\n                schema=unused_schema,\n                infer_schema=False,\n            ).sql(),\n            \"SELECT CAST(x AS INT) AS y FROM z AS z\",\n        )\n\n        # BigQuery expands overlapping alias only for GROUP BY + HAVING\n        sql = \"WITH data AS (SELECT 1 AS id, 2 AS my_id, 'a' AS name, 'b' AS full_name) SELECT id AS my_id, CONCAT(id, name) AS full_name FROM data WHERE my_id = 1 GROUP BY my_id, full_name HAVING my_id = 1\"\n        self.assertEqual(\n            optimizer.qualify_columns.qualify_columns(\n                parse_one(sql, dialect=\"bigquery\"),\n                schema=MappingSchema(schema=unused_schema, dialect=\"bigquery\"),\n            ).sql(),\n            \"WITH data AS (SELECT 1 AS id, 2 AS my_id, 'a' AS name, 'b' AS full_name) SELECT data.id AS my_id, CONCAT(data.id, data.name) AS full_name FROM data WHERE data.my_id = 1 GROUP BY data.id, CONCAT(data.id, data.name) HAVING data.id = 1\",\n        )\n\n        # Clickhouse expands overlapping alias across the entire query\n        self.assertEqual(\n            optimizer.qualify_columns.qualify_columns(\n                parse_one(sql, dialect=\"clickhouse\"),\n                schema=MappingSchema(schema=unused_schema, dialect=\"clickhouse\"),\n            ).sql(),\n            \"WITH data AS (SELECT 1 AS id, 2 AS my_id, 'a' AS name, 'b' AS full_name) SELECT data.id AS my_id, CONCAT(data.id, data.name) AS full_name FROM data WHERE data.id = 1 GROUP BY data.id, CONCAT(data.id, data.name) HAVING data.id = 1\",\n        )\n\n        # Edge case: BigQuery shouldn't expand aliases in complex expressions\n        sql = \"WITH data AS (SELECT 1 AS id) SELECT FUNC(id) AS id FROM data GROUP BY FUNC(id)\"\n        self.assertEqual(\n            optimizer.qualify_columns.qualify_columns(\n                parse_one(sql, dialect=\"bigquery\"),\n                schema=MappingSchema(schema=unused_schema, dialect=\"bigquery\"),\n            ).sql(),\n            \"WITH data AS (SELECT 1 AS id) SELECT FUNC(data.id) AS id FROM data GROUP BY FUNC(data.id)\",\n        )\n\n        sql = \"SELECT x.a, max(x.b) as x FROM x AS x GROUP BY 1 HAVING x > 1\"\n        self.assertEqual(\n            optimizer.qualify_columns.qualify_columns(\n                parse_one(sql, dialect=\"bigquery\"),\n                schema=MappingSchema(schema=unused_schema, dialect=\"bigquery\"),\n            ).sql(),\n            \"SELECT x.a AS a, MAX(x.b) AS x FROM x AS x GROUP BY 1 HAVING x > 1\",\n        )\n\n    def test_optimize_joins(self):\n        self.check_file(\n            \"optimize_joins\",\n            optimizer.optimize_joins.optimize_joins,\n        )\n\n    def test_eliminate_joins(self):\n        self.check_file(\n            \"eliminate_joins\",\n            optimizer.eliminate_joins.eliminate_joins,\n            pretty=True,\n        )\n\n    def test_eliminate_ctes(self):\n        self.check_file(\n            \"eliminate_ctes\",\n            optimizer.eliminate_ctes.eliminate_ctes,\n            pretty=True,\n        )\n\n    @patch(\"sqlglot.generator.logger\")\n    def test_merge_subqueries(self, logger):\n        optimize = partial(\n            optimizer.optimize,\n            rules=[\n                optimizer.qualify_tables.qualify_tables,\n                optimizer.qualify_columns.qualify_columns,\n                optimizer.merge_subqueries.merge_subqueries,\n            ],\n        )\n\n        self.check_file(\"merge_subqueries\", optimize, execute=True, schema=self.schema)\n\n    def test_eliminate_subqueries(self):\n        self.check_file(\"eliminate_subqueries\", optimizer.eliminate_subqueries.eliminate_subqueries)\n\n    def test_canonicalize(self):\n        optimize = partial(\n            optimizer.optimize,\n            rules=[\n                optimizer.qualify.qualify,\n                optimizer.qualify_columns.quote_identifiers,\n                annotate_types,\n                optimizer.canonicalize.canonicalize,\n            ],\n        )\n        self.check_file(\"canonicalize\", optimize, schema=self.schema)\n\n    def test_tpch(self):\n        self.check_file(\"tpc-h/tpc-h\", optimizer.optimize, schema=TPCH_SCHEMA, pretty=True)\n\n    def test_tpcds(self):\n        self.check_file(\"tpc-ds/tpc-ds\", optimizer.optimize, schema=TPCDS_SCHEMA, pretty=True)\n\n    def test_file_schema(self):\n        expression = parse_one(\n            \"\"\"\n            SELECT *\n            FROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|')\n            \"\"\"\n        )\n        self.assertEqual(\n            \"\"\"\nSELECT\n  \"_q_0\".\"n_nationkey\" AS \"n_nationkey\",\n  \"_q_0\".\"n_name\" AS \"n_name\",\n  \"_q_0\".\"n_regionkey\" AS \"n_regionkey\",\n  \"_q_0\".\"n_comment\" AS \"n_comment\"\nFROM READ_CSV('tests/fixtures/optimizer/tpc-h/nation.csv.gz', 'delimiter', '|') AS \"_q_0\"\n\"\"\".strip(),\n            optimizer.optimize(expression, infer_csv_schemas=True).sql(pretty=True),\n        )\n\n    def test_scope(self):\n        ast = parse_one(\"SELECT IF(a IN UNNEST(b), 1, 0) AS c FROM t\", dialect=\"bigquery\")\n        self.assertEqual(build_scope(ast).columns, [exp.column(\"a\"), exp.column(\"b\")])\n\n        many_unions = parse_one(\" UNION ALL \".join([\"SELECT x FROM t\"] * 10000))\n        scopes_using_traverse = list(build_scope(many_unions).traverse())\n        scopes_using_traverse_scope = traverse_scope(many_unions)\n        self.assertEqual(len(scopes_using_traverse), len(scopes_using_traverse_scope))\n        assert all(\n            x.expression is y.expression\n            for x, y in zip(scopes_using_traverse, scopes_using_traverse_scope)\n        )\n\n        sql = \"\"\"\n        WITH q AS (\n          SELECT x.b FROM x\n        ), r AS (\n          SELECT y.b FROM y\n        ), z as (\n          SELECT cola, colb FROM (VALUES(1, 'test')) AS tab(cola, colb)\n        )\n        SELECT\n          r.b,\n          s.b\n        FROM r\n        JOIN (\n          SELECT y.c AS b FROM y\n        ) s\n        ON s.b = r.b\n        WHERE s.b > (SELECT MAX(x.a) FROM x WHERE x.b = s.b)\n        \"\"\"\n        expression = parse_one(sql)\n        for scopes in traverse_scope(expression), list(build_scope(expression).traverse()):\n            self.assertEqual(len(scopes), 7)\n            self.assertEqual(scopes[0].expression.sql(), \"SELECT x.b FROM x\")\n            self.assertEqual(scopes[1].expression.sql(), \"SELECT y.b FROM y\")\n            self.assertEqual(scopes[2].expression.sql(), \"(VALUES (1, 'test')) AS tab(cola, colb)\")\n            self.assertEqual(\n                scopes[3].expression.sql(),\n                \"SELECT cola, colb FROM (VALUES (1, 'test')) AS tab(cola, colb)\",\n            )\n            self.assertEqual(scopes[4].expression.sql(), \"SELECT y.c AS b FROM y\")\n            self.assertEqual(scopes[5].expression.sql(), \"SELECT MAX(x.a) FROM x WHERE x.b = s.b\")\n            self.assertEqual(scopes[6].expression.sql(), parse_one(sql).sql())\n\n            self.assertEqual(set(scopes[6].sources), {\"q\", \"z\", \"r\", \"s\"})\n            self.assertEqual(len(scopes[6].columns), 6)\n            self.assertEqual({c.table for c in scopes[6].columns}, {\"r\", \"s\"})\n            self.assertEqual(scopes[6].source_columns(\"q\"), [])\n            self.assertEqual(len(scopes[6].source_columns(\"r\")), 2)\n            self.assertEqual({c.table for c in scopes[6].source_columns(\"r\")}, {\"r\"})\n\n            self.assertEqual({c.sql() for c in scopes[-1].find_all(exp.Column)}, {\"r.b\", \"s.b\"})\n            self.assertEqual(scopes[-1].find(exp.Column).sql(), \"r.b\")\n            self.assertEqual({c.sql() for c in scopes[0].find_all(exp.Column)}, {\"x.b\"})\n\n        # Check that we can walk in scope from an arbitrary node\n        self.assertEqual(\n            {\n                node.sql()\n                for node in walk_in_scope(expression.find(exp.Where))\n                if isinstance(node, exp.Column)\n            },\n            {\"s.b\"},\n        )\n\n        # Check that parentheses don't introduce a new scope unless an alias is attached\n        sql = \"SELECT * FROM (((SELECT * FROM (t1 JOIN t2) AS t3) JOIN (SELECT * FROM t4)))\"\n        expression = parse_one(sql)\n        for scopes in traverse_scope(expression), list(build_scope(expression).traverse()):\n            self.assertEqual(len(scopes), 4)\n\n            self.assertEqual(scopes[0].expression.sql(), \"t1, t2\")\n            self.assertEqual(set(scopes[0].sources), {\"t1\", \"t2\"})\n\n            self.assertEqual(scopes[1].expression.sql(), \"SELECT * FROM (t1, t2) AS t3\")\n            self.assertEqual(set(scopes[1].sources), {\"t3\"})\n\n            self.assertEqual(scopes[2].expression.sql(), \"SELECT * FROM t4\")\n            self.assertEqual(set(scopes[2].sources), {\"t4\"})\n\n            self.assertEqual(\n                scopes[3].expression.sql(),\n                \"SELECT * FROM (((SELECT * FROM (t1, t2) AS t3), (SELECT * FROM t4)))\",\n            )\n            self.assertEqual(set(scopes[3].sources), {\"\"})\n\n        inner_query = \"SELECT bar FROM baz\"\n        for udtf in (f\"UNNEST(({inner_query}))\", f\"LATERAL ({inner_query})\"):\n            sql = f\"SELECT a FROM foo CROSS JOIN {udtf}\"\n            expression = parse_one(sql)\n\n            for scopes in traverse_scope(expression), list(build_scope(expression).traverse()):\n                self.assertEqual(len(scopes), 3)\n\n                self.assertEqual(scopes[0].expression.sql(), inner_query)\n                self.assertEqual(set(scopes[0].sources), {\"baz\"})\n\n                self.assertEqual(scopes[1].expression.sql(), udtf)\n                self.assertEqual(set(scopes[1].sources), {\"\", \"foo\"})  # foo is a lateral source\n\n                self.assertEqual(scopes[2].expression.sql(), f\"SELECT a FROM foo CROSS JOIN {udtf}\")\n                self.assertEqual(set(scopes[2].sources), {\"\", \"foo\"})\n\n        # Check DML statement scopes\n        sql = (\n            \"UPDATE customers SET total_spent = (SELECT 1 FROM t1) WHERE EXISTS (SELECT 1 FROM t2)\"\n        )\n        self.assertEqual(len(traverse_scope(parse_one(sql))), 3)\n\n        sql = \"UPDATE tbl1 SET col = 1 WHERE EXISTS (SELECT 1 FROM tbl2 WHERE tbl1.id = tbl2.id)\"\n        self.assertEqual(len(traverse_scope(parse_one(sql))), 1)\n\n        sql = \"UPDATE tbl1 SET col = 0\"\n        self.assertEqual(len(traverse_scope(parse_one(sql))), 0)\n\n        sql = \"SELECT * FROM t LEFT JOIN UNNEST(a) AS a1 LEFT JOIN UNNEST(a1.a) AS a2\"\n        scope = build_scope(parse_one(sql, read=\"bigquery\"))\n        self.assertEqual(set(scope.selected_sources), {\"t\", \"a1\", \"a2\"})\n\n    @patch(\"sqlglot.optimizer.scope.logger\")\n    def test_scope_warning(self, logger):\n        self.assertEqual(len(traverse_scope(parse_one(\"WITH q AS (@y) SELECT * FROM q\"))), 1)\n        assert_logger_contains(\n            \"Cannot traverse scope %s with type '%s'\",\n            logger,\n            level=\"warning\",\n        )\n\n    def test_annotate_types(self):\n        for i, (meta, sql, expected) in enumerate(\n            load_sql_fixture_pairs(\"optimizer/annotate_types.sql\"), start=1\n        ):\n            title = meta.get(\"title\") or f\"{i}, {sql}\"\n            dialect = meta.get(\"dialect\")\n            result = parse_and_optimize(annotate_types, sql, dialect)\n\n            with self.subTest(title):\n                self.assertEqual(result.type.sql(), exp.DataType.build(expected).sql())\n\n    def test_annotate_funcs(self):\n        test_schema = {\n            \"tbl\": {\n                \"bin_col\": \"BINARY\",\n                \"str_col\": \"STRING\",\n                \"bignum_col\": \"BIGNUMERIC\",\n                \"date_col\": \"DATE\",\n                \"timestamp_col\": \"TIMESTAMP\",\n                \"double_col\": \"DOUBLE\",\n                \"bigint_col\": \"BIGINT\",\n                \"bool_col\": \"BOOLEAN\",\n                \"bytes_col\": \"BYTES\",\n                \"interval_col\": \"INTERVAL\",\n                \"array_col\": \"ARRAY<STRING>\",\n            }\n        }\n\n        for i, (meta, sql, expected) in enumerate(\n            load_sql_fixture_pairs(\"optimizer/annotate_functions.sql\"), start=1\n        ):\n            title = meta.get(\"title\") or f\"{i}, {sql}\"\n            dialect = meta.get(\"dialect\") or \"\"\n            sql = f\"SELECT {sql} FROM tbl\"\n\n            for dialect in dialect.split(\", \"):\n                result = parse_and_optimize(\n                    annotate_functions, sql, dialect, schema=test_schema, dialect=dialect\n                )\n\n                with self.subTest(title):\n                    self.assertEqual(\n                        result.type.sql(dialect),\n                        exp.DataType.build(expected, dialect=dialect).sql(dialect),\n                    )\n\n    def test_cast_type_annotation(self):\n        expression = annotate_types(parse_one(\"CAST('2020-01-01' AS TIMESTAMPTZ(9))\"))\n        self.assertEqual(expression.type.this, exp.DataType.Type.TIMESTAMPTZ)\n        self.assertEqual(expression.this.type.this, exp.DataType.Type.VARCHAR)\n        self.assertEqual(expression.args[\"to\"].type.this, exp.DataType.Type.TIMESTAMPTZ)\n        self.assertEqual(expression.args[\"to\"].expressions[0].this.type.this, exp.DataType.Type.INT)\n\n        expression = annotate_types(parse_one(\"ARRAY(1)::ARRAY<INT>\"))\n        self.assertEqual(expression.type, parse_one(\"ARRAY<INT>\", into=exp.DataType))\n\n        expression = annotate_types(parse_one(\"CAST(x AS INTERVAL)\"))\n        self.assertEqual(expression.type.this, exp.DataType.Type.INTERVAL)\n        self.assertEqual(expression.this.type.this, exp.DataType.Type.UNKNOWN)\n        self.assertEqual(expression.args[\"to\"].type.this, exp.DataType.Type.INTERVAL)\n\n    def test_cache_annotation(self):\n        expression = annotate_types(\n            parse_one(\"CACHE LAZY TABLE x OPTIONS('storageLevel' = 'value') AS SELECT 1\")\n        )\n        self.assertEqual(expression.expression.expressions[0].type.this, exp.DataType.Type.INT)\n\n    def test_binary_annotation(self):\n        expression = annotate_types(parse_one(\"SELECT 0.0 + (2 + 3)\")).expressions[0]\n\n        self.assertEqual(expression.type.this, exp.DataType.Type.DOUBLE)\n        self.assertEqual(expression.left.type.this, exp.DataType.Type.DOUBLE)\n        self.assertEqual(expression.right.type.this, exp.DataType.Type.INT)\n        self.assertEqual(expression.right.this.type.this, exp.DataType.Type.INT)\n        self.assertEqual(expression.right.this.left.type.this, exp.DataType.Type.INT)\n        self.assertEqual(expression.right.this.right.type.this, exp.DataType.Type.INT)\n\n        for numeric_type in (\"BIGINT\", \"DOUBLE\", \"INT\"):\n            query = f\"SELECT '1' + CAST(x AS {numeric_type})\"\n            expression = annotate_types(parse_one(query)).expressions[0]\n            self.assertEqual(expression.type, exp.DataType.build(numeric_type))\n\n    def test_typeddiv_annotation(self):\n        expressions = annotate_types(\n            parse_one(\"SELECT 2 / 3, 2 / 3.0\", dialect=\"presto\")\n        ).expressions\n\n        self.assertEqual(expressions[0].type.this, exp.DataType.Type.BIGINT)\n        self.assertEqual(expressions[1].type.this, exp.DataType.Type.DOUBLE)\n\n        expressions = annotate_types(\n            parse_one(\"SELECT SUM(2 / 3), CAST(2 AS DECIMAL) / 3\", dialect=\"mysql\")\n        ).expressions\n\n        self.assertEqual(expressions[0].type.this, exp.DataType.Type.DOUBLE)\n        self.assertEqual(expressions[0].this.type.this, exp.DataType.Type.DOUBLE)\n        self.assertEqual(expressions[1].type.this, exp.DataType.Type.DECIMAL)\n\n    def test_bracket_annotation(self):\n        expression = annotate_types(parse_one(\"SELECT A[:]\")).expressions[0]\n\n        self.assertEqual(expression.type.this, exp.DataType.Type.UNKNOWN)\n        self.assertEqual(expression.expressions[0].type.this, exp.DataType.Type.UNKNOWN)\n\n        expression = annotate_types(parse_one(\"SELECT ARRAY[1, 2, 3][1]\")).expressions[0]\n        self.assertEqual(expression.this.type.sql(), \"ARRAY<INT>\")\n        self.assertEqual(expression.type.this, exp.DataType.Type.INT)\n\n        expression = annotate_types(parse_one(\"SELECT ARRAY[1, 2, 3][1 : 2]\")).expressions[0]\n        self.assertEqual(expression.this.type.sql(), \"ARRAY<INT>\")\n        self.assertEqual(expression.type.sql(), \"ARRAY<INT>\")\n\n        expression = annotate_types(\n            parse_one(\"SELECT ARRAY[ARRAY[1], ARRAY[2], ARRAY[3]][1][2]\")\n        ).expressions[0]\n        self.assertEqual(expression.this.this.type.sql(), \"ARRAY<ARRAY<INT>>\")\n        self.assertEqual(expression.this.type.sql(), \"ARRAY<INT>\")\n        self.assertEqual(expression.type.this, exp.DataType.Type.INT)\n\n        expression = annotate_types(\n            parse_one(\"SELECT ARRAY[ARRAY[1], ARRAY[2], ARRAY[3]][1:2]\")\n        ).expressions[0]\n        self.assertEqual(expression.type.sql(), \"ARRAY<ARRAY<INT>>\")\n\n        expression = annotate_types(parse_one(\"MAP(1.0, 2, '2', 3.0)['2']\", read=\"spark\"))\n        self.assertEqual(expression.type.this, exp.DataType.Type.DOUBLE)\n\n        expression = annotate_types(parse_one(\"MAP(1.0, 2, x, 3.0)[2]\", read=\"spark\"))\n        self.assertEqual(expression.type.this, exp.DataType.Type.UNKNOWN)\n\n        expression = annotate_types(parse_one(\"MAP(ARRAY(1.0, x), ARRAY(2, 3.0))[x]\"))\n        self.assertEqual(expression.type.this, exp.DataType.Type.DOUBLE)\n\n        expression = annotate_types(\n            parse_one(\"SELECT MAP(1.0, 2, 2, t.y)[2] FROM t\", read=\"spark\"),\n            schema={\"t\": {\"y\": \"int\"}},\n        ).expressions[0]\n        self.assertEqual(expression.type.this, exp.DataType.Type.INT)\n\n    def test_interval_math_annotation(self):\n        schema = {\n            \"x\": {\n                \"a\": \"DATE\",\n                \"b\": \"DATETIME\",\n            }\n        }\n        for sql, expected_type in [\n            (\n                \"SELECT '2023-01-01' + INTERVAL '1' DAY\",\n                exp.DataType.Type.DATE,\n            ),\n            (\n                \"SELECT '2023-01-01' + INTERVAL '1' HOUR\",\n                exp.DataType.Type.DATETIME,\n            ),\n            (\n                \"SELECT '2023-01-01 00:00:01' + INTERVAL '1' HOUR\",\n                exp.DataType.Type.DATETIME,\n            ),\n            (\"SELECT 'nonsense' + INTERVAL '1' DAY\", exp.DataType.Type.UNKNOWN),\n            (\"SELECT x.a + INTERVAL '1' DAY FROM x AS x\", exp.DataType.Type.DATE),\n            (\n                \"SELECT x.a + INTERVAL '1' HOUR FROM x AS x\",\n                exp.DataType.Type.DATETIME,\n            ),\n            (\"SELECT x.b + INTERVAL '1' DAY FROM x AS x\", exp.DataType.Type.DATETIME),\n            (\"SELECT x.b + INTERVAL '1' HOUR FROM x AS x\", exp.DataType.Type.DATETIME),\n            (\n                \"SELECT DATE_ADD('2023-01-01', 1, 'DAY')\",\n                exp.DataType.Type.DATE,\n            ),\n            (\n                \"SELECT DATE_ADD('2023-01-01 00:00:00', 1, 'DAY')\",\n                exp.DataType.Type.DATETIME,\n            ),\n            (\"SELECT DATE_ADD(x.a, 1, 'DAY') FROM x AS x\", exp.DataType.Type.DATE),\n            (\n                \"SELECT DATE_ADD(x.a, 1, 'HOUR') FROM x AS x\",\n                exp.DataType.Type.DATETIME,\n            ),\n            (\"SELECT DATE_ADD(x.b, 1, 'DAY') FROM x AS x\", exp.DataType.Type.DATETIME),\n            (\"SELECT DATE_TRUNC('DAY', x.a) FROM x AS x\", exp.DataType.Type.DATE),\n            (\"SELECT DATE_TRUNC('DAY', x.b) FROM x AS x\", exp.DataType.Type.DATETIME),\n            (\n                \"SELECT DATE_TRUNC('SECOND', x.a) FROM x AS x\",\n                exp.DataType.Type.DATETIME,\n            ),\n            (\n                \"SELECT DATE_TRUNC('DAY', '2023-01-01') FROM x AS x\",\n                exp.DataType.Type.DATE,\n            ),\n            (\n                \"SELECT DATEDIFF('2023-01-01', '2023-01-02', DAY) FROM x AS x\",\n                exp.DataType.Type.INT,\n            ),\n        ]:\n            with self.subTest(sql):\n                expression = annotate_types(parse_one(sql), schema=schema)\n                self.assertEqual(expected_type, expression.expressions[0].type.this)\n                self.assertEqual(sql, expression.sql())\n\n    def test_lateral_annotation(self):\n        expression = optimizer.optimize(\n            parse_one(\"SELECT c FROM (select 1 a) as x LATERAL VIEW EXPLODE (a) AS c\")\n        ).expressions[0]\n        self.assertEqual(expression.type.this, exp.DataType.Type.INT)\n\n    def test_derived_tables_column_annotation(self):\n        schema = {\"x\": {\"cola\": \"INT\"}, \"y\": {\"cola\": \"FLOAT\"}}\n        sql = \"\"\"\n            SELECT a.cola AS cola\n            FROM (\n                SELECT x.cola + y.cola AS cola\n                FROM (\n                    SELECT x.cola AS cola\n                    FROM x AS x\n                ) AS x\n                JOIN (\n                    SELECT y.cola AS cola\n                    FROM y AS y\n                ) AS y\n            ) AS a\n        \"\"\"\n\n        expression = annotate_types(parse_one(sql), schema=schema)\n        self.assertEqual(\n            expression.expressions[0].type.this, exp.DataType.Type.FLOAT\n        )  # a.cola AS cola\n\n        addition_alias = expression.args[\"from\"].this.this.expressions[0]\n        self.assertEqual(\n            addition_alias.type.this, exp.DataType.Type.FLOAT\n        )  # x.cola + y.cola AS cola\n\n        addition = addition_alias.this\n        self.assertEqual(addition.type.this, exp.DataType.Type.FLOAT)\n        self.assertEqual(addition.this.type.this, exp.DataType.Type.INT)\n        self.assertEqual(addition.expression.type.this, exp.DataType.Type.FLOAT)\n\n    def test_cte_column_annotation(self):\n        schema = {\"x\": {\"cola\": \"CHAR\"}, \"y\": {\"colb\": \"TEXT\", \"colc\": \"BOOLEAN\"}}\n        sql = \"\"\"\n            WITH tbl AS (\n                SELECT x.cola + 'bla' AS cola, y.colb AS colb, y.colc AS colc\n                FROM (\n                    SELECT x.cola AS cola\n                    FROM x AS x\n                ) AS x\n                JOIN (\n                    SELECT y.colb AS colb, y.colc AS colc\n                    FROM y AS y\n                ) AS y\n            )\n            SELECT tbl.cola + tbl.colb + 'foo' AS col\n            FROM tbl AS tbl\n            WHERE tbl.colc = True\n        \"\"\"\n\n        expression = annotate_types(parse_one(sql), schema=schema)\n        self.assertEqual(\n            expression.expressions[0].type.this, exp.DataType.Type.TEXT\n        )  # tbl.cola + tbl.colb + 'foo' AS col\n\n        outer_addition = expression.expressions[0].this  # (tbl.cola + tbl.colb) + 'foo'\n        self.assertEqual(outer_addition.type.this, exp.DataType.Type.TEXT)\n        self.assertEqual(outer_addition.left.type.this, exp.DataType.Type.TEXT)\n        self.assertEqual(outer_addition.right.type.this, exp.DataType.Type.VARCHAR)\n\n        inner_addition = expression.expressions[0].this.left  # tbl.cola + tbl.colb\n        self.assertEqual(inner_addition.left.type.this, exp.DataType.Type.VARCHAR)\n        self.assertEqual(inner_addition.right.type.this, exp.DataType.Type.TEXT)\n\n        # WHERE tbl.colc = True\n        self.assertEqual(expression.args[\"where\"].this.type.this, exp.DataType.Type.BOOLEAN)\n\n        cte_select = expression.args[\"with\"].expressions[0].this\n        self.assertEqual(\n            cte_select.expressions[0].type.this, exp.DataType.Type.VARCHAR\n        )  # x.cola + 'bla' AS cola\n        self.assertEqual(\n            cte_select.expressions[1].type.this, exp.DataType.Type.TEXT\n        )  # y.colb AS colb\n        self.assertEqual(\n            cte_select.expressions[2].type.this, exp.DataType.Type.BOOLEAN\n        )  # y.colc AS colc\n\n        cte_select_addition = cte_select.expressions[0].this  # x.cola + 'bla'\n        self.assertEqual(cte_select_addition.type.this, exp.DataType.Type.VARCHAR)\n        self.assertEqual(cte_select_addition.left.type.this, exp.DataType.Type.CHAR)\n        self.assertEqual(cte_select_addition.right.type.this, exp.DataType.Type.VARCHAR)\n\n        # Check that x.cola AS cola and y.colb AS colb have types CHAR and TEXT, respectively\n        for d, t in zip(\n            cte_select.find_all(exp.Subquery),\n            [exp.DataType.Type.CHAR, exp.DataType.Type.TEXT],\n        ):\n            self.assertEqual(d.this.expressions[0].this.type.this, t)\n\n    def test_function_annotation(self):\n        schema = {\"x\": {\"cola\": \"VARCHAR\", \"colb\": \"CHAR\"}}\n        sql = (\n            \"SELECT x.cola || TRIM(x.colb) AS col, DATE(x.colb), DATEFROMPARTS(y, m, d) FROM x AS x\"\n        )\n\n        expression = annotate_types(parse_one(sql), schema=schema)\n        concat_expr_alias = expression.expressions[0]\n        self.assertEqual(concat_expr_alias.type.this, exp.DataType.Type.VARCHAR)\n\n        concat_expr = concat_expr_alias.this\n        self.assertEqual(concat_expr.type.this, exp.DataType.Type.VARCHAR)\n        self.assertEqual(concat_expr.left.type.this, exp.DataType.Type.VARCHAR)  # x.cola\n        self.assertEqual(concat_expr.right.type.this, exp.DataType.Type.VARCHAR)  # TRIM(x.colb)\n        self.assertEqual(concat_expr.right.this.type.this, exp.DataType.Type.CHAR)  # x.colb\n\n        date_expr = expression.expressions[1]\n        self.assertEqual(date_expr.type.this, exp.DataType.Type.DATE)\n\n        date_expr = expression.expressions[2]\n        self.assertEqual(date_expr.type.this, exp.DataType.Type.DATE)\n\n        sql = \"SELECT CASE WHEN 1=1 THEN x.cola ELSE x.colb END AS col FROM x AS x\"\n\n        case_expr_alias = annotate_types(parse_one(sql), schema=schema).expressions[0]\n        self.assertEqual(case_expr_alias.type.this, exp.DataType.Type.VARCHAR)\n\n        case_expr = case_expr_alias.this\n        self.assertEqual(case_expr.type.this, exp.DataType.Type.VARCHAR)\n        self.assertEqual(case_expr.args[\"default\"].type.this, exp.DataType.Type.CHAR)\n\n        case_ifs_expr = case_expr.args[\"ifs\"][0]\n        self.assertEqual(case_ifs_expr.type.this, exp.DataType.Type.VARCHAR)\n        self.assertEqual(case_ifs_expr.args[\"true\"].type.this, exp.DataType.Type.VARCHAR)\n\n        timestamp = annotate_types(parse_one(\"TIMESTAMP(x)\"))\n        self.assertEqual(timestamp.type.this, exp.DataType.Type.TIMESTAMP)\n\n        timestamptz = annotate_types(parse_one(\"TIMESTAMP(x)\", read=\"bigquery\"))\n        self.assertEqual(timestamptz.type.this, exp.DataType.Type.TIMESTAMPTZ)\n\n    def test_unknown_annotation(self):\n        schema = {\"x\": {\"cola\": \"VARCHAR\"}}\n        sql = \"SELECT x.cola + SOME_ANONYMOUS_FUNC(x.cola) AS col FROM x AS x\"\n\n        concat_expr_alias = annotate_types(parse_one(sql), schema=schema).expressions[0]\n        self.assertEqual(concat_expr_alias.type.this, exp.DataType.Type.UNKNOWN)\n\n        concat_expr = concat_expr_alias.this\n        self.assertEqual(concat_expr.type.this, exp.DataType.Type.UNKNOWN)\n        self.assertEqual(concat_expr.left.type.this, exp.DataType.Type.VARCHAR)  # x.cola\n        self.assertEqual(\n            concat_expr.right.type.this, exp.DataType.Type.UNKNOWN\n        )  # SOME_ANONYMOUS_FUNC(x.cola)\n        self.assertEqual(\n            concat_expr.right.expressions[0].type.this, exp.DataType.Type.VARCHAR\n        )  # x.cola (arg)\n\n        # Ensures we don't raise if there are unqualified columns\n        annotate_types(parse_one(\"select x from y lateral view explode(y) as x\")).expressions[0]\n\n        # NULL <op> UNKNOWN should yield UNKNOWN\n        self.assertEqual(\n            annotate_types(parse_one(\"SELECT NULL + ANONYMOUS_FUNC()\")).expressions[0].type.this,\n            exp.DataType.Type.UNKNOWN,\n        )\n\n    def test_predicate_annotation(self):\n        expression = annotate_types(parse_one(\"x BETWEEN a AND b\"))\n        self.assertEqual(expression.type.this, exp.DataType.Type.BOOLEAN)\n\n        expression = annotate_types(parse_one(\"x IN (a, b, c, d)\"))\n        self.assertEqual(expression.type.this, exp.DataType.Type.BOOLEAN)\n\n    def test_aggfunc_annotation(self):\n        schema = {\"x\": {\"cola\": \"SMALLINT\", \"colb\": \"FLOAT\", \"colc\": \"TEXT\", \"cold\": \"DATE\"}}\n\n        tests = {\n            (\"AVG\", \"cola\"): exp.DataType.Type.DOUBLE,\n            (\"SUM\", \"cola\"): exp.DataType.Type.BIGINT,\n            (\"SUM\", \"colb\"): exp.DataType.Type.DOUBLE,\n            (\"MIN\", \"cola\"): exp.DataType.Type.SMALLINT,\n            (\"MIN\", \"colb\"): exp.DataType.Type.FLOAT,\n            (\"MAX\", \"colc\"): exp.DataType.Type.TEXT,\n            (\"MAX\", \"cold\"): exp.DataType.Type.DATE,\n            (\"COUNT\", \"colb\"): exp.DataType.Type.BIGINT,\n            (\"STDDEV\", \"cola\"): exp.DataType.Type.DOUBLE,\n            (\"ABS\", \"cola\"): exp.DataType.Type.SMALLINT,\n            (\"ABS\", \"colb\"): exp.DataType.Type.FLOAT,\n        }\n\n        for (func, col), target_type in tests.items():\n            expression = annotate_types(\n                parse_one(f\"SELECT {func}(x.{col}) AS _col_0 FROM x AS x\"),\n                schema=schema,\n            )\n            self.assertEqual(expression.expressions[0].type.this, target_type)\n\n    def test_concat_annotation(self):\n        expression = annotate_types(parse_one(\"CONCAT('A', 'B')\"))\n        self.assertEqual(expression.type.this, exp.DataType.Type.VARCHAR)\n\n    def test_root_subquery_annotation(self):\n        expression = annotate_types(parse_one(\"(SELECT 1, 2 FROM x) LIMIT 0\"))\n        self.assertIsInstance(expression, exp.Subquery)\n        self.assertEqual(exp.DataType.Type.INT, expression.selects[0].type.this)\n        self.assertEqual(exp.DataType.Type.INT, expression.selects[1].type.this)\n\n    def test_nested_type_annotation(self):\n        schema = {\n            \"order\": {\n                \"customer_id\": \"bigint\",\n                \"item_id\": \"bigint\",\n                \"item_price\": \"numeric\",\n            }\n        }\n        sql = \"\"\"\n            SELECT ARRAY_AGG(DISTINCT order.item_id) FILTER (WHERE order.item_price > 10) AS items,\n            FROM order AS order\n            GROUP BY order.customer_id\n        \"\"\"\n        expression = annotate_types(parse_one(sql), schema=schema)\n\n        self.assertEqual(exp.DataType.Type.ARRAY, expression.selects[0].type.this)\n        self.assertEqual(expression.selects[0].type.sql(), \"ARRAY<BIGINT>\")\n\n        expression = annotate_types(\n            parse_one(\"SELECT ARRAY_CAT(ARRAY[1,2,3], ARRAY[4,5])\", read=\"postgres\")\n        )\n        self.assertEqual(exp.DataType.Type.ARRAY, expression.selects[0].type.this)\n        self.assertEqual(expression.selects[0].type.sql(), \"ARRAY<INT>\")\n\n        schema = MappingSchema({\"t\": {\"c\": \"STRUCT<`f` STRING>\"}}, dialect=\"bigquery\")\n        expression = annotate_types(parse_one(\"SELECT t.c, [t.c] FROM t\"), schema=schema)\n\n        self.assertEqual(expression.selects[0].type.sql(dialect=\"bigquery\"), \"STRUCT<`f` STRING>\")\n        self.assertEqual(\n            expression.selects[1].type.sql(dialect=\"bigquery\"),\n            \"ARRAY<STRUCT<`f` STRING>>\",\n        )\n\n        expression = annotate_types(\n            parse_one(\"SELECT unnest(t.x) FROM t AS t\", dialect=\"postgres\"),\n            schema={\"t\": {\"x\": \"array<int>\"}},\n        )\n        self.assertTrue(expression.selects[0].is_type(\"int\"))\n\n    def test_type_annotation_cache(self):\n        sql = \"SELECT 1 + 1\"\n        expression = annotate_types(parse_one(sql))\n\n        self.assertEqual(exp.DataType.Type.INT, expression.selects[0].type.this)\n\n        expression.selects[0].this.replace(parse_one(\"1.2\"))\n        expression = annotate_types(expression)\n\n        self.assertEqual(exp.DataType.Type.DOUBLE, expression.selects[0].type.this)\n\n    def test_user_defined_type_annotation(self):\n        schema = MappingSchema({\"t\": {\"x\": \"int\"}}, dialect=\"postgres\")\n        expression = annotate_types(parse_one(\"SELECT CAST(x AS IPADDRESS) FROM t\"), schema=schema)\n\n        self.assertEqual(exp.DataType.Type.USERDEFINED, expression.selects[0].type.this)\n        self.assertEqual(expression.selects[0].type.sql(dialect=\"postgres\"), \"IPADDRESS\")\n\n    def test_unnest_annotation(self):\n        expression = annotate_types(\n            optimizer.qualify.qualify(\n                parse_one(\n                    \"\"\"\n                SELECT a, a.b, a.b.c FROM x, UNNEST(x.a) AS a\n                \"\"\",\n                    read=\"bigquery\",\n                )\n            ),\n            schema={\"x\": {\"a\": \"ARRAY<STRUCT<b STRUCT<c int>>>\"}},\n        )\n        self.assertEqual(expression.selects[0].type, exp.DataType.build(\"STRUCT<b STRUCT<c int>>\"))\n        self.assertEqual(expression.selects[1].type, exp.DataType.build(\"STRUCT<c int>\"))\n        self.assertEqual(expression.selects[2].type, exp.DataType.build(\"int\"))\n\n        self.assertEqual(\n            annotate_types(\n                optimizer.qualify.qualify(\n                    parse_one(\n                        \"SELECT x FROM UNNEST(GENERATE_DATE_ARRAY('2021-01-01', current_date(), interval 1 day)) AS x\"\n                    )\n                )\n            )\n            .selects[0]\n            .type,\n            exp.DataType.build(\"date\"),\n        )\n\n        self.assertEqual(\n            annotate_types(\n                optimizer.qualify.qualify(\n                    parse_one(\n                        \"SELECT x FROM UNNEST(GENERATE_TIMESTAMP_ARRAY('2016-10-05 00:00:00', '2016-10-06 02:00:00', interval 1 day)) AS x\"\n                    )\n                )\n            )\n            .selects[0]\n            .type,\n            exp.DataType.build(\"timestamp\"),\n        )\n\n    def test_map_annotation(self):\n        # ToMap annotation\n        expression = annotate_types(parse_one(\"SELECT MAP {'x': 1}\", read=\"duckdb\"))\n        self.assertEqual(expression.selects[0].type, exp.DataType.build(\"MAP(VARCHAR, INT)\"))\n\n        # Map annotation\n        expression = annotate_types(\n            parse_one(\"SELECT MAP(['key1', 'key2', 'key3'], [10, 20, 30])\", read=\"duckdb\")\n        )\n        self.assertEqual(expression.selects[0].type, exp.DataType.build(\"MAP(VARCHAR, INT)\"))\n\n        # VarMap annotation\n        expression = annotate_types(parse_one(\"SELECT MAP('a', 'b')\", read=\"spark\"))\n        self.assertEqual(expression.selects[0].type, exp.DataType.build(\"MAP(VARCHAR, VARCHAR)\"))\n\n    def test_union_annotation(self):\n        for left, right, expected_type in (\n            (\"SELECT 1::INT AS c\", \"SELECT 2::BIGINT AS c\", \"BIGINT\"),\n            (\"SELECT 1 AS c\", \"SELECT NULL AS c\", \"INT\"),\n            (\"SELECT FOO() AS c\", \"SELECT 1 AS c\", \"UNKNOWN\"),\n            (\"SELECT FOO() AS c\", \"SELECT BAR() AS c\", \"UNKNOWN\"),\n        ):\n            with self.subTest(f\"left: {left}, right: {right}, expected: {expected_type}\"):\n                lr = annotate_types(parse_one(f\"SELECT t.c FROM ({left} UNION ALL {right}) t(c)\"))\n                rl = annotate_types(parse_one(f\"SELECT t.c FROM ({right} UNION ALL {left}) t(c)\"))\n                assert lr.selects[0].type == rl.selects[0].type == exp.DataType.build(expected_type)\n\n        union_by_name = annotate_types(\n            parse_one(\n                \"SELECT t.a, t.d FROM (SELECT 1 a, 3 d, UNION ALL BY NAME SELECT 7.0 d, 8::BIGINT a) AS t(a, d)\"\n            )\n        )\n        self.assertEqual(union_by_name.selects[0].type.this, exp.DataType.Type.BIGINT)\n        self.assertEqual(union_by_name.selects[1].type.this, exp.DataType.Type.DOUBLE)\n\n        # Test chained UNIONs\n        sql = \"\"\"\n            WITH t AS\n            (\n                SELECT NULL AS col\n                UNION\n                SELECT NULL AS col\n                UNION\n                SELECT 'a' AS col\n                UNION\n                SELECT NULL AS col\n                UNION\n                SELECT NULL AS col\n            )\n            SELECT col FROM t;\n        \"\"\"\n        self.assertEqual(optimizer.optimize(sql).selects[0].type.this, exp.DataType.Type.VARCHAR)\n\n        # Test UNIONs with nested subqueries\n        sql = \"\"\"\n            WITH t AS\n            (\n                SELECT NULL AS col\n                UNION\n                (SELECT NULL AS col UNION ALL SELECT 'a' AS col)\n            )\n            SELECT col FROM t;\n        \"\"\"\n        self.assertEqual(optimizer.optimize(sql).selects[0].type.this, exp.DataType.Type.VARCHAR)\n\n        sql = \"\"\"\n            WITH t AS\n            (\n                (SELECT NULL AS col UNION ALL SELECT 'a' AS col)\n                UNION\n                SELECT NULL AS col\n            )\n            SELECT col FROM t;\n        \"\"\"\n        self.assertEqual(optimizer.optimize(sql).selects[0].type.this, exp.DataType.Type.VARCHAR)\n\n    def test_udtf_annotation(self):\n        table_udtf = parse_one(\n            \"SELECT * FROM TABLE(GENERATOR(ROWCOUNT => 100000))\",\n            read=\"snowflake\",\n        )\n        self.assertEqual(\n            annotate_types(table_udtf, dialect=\"snowflake\").sql(\"snowflake\"),\n            \"SELECT * FROM TABLE(GENERATOR(ROWCOUNT => 100000))\",\n        )\n\n    def test_recursive_cte(self):\n        query = parse_one(\n            \"\"\"\n            with recursive t(n) AS\n            (\n              select 1\n              union all\n              select n + 1\n              FROM t\n              where n < 3\n            ), y AS (\n              select n\n              FROM t\n              union all\n              select n + 1\n              FROM y\n              where n < 2\n            )\n            select * from y\n            \"\"\"\n        )\n\n        scope_t, scope_y = build_scope(query).cte_scopes\n        self.assertEqual(set(scope_t.cte_sources), {\"t\"})\n        self.assertEqual(set(scope_y.cte_sources), {\"t\", \"y\"})\n\n    def test_schema_with_spaces(self):\n        schema = {\n            \"a\": {\n                \"b c\": \"text\",\n                '\"d e\"': \"text\",\n            }\n        }\n\n        self.assertEqual(\n            optimizer.optimize(parse_one(\"SELECT * FROM a\"), schema=schema),\n            parse_one('SELECT \"a\".\"b c\" AS \"b c\", \"a\".\"d e\" AS \"d e\" FROM \"a\" AS \"a\"'),\n        )\n\n    def test_quotes(self):\n        schema = {\n            \"example\": {\n                '\"source\"': {\n                    \"id\": \"text\",\n                    '\"name\"': \"text\",\n                    '\"payload\"': \"text\",\n                }\n            }\n        }\n\n        expected = parse_one(\n            \"\"\"\n            SELECT\n             \"source\".\"ID\" AS \"ID\",\n             \"source\".\"name\" AS \"name\",\n             \"source\".\"payload\" AS \"payload\"\n            FROM \"EXAMPLE\".\"source\" AS \"source\"\n            \"\"\",\n            read=\"snowflake\",\n        ).sql(pretty=True, dialect=\"snowflake\")\n\n        for func in (optimizer.qualify.qualify, optimizer.optimize):\n            source_query = parse_one('SELECT * FROM example.\"source\" AS \"source\"', read=\"snowflake\")\n            transformed = func(source_query, dialect=\"snowflake\", schema=schema)\n            self.assertEqual(transformed.sql(pretty=True, dialect=\"snowflake\"), expected)\n\n    def test_no_pseudocolumn_expansion(self):\n        schema = {\n            \"a\": {\n                \"a\": \"text\",\n                \"b\": \"text\",\n                \"_PARTITIONDATE\": \"date\",\n                \"_PARTITIONTIME\": \"timestamp\",\n            }\n        }\n\n        self.assertEqual(\n            optimizer.optimize(\n                parse_one(\"SELECT * FROM a\"),\n                schema=MappingSchema(schema, dialect=\"bigquery\"),\n            ),\n            parse_one('SELECT \"a\".\"a\" AS \"a\", \"a\".\"b\" AS \"b\" FROM \"a\" AS \"a\"'),\n        )\n\n    def test_semistructured(self):\n        query = parse_one(\"select a.b:c from d\", read=\"snowflake\")\n        qualified = optimizer.qualify.qualify(query)\n        self.assertEqual(qualified.expressions[0].alias, \"c\")\n\n    def test_gen(self):\n        for func in exp.ALL_FUNCTIONS:\n            self.assertIsInstance(optimizer.simplify.gen(func()), str)\n\n    def test_normalization_distance(self):\n        def gen_expr(depth: int) -> exp.Expression:\n            return parse_one(\" OR \".join(\"a AND b\" for _ in range(depth)))\n\n        self.assertEqual(4, normalization_distance(gen_expr(2), max_=100))\n        self.assertEqual(18, normalization_distance(gen_expr(3), max_=100))\n        self.assertEqual(110, normalization_distance(gen_expr(10), max_=100))\n\n    def test_manually_annotate_snowflake(self):\n        dialect = \"snowflake\"\n        schema = {\n            \"SCHEMA\": {\n                \"TBL\": {\"COL\": \"INT\", \"col2\": \"VARCHAR\"},\n            }\n        }\n        example_query = 'SELECT * FROM \"SCHEMA\".\"TBL\"'\n\n        expression = parse_one(example_query, dialect=dialect)\n        qual = optimizer.qualify.qualify(expression, schema=schema, dialect=dialect)\n        annotated = optimizer.annotate_types.annotate_types(qual, schema=schema, dialect=dialect)\n\n        self.assertTrue(annotated.selects[0].is_type(\"INT\"))\n        self.assertTrue(annotated.selects[1].is_type(\"VARCHAR\"))\n\n    def test_annotate_table_as_struct_bigquery(self):\n        dialect = \"bigquery\"\n        schema = {\"d\": {\"s\": {\"t\": {\"c1\": \"int64\", \"c2\": \"struct<f1 int64, f2 string>\"}}}}\n\n        def _annotate(query: str) -> exp.Expression:\n            expression = parse_one(query, dialect=dialect)\n            qual = optimizer.qualify.qualify(expression, schema=schema, dialect=dialect)\n            return optimizer.annotate_types.annotate_types(qual, schema=schema, dialect=dialect)\n\n        example_query = \"SELECT t FROM d.s.t\"\n        annotated = _annotate(example_query)\n\n        self.assertIsInstance(annotated.selects[0].this, exp.TableColumn)\n        self.assertEqual(\n            annotated.sql(\"bigquery\"), \"SELECT `t` AS `_col_0` FROM `d`.`s`.`t` AS `t`\"\n        )\n        self.assertTrue(\n            annotated.selects[0].is_type(\"STRUCT<c1 BIGINT, c2 STRUCT<f1 BIGINT, f2 TEXT>>\")\n        )\n\n        example_query = \"SELECT subq FROM (SELECT * from d.s.t) subq\"\n        annotated = _annotate(example_query)\n\n        self.assertTrue(\n            annotated.selects[0].is_type(\"STRUCT<c1 BIGINT, c2 STRUCT<f1 BIGINT, f2 TEXT>>\")\n        )\n\n        example_query = \"WITH t AS (SELECT 1 AS c) SELECT t FROM t\"\n        annotated = _annotate(example_query)\n\n        self.assertTrue(annotated.selects[0].is_type(\"STRUCT<c INT>\"))\n\n        example_query = \"WITH t AS (SELECT FOO() AS c) SELECT t FROM t\"\n        annotated = _annotate(example_query)\n\n        self.assertTrue(annotated.selects[0].is_type(\"UNKNOWN\"))\n\n        for query in (\"SELECT 'foo'\", \"(SELECT 'foo')\"):\n            query = f\"SELECT ARRAY({query})\"\n            with self.subTest(f\"Annotating '{query}' in BigQuery\"):\n                self.assertTrue(_annotate(query).selects[0].is_type(\"ARRAY<VARCHAR>\"))\n\n        def test_semi_anti_join(self):\n            # - Do not remove semi/anti join\n            # - Do not remove CTEs/subqueries that participate in anti/semi joins, even though they do not count as selected sources\n            for join_kind in (\"LEFT ANTI\", \"ANTI\", \"SEMI\"):\n                query = f\"\"\"\n                WITH x AS (SELECT 1 AS b UNION ALL SELECT 2 AS b) SELECT x.b FROM x {join_kind} JOIN (SELECT 1 AS b) AS sub ON x.b = sub.b\n                \"\"\"\n                self.assertEqual(\n                    optimizer.optimize(query).sql(),\n                    f\"\"\"\n                    WITH \"x\" AS (SELECT 1 AS \"b\" UNION ALL SELECT 2 AS \"b\"), \"sub\" AS (SELECT 1 AS \"b\") SELECT \"x\".\"b\" AS \"b\" FROM \"x\" AS \"x\" {join_kind} JOIN \"sub\" AS \"sub\" ON \"sub\".\"b\" = \"x\".\"b\"\n                    \"\"\",\n                )"
                    }
                ]
            }
        ]
    },
    {
        "sha_fail": "ff15e0ed7276b5aa8e4581769e8e8e7deca1420d",
        "fault_localization_data": []
    },
    {
        "sha_fail": "c7fbe73582650fe0c431fad4d0e290caa3efb3bb",
        "fault_localization_data": []
    }
]
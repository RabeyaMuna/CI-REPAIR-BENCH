{
    "sha_fail": "edaf59b69f96acdf155c4514061ea648ea6df122",
    "changed_files": [
        {
            "commit": "edaf59b69f96acdf155c4514061ea648ea6df122",
            "file_path": "sky/backends/backend_utils.py",
            "diff": "diff --git a/sky/backends/backend_utils.py b/sky/backends/backend_utils.py\nindex 7b758084..e4222af4 100644\n--- a/sky/backends/backend_utils.py\n+++ b/sky/backends/backend_utils.py\n@@ -115,7 +115,6 @@ CLUSTER_FILE_MOUNTS_LOCK_PATH = os.path.expanduser(\n \n CLUSTER_FILE_MOUNTS_LOCK_TIMEOUT_SECONDS = 10\n \n-\n # Remote dir that holds our runtime files.\n _REMOTE_RUNTIME_FILES_DIR = '~/.sky/.runtime_files'\n \n"
        },
        {
            "commit": "edaf59b69f96acdf155c4514061ea648ea6df122",
            "file_path": "sky/backends/cloud_vm_ray_backend.py",
            "diff": "diff --git a/sky/backends/cloud_vm_ray_backend.py b/sky/backends/cloud_vm_ray_backend.py\nindex 88af1ee2..8a93b58c 100644\n--- a/sky/backends/cloud_vm_ray_backend.py\n+++ b/sky/backends/cloud_vm_ray_backend.py\n@@ -4557,7 +4557,6 @@ class CloudVmRayBackend(backends.Backend['CloudVmRayResourceHandle']):\n         end = time.time()\n         logger.debug(f'File mount sync took {end - start} seconds.')\n \n-\n     def _execute_storage_mounts(self, handle: CloudVmRayResourceHandle,\n                                 storage_mounts: Dict[Path, storage_lib.Storage],\n                                 mount_mode: storage_utils.StorageMode):\n@@ -4657,10 +4656,11 @@ class CloudVmRayBackend(backends.Backend['CloudVmRayResourceHandle']):\n                     raise RuntimeError(error_msg) from None\n                 else:\n                     if env_options.Options.SHOW_DEBUG_INFO.get():\n-                        raise exceptions.CommandError(e.returncode,\n-                                                      command=f'to {mode_str}',\n-                                                      error_msg=e.error_msg,\n-                                                      detailed_reason=e.detailed_reason)\n+                        raise exceptions.CommandError(\n+                            e.returncode,\n+                            command=f'to {mode_str}',\n+                            error_msg=e.error_msg,\n+                            detailed_reason=e.detailed_reason)\n                     else:\n                         # Strip the command (a big heredoc) from the exception\n                         raise exceptions.CommandError(\n@@ -4672,48 +4672,6 @@ class CloudVmRayBackend(backends.Backend['CloudVmRayResourceHandle']):\n         end = time.time()\n         logger.debug(f'Setting storage {mode_str} took {end - start} seconds.')\n \n-    def _set_storage_mounts_metadata(\n-            self, cluster_name: str,\n-            storage_mounts: Dict[Path, storage_lib.Storage]) -> None:\n-        \"\"\"Sets 'storage_mounts' object in cluster's storage_mounts_metadata\n-\n-        After converting Storage objects in 'storage_mounts' to metadata,\n-        it stores {PATH: StorageMetadata} into the table.\n-        \"\"\"\n-        if not storage_mounts:\n-            return\n-        storage_mounts_metadata = {}\n-        for dst, storage_obj in storage_mounts.items():\n-            storage_mounts_metadata[dst] = storage_obj.handle\n-        lock_path = (\n-            backend_utils.CLUSTER_FILE_MOUNTS_LOCK_PATH.format(cluster_name))\n-        with filelock.FileLock(lock_path):\n-            global_user_state.set_cluster_storage_mounts_metadata(\n-                cluster_name, storage_mounts_metadata)\n-\n-    def _get_storage_mounts_metadata(\n-            self,\n-            cluster_name: str) -> Optional[Dict[Path, storage_lib.Storage]]:\n-        \"\"\"Gets 'storage_mounts' object from cluster's storage_mounts_metadata\n-\n-        After retrieving storage_mounts_metadata, it converts back the\n-        StorageMetadata to Storage object and restores 'storage_mounts'\n-        \"\"\"\n-        lock_path = \\\n-            backend_utils.CLUSTER_FILE_MOUNTS_LOCK_PATH.format(cluster_name)\n-        with filelock.FileLock(lock_path):\n-            storage_mounts_metadata = \\\n-                global_user_state.get_cluster_storage_mounts_metadata(\n-                cluster_name)\n-        if storage_mounts_metadata is None:\n-            return None\n-        storage_mounts = {}\n-        for dst, storage_metadata in storage_mounts_metadata.items():\n-            storage_mounts[dst] = \\\n-                storage_lib.Storage.from_metadata(storage_metadata,\n-                                                  sync_on_reconstruction=False)\n-        return storage_mounts\n-\n     def _has_csync(self, cluster_name: str) -> bool:\n         \"\"\"Chekcs if there are CSYNC mode storages within the cluster.\"\"\"\n         storage_mounts = self._get_storage_mounts_metadata(cluster_name)\n"
        },
        {
            "commit": "edaf59b69f96acdf155c4514061ea648ea6df122",
            "file_path": "sky/clouds/kubernetes.py",
            "diff": "diff --git a/sky/clouds/kubernetes.py b/sky/clouds/kubernetes.py\nindex 8dd1c368..fede03c9 100644\n--- a/sky/clouds/kubernetes.py\n+++ b/sky/clouds/kubernetes.py\n@@ -216,7 +216,7 @@ class Kubernetes(clouds.Cloud):\n         # TODO(romilb): Create a lightweight image for SSH jump host\n         ssh_jump_image = service_catalog.get_image_id_from_tag(\n             self.IMAGE_CPU, clouds='kubernetes')\n-        \n+\n         k8s_acc_label_key = None\n         k8s_acc_label_value = None\n \n"
        },
        {
            "commit": "edaf59b69f96acdf155c4514061ea648ea6df122",
            "file_path": "sky/data/storage.py",
            "diff": "diff --git a/sky/data/storage.py b/sky/data/storage.py\nindex 50e93367..dea9b906 100644\n--- a/sky/data/storage.py\n+++ b/sky/data/storage.py\n@@ -762,7 +762,6 @@ class Storage(object):\n             f'Validation failed for storage source {self.source}, name '\n             f'{self.name} and mode {self.mode}. Please check the arguments.')\n \n-\n     def _add_store_from_metadata(\n             self, sky_stores: Dict[StoreType,\n                                    AbstractStore.StoreMetadata]) -> None:\n@@ -811,7 +810,6 @@ class Storage(object):\n     @classmethod\n     def from_metadata(cls, metadata: StorageMetadata,\n                       **override_args) -> 'Storage':\n-\n         \"\"\"Create Storage from StorageMetadata object.\n \n         Used when reconstructing Storage object and AbstractStore objects from\n@@ -821,16 +819,14 @@ class Storage(object):\n         source = override_args.get('source', metadata.source)\n         name = override_args.get('name', metadata.storage_name)\n         # If the source is a list, it consists of local paths\n-        if not isinstance(source,\n-                          list) and data_utils.is_cloud_store_url(source):\n-            name = None\n-        interval_seconds=override_args.get('interval_seconds',\n-                                           metadata.interval_seconds)\n+        if not isinstance(source, list): \n+            if data_utils.is_cloud_store_url(source):\n+                name = None\n+\n         storage_obj = cls(name=name,\n                           source=source,\n                           sync_on_reconstruction=override_args.get(\n-                              'sync_on_reconstruction', True),\n-                          interval_seconds=interval_seconds)\n+                              'sync_on_reconstruction', True))\n \n         # For backward compatibility\n         # TODO(Doyoung): Implement __setstate__ to resolve backwards\n@@ -844,7 +840,6 @@ class Storage(object):\n \n         return storage_obj\n \n-\n     def add_store(self, store_type: Union[str, StoreType]) -> AbstractStore:\n         \"\"\"Initializes and adds a new store to the storage.\n \n"
        }
    ]
}
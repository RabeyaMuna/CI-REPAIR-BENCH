{
    "sha_fail": "bbe7b82b778adbafd56d40bd00bc3aabcd5cb9c9",
    "changed_files": [
        {
            "commit": "bbe7b82b778adbafd56d40bd00bc3aabcd5cb9c9",
            "file_path": "taipy/event/__init__.py",
            "diff": "diff --git a/taipy/event/__init__.py b/taipy/event/__init__.py\nindex a5b36cec..209c6a4c 100644\n--- a/taipy/event/__init__.py\n+++ b/taipy/event/__init__.py\n@@ -10,4 +10,4 @@\n # specific language governing permissions and limitations under the License.\n \n from ..core.notification.event import Event, EventEntityType, EventOperation\n-from .event_consumer import EventConsumer\n+from .event_consumer import GuiEventConsumer\n"
        },
        {
            "commit": "bbe7b82b778adbafd56d40bd00bc3aabcd5cb9c9",
            "file_path": "taipy/event/_event_processor.py",
            "diff": "diff --git a/taipy/event/_event_processor.py b/taipy/event/_event_processor.py\nindex b173f407..9b8225a4 100644\n--- a/taipy/event/_event_processor.py\n+++ b/taipy/event/_event_processor.py\n@@ -8,6 +8,8 @@\n # Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n # an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n # specific language governing permissions and limitations under the License.\n+from abc import abstractmethod\n+\n from taipy.core.notification import Event\n \n \n@@ -15,6 +17,7 @@ class _AbstractEventProcessor:\n     \"\"\"Abstract base class for implementing an event processor.\"\"\"\n \n     @classmethod\n+    @abstractmethod\n     def process_event(cls, event_consumer, event: Event):\n         raise NotImplementedError(\"Subclasses must implement this method.\")\n \n"
        },
        {
            "commit": "bbe7b82b778adbafd56d40bd00bc3aabcd5cb9c9",
            "file_path": "taipy/event/event_consumer.py",
            "diff": "diff --git a/taipy/event/event_consumer.py b/taipy/event/event_consumer.py\nindex f43355ce..947107c3 100644\n--- a/taipy/event/event_consumer.py\n+++ b/taipy/event/event_consumer.py\n@@ -11,7 +11,7 @@\n \n from typing import Callable, Dict, List, Optional, Union\n \n-from taipy import Gui, SubmissionStatus\n+from taipy import DataNode, Gui, Scenario, Submission, SubmissionStatus\n from taipy.common.logger._taipy_logger import _TaipyLogger\n from taipy.core.common._check_dependencies import EnterpriseEditionUtils\n from taipy.core.common._utils import _load_fct\n@@ -30,13 +30,16 @@ from taipy.event._event_processor import _AbstractEventProcessor, _EventProcesso\n from taipy.exceptions import NoGuiDefinedInEventConsumer\n \n \n-class EventConsumer(_CoreEventConsumerBase):\n+class GuiEventConsumer(_CoreEventConsumerBase):\n     \"\"\"\n     The Taipy event consumer service.\n \n-    This service listens for events in a Taipy application and triggers callbacks\n-    when events matching specific topics are produced. The main method to use is\n-    `on_event()^`, that registers a callback to a topic.\n+    This service listens for events in a Taipy application and triggers callback\n+    executions when events matching specific topics are produced. The service handle\n+    both cases where callbacks are broadcast to all states or executed once on the\n+    server side.\n+\n+    The main method to use is `on_event()^`, that registers a callback to a topic.\n \n     Before starting the event consumer service, register each callback to a topic.\n     The topics are defined by the entity type, the entity id, the operation, and the\n@@ -72,13 +75,13 @@ class EventConsumer(_CoreEventConsumerBase):\n         === \"One callback to match all events\"\n \n             ```python\n-            from taipy import Event, EventConsumer, Gui\n+            from taipy import Event, GuiEventConsumer, Gui\n \n             def event_received(gui: Gui, event: Event):\n                 print(f\"Received event created at : {event.creation_date}\")\n \n             if __name__ == \"__main__\":\n-                event_consumer = EventConsumer()\n+                event_consumer = GuiEventConsumer()\n                 event_consumer.on_event(callback=event_received)\n                 event_consumer.start()\n             ```\n@@ -86,16 +89,16 @@ class EventConsumer(_CoreEventConsumerBase):\n         === \"Two callbacks to match different topics\"\n \n             ```python\n-            from taipy import Event, EventConsumer, Gui\n+            from taipy import Event, GuiEventConsumer, Gui\n \n-            def on_entity_creation(gui: Gui, event: Event):\n+            def on_entity_creation(event: Event, gui: Gui):\n                 print(f\" {event.entity_type} entity created at {event.creation_date}\")\n \n-            def on_scenario(gui: Gui, event: Event):\n+            def on_scenario(event: Event, gui: Gui):\n                 print(f\"Scenario '{event.entity_id}' processed for a '{event.operation}' operation.\")\n \n             if __name__ == \"__main__\":\n-                event_consumer = EventConsumer()\n+                event_consumer = GuiEventConsumer()\n                 event_consumer.on_event(callback=on_entity_creation, operation=EventOperation.CREATION)\n                 event_consumer.on_event(callback=scenario_event, entity_type=EventEntityType.SCENARIO)\n                 event_consumer.start()\n@@ -105,7 +108,7 @@ class EventConsumer(_CoreEventConsumerBase):\n \n             ```python\n             import taipy as tp\n-            from taipy import Event, EventConsumer, Gui\n+            from taipy import Event, GuiEventConsumer, Gui\n \n             def event_received(state, event: Event):\n                 scenario = tp.get(event.entity_id)\n@@ -113,9 +116,32 @@ class EventConsumer(_CoreEventConsumerBase):\n \n             if __name__ == \"__main__\":\n                 gui = Gui()\n-                event_consumer = EventConsumer(gui)\n-                event_consumer.on_event(callback=event_received, broadcast=True)\n+                event_consumer = GuiEventConsumer(gui)\n+                event_consumer.broadcast_on_event(callback=event_received)\n+                event_consumer.start()\n+                taipy.run(gui)\n+            ```\n+\n+        === \"Two callbacks for scenario creations\"\n+\n+            ```python\n+            import taipy as tp\n+            from taipy import Event, GuiEventConsumer, Gui, State\n+\n+            def print_scenario_created(event: Event, scenario: Scenario, gui: Gui):\n+                print(f\"Scenario '{scenario.name}' created at '{event.creation_date}'.\")\n+\n+            def store_latest_scenario(state: State, event: Event, scenario: Scenario):\n+                print(f\"Scenario '{scenario.name}' created at '{event.creation_date}'.\")\n+                state.latest_scenario = scenario\n+\n+            if __name__ == \"__main__\":\n+                gui = Gui()\n+                event_consumer = GuiEventConsumer(gui)\n+                event_consumer.on_scenario_created(callback=print_scenario_created)\n+                event_consumer.broadcast_on_scenario_created(callback=store_latest_scenario)\n                 event_consumer.start()\n+                ...\n                 taipy.run(gui)\n             ```\n \n@@ -123,9 +149,9 @@ class EventConsumer(_CoreEventConsumerBase):\n \n             ```python\n             import taipy as tp\n-            from taipy import Event, EventConsumer, Gui\n+            from taipy import Event, GuiEventConsumer, Gui\n \n-            def cycle_filter(gui: Gui, event: Event):\n+            def cycle_filter(event: Event, gui: Gui):\n                 scenario = tp.get(event.entity_id)\n                 return scenario.cycle.name == \"2023\"\n \n@@ -136,12 +162,11 @@ class EventConsumer(_CoreEventConsumerBase):\n \n             if __name__ == \"__main__\":\n                 gui = Gui()\n-                event_consumer = EventConsumer(gui)\n-                event_consumer.on_event(\n+                event_consumer = GuiEventConsumer(gui)\n+                event_consumer.broadcast_on_event(\n                     callback=event_received,\n                     entity_type=EventEntityType.SCENARIO,\n-                    filter=cycle_filter,\n-                    broadcast=True)\n+                    filter=cycle_filter)\n                 event_consumer.start()\n                 taipy.run(gui)\n             ```\n@@ -151,11 +176,11 @@ class EventConsumer(_CoreEventConsumerBase):\n     filters.\n     \"\"\"\n \n-    def __init__(self, gui: Gui = None) -> None:\n-        \"\"\"Initialize the Event Consumer service.\n+    def __init__(self, gui: Optional[Gui] = None) -> None:\n+        \"\"\"Initialize the Gui Event Consumer service.\n \n         Arguments:\n-            gui (Optional[Gui]): The Gui instance used to broadcast the callbacks to all states.\n+            gui (Gui): The Gui instance used to broadcast the callbacks to all states.\n         \"\"\"\n         self._registration = _Registration()\n         self._topic_callbacks_map: Dict[_Topic, List[_Callback]] = {}\n@@ -177,27 +202,21 @@ class EventConsumer(_CoreEventConsumerBase):\n         operation: Optional[EventOperation] = None,\n         attribute_name: Optional[str] = None,\n         filter: Optional[Callable[[Event], bool]] = None,\n-        broadcast: Optional[bool] = False,\n-    ) -> 'EventConsumer':\n-        \"\"\"Register a callback for a specific event.\n+    ) -> \"GuiEventConsumer\":\n+        \"\"\"Register a callback to be executed on a specific event.\n \n         Arguments:\n             callback (callable): The callback to be executed when the event is produced.\n-                If the callback is broadcast to all states (see the `broadcast`\n-                argument), the first argument is a state.\n+                The callback takes the event as the first argument and the GUI instance as\n+                the second argument.\n                 ```python\n-                def event_received(state: State, event: Event):\n+                def on_event_received(event: Event, gui: Gui):\n                     ...\n                 ```\n-                Otherwise, it is the gui instance.\n-                ```python\n-                def event_received(gui: Gui, event: Event):\n-                    ...\n-                ```\n-                The second argument must be the event. Optionally, the callback can accept\n-                extra arguments (see the `callback_args` argument).\n+                Optionally, the callback can accept extra arguments (see the `callback_args`\n+                argument).\n             callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n-                function in addition to the event and possibly the state.\n+                function in addition to the event and the GUI.\n             entity_type (Optional[EventEntityType]): The entity type of the event.\n                 If None, the callback is registered for all entity types.\n             entity_id (Optional[str]): The entity id of the event.\n@@ -210,11 +229,81 @@ class EventConsumer(_CoreEventConsumerBase):\n                 the event before triggering the callback. The filter must accept an event\n                 as the only argument and return a boolean. If the filter returns False, the\n                 callback is not triggered.\n-            broadcast (Optional[bool]): If True, the callback is broadcast to all states.\n-                If false, the callback is only triggered once per event.\n         Returns:\n-            EventConsumer: The current instance of the `EventConsumer` service.\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n         \"\"\"\n+        return self.__on_event(\n+            callback=callback,\n+            callback_args=callback_args,\n+            entity_type=entity_type,\n+            entity_id=entity_id,\n+            operation=operation,\n+            attribute_name=attribute_name,\n+            filter=filter,\n+            broadcast=False,\n+        )\n+\n+    def broadcast_on_event(\n+        self,\n+        callback: Callable,\n+        callback_args: Optional[List] = None,\n+        entity_type: Optional[EventEntityType] = None,\n+        entity_id: Optional[str] = None,\n+        operation: Optional[EventOperation] = None,\n+        attribute_name: Optional[str] = None,\n+        filter: Optional[Callable[[Event], bool]] = None,\n+    ) -> \"GuiEventConsumer\":\n+        \"\"\"Register a callback to be broadcast to all states on a specific event.\n+\n+                Arguments:\n+                    callback (callable): The callback to be executed for each state when the\n+                        event is produced. The callback takes the state as the first argument\n+                        and the event as the second argument.\n+                        ```python\n+                        def on_event_received(state, event: Event):\n+                            ...\n+                        ```\n+                        Optionally, the callback can accept extra arguments (see the `callback_args`\n+                        argument).\n+                    callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n+                        function in addition to the state and the event.\n+                    entity_type (Optional[EventEntityType]): The entity type of the event.\n+                        If None, the callback is registered for all entity types.\n+                    entity_id (Optional[str]): The entity id of the event.\n+                        If None, the callback is registered for all entities.\n+                    operation (Optional[EventOperation]): The operation of the event.\n+                        If None, the callback is registered for all operations.\n+                    attribute_name (Optional[str]): The attribute name of an update event.\n+                        If None, the callback is registered for all attribute names.\n+                    filter (Optional[Callable[[Event], bool]]): A custom filter to apply to\n+                        the event before triggering the callback. The filter must accept an event\n+                        as the only argument and return a boolean. If the filter returns False, the\n+                        callback is not triggered.\n+                Returns:\n+                    GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n+                \"\"\"\n+        return self.__on_event(\n+            callback=callback,\n+            callback_args=callback_args,\n+            entity_type=entity_type,\n+            entity_id=entity_id,\n+            operation=operation,\n+            attribute_name=attribute_name,\n+            filter=filter,\n+            broadcast=True,\n+        )\n+\n+    def __on_event(\n+        self,\n+        callback: Callable,\n+        callback_args: Optional[List] = None,\n+        entity_type: Optional[EventEntityType] = None,\n+        entity_id: Optional[str] = None,\n+        operation: Optional[EventOperation] = None,\n+        attribute_name: Optional[str] = None,\n+        filter: Optional[Callable[[Event], bool]] = None,\n+        broadcast: bool = False,\n+    ) -> \"GuiEventConsumer\":\n         topic = self.__build_topic(entity_type, entity_id, operation, attribute_name)\n         cb = self.__build_callback(callback, callback_args, filter, broadcast)\n         self.__register_callback(topic, cb)\n@@ -222,22 +311,87 @@ class EventConsumer(_CoreEventConsumerBase):\n \n     def on_scenario_created(self,\n                             callback: Callable,\n-                            callback_args: Optional[List]=None,\n-                            scenario_config: Union[str, ScenarioConfig, List, None]=None,\n-                            broadcast: Optional[bool]=False\n-                            ) -> 'EventConsumer':\n+                            callback_args: Optional[List] = None,\n+                            scenario_config: Union[str, ScenarioConfig, List, None] = None,\n+                            ) -> \"GuiEventConsumer\":\n         \"\"\" Register a callback for scenario creation events.\n \n+        !!! Example:\n+\n+            === \"A callback for all scenario creations\"\n+\n+            ```python\n+            import taipy as tp\n+            from taipy import Event, GuiEventConsumer, Gui, State\n+\n+            def print_scenario_created(event: Event, scenario: Scenario, gui: Gui):\n+                print(f\"Scenario '{scenario.name}' created at '{event.creation_date}'.\")\n+\n+            if __name__ == \"__main__\":\n+                gui = Gui()\n+                event_consumer = GuiEventConsumer(gui)\n+                event_consumer.on_scenario_created(callback=print_scenario_created)\n+                event_consumer.start()\n+                ...\n+                taipy.run(gui)\n+            ```\n+\n+            === \"One callback for a specific scenario configuration\"\n+\n+            ```python\n+            import taipy as tp\n+            from taipy import Event, GuiEventConsumer, Gui\n+\n+            def print_scenario_created(event: Event, scenario: Scenario, gui: Gui):\n+                print(f\"Scenario '{scenario.name}' created at '{event.creation_date}'.\")\n+\n+            if __name__ == \"__main__\":\n+                event_consumer = GuiEventConsumer()\n+                event_consumer.on_scenario_created(callback=print_scenario_created, scenario_config=\"my_cfg\")\n+                event_consumer.start()\n+                ...\n+            ```\n+\n+        Arguments:\n+            callback (callable):The callback to be executed when consuming the event.\n+                ```python\n+                def on_event_received(event: Event, scenario: Scenario, gui: Gui):\n+                    ...\n+                ```\n+                The callback is triggered when a scenario is created. It takes the event\n+                the scenario, and the GUI instance as arguments. It can also accept extra\n+                arguments (see the `callback_args` argument).\n+            callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n+                function in addition to the event, the scenario and the GUI.\n+            scenario_config (Union[str, ScenarioConfig, List, None]): The\n+                optional scenario configuration ids or scenario configurations\n+                for which the callback is registered. If None, the callback is registered\n+                for all scenario configurations.\n+\n+        Returns:\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n+        \"\"\"\n+        return self.__on_scenario_created(\n+            callback=callback,\n+            callback_args=callback_args,\n+            scenario_config=scenario_config,\n+            broadcast=False,\n+        )\n+\n+    def broadcast_on_scenario_created(self,\n+                                      callback: Callable,\n+                                      callback_args: Optional[List] = None,\n+                                      scenario_config: Union[str, ScenarioConfig, List, None] = None,\n+                                      ) -> \"GuiEventConsumer\":\n+        \"\"\" Register a callback executed for all states on scenario creation events.\n+\n         !!! Examples:\n \n                 === \"Two callbacks for all scenario creations\"\n \n                 ```python\n                 import taipy as tp\n-                from taipy import Event, EventConsumer, Gui, State\n-\n-                def print_scenario_created(gui: Optional[Gui], event: Event, scenario: Scenario):\n-                    print(f\"Scenario '{scenario.name}' created at '{event.creation_date}'.\")\n+                from taipy import Event, GuiEventConsumer, Gui, State\n \n                 def store_latest_scenario(state: State, event: Event, scenario: Scenario):\n                     print(f\"Scenario '{scenario.name}' created at '{event.creation_date}'.\")\n@@ -245,9 +399,8 @@ class EventConsumer(_CoreEventConsumerBase):\n \n                 if __name__ == \"__main__\":\n                     gui = Gui()\n-                    event_consumer = EventConsumer(gui)\n-                    event_consumer.on_scenario_created(callback=print_scenario_created)\n-                    event_consumer.on_scenario_created(callback=store_latest_scenario, broadcast=True)\n+                    event_consumer = GuiEventConsumer(gui)\n+                    event_consumer.broadcast_on_scenario_created(callback=store_latest_scenario)\n                     event_consumer.start()\n                     ...\n                     taipy.run(gui)\n@@ -257,37 +410,27 @@ class EventConsumer(_CoreEventConsumerBase):\n \n                 ```python\n                 import taipy as tp\n-                from taipy import Event, EventConsumer, Gui\n+                from taipy import Event, GuiEventConsumer, Gui\n \n-                def print_scenario_created(gui: Optional[Gui], event: Event, scenario: Scenario):\n+                def scenario_created(state, event: Event, scenario: Scenario):\n                     print(f\"Scenario '{scenario.name}' created at '{event.creation_date}'.\")\n-\n+                    state.latest_scenario = scenario\n \n                 if __name__ == \"__main__\":\n-                    event_consumer = EventConsumer()\n-                    event_consumer.on_scenario_created(callback=print_scenario_created, scenario_config=\"my_cfg\")\n+                    event_consumer = GuiEventConsumer()\n+                    event_consumer.broadcast_on_scenario_created(callback=scenario_created, scenario_config=\"my_cfg\")\n                     event_consumer.start()\n                     ...\n                 ```\n \n-        The callback is triggered when a scenario is created. If the `broadcast` argument\n-        is set to True, the callback is broadcast to all states of the GUI. The callback\n-        can also accept extra arguments (see the `callback_args` argument).\n-\n         Arguments:\n-            callback (callable):The callback to be executed when consuming the event.\n-                If the callback is broadcast to all states (see the `broadcast`\n-                argument), the first argument is a state.\n+            callback (callable):The callback to be executed for each state when\n+                a scenario creation event occurs.\n                 ```python\n-                def event_received(state: State, event: Event, scenario: Scenario):\n+                def on_event_received(state: State, event: Event, scenario: Scenario):\n                     ...\n                 ```\n-                Otherwise, it is the gui instance.\n-                ```python\n-                def event_received(gui: Optional[Gui], event: Event, scenario: Scenario):\n-                    ...\n-                ```\n-                The second and third arguments are the event and the scenario.\n+                The callback takes the state, the event, and the scenario as arguments.\n                 Optionally, the callback can accept extra arguments (see the\n                 `callback_args` argument).\n             callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n@@ -296,86 +439,156 @@ class EventConsumer(_CoreEventConsumerBase):\n                 optional scenario configuration ids or scenario configurations\n                 for which the callback is registered. If None, the callback is registered\n                 for all scenario configurations.\n-            broadcast (Optional[bool]): If True, the callback is broadcast to all states\n-                If false, the callback is only triggered once per event.\n \n         Returns:\n-            EventConsumer: The current instance of the `EventConsumer` service.\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n         \"\"\"\n+        return self.__on_scenario_created(\n+            callback=callback,\n+            callback_args=callback_args,\n+            scenario_config=scenario_config,\n+            broadcast=True,\n+        )\n+\n+    def __on_scenario_created(self,\n+                              callback: Callable,\n+                              callback_args: Optional[List] = None,\n+                              scenario_config: Union[str, ScenarioConfig, List, None] = None,\n+                              broadcast: bool = False,\n+                              ) -> \"GuiEventConsumer\":\n         scenario_config = self.__format_configs_parameter(ScenarioConfig, scenario_config)\n \n         def _filter(event: Event) -> bool:\n+            if not event.entity_id:\n+                return False\n             import taipy as tp\n \n             sc = tp.get(event.entity_id)\n-            if scenario_config and sc.config_id not in scenario_config:\n+            if not isinstance(sc, Scenario):\n+                return False\n+            if scenario_config and sc.config_id not in scenario_config: # type: ignore[union-attr]\n                 return False\n             event.metadata[\"predefined_args\"] = [sc]\n             return True\n \n-        self.on_event(callback=callback,\n-                      callback_args=callback_args,\n-                      entity_type=EventEntityType.SCENARIO,\n-                      operation=EventOperation.CREATION,\n-                      filter=_filter,\n-                      broadcast=broadcast)\n+        self.__on_event(callback=callback,\n+                        callback_args=callback_args,\n+                        entity_type=EventEntityType.SCENARIO,\n+                        operation=EventOperation.CREATION,\n+                        filter=_filter,\n+                        broadcast=broadcast)\n         return self\n \n     def on_scenario_deleted(self,\n                             callback: Callable,\n-                            callback_args: Optional[List]=None,\n+                            callback_args: Optional[List] = None,\n                             scenario_config: Union[str, ScenarioConfig, List, None] = None,\n-                            broadcast: Optional[bool]=False\n-                            ) -> 'EventConsumer':\n+                            ) -> \"GuiEventConsumer\":\n         \"\"\" Register a callback for scenario deletion events.\n \n-        !!! Examples:\n+        !!! Example:\n \n             ```python\n             import taipy as tp\n-            from taipy import Event, EventConsumer, Gui, State\n+            from taipy import Event, GuiEventConsumer, Gui, State\n \n-            def record_deletions(state: State, event: Event, scenario_id: str):\n-                print(f\"Scenario deleted at '{event.creation_date}'.\")\n-                state.deleted_scenarios.append[scenario_id]\n+            def print_scenario_deleted(event: Event, scenario_id: str, gui: Gui):\n+                print(f\"A scenario has been deleted at '{event.creation_date}'.\")\n \n             if __name__ == \"__main__\":\n                 gui = Gui()\n-                event_consumer = EventConsumer(gui)\n-                event_consumer.on_scenario_deleted(callback=record_deletions, broadcast=True)\n+                event_consumer = GuiEventConsumer(gui)\n+                event_consumer.on_scenario_deleted(callback=print_scenario_)\n+                event_consumer.on_scenario_deleted(callback=print_scenario_deleted)\n                 event_consumer.start()\n                 ...\n                 taipy.run(gui)\n             ```\n \n         Arguments:\n-            callback (callable):The callback to be executed when consuming the event.\n-                If the callback is broadcast to all states (see the `broadcast`\n-                argument), the first argument is a state.\n+            callback (callable):The callback to be executed on scenario deletion event.\n                 ```python\n-                def event_received(state: State, event: Event, scenario_id: str):\n+                def on_event_received(event: Event, scenario_id: str, gui: Gui):\n                     ...\n                 ```\n-                Otherwise, it is the gui instance.\n+                The callback takes the event, the scenario id, and the GUI instance as\n+                arguments. Optionally, it can also accept extra arguments (see the\n+                `callback_args` argument).\n+            callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n+                function in addition to the event, the scenario id, and the GUI.\n+            scenario_config (Union[str, ScenarioConfig, List, None]): The\n+                optional scenario configuration ids or scenario configurations\n+                for which the callback is registered. If None, the callback is registered\n+                for all scenario configurations.\n+\n+        Returns:\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n+        \"\"\"\n+        return self.__on_scenario_deleted(\n+            callback=callback,\n+            callback_args=callback_args,\n+            scenario_config=scenario_config,\n+            broadcast=False,\n+        )\n+\n+    def broadcast_on_scenario_deleted(self,\n+                                      callback: Callable,\n+                                      callback_args: Optional[List] = None,\n+                                      scenario_config: Union[str, ScenarioConfig, List, None] = None,\n+                                      ) -> \"GuiEventConsumer\":\n+        \"\"\" Register a callback executed for all states on scenario deletion events.\n+\n+        !!! Example:\n+\n+            ```python\n+            import taipy as tp\n+            from taipy import Event, GuiEventConsumer, Gui, State\n+            from taipy.gui import notify\n+\n+            def on_scenario_deleted(state: State, event: Event, scenario_id: str):\n+                notify(state, f\"A scenario has been deleted at '{event.creation_date}'.\")\n+\n+            if __name__ == \"__main__\":\n+                gui = Gui()\n+                event_consumer = GuiEventConsumer(gui)\n+                event_consumer.broadcast_on_scenario_deleted(callback=on_scenario_deleted)\n+                event_consumer.start()\n+                ...\n+                taipy.run(gui)\n+            ```\n+\n+        Arguments:\n+            callback (Callable):The callback to be executed for each state on scenario\n+                deletion event.\n                 ```python\n-                def event_received(gui: Optional[Gui], event: Event, scenario_id: str):\n+                def on_event_received(state: State, event: Event, scenario_id: str):\n                     ...\n                 ```\n-                The second and third arguments are the event and the scenario_id.\n-                Optionally, the callback can accept extra arguments (see the\n-                `callback_args` argument).\n+                The callback takes the state, the event, and the scenario id as arguments.\n+                Optionally, it can also accept extra arguments (see the `callback_args` argument).\n             callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n                 function in addition to the state, the event, and the scenario id.\n             scenario_config (Union[str, ScenarioConfig, List, None]): The\n                 optional scenario configuration ids or scenario configurations\n                 for which the callback is registered. If None, the callback is registered\n                 for all scenario configurations.\n-            broadcast (Optional[bool]): If True, the callback is broadcast to all states.\n-                If false, the callback is only triggered once per event.\n \n         Returns:\n-            EventConsumer: The current instance of the `EventConsumer` service.\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n         \"\"\"\n+        return self.__on_scenario_deleted(\n+            callback=callback,\n+            callback_args=callback_args,\n+            scenario_config=scenario_config,\n+            broadcast=True,\n+        )\n+\n+    def __on_scenario_deleted(self,\n+                              callback: Callable,\n+                              callback_args: Optional[List] = None,\n+                              scenario_config: Union[str, ScenarioConfig, List, None] = None,\n+                              broadcast: bool = False\n+                              ) -> \"GuiEventConsumer\":\n         scenario_config = self.__format_configs_parameter(ScenarioConfig, scenario_config)\n \n         def _filter(event: Event) -> bool:\n@@ -383,118 +596,181 @@ class EventConsumer(_CoreEventConsumerBase):\n                 event.metadata[\"predefined_args\"] = [event.entity_id]\n                 return True\n             for cfg_id in scenario_config:\n-                if cfg_id in event.entity_id:\n+                if cfg_id in str(event.entity_id):\n                     event.metadata[\"predefined_args\"] = [event.entity_id]\n                     return True\n             return False\n \n-        self.on_event(callback=callback,\n-                      callback_args=callback_args,\n-                      entity_type=EventEntityType.SCENARIO,\n-                      operation=EventOperation.DELETION,\n-                      filter=_filter,\n-                      broadcast=broadcast)\n+        self.__on_event(callback=callback,\n+                        callback_args=callback_args,\n+                        entity_type=EventEntityType.SCENARIO,\n+                        operation=EventOperation.DELETION,\n+                        filter=_filter,\n+                        broadcast=broadcast)\n         return self\n \n     def on_datanode_written(self,\n                             callback: Callable,\n                             callback_args: Optional[List] = None,\n                             datanode_config: Union[str, DataNodeConfig, List, None] = None,\n-                            broadcast: Optional[bool] = False\n-                            ) -> 'EventConsumer':\n+                            ) -> \"GuiEventConsumer\":\n         \"\"\" Register a callback for data node written events.\n \n-        !!! Examples:\n+        The callback is triggered when a datanode is written (see methods\n+        `Datanode.write()^` or `Datanode.append()^`).\n+\n+        !!! Example:\n             ```python\n             import taipy as tp\n-            from taipy import Event, EventConsumer, Gui, State\n+            from taipy import Event, GuiEventConsumer, Gui, State\n \n-            def last_data_edition(state: State, event: Event, datanode: Datanode, data: Any):\n+            def last_data_edition(event: Event, datanode: Datanode, data: Any, gui: Gui):\n                 print(f\"Datanode written at '{event.creation_date}'.\")\n                 state.last_data_edition.append[datanode.id]\n \n             if __name__ == \"__main__\":\n                 gui = Gui()\n-                event_consumer = EventConsumer(gui)\n+                event_consumer = GuiEventConsumer(gui)\n                 event_consumer.on_datanode_written(callback=last_data_edition, broadcast=True)\n                 event_consumer.start()\n                 ...\n                 taipy.run(gui)\n             ```\n \n-        The callback is triggered when a datanode is written (see methods\n-        `Datanode.write()^` or `Datanode.append()^`).\n-\n         Arguments:\n             callback (callable):The callback to be executed when consuming the event.\n-                If the callback is broadcast to all states (see the `broadcast`\n-                argument), the first argument is a state.\n                 ```python\n-                def event_received(state: State, event: Event, datanode: Datanode, data: Any):\n+                def on_event_received(event: Event,\n+                                      datanode: Datanode,\n+                                      data: Any,\n+                                      gui: Gui):\n                     ...\n                 ```\n-                Otherwise, it is the gui instance.\n+               The callback takes the event, the datanode, the data, and the GUI instance as\n+                arguments. Optionally, the callback can accept extra arguments (see the\n+                `callback_args` argument).\n+            callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n+                function in addition to the event, the datanode, the data, and the GUI.\n+            datanode_config (Union[str, DataNodeConfig, List, None]): The\n+                optional datanode configuration ids or datanode configurations\n+                for which the callback is registered. If None, the callback is registered\n+                for all datanode configurations.\n+\n+        Returns:\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n+        \"\"\"\n+        return self.__on_datanode_written(\n+            callback=callback,\n+            callback_args=callback_args,\n+            datanode_config=datanode_config,\n+            broadcast=False,\n+        )\n+\n+    def broadcast_on_datanode_written(self,\n+                                      callback: Callable,\n+                                      callback_args: Optional[List] = None,\n+                                      datanode_config: Union[str, DataNodeConfig, List, None] = None,\n+                                      ) -> \"GuiEventConsumer\":\n+        \"\"\" Register a callback for data node written events.\n+\n+        The callback is triggered when a datanode is written (see methods\n+        `Datanode.write()^` or `Datanode.append()^`).\n+\n+        !!! Example:\n+            ```python\n+            import taipy as tp\n+            from taipy import Event, GuiEventConsumer, Gui, State\n+\n+            def last_data_edition(state: State, event: Event, datanode: Datanode, data: Any):\n+                print(f\"Datanode written at '{event.creation_date}'.\")\n+                state.last_data_edition.append[datanode.id]\n+\n+            if __name__ == \"__main__\":\n+                gui = Gui()\n+                event_consumer = GuiEventConsumer(gui)\n+                event_consumer.broadcast_on_datanode_written(callback=last_data_edition)\n+                event_consumer.start()\n+                ...\n+                taipy.run(gui)\n+            ```\n+\n+        Arguments:\n+            callback (callable): The callback to be executed for all states on data node\n+                written events.\n                 ```python\n-                def event_received(gui: Optional[Gui], event: Event, datanode: Datanode, data: Any):\n+                def on_event_received(state: State, event: Event, datanode: Datanode, data: Any):\n                     ...\n                 ```\n-                The second, third, and fourth arguments are the event and the data node,\n-                and the data.\n-                Optionally, the callback can accept extra arguments (see the\n-                `callback_args` argument).\n+               The callback takes the state, the event, the datanode, the data, and the GUI\n+                instance as arguments. Optionally, the callback can accept extra arguments\n+                (see the `callback_args` argument).\n             callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n                 function in addition to the state, the event, the datanode, and the data.\n             datanode_config (Union[str, DataNodeConfig, List, None]): The\n                 optional datanode configuration ids or datanode configurations\n                 for which the callback is registered. If None, the callback is registered\n                 for all datanode configurations.\n-            broadcast (Optional[bool]): If True, the callback is broadcast to all states.\n-                If false, the callback is only triggered once for each event.\n \n         Returns:\n-            EventConsumer: The current instance of the `EventConsumer` service.\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n         \"\"\"\n+        return self.__on_datanode_written(\n+            callback=callback,\n+            callback_args=callback_args,\n+            datanode_config=datanode_config,\n+            broadcast=True,\n+        )\n+\n+    def __on_datanode_written(self,\n+                              callback: Callable,\n+                              callback_args: Optional[List] = None,\n+                              datanode_config: Union[str, DataNodeConfig, List, None] = None,\n+                              broadcast: bool = False\n+                              ) -> \"GuiEventConsumer\":\n         datanode_config = self.__format_configs_parameter(DataNodeConfig, datanode_config)\n \n         def _filter(event: Event) -> bool:\n+            if not event.entity_id:\n+                return False\n+\n             import taipy as tp\n \n             dn = tp.get(event.entity_id)\n+            if not isinstance(dn, DataNode):\n+                return False\n             if datanode_config and dn.config_id not in datanode_config:\n                 return False\n             event.metadata[\"predefined_args\"] = [dn, dn.read()]\n             return True\n \n-        self.on_event(callback=callback,\n-                      callback_args=callback_args,\n-                      entity_type=EventEntityType.DATA_NODE,\n-                      operation=EventOperation.UPDATE,\n-                      attribute_name=\"last_edit_date\",\n-                      filter=_filter,\n-                      broadcast=broadcast)\n+        self.__on_event(callback=callback,\n+                        callback_args=callback_args,\n+                        entity_type=EventEntityType.DATA_NODE,\n+                        operation=EventOperation.UPDATE,\n+                        attribute_name=\"last_edit_date\",\n+                        filter=_filter,\n+                        broadcast=broadcast)\n         return self\n \n     def on_datanode_deleted(self,\n                             callback: Callable,\n                             callback_args: Optional[List] = None,\n                             datanode_config: Union[str, DataNodeConfig, List, None] = None,\n-                            broadcast: Optional[bool] = False\n-                            ) -> 'EventConsumer':\n+                            ) -> \"GuiEventConsumer\":\n         \"\"\" Register a callback for data node deletion events.\n \n-        !!! Examples:\n+        !!! Example:\n             ```python\n             import taipy as tp\n-            from taipy import Event, EventConsumer, Gui, State\n+            from taipy import Event, GuiEventConsumer, Gui, State\n \n-            def record_deletions(state: State, event: Event, datanode_id: str):\n+            def on_deletions(event: Event, datanode_id: str, gui: Gui):\n                 print(f\"Datanode deleted at '{event.creation_date}'.\")\n-                state.deleted_datanodes.append[datanode_id]\n \n             if __name__ == \"__main__\":\n                 gui = Gui()\n-                event_consumer = EventConsumer(gui)\n-                event_consumer.on_datanode_deleted(callback=record_deletions, broadcast=True)\n+                event_consumer = GuiEventConsumer(gui)\n+                event_consumer.on_datanode_deleted(callback=record_deletions)\n                 event_consumer.start()\n                 ...\n                 taipy.run(gui)\n@@ -502,19 +778,64 @@ class EventConsumer(_CoreEventConsumerBase):\n \n         Arguments:\n             callback (callable):The callback to be executed when consuming the event.\n-                If the callback is broadcast to all states (see the `broadcast`\n-                argument), the first argument is a state.\n                 ```python\n-                def event_received(state: State, event: Event, datanode_id: str):\n+                def on_event_received(event: Event, datanode_id: str, gui: Gui):\n                     ...\n                 ```\n-                Otherwise, it is the gui instance.\n+                The callback takes the event, the datanode id, and the GUI instance as\n+                arguments. Optionally, it can accept extra arguments (see the\n+                `callback_args` argument).\n+            callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n+                function in addition to the event, the datanode id, and the GUI.\n+            datanode_config (Union[str, DataNodeConfig, List, None]): The\n+                optional datanode configuration ids or datanode configurations\n+                for which the callback is registered. If None, the callback is registered\n+                for all datanode configurations.\n+\n+        Returns:\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n+        \"\"\"\n+        return self.__on_datanode_deleted(\n+            callback=callback,\n+            callback_args=callback_args,\n+            datanode_config=datanode_config,\n+            broadcast=False,\n+        )\n+\n+    def broadcast_on_datanode_deleted(self,\n+                                      callback: Callable,\n+                                      callback_args: Optional[List] = None,\n+                                      datanode_config: Union[str, DataNodeConfig, List, None] = None,\n+                                      ) -> \"GuiEventConsumer\":\n+        \"\"\" Register a callback for each state on data node deletion events.\n+\n+        !!! Example:\n+            ```python\n+            import taipy as tp\n+            from taipy import Event, GuiEventConsumer, Gui, State\n+\n+            def record_deletions(state: State, event: Event, datanode_id: str):\n+                print(f\"Datanode deleted at '{event.creation_date}'.\")\n+                state.deleted_datanodes.append[datanode_id]\n+\n+            if __name__ == \"__main__\":\n+                gui = Gui()\n+                event_consumer = GuiEventConsumer(gui)\n+                event_consumer.broadcast_on_datanode_deleted(callback=record_deletions)\n+                event_consumer.start()\n+                ...\n+                taipy.run(gui)\n+            ```\n+\n+        Arguments:\n+            callback (callable): The callback to be executed for each state on data node\n+                deletion events.\n                 ```python\n-                def event_received(gui: Optional[Gui], event: Event, datanode_id: str):\n+                def on_event_received(state: State, event: Event, datanode_id: str):\n                     ...\n                 ```\n-                The second and third arguments are the event and the data node id.\n-                Optionally, the callback can accept extra arguments (see the\n+                The callback takes the state, the event, the datanode id, and the GUI\n+                instance as arguments. Optionally, it can accept extra arguments (see the\n                 `callback_args` argument).\n             callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n                 function in addition to the state, the event, and the datanode id.\n@@ -522,12 +843,23 @@ class EventConsumer(_CoreEventConsumerBase):\n                 optional datanode configuration ids or datanode configurations\n                 for which the callback is registered. If None, the callback is registered\n                 for all datanode configurations.\n-            broadcast (Optional[bool]): If True, the callback is broadcast to all states\n-                of the GUI. If false, the callback is only triggered once for each event.\n \n         Returns:\n-            EventConsumer: The current instance of the `EventConsumer` service.\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n         \"\"\"\n+        return self.__on_datanode_deleted(\n+            callback=callback,\n+            callback_args=callback_args,\n+            datanode_config=datanode_config,\n+            broadcast=True,\n+        )\n+\n+    def __on_datanode_deleted(self,\n+                              callback: Callable,\n+                              callback_args: Optional[List] = None,\n+                              datanode_config: Union[str, DataNodeConfig, List, None] = None,\n+                              broadcast: bool = False\n+                              ) -> \"GuiEventConsumer\":\n         datanode_config = self.__format_configs_parameter(DataNodeConfig, datanode_config)\n \n         def _filter(event: Event) -> bool:\n@@ -535,60 +867,102 @@ class EventConsumer(_CoreEventConsumerBase):\n                 event.metadata[\"predefined_args\"] = [event.entity_id]\n                 return True\n             for cfg_id in datanode_config:\n-                if cfg_id in event.entity_id:\n+                if cfg_id in str(event.entity_id):\n                     event.metadata[\"predefined_args\"] = [event.entity_id]\n                     return True\n             return False\n \n-        self.on_event(callback=callback,\n-                      callback_args=callback_args,\n-                      entity_type=EventEntityType.DATA_NODE,\n-                      operation=EventOperation.DELETION,\n-                      filter=_filter,\n-                      broadcast=broadcast)\n+        self.__on_event(callback=callback,\n+                        callback_args=callback_args,\n+                        entity_type=EventEntityType.DATA_NODE,\n+                        operation=EventOperation.DELETION,\n+                        filter=_filter,\n+                        broadcast=broadcast)\n         return self\n \n-\n     def on_datanode_created(self,\n                             callback: Callable,\n                             callback_args: Optional[List] = None,\n                             datanode_config: Union[str, DataNodeConfig, List, None] = None,\n-                            broadcast: Optional[bool] = False\n-                            ) -> 'EventConsumer':\n+                            ) -> \"GuiEventConsumer\":\n         \"\"\" Register a callback to be executed on data node creation event.\n \n-        !!! Examples:\n+        !!! Example:\n             ```python\n             import taipy as tp\n-            from taipy import Event, EventConsumer, Gui, State\n+            from taipy import Event, GuiEventConsumer, Gui, State\n \n-            def record_creations(state: State, event: Event, datanode: DataNode):\n+            def on_datanode_creations(event: Event, datanode: DataNode, gui: Gui):\n                 print(f\"Datanode created at '{event.creation_date}'.\")\n-                state.created_datanodes.append[datanode_id]\n \n             if __name__ == \"__main__\":\n                 gui = Gui()\n-                event_consumer = EventConsumer(gui)\n-                event_consumer.on_datanode_created(callback=record_creations, broadcast=True)\n+                event_consumer = GuiEventConsumer(gui)\n+                event_consumer.on_datanode_created(callback=record_creations)\n                 event_consumer.start()\n                 ...\n                 taipy.run(gui)\n             ```\n \n         Arguments:\n-            callback (callable):The callback to be executed when consuming the event.\n-                If the callback is broadcast to all states (see the `broadcast`\n-                argument), the first argument is a state.\n+            callback (callable):The callback to be executed on data node creation events.\n                 ```python\n-                def event_received(state: State, event: Event, datanode: DataNode):\n+                def on_event_received(event: Event, datanode: DataNode, gui: Gui):\n                     ...\n                 ```\n-                Otherwise, it is the gui instance.\n+                The callback takes the event, the datanode, and the GUI instance as\n+                arguments. Optionally, the callback can accept extra arguments (see the\n+                `callback_args` argument).\n+            callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n+                function in addition to the event, the datanode, and the GUI.\n+            datanode_config (Union[str, ScenarioConfig, List, None]): The\n+                optional datanode configuration ids or datanode configurations\n+                for which the callback is registered. If None, the callback is registered\n+                for all datanode configurations.\n+\n+        Returns:\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n+        \"\"\"\n+        return self.__on_datanode_created(\n+            callback=callback,\n+            callback_args=callback_args,\n+            datanode_config=datanode_config,\n+            broadcast=False,\n+        )\n+\n+    def broadcast_on_datanode_created(self,\n+                                      callback: Callable,\n+                                      callback_args: Optional[List] = None,\n+                                      datanode_config: Union[str, DataNodeConfig, List, None] = None,\n+                                      ) -> \"GuiEventConsumer\":\n+        \"\"\" Register a callback to be executed for each state on data node creation event.\n+\n+        !!! Examples:\n+            ```python\n+            import taipy as tp\n+            from taipy import Event, GuiEventConsumer, Gui, State\n+            from taipy.gui import notify\n+\n+            def on_datanode_creations(state: State, event: Event, datanode: DataNode):\n+                print(f\"Datanode created at '{event.creation_date}'.\")\n+                notify(state, f\"Datanode '{datanode.id}' created.\")\n+\n+            if __name__ == \"__main__\":\n+                gui = Gui()\n+                event_consumer = GuiEventConsumer(gui)\n+                event_consumer.broadcast_on_datanode_created(callback=record_creations)\n+                event_consumer.start()\n+                ...\n+                taipy.run(gui)\n+            ```\n+\n+        Arguments:\n+            callback (callable):The callback to be executed on data node creation events.\n                 ```python\n-                def event_received(gui: Optional[Gui], event: Event, datanode: DataNode):\n+                def on_event_received(state: State, event: Event, datanode: DataNode):\n                     ...\n                 ```\n-                The second and third arguments are the event and the data node.\n+                The callback takes the state, the event, the datanode as arguments.\n                 Optionally, the callback can accept extra arguments (see the\n                 `callback_args` argument).\n             callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n@@ -597,46 +971,114 @@ class EventConsumer(_CoreEventConsumerBase):\n                 optional datanode configuration ids or datanode configurations\n                 for which the callback is registered. If None, the callback is registered\n                 for all datanode configurations.\n-            broadcast (Optional[bool]): If True, the callback is broadcast to all states\n-                of the GUI. If false, the callback is only triggered once for each event.\n \n         Returns:\n-            EventConsumer: The current instance of the `EventConsumer` service.\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n         \"\"\"\n+        return self.__on_datanode_created(\n+            callback=callback,\n+            callback_args=callback_args,\n+            datanode_config=datanode_config,\n+            broadcast=True,\n+        )\n+\n+    def __on_datanode_created(self,\n+                              callback: Callable,\n+                              callback_args: Optional[List] = None,\n+                              datanode_config: Union[str, DataNodeConfig, List, None] = None,\n+                              broadcast: bool = False\n+                              ) -> \"GuiEventConsumer\":\n         datanode_config = self.__format_configs_parameter(DataNodeConfig, datanode_config)\n \n         def _filter(event: Event) -> bool:\n+            if not event.entity_id:\n+                return False\n             import taipy as tp\n \n             dn = tp.get(event.entity_id)\n+            if not isinstance(dn, DataNode):\n+                return False\n             if datanode_config and dn.config_id not in datanode_config:\n                 return False\n             event.metadata[\"predefined_args\"] = [dn]\n             return True\n \n-        self.on_event(callback=callback,\n-                      callback_args=callback_args,\n-                      entity_type=EventEntityType.DATA_NODE,\n-                      operation=EventOperation.CREATION,\n-                      filter=_filter,\n-                      broadcast=broadcast)\n+        self.__on_event(callback=callback,\n+                        callback_args=callback_args,\n+                        entity_type=EventEntityType.DATA_NODE,\n+                        operation=EventOperation.CREATION,\n+                        filter=_filter,\n+                        broadcast=broadcast)\n         return self\n \n     def on_submission_finished(self,\n                                callback: Callable,\n                                callback_args: Optional[List] = None,\n                                config_ids: Union[str, ScenarioConfig, TaskConfig, List, None] = None,\n-                               broadcast: Optional[bool] = False\n-                               ) -> 'EventConsumer':\n+                               ) -> \"GuiEventConsumer\":\n         \"\"\"Register a callback for submission finished events.\n \n-        !!! Examples:\n+        !!! Example:\n+            ```python\n+            import taipy as tp\n+            from taipy import Event, GuiEventConsumer, Gui, State\n+\n+            def record_submissions(event: Event, submittable: Submittable, submission: Submission, gui: Gui):\n+                if submission.submission_status == SubmissionStatus.COMPLETED:\n+                    print(f\"Submission completed at '{event.creation_date}'. Status: '{submission.submission_status}'\")\n+                elif submission.submission_status == SubmissionStatus.FAILED:\n+                    print(f\"Submission failed at '{event.creation_date}'. Status: '{submission.submission_status}'\")\n+\n+            if __name__ == \"__main__\":\n+                gui = Gui()\n+                event_consumer = GuiEventConsumer(gui)\n+                event_consumer.on_submission_finished(callback=record_submissions)\n+                event_consumer.start()\n+                ...\n+                taipy.run(gui)\n+            ```\n+\n+        Arguments:\n+            callback (callable): The callback to be executed on submission finished\n+                events.\n+                ```python\n+                def on_event_received(event: Event, submittable: Submittable, submission: Submission, gui: Gui):\n+                    ...\n+                ```\n+                The callback takes the event, the submittable (scenario, sequence or task),\n+                the submission, and the GUI instance as arguments. Optionally, the\n+                callback can accept extra arguments (see the `callback_args` argument).\n+            callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n+                function in addition to the event, the submittable, the submission, and the GUI.\n+            config_ids (Union[str, ScenarioConfig, TaskConfig, List, None]): The\n+                optional scenario configuration ids or task configuration ids or scenario\n+                configurations or task configurations for which the callback is registered.\n+                If None, the callback is registered for any submittable.\n+\n+        Returns:\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n+        \"\"\"\n+        return self.__on_submission_finished(\n+            callback=callback,\n+            callback_args=callback_args,\n+            config_ids=config_ids,\n+            broadcast=False,\n+        )\n+\n+    def broadcast_on_submission_finished(self,\n+                                         callback: Callable,\n+                                         callback_args: Optional[List] = None,\n+                                         config_ids: Union[str, ScenarioConfig, TaskConfig, List, None] = None,\n+                                         ) -> \"GuiEventConsumer\":\n+        \"\"\"Register a callback to be executed for each state on submission finished events.\n+\n+        !!! Example:\n             ```python\n             import taipy as tp\n             from taipy import Event, EventConsumer, Gui, State\n \n             def record_submissions(state: State, event: Event, submittable: Submittable, submission: Submission):\n-                print(f\"Submission finished at '{event.creation_date}' with status '{submission.submission_status}'.\")\n+                print(f\"Submission finished at '{event.creation_date}'. Status: '{submission.submission_status}'\")\n                 if submission.submission_status == SubmissionStatus.COMPLETED:\n                     state.completed.append[submittable.id]\n                 elif submission.submission_status == SubmissionStatus.FAILED:\n@@ -644,7 +1086,7 @@ class EventConsumer(_CoreEventConsumerBase):\n \n             if __name__ == \"__main__\":\n                 gui = Gui()\n-                event_consumer = EventConsumer(gui)\n+                event_consumer = GuiEventConsumer(gui)\n                 event_consumer.on_submission_finished(callback=record_submissions, broadcast=True)\n                 event_consumer.start()\n                 ...\n@@ -652,21 +1094,15 @@ class EventConsumer(_CoreEventConsumerBase):\n             ```\n \n         Arguments:\n-            callback (callable):The callback to be executed when consuming the event.\n-                If the callback is broadcast to all states (see the `broadcast`\n-                argument), the first argument is a state.\n+            callback (callable): The callback to be executed for each state on submission\n+                finished events.\n                 ```python\n-                def event_received(state: State, event: Event, submittable: Submittable, submission: Submission):\n+                def on_event_received(state: State, event: Event, submittable: Submittable, submission: Submission):\n                     ...\n                 ```\n-                Otherwise, it is the gui instance.\n-                ```python\n-                def event_received(gui: Optional[Gui], event: Event, submittable: Submittable, submission: Submission):\n-                    ...\n-                ```\n-                The second, third, and fourth arguments are the event, the submittable\n-                (scenario, sequence or task), and the submission. Optionally, the\n-                callback can accept extra arguments (see the `callback_args` argument).\n+                The callback takes the state, the event, the submittable (scenario, sequence\n+                or task), and the submission. Optionally, the callback can accept extra\n+                arguments (see the `callback_args` argument).\n             callback_args (List[AnyOf]): The extra arguments to be passed to the callback\n                 function in addition to the state, the event, the submittable, and the\n                 submission.\n@@ -674,12 +1110,23 @@ class EventConsumer(_CoreEventConsumerBase):\n                 optional scenario configuration ids or task configuration ids or scenario\n                 configurations or task configurations for which the callback is registered.\n                 If None, the callback is registered for any submittable.\n-            broadcast (Optional[bool]): If True, the callback is broadcast to all states\n-                of the GUI. If false, the callback is only triggered once for each event.\n \n         Returns:\n-            EventConsumer: The current instance of the `EventConsumer` service.\n+            GuiEventConsumer: The current instance of the `GuiEventConsumer` service.\n         \"\"\"\n+        return self.__on_submission_finished(\n+            callback=callback,\n+            callback_args=callback_args,\n+            config_ids=config_ids,\n+            broadcast=True,\n+        )\n+\n+    def __on_submission_finished(self,\n+                                 callback: Callable,\n+                                 callback_args: Optional[List] = None,\n+                                 config_ids: Union[str, ScenarioConfig, TaskConfig, List, None] = None,\n+                                 broadcast: bool = False\n+                                 ) -> \"GuiEventConsumer\":\n         if isinstance(config_ids, str):\n             config_ids = [config_ids]\n         if isinstance(config_ids, TaskConfig):\n@@ -699,11 +1146,13 @@ class EventConsumer(_CoreEventConsumerBase):\n \n         def _filter(event: Event) -> bool:\n             finished_statuses = {SubmissionStatus.COMPLETED, SubmissionStatus.FAILED, SubmissionStatus.CANCELED}\n-            if not event.attribute_value or event.attribute_value not in finished_statuses:\n+            if not event.entity_id or not event.attribute_value or event.attribute_value not in finished_statuses:\n                 return False\n             import taipy as tp\n \n             submission = tp.get(event.entity_id)\n+            if not isinstance(submission, Submission):\n+                return False\n             if config_ids:\n                 # We are filtering on a specific config\n                 if not submission.entity_config_id:\n@@ -712,17 +1161,18 @@ class EventConsumer(_CoreEventConsumerBase):\n                 if submission.entity_config_id not in config_ids:\n                     # It is a submission for a config that is not in the list\n                     return False\n-            submittable = tp.get(submission.entity_id)\n+\n+            submittable = tp.get(submission.entity_id) # type: ignore[arg-type]\n             event.metadata[\"predefined_args\"] = [submittable, submission]\n             return True\n \n-        self.on_event(callback=callback,\n-                      callback_args=callback_args,\n-                      entity_type=EventEntityType.SUBMISSION,\n-                      operation=EventOperation.UPDATE,\n-                      attribute_name=\"submission_status\",\n-                      filter=_filter,\n-                      broadcast=broadcast)\n+        self.__on_event(callback=callback,\n+                        callback_args=callback_args,\n+                        entity_type=EventEntityType.SUBMISSION,\n+                        operation=EventOperation.UPDATE,\n+                        attribute_name=\"submission_status\",\n+                        filter=_filter,\n+                        broadcast=broadcast)\n         return self\n \n     def process_event(self, event: Event) -> None:\n@@ -752,7 +1202,7 @@ class EventConsumer(_CoreEventConsumerBase):\n         if isinstance(parameter, clazz):\n             parameter = [parameter.id]  # type: ignore[attr-defined]\n         if isinstance(parameter, list):\n-            parameter = [cfg.id if isinstance(cfg, clazz) else cfg for cfg in parameter] # type: ignore[attr-defined]\n+            parameter = [cfg.id if isinstance(cfg, clazz) else cfg for cfg in parameter]  # type: ignore[attr-defined]\n         return parameter\n \n     def __build_topic(self, entity_type, entity_id, operation, attribute_name):\n@@ -800,4 +1250,4 @@ class EventConsumer(_CoreEventConsumerBase):\n                 return\n             self._gui.broadcast_callback(cb.callback, [event, *predefined_args, *cb.args])\n         else:\n-            cb.callback(self._gui, event, *predefined_args, *cb.args)\n+            cb.callback(event, *predefined_args, self._gui, *cb.args)\n"
        },
        {
            "commit": "bbe7b82b778adbafd56d40bd00bc3aabcd5cb9c9",
            "file_path": "tests/event/test_consumer__on_datanode_created.py",
            "diff": "diff --git a/tests/event/test_consumer__on_datanode_created.py b/tests/event/test_consumer__on_datanode_created.py\nindex 4d8fc67b..fd9b52a1 100644\n--- a/tests/event/test_consumer__on_datanode_created.py\n+++ b/tests/event/test_consumer__on_datanode_created.py\n@@ -14,7 +14,7 @@ from unittest.mock import ANY\n from taipy import DataNode, Gui\n from taipy.core.config import DataNodeConfig\n from taipy.core.notification import Event, EventEntityType, EventOperation\n-from taipy.event.event_consumer import EventConsumer\n+from taipy.event.event_consumer import GuiEventConsumer\n \n \n def cb_0(event: Event, datanode: DataNode):\n@@ -30,8 +30,8 @@ def cb_for_state(state, event: Event, datanode: DataNode):\n \n \n def test_on_datanode_created(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_created(callback=cb_0)\n         # test the on_datanode_created method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_0,\n@@ -54,8 +54,8 @@ def test_on_datanode_created(data_node):\n \n \n def test_on_datanode_created_multiple_configs(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_created(callback=cb_0,\n                                      datanode_config=[DataNodeConfig(\"dn0\"), \"dn1\", DataNodeConfig(\"dn2\"), \"data_node\"])\n         # test the on_datanode_created method delegates to on_event with the correct parameters\n@@ -79,8 +79,8 @@ def test_on_datanode_created_multiple_configs(data_node):\n \n \n def test_on_datanode_created_multiple_configs_no_matching(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_created(callback=cb_0,\n                                      datanode_config=[DataNodeConfig(\"dn0\"), \"dn1\"])\n         # test the on_datanode_created method delegates to on_event with the correct parameters\n@@ -105,8 +105,8 @@ def test_on_datanode_created_multiple_configs_no_matching(data_node):\n \n \n def test_on_datanode_created_with_args_and_matching_config(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_created(callback=cb_1, callback_args=[\"foo\"], datanode_config=\"data_node\")\n         # test the on_datanode_created method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_1,\n@@ -129,8 +129,8 @@ def test_on_datanode_created_with_args_and_matching_config(data_node):\n \n \n def test_on_datanode_created_with_args_and_not_matching_config(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_created(callback=cb_1, callback_args=[\"foo\"], datanode_config=\"WRONG_CFG\")\n         # test the on_datanode_created method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_1,\n@@ -153,9 +153,9 @@ def test_on_datanode_created_with_args_and_not_matching_config(data_node):\n \n \n def test_on_datanode_created_with_broadcast():\n-    consumer = EventConsumer(Gui())\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n-        consumer.on_datanode_created(callback=cb_for_state, broadcast=True)\n+    consumer = GuiEventConsumer(Gui())\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n+        consumer.broadcast_on_datanode_created(callback=cb_for_state)\n         mck.assert_called_once_with(callback=cb_for_state,\n                                     callback_args=None,\n                                     entity_type=EventEntityType.DATA_NODE,\n"
        },
        {
            "commit": "bbe7b82b778adbafd56d40bd00bc3aabcd5cb9c9",
            "file_path": "tests/event/test_consumer__on_datanode_deleted.py",
            "diff": "diff --git a/tests/event/test_consumer__on_datanode_deleted.py b/tests/event/test_consumer__on_datanode_deleted.py\nindex da5aa032..0dcda6ba 100644\n--- a/tests/event/test_consumer__on_datanode_deleted.py\n+++ b/tests/event/test_consumer__on_datanode_deleted.py\n@@ -14,7 +14,7 @@ from unittest.mock import ANY\n from taipy import Gui\n from taipy.core.config import DataNodeConfig\n from taipy.core.notification import Event, EventEntityType, EventOperation\n-from taipy.event.event_consumer import EventConsumer\n+from taipy.event.event_consumer import GuiEventConsumer\n \n \n def cb_0(event: Event, datanode: str):\n@@ -30,8 +30,8 @@ def cb_for_state(state, event: Event, datanode: str):\n \n \n def test_on_datanode_deleted(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_deleted(callback=cb_0)\n         # test the on_datanode_deleted method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_0,\n@@ -51,8 +51,8 @@ def test_on_datanode_deleted(data_node):\n \n \n def test_on_datanode_deleted_multiple_configs(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_deleted(callback=cb_0,\n                                      datanode_config=[DataNodeConfig(\"dn0\"), \"dn1\", DataNodeConfig(\"dn2\"), \"data_node\"])\n         # test the on_datanode_deleted method delegates to on_event with the correct parameters\n@@ -73,8 +73,8 @@ def test_on_datanode_deleted_multiple_configs(data_node):\n \n \n def test_on_datanode_deleted_multiple_configs_no_matching(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_deleted(callback=cb_0,\n                                      datanode_config=[DataNodeConfig(\"dn0\"), \"dn1\"])\n         # test the on_datanode_deleted method delegates to on_event with the correct parameters\n@@ -96,8 +96,8 @@ def test_on_datanode_deleted_multiple_configs_no_matching(data_node):\n \n \n def test_on_datanode_deleted_with_args_and_matching_config(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_deleted(callback=cb_1, callback_args=[\"foo\"], datanode_config=\"data_node\")\n         # test the on_datanode_deleted method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_1,\n@@ -117,8 +117,8 @@ def test_on_datanode_deleted_with_args_and_matching_config(data_node):\n \n \n def test_on_datanode_deleted_with_args_and_not_matching_config(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_deleted(callback=cb_1, callback_args=[\"foo\"], datanode_config=\"WRONG_CFG\")\n         # test the on_datanode_deleted method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_1,\n@@ -138,9 +138,9 @@ def test_on_datanode_deleted_with_args_and_not_matching_config(data_node):\n \n \n def test_on_datanode_deleted_with_broadcast(data_node):\n-    consumer = EventConsumer(Gui())\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n-        consumer.on_datanode_deleted(callback=cb_for_state, broadcast=True)\n+    consumer = GuiEventConsumer(Gui())\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n+        consumer.broadcast_on_datanode_deleted(callback=cb_for_state)\n         mck.assert_called_once_with(callback=cb_for_state,\n                                     callback_args=None,\n                                     entity_type=EventEntityType.DATA_NODE,\n"
        },
        {
            "commit": "bbe7b82b778adbafd56d40bd00bc3aabcd5cb9c9",
            "file_path": "tests/event/test_consumer__on_datanode_written.py",
            "diff": "diff --git a/tests/event/test_consumer__on_datanode_written.py b/tests/event/test_consumer__on_datanode_written.py\nindex 4f26976a..a3e384b8 100644\n--- a/tests/event/test_consumer__on_datanode_written.py\n+++ b/tests/event/test_consumer__on_datanode_written.py\n@@ -15,7 +15,7 @@ from unittest.mock import ANY\n from taipy import DataNode, Gui\n from taipy.core.config import DataNodeConfig\n from taipy.core.notification import Event, EventEntityType, EventOperation\n-from taipy.event.event_consumer import EventConsumer\n+from taipy.event.event_consumer import GuiEventConsumer\n \n \n def cb_0(event: Event, datanode: DataNode, data: Any):\n@@ -31,8 +31,8 @@ def cb_for_state(state, event: Event, datanode: DataNode, data: Any):\n \n \n def test_on_datanode_written(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_written(callback=cb_0)\n         # test the on_datanode_written method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_0,\n@@ -59,8 +59,8 @@ def test_on_datanode_written(data_node):\n \n \n def test_on_datanode_written_multiple_configs(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_written(callback=cb_0,\n                                      datanode_config=[DataNodeConfig(\"dn0\"), \"dn1\", DataNodeConfig(\"dn2\"), \"data_node\"])\n         # test the on_datanode_written method delegates to on_event with the correct parameters\n@@ -88,8 +88,8 @@ def test_on_datanode_written_multiple_configs(data_node):\n \n \n def test_on_datanode_written_multiple_configs_no_matching(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_written(callback=cb_0,\n                                      datanode_config=[DataNodeConfig(\"dn0\"), \"dn1\"])\n         # test the on_datanode_written method delegates to on_event with the correct parameters\n@@ -117,8 +117,8 @@ def test_on_datanode_written_multiple_configs_no_matching(data_node):\n \n \n def test_on_datanode_written_with_args_and_matching_config(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_written(callback=cb_1, callback_args=[\"foo\"], datanode_config=\"data_node\")\n         # test the on_datanode_written method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_1,\n@@ -145,8 +145,8 @@ def test_on_datanode_written_with_args_and_matching_config(data_node):\n \n \n def test_on_datanode_written_with_args_and_not_matching_config(data_node):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_datanode_written(callback=cb_1, callback_args=[\"foo\"], datanode_config=\"WRONG_CFG\")\n         # test the on_datanode_written method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_1,\n@@ -173,9 +173,9 @@ def test_on_datanode_written_with_args_and_not_matching_config(data_node):\n \n \n def test_on_datanode_written_with_broadcast(data_node):\n-    consumer = EventConsumer(Gui())\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n-        consumer.on_datanode_written(callback=cb_for_state, broadcast=True)\n+    consumer = GuiEventConsumer(Gui())\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n+        consumer.broadcast_on_datanode_written(callback=cb_for_state)\n         mck.assert_called_once_with(callback=cb_for_state,\n                                     callback_args=None,\n                                     entity_type=EventEntityType.DATA_NODE,\n"
        },
        {
            "commit": "bbe7b82b778adbafd56d40bd00bc3aabcd5cb9c9",
            "file_path": "tests/event/test_consumer__on_event.py",
            "diff": "diff --git a/tests/event/test_consumer__on_event.py b/tests/event/test_consumer__on_event.py\nindex f8c96309..aafbceca 100644\n--- a/tests/event/test_consumer__on_event.py\n+++ b/tests/event/test_consumer__on_event.py\n@@ -14,7 +14,7 @@ import pytest\n from taipy import Gui\n from taipy.core.notification import Event, EventEntityType, EventOperation, _Topic\n from taipy.event._event_callback import _Callback\n-from taipy.event.event_consumer import EventConsumer\n+from taipy.event.event_consumer import GuiEventConsumer\n from taipy.exceptions import NoGuiDefinedInEventConsumer\n \n \n@@ -35,7 +35,7 @@ def cb_for_state(state, event: Event):\n \n \n def test_on_event():\n-    consumer = EventConsumer()\n+    consumer = GuiEventConsumer()\n     consumer.on_event(callback=cb_0, callback_args=[\"foo\"])\n     consumer.on_event(callback=cb_1, entity_type=EventEntityType.SCENARIO)\n     consumer.on_event(callback=cb_2, entity_type=EventEntityType.SCENARIO, entity_id=\"bar\")\n@@ -76,8 +76,8 @@ def test_on_event():\n \n \n def test_on_event_for_state():\n-    consumer = EventConsumer(gui=Gui())\n-    consumer.on_event(callback=cb_for_state, broadcast=True)\n+    consumer = GuiEventConsumer(gui=Gui())\n+    consumer.broadcast_on_event(callback=cb_for_state)\n \n     assert consumer._gui is not None\n     assert len(consumer._topic_callbacks_map) == 1\n@@ -87,7 +87,7 @@ def test_on_event_for_state():\n \n \n def test_on_event_missing_gui():\n-    consumer = EventConsumer()\n+    consumer = GuiEventConsumer()\n     with pytest.raises(NoGuiDefinedInEventConsumer):\n-        consumer.on_event(callback=cb_for_state, broadcast=True)\n+        consumer.broadcast_on_event(callback=cb_for_state)\n     assert len(consumer._topic_callbacks_map) == 0\n"
        },
        {
            "commit": "bbe7b82b778adbafd56d40bd00bc3aabcd5cb9c9",
            "file_path": "tests/event/test_consumer__on_scenario_created.py",
            "diff": "diff --git a/tests/event/test_consumer__on_scenario_created.py b/tests/event/test_consumer__on_scenario_created.py\nindex 5c0d0b4a..51f75890 100644\n--- a/tests/event/test_consumer__on_scenario_created.py\n+++ b/tests/event/test_consumer__on_scenario_created.py\n@@ -14,7 +14,7 @@ from unittest.mock import ANY\n from taipy import Gui, Scenario\n from taipy.core.config import ScenarioConfig\n from taipy.core.notification import Event, EventEntityType, EventOperation\n-from taipy.event.event_consumer import EventConsumer\n+from taipy.event.event_consumer import GuiEventConsumer\n \n \n def cb_0(event: Event, scenario: Scenario):\n@@ -30,8 +30,8 @@ def cb_for_state(state, event: Event, scenario: Scenario):\n \n \n def test_on_scenario_created(scenario):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_scenario_created(callback=cb_0)\n         # test the on_scenario_created method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_0,\n@@ -54,8 +54,8 @@ def test_on_scenario_created(scenario):\n \n \n def test_on_scenario_created_multiple_configs(scenario):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_scenario_created(callback=cb_0,\n                                      scenario_config=[ScenarioConfig(\"sc_0\"), \"sc_1\", ScenarioConfig(\"sc_2\"), \"sc\"])\n         # test the on_scenario_created method delegates to on_event with the correct parameters\n@@ -79,8 +79,8 @@ def test_on_scenario_created_multiple_configs(scenario):\n \n \n def test_on_scenario_created_multiple_configs_no_matching(scenario):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_scenario_created(callback=cb_0,\n                                      scenario_config=[ScenarioConfig(\"sc_0\"), \"sc_1\"])\n         # test the on_scenario_created method delegates to on_event with the correct parameters\n@@ -105,8 +105,8 @@ def test_on_scenario_created_multiple_configs_no_matching(scenario):\n \n \n def test_on_scenario_created_with_args_and_matching_config(scenario):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_scenario_created(callback=cb_1, callback_args=[\"foo\"], scenario_config=\"sc\")\n         # test the on_scenario_created method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_1,\n@@ -129,8 +129,8 @@ def test_on_scenario_created_with_args_and_matching_config(scenario):\n \n \n def test_on_scenario_created_with_args_and_not_matching_config(scenario):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_scenario_created(callback=cb_1, callback_args=[\"foo\"], scenario_config=\"WRONG_CFG\")\n         # test the on_scenario_created method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_1,\n@@ -153,9 +153,9 @@ def test_on_scenario_created_with_args_and_not_matching_config(scenario):\n \n \n def test_on_scenario_created_with_broadcast():\n-    consumer = EventConsumer(Gui())\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n-        consumer.on_scenario_created(callback=cb_for_state, broadcast=True)\n+    consumer = GuiEventConsumer(Gui())\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n+        consumer.broadcast_on_scenario_created(callback=cb_for_state)\n         mck.assert_called_once_with(callback=cb_for_state,\n                                     callback_args=None,\n                                     entity_type=EventEntityType.SCENARIO,\n"
        },
        {
            "commit": "bbe7b82b778adbafd56d40bd00bc3aabcd5cb9c9",
            "file_path": "tests/event/test_consumer__on_scenario_deleted.py",
            "diff": "diff --git a/tests/event/test_consumer__on_scenario_deleted.py b/tests/event/test_consumer__on_scenario_deleted.py\nindex 714b7726..12f51cb0 100644\n--- a/tests/event/test_consumer__on_scenario_deleted.py\n+++ b/tests/event/test_consumer__on_scenario_deleted.py\n@@ -14,7 +14,7 @@ from unittest.mock import ANY\n from taipy import Gui\n from taipy.core.config import ScenarioConfig\n from taipy.core.notification import Event, EventEntityType, EventOperation\n-from taipy.event.event_consumer import EventConsumer\n+from taipy.event.event_consumer import GuiEventConsumer\n \n \n def cb_0(event: Event, scenario: str):\n@@ -30,8 +30,8 @@ def cb_for_state(state, event: Event, scenario: str):\n \n \n def test_on_scenario_deleted(scenario):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_scenario_deleted(callback=cb_0)\n         # test the on_scenario_deleted method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_0,\n@@ -51,8 +51,8 @@ def test_on_scenario_deleted(scenario):\n \n \n def test_on_scenario_deleted_multiple_configs(scenario):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_scenario_deleted(callback=cb_0,\n                                      scenario_config=[ScenarioConfig(\"sc_0\"), \"sc_1\", ScenarioConfig(\"sc_2\"), \"sc\"])\n         # test the on_scenario_deleted method delegates to on_event with the correct parameters\n@@ -73,8 +73,8 @@ def test_on_scenario_deleted_multiple_configs(scenario):\n \n \n def test_on_scenario_deleted_multiple_configs_no_matching(scenario):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_scenario_deleted(callback=cb_0,\n                                      scenario_config=[ScenarioConfig(\"sc_0\"), \"sc_1\"])\n         # test the on_scenario_deleted method delegates to on_event with the correct parameters\n@@ -96,8 +96,8 @@ def test_on_scenario_deleted_multiple_configs_no_matching(scenario):\n \n \n def test_on_scenario_deleted_with_args_and_matching_config(scenario):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_scenario_deleted(callback=cb_1, callback_args=[\"foo\"], scenario_config=\"sc\")\n         # test the on_scenario_deleted method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_1,\n@@ -117,8 +117,8 @@ def test_on_scenario_deleted_with_args_and_matching_config(scenario):\n \n \n def test_on_scenario_deleted_with_args_and_not_matching_config(scenario):\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_scenario_deleted(callback=cb_1, callback_args=[\"foo\"], scenario_config=\"WRONG_CFG\")\n         # test the on_scenario_deleted method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_1,\n@@ -138,9 +138,9 @@ def test_on_scenario_deleted_with_args_and_not_matching_config(scenario):\n \n \n def test_on_scenario_deleted_with_broadcast(scenario):\n-    consumer = EventConsumer(Gui())\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n-        consumer.on_scenario_deleted(callback=cb_for_state, broadcast=True)\n+    consumer = GuiEventConsumer(Gui())\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n+        consumer.broadcast_on_scenario_deleted(callback=cb_for_state)\n         mck.assert_called_once_with(callback=cb_for_state,\n                                     callback_args=None,\n                                     entity_type=EventEntityType.SCENARIO,\n"
        },
        {
            "commit": "bbe7b82b778adbafd56d40bd00bc3aabcd5cb9c9",
            "file_path": "tests/event/test_consumer__on_submission_finished.py",
            "diff": "diff --git a/tests/event/test_consumer__on_submission_finished.py b/tests/event/test_consumer__on_submission_finished.py\nindex a0e35e4e..ac711351 100644\n--- a/tests/event/test_consumer__on_submission_finished.py\n+++ b/tests/event/test_consumer__on_submission_finished.py\n@@ -13,7 +13,7 @@ from unittest.mock import ANY\n \n from taipy import Gui, Scenario, Submission, SubmissionStatus\n from taipy.core.notification import Event, EventEntityType, EventOperation\n-from taipy.event.event_consumer import EventConsumer\n+from taipy.event.event_consumer import GuiEventConsumer\n \n \n def cb_0(event: Event, submittable: Scenario, submission: Submission):\n@@ -30,8 +30,8 @@ def cb_for_state(state, event: Event, submittable: Scenario, submission: Submiss\n \n def test_on_scenario_submission_finished(scenario, submission):\n     submission._entity_id = scenario.id\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_submission_finished(callback=cb_0)\n         # test the on_submission_finished method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_0,\n@@ -87,8 +87,8 @@ def test_on_scenario_submission_finished(scenario, submission):\n \n def test_filter_false__wrong_status(scenario, submission):\n     submission._entity_id = scenario.id\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_submission_finished(callback=cb_0)\n         # test the on_submission_finished method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_0,\n@@ -127,8 +127,8 @@ def test_filter_false__wrong_status(scenario, submission):\n \n def test_filter_false__config_ids_and_sequence(scenario, sequence, submission):\n     submission._entity_id = sequence.id\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_submission_finished(callback=cb_0, config_ids=scenario.config_id)\n         # test the on_submission_finished method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_0,\n@@ -160,8 +160,8 @@ def test_filter_false__config_ids_and_sequence(scenario, sequence, submission):\n def test_filter_false__not_matching_config_ids(scenario, submission):\n     submission._entity_id = scenario.id\n     submission._entity_config_id = scenario.config_id\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_submission_finished(callback=cb_0, config_ids=[\"NOT_MATCHING_CONFIG_ID\"])\n         # test the on_submission_finished method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_0,\n@@ -194,8 +194,8 @@ def test_filter_false__not_matching_config_ids(scenario, submission):\n def test_filter_true__with_config(scenario, submission):\n     submission._entity_id = scenario.id\n     submission._entity_config_id = scenario.config_id\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_submission_finished(callback=cb_0, config_ids=[\"scenario_cfg\", scenario.config_id])\n         # test the on_submission_finished method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_0,\n@@ -226,8 +226,8 @@ def test_filter_true__with_config(scenario, submission):\n \n def test_filter_true__without_config(scenario, submission):\n     submission._entity_id = scenario.id\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_submission_finished(callback=cb_0)\n         # test the on_submission_finished method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_0,\n@@ -257,8 +257,8 @@ def test_filter_true__without_config(scenario, submission):\n \n \n def test_on_scenario_submission_finished_with_args():\n-    consumer = EventConsumer()\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n+    consumer = GuiEventConsumer()\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n         consumer.on_submission_finished(callback=cb_1, callback_args=[\"extra\"])\n         # test the on_submission_finished method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_1,\n@@ -271,9 +271,9 @@ def test_on_scenario_submission_finished_with_args():\n \n \n def test_on_scenario_submission_finished_with_args_and_state():\n-    consumer = EventConsumer(gui=Gui())\n-    with mock.patch(\"taipy.event.event_consumer.EventConsumer.on_event\") as mck:\n-        consumer.on_submission_finished(callback=cb_for_state, callback_args=[\"extra\"], broadcast=True)\n+    consumer = GuiEventConsumer(gui=Gui())\n+    with mock.patch(\"taipy.event.event_consumer.GuiEventConsumer._GuiEventConsumer__on_event\") as mck:\n+        consumer.broadcast_on_submission_finished(callback=cb_for_state, callback_args=[\"extra\"])\n         # test the on_submission_finished method delegates to on_event with the correct parameters\n         mck.assert_called_once_with(callback=cb_for_state,\n                                     callback_args=[\"extra\"],\n"
        },
        {
            "commit": "bbe7b82b778adbafd56d40bd00bc3aabcd5cb9c9",
            "file_path": "tests/event/test_consumer__process_event.py",
            "diff": "diff --git a/tests/event/test_consumer__process_event.py b/tests/event/test_consumer__process_event.py\nindex 524e792c..5f6552e5 100644\n--- a/tests/event/test_consumer__process_event.py\n+++ b/tests/event/test_consumer__process_event.py\n@@ -14,7 +14,7 @@ from unittest import mock\n from taipy import Gui, Scenario\n from taipy.core.notification import Event, EventEntityType, EventOperation, _Topic\n from taipy.event._event_callback import _Callback\n-from taipy.event.event_consumer import EventConsumer\n+from taipy.event.event_consumer import GuiEventConsumer\n \n collector: Dict[str, Any] = {\"cb_0\": 0, \"cb_1\": 0, \"cb_2\": 0, \"cb_3\": 0, \"cb_for_state\": 0,\n             \"cb_scenario_creation\": 0, \"cb_scenario_creation_with_state\": 0}\n@@ -26,7 +26,7 @@ def init_collector():\n             \"cb_scenario_creation\": 0, \"cb_scenario_creation_with_state\": 0}, {}\n \n \n-def cb_0(gui: Optional[Gui], event: Event, extra:str):\n+def cb_0(event: Event, gui: Optional[Gui], extra:str):\n     collector[\"cb_0\"]+=1\n     if not args_collector.get(\"cb_0\"):\n         args_collector[\"cb_0\"] = [extra]\n@@ -35,17 +35,17 @@ def cb_0(gui: Optional[Gui], event: Event, extra:str):\n     print(f\"event created at {event.creation_date} triggered callback cb_0.\")  # noqa: T201\n \n \n-def cb_1(gui: Optional[Gui], event: Event):\n+def cb_1(event: Event, gui: Optional[Gui]):\n     collector[\"cb_1\"]+=1\n     print(f\"event created at {event.creation_date} triggered callback cb_1.\")  # noqa: T201\n \n \n-def cb_2(gui: Optional[Gui], event: Event):\n+def cb_2(event: Event, gui: Gui,):\n     collector[\"cb_2\"]+=1\n     print(f\"event created at {event.creation_date} triggered callback cb_2.\")  # noqa: T201\n \n \n-def cb_3(gui: Optional[Gui], event: Event):\n+def cb_3(event: Event, gui: Gui, ):\n     collector[\"cb_3\"]+=1\n     print(f\"event created at {event.creation_date} triggered callback cb_3.\")  # noqa: T201\n \n@@ -55,7 +55,7 @@ def cb_for_state(state, event: Event):\n     print(f\"event created at {event.creation_date} triggered callback cb_for_state.\")  # noqa: T201\n \n \n-def cb_scenario_creation(gui: Optional[Gui], event: Event, scenario: Scenario, extra_arg: str):\n+def cb_scenario_creation(event: Event, scenario: Scenario, gui: Gui, extra_arg: str):\n     collector[\"cb_scenario_creation\"]+=1\n     print(f\"scenario {scenario.id} created at {event.creation_date} with {extra_arg}.\")  # noqa: T201\n \n@@ -69,7 +69,7 @@ def cb_scenario_creation_with_state(state, event: Event, scenario: Scenario, ext\n def test_process_event(scenario):\n     global collector\n     global args_collector\n-    consumer = EventConsumer()\n+    consumer = GuiEventConsumer()\n     consumer.on_event(callback=cb_0, callback_args=[\"foo\"])\n     consumer.on_event(callback=cb_1, entity_type=EventEntityType.SCENARIO)\n     consumer.on_event(callback=cb_2, entity_type=EventEntityType.SCENARIO, entity_id=\"bar\")\n@@ -131,8 +131,8 @@ def test_process_event(scenario):\n \n \n def test_process_event_with_state():\n-    consumer = EventConsumer(gui=Gui())\n-    consumer.on_event(callback=cb_for_state, broadcast=True)\n+    consumer = GuiEventConsumer(gui=Gui())\n+    consumer.broadcast_on_event(callback=cb_for_state)\n \n     event_1 = Event(\n         entity_type=EventEntityType.SCENARIO,\n@@ -153,13 +153,12 @@ def test_process_event_with_filter():\n     def filt(event: Event) -> bool:\n         return event.metadata.get(\"foo\") == \"bar\"\n \n-    consumer = EventConsumer()\n+    consumer = GuiEventConsumer()\n     consumer.on_event(callback=cb_0,\n                       callback_args=[\"foo\"],\n                       entity_type=EventEntityType.SCENARIO,\n                       operation=EventOperation.CREATION,\n-                      filter=filt,\n-                      broadcast=False)\n+                      filter=filt)\n \n     topic = _Topic(entity_type=EventEntityType.SCENARIO, operation=EventOperation.CREATION)\n     assert len(consumer._topic_callbacks_map) == 1\n@@ -190,7 +189,7 @@ def test_process_event_with_filter():\n def test_process_event_with_predefined_args(scenario):\n     global collector\n     global args_collector\n-    consumer = EventConsumer()\n+    consumer = GuiEventConsumer()\n     consumer.on_event(callback=cb_scenario_creation, callback_args=[\"foo\"])\n     collector, args_collector = init_collector()\n     event = Event(\n@@ -208,8 +207,8 @@ def test_process_event_with_predefined_args(scenario):\n \n \n def test_process_event_with_predefined_args_and_state(scenario):\n-    consumer = EventConsumer(Gui())\n-    consumer.on_event(callback=cb_scenario_creation_with_state, callback_args=[\"foo\"], broadcast=True)\n+    consumer = GuiEventConsumer(Gui())\n+    consumer.broadcast_on_event(callback=cb_scenario_creation_with_state, callback_args=[\"foo\"])\n     event = Event(\n         entity_type=EventEntityType.SCENARIO,\n         operation=EventOperation.CREATION,\n"
        }
    ]
}
{
    "sha_fail": "4d5898b8a73c93e1ed4434744c2fa7c3f7fbd501",
    "changed_files": [
        {
            "commit": "4d5898b8a73c93e1ed4434744c2fa7c3f7fbd501",
            "file_path": "cloudinit/distros/__init__.py",
            "diff": "diff --git a/cloudinit/distros/__init__.py b/cloudinit/distros/__init__.py\nindex e1b4c864..5c891f26 100644\n--- a/cloudinit/distros/__init__.py\n+++ b/cloudinit/distros/__init__.py\n@@ -147,7 +147,6 @@ class Distro(persistence.CloudInitPickleMixin, metaclass=abc.ABCMeta):\n     resolve_conf_fn = \"/etc/resolv.conf\"\n \n     osfamily: str\n-    dhcp_client_priority = [dhcp.IscDhclient, dhcp.Dhcpcd, dhcp.Udhcpc]\n     # Directory where the distro stores their DHCP leases.\n     # The children classes should override this with their dhcp leases\n     # directory\n@@ -170,7 +169,7 @@ class Distro(persistence.CloudInitPickleMixin, metaclass=abc.ABCMeta):\n         self.net_ops = iproute2.Iproute2\n         self._runner = helpers.Runners(paths)\n         self.package_managers: List[PackageManager] = []\n-        self._selected_dhcp_client = None\n+        self._dhcp_client = None\n \n     def _unpickle(self, ci_pkl_version: int) -> None:\n         \"\"\"Perform deserialization fixes for Distro.\"\"\"\n@@ -277,19 +276,28 @@ class Distro(persistence.CloudInitPickleMixin, metaclass=abc.ABCMeta):\n \n     @property\n     def dhcp_client(self) -> dhcp.DhcpClient:\n-        \"\"\"distros set priority list, select based on this order which to use\n+        \"\"\"access the distro's preferred dhcp client\n \n-        If the priority dhcp client isn't found, fall back to lower in list.\n+        if no client has been selected yet select one - uses\n+        self.dhcp_client_priority, which may be overriden in each distro's\n+        object to eliminate checking for clients which will not be provided\n+        by the distro\n         \"\"\"\n-        if self._selected_dhcp_client:\n-            return self._selected_dhcp_client\n+        if self._dhcp_client:\n+            return self._dhcp_client\n+        self._select_dhcp_client()\n+        return self._dhcp_client\n+\n+    def _select_dhcp_client(self) -> dhcp.DhcpClient:\n+        if self._dhcp_client:\n+            return self._dhcp_client\n         for client in self.dhcp_client_priority:\n             try:\n-                self._selected_dhcp_client = client()\n+                self._dhcp_client = client()\n                 LOG.debug(\"DHCP client selected: %s\", client.client_name)\n-                return self._selected_dhcp_client\n+                return self._dhcp_client\n             except (dhcp.NoDHCPLeaseMissingDhclientError,):\n-                LOG.warning(\"DHCP client not found: %s\", client.client_name)\n+                LOG.debug(\"DHCP client not found: %s\", client.client_name)\n         raise dhcp.NoDHCPLeaseMissingDhclientError()\n \n     @property\n"
        },
        {
            "commit": "4d5898b8a73c93e1ed4434744c2fa7c3f7fbd501",
            "file_path": "cloudinit/net/dhcp.py",
            "diff": "diff --git a/cloudinit/net/dhcp.py b/cloudinit/net/dhcp.py\nindex 5da8f756..9c94b3f9 100644\n--- a/cloudinit/net/dhcp.py\n+++ b/cloudinit/net/dhcp.py\n@@ -13,7 +13,7 @@ import signal\n import time\n from contextlib import suppress\n from io import StringIO\n-from typing import Any, Dict, List, Tuple\n+from typing import Any, Callable, Dict, List, Optional, Tuple\n \n import configobj\n \n@@ -85,10 +85,6 @@ class NoDHCPLeaseMissingDhclientError(NoDHCPLeaseError):\n     \"\"\"Raised when unable to find dhclient.\"\"\"\n \n \n-class NoDHCPLeaseMissingUdhcpcError(NoDHCPLeaseError):\n-    \"\"\"Raised when unable to find udhcpc client.\"\"\"\n-\n-\n def maybe_perform_dhcp_discovery(distro, nic=None, dhcp_log_func=None):\n     \"\"\"Perform dhcp discovery if nic valid and dhclient command exists.\n \n@@ -201,19 +197,24 @@ class IscDhclient(DhcpClient):\n         self.lease_file = \"/run/dhclient.lease\"\n \n     @staticmethod\n-    def parse_leases(lease_content) -> List[Dict]:\n+    def parse_leases(lease_content: str) -> List[Dict[str, Any]]:\n+        \"\"\"parse the content of a lease file\n+\n+        @param lease_content: a string containing the contents of an\n+                              isc-dhclient lease\n+        @return: a list of leases, most recent last\n+        \"\"\"\n         lease_regex = re.compile(r\"lease {(?P<lease>.*?)}\\n\", re.DOTALL)\n-        dhcp_leases = []\n+        dhcp_leases: List[Dict] = []\n         if len(lease_content) == 0:\n-            return dhcp_leases\n+            return []\n         for lease in lease_regex.findall(lease_content):\n             lease_options = []\n             for line in lease.split(\";\"):\n                 # Strip newlines, double-quotes and option prefix\n                 line = line.strip().replace('\"', \"\").replace(\"option \", \"\")\n-                if not line:\n-                    continue\n-                lease_options.append(line.split(\" \", 1))\n+                if line:\n+                    lease_options.append(line.split(\" \", 1))\n             dhcp_leases.append(dict(lease_options))\n         return dhcp_leases\n \n@@ -223,33 +224,36 @@ class IscDhclient(DhcpClient):\n         Return a dict of dhcp options. The dict contains key value\n         pairs from the most recent lease.\n \n-        @raises: InvalidDHCPLeaseFileError on empty of unparseable leasefile\n+        @param distro: a distro object - not used in this class, but required\n+                       for function signature compatibility with other classes\n+                       that require a distro object\n+        @raises: InvalidDHCPLeaseFileError on empty or unparseable leasefile\n             content.\n         \"\"\"\n-        content = util.load_file(self.lease_file)\n-        if content:\n-            dhcp_leases = self.parse_leases(content)\n-            if dhcp_leases:\n-                return dhcp_leases[-1]\n-        raise InvalidDHCPLeaseFileError(\n-            f\"Cannot parse dhcp lease file. No leases found {self.lease_file}\"\n-        )\n+        with suppress(FileNotFoundError):\n+            content: str\n+            content = util.load_file(self.lease_file)  # pyright: ignore\n+            if content:\n+                dhcp_leases = self.parse_leases(content)\n+                if dhcp_leases:\n+                    return dhcp_leases[-1]\n+        return {}\n \n     def dhcp_discovery(\n         self,\n-        interface,\n-        dhcp_log_func=None,\n+        interface: str,\n+        dhcp_log_func: Optional[Callable] = None,\n         distro=None,\n-    ):\n+    ) -> Dict[str, Any]:\n         \"\"\"Run dhclient on the interface without scripts/filesystem artifacts.\n \n-        @param dhclient_cmd_path: Full path to the dhclient used.\n-        @param interface: Name of the network interface on which to dhclient.\n+        @param interface: Name of the network interface on which to send a\n+                          dhcp request\n         @param dhcp_log_func: A callable accepting the dhclient output and\n-            error streams.\n-\n-        @return: A list of dicts of representing the dhcp leases parsed from\n-            the dhclient.lease file or empty list.\n+                              error streams.\n+        @param distro: a distro object for network interface manipulation\n+        @return: dict of lease options representing the most recent dhcp lease\n+                 parsed from the dhclient.lease file\n         \"\"\"\n         LOG.debug(\"Performing a dhcp discovery on %s\", interface)\n \n@@ -321,10 +325,11 @@ class IscDhclient(DhcpClient):\n                 \"dhclient did not produce expected files: %s\",\n                 \", \".join(os.path.basename(f) for f in missing),\n             )\n-            return []\n+            return {}\n \n         ppid = \"unknown\"\n         daemonized = False\n+        pid_content = None\n         for _ in range(1000):\n             pid_content = util.load_file(pid_file).strip()\n             try:\n@@ -350,7 +355,10 @@ class IscDhclient(DhcpClient):\n             )\n         if dhcp_log_func is not None:\n             dhcp_log_func(out, err)\n-        return self.get_newest_lease(distro)\n+        lease = self.get_newest_lease(distro)\n+        if lease:\n+            return lease\n+        raise InvalidDHCPLeaseFileError()\n \n     @staticmethod\n     def parse_static_routes(routes: str) -> List[Tuple[str, str]]:\n@@ -460,15 +468,22 @@ class IscDhclient(DhcpClient):\n         return static_routes\n \n     @staticmethod\n-    def get_latest_lease(lease_dir, lease_file_regex):\n-        \"\"\"used for getting leases managed by distro network managers, doesn't\n-        consider ephemeral lease\n+    def get_newest_lease_file_from_distro(distro) -> Optional[str]:\n+        \"\"\"Get the latest lease file from a distro-managed dhclient\n+\n+        Doesn't consider the ephemeral timeframe lease.\n+\n+        @param distro: used for distro-specific lease location and filename\n+        @return: The most recent lease file, or None\n         \"\"\"\n         latest_file = None\n \n         # Try primary dir/regex, then the fallback ones\n         for directory, regex in (\n-            (lease_dir, lease_file_regex),\n+            (\n+                distro.dhclient_lease_directory,\n+                distro.dhclient_lease_file_regex,\n+            ),\n             (DHCLIENT_FALLBACK_LEASE_DIR, DHCLIENT_FALLBACK_LEASE_REGEX),\n         ):\n             if not directory:\n@@ -480,7 +495,7 @@ class IscDhclient(DhcpClient):\n             except FileNotFoundError:\n                 continue\n \n-            latest_mtime = -1\n+            latest_mtime = -1.0\n             for fname in lease_files:\n                 if not re.search(regex, fname):\n                     continue\n@@ -496,6 +511,26 @@ class IscDhclient(DhcpClient):\n                 return latest_file\n         return None\n \n+    def get_key_from_latest_lease(self, distro, key: str):\n+        \"\"\"Get a key from the latest lease from distro-managed dhclient\n+\n+        Doesn't consider the ephemeral timeframe lease.\n+\n+        @param lease_dir: distro-specific lease to check\n+        @param lease_file_regex: distro-specific regex to match lease name\n+        @return: The most recent lease file, or None\n+        \"\"\"\n+        lease_file = self.get_newest_lease_file_from_distro(distro)\n+        if lease_file:\n+            with suppress(FileNotFoundError):\n+                content: str\n+                content = util.load_file(lease_file)  # pyright: ignore\n+                if content:\n+                    for lease in reversed(self.parse_leases(content)):\n+                        server = lease.get(key)\n+                        if server:\n+                            return server\n+\n \n class Dhcpcd(DhcpClient):\n     client_name = \"dhcpcd\"\n@@ -505,19 +540,19 @@ class Dhcpcd(DhcpClient):\n \n     def dhcp_discovery(\n         self,\n-        interface,\n-        dhcp_log_func=None,\n+        interface: str,\n+        dhcp_log_func: Optional[Callable] = None,\n         distro=None,\n-    ):\n-        \"\"\"Run dhclient on the interface without scripts/filesystem artifacts.\n-\n-        @param dhclient_cmd_path: Full path to the dhclient used.\n-        @param interface: Name of the network interface on which to dhclient.\n-        @param dhcp_log_func: A callable accepting the dhclient output and\n-            error streams.\n-\n-        @return: A list of dicts of representing the dhcp leases parsed from\n-            the dhclient.lease file or empty list.\n+    ) -> Dict[str, Any]:\n+        \"\"\"Run dhcpcd on the interface without scripts/filesystem artifacts.\n+\n+        @param interface: Name of the network interface on which to send a\n+                          dhcp request\n+        @param dhcp_log_func: A callable accepting the client output and\n+                              error streams.\n+        @param distro: a distro object for network interface manipulation\n+        @return: dict of lease options representing the most recent dhcp lease\n+                 parsed from the dhclient.lease file\n         \"\"\"\n         LOG.debug(\"Performing a dhcp discovery on %s\", interface)\n \n@@ -531,7 +566,7 @@ class Dhcpcd(DhcpClient):\n         # /lib/dhcpcd/dhcpcd-hooks/ and pass each of those with the --nohook\n         # argument to dhcpcd\n         try:\n-            subp.subp(\n+            out, err = subp.subp(\n                 [\n                     self.client_name,\n                     \"--oneshot\",  # get lease then exit\n@@ -543,7 +578,13 @@ class Dhcpcd(DhcpClient):\n                     interface,\n                 ]\n             )\n-            return self.get_newest_lease(distro)\n+            if dhcp_log_func is not None:\n+                dhcp_log_func(out, err)\n+            lease = self.get_newest_lease(distro)\n+            if lease:\n+                return lease\n+            raise NoDHCPLeaseError(\"No lease found\")\n+\n         except subp.ProcessExecutionError as error:\n             LOG.debug(\n                 \"dhclient exited with code: %s stderr: %r stdout: %r\",\n@@ -584,7 +625,7 @@ class Dhcpcd(DhcpClient):\n             ]\n         )\n \n-        # this is expected by cloud-init code, we can probably change that\n+        # this is expected by cloud-init's code\n         lease[\"interface\"] = interface\n \n         # transform underscores to hyphens\n@@ -604,7 +645,7 @@ class Dhcpcd(DhcpClient):\n         return lease\n \n     def get_newest_lease(self, distro) -> Dict[str, Any]:\n-        \"\"\"Return a list of leases\n+        \"\"\"Return a lease\n \n         Return a list of dicts of dhcp options. Each dict contains key value\n         pairs a specific lease in order from oldest to newest.\n@@ -657,12 +698,10 @@ class Dhcpcd(DhcpClient):\n             (\"169.63.129.16/32\", \"10.0.0.1\"),\n         ]\n         \"\"\"\n-        route_list = routes.split()\n-        if not len(route_list) % 2:\n-            return [\n-                (route_list[i], route_list[i + 1])\n-                for i in range(0, len(route_list), 2)\n-            ]\n+        static_routes = routes.split()\n+        if static_routes:\n+            # format: dest1/mask gw1 ... destn/mask gwn\n+            return [i for i in zip(static_routes[::2], static_routes[1::2])]\n         LOG.warning(\"Malformed classless static routes: [%s]\", routes)\n         return []\n \n@@ -676,18 +715,17 @@ class Udhcpc(DhcpClient):\n \n     def dhcp_discovery(\n         self,\n-        interface,\n-        dhcp_log_func=None,\n+        interface: str,\n+        dhcp_log_func: Optional[Callable] = None,\n         distro=None,\n-    ):\n+    ) -> Dict[str, Any]:\n         \"\"\"Run udhcpc on the interface without scripts or filesystem artifacts.\n \n         @param interface: Name of the network interface on which to run udhcpc.\n         @param dhcp_log_func: A callable accepting the udhcpc output and\n-            error streams.\n-\n+                              error streams.\n         @return: A list of dicts of representing the dhcp leases parsed from\n-            the udhcpc lease file.\n+                 the udhcpc lease file.\n         \"\"\"\n         LOG.debug(\"Performing a dhcp discovery on %s\", interface)\n \n@@ -746,6 +784,17 @@ class Udhcpc(DhcpClient):\n         return self.get_newest_lease(distro)\n \n     def get_newest_lease(self, distro) -> Dict[str, Any]:\n+        \"\"\"Get the most recent lease from the ephemeral phase as a dict.\n+\n+        Return a dict of dhcp options. The dict contains key value\n+        pairs from the most recent lease.\n+\n+        @param distro: a distro object - not used in this class, but required\n+                       for function signature compatibility with other classes\n+                       that require a distro object\n+        @raises: InvalidDHCPLeaseFileError on empty or unparseable leasefile\n+            content.\n+        \"\"\"\n         lease_json = util.load_json(util.load_file(self.lease_file))\n         static_routes = lease_json[\"static_routes\"].split()\n         if static_routes:\n"
        },
        {
            "commit": "4d5898b8a73c93e1ed4434744c2fa7c3f7fbd501",
            "file_path": "cloudinit/sources/DataSourceCloudStack.py",
            "diff": "diff --git a/cloudinit/sources/DataSourceCloudStack.py b/cloudinit/sources/DataSourceCloudStack.py\nindex c66bc154..6c1c1d76 100644\n--- a/cloudinit/sources/DataSourceCloudStack.py\n+++ b/cloudinit/sources/DataSourceCloudStack.py\n@@ -23,7 +23,6 @@ from cloudinit import sources, subp\n from cloudinit import url_helper as uhelp\n from cloudinit import util\n from cloudinit.net import dhcp\n-from cloudinit.net.dhcp import InvalidDHCPLeaseFileError\n from cloudinit.sources.helpers import ec2\n \n LOG = logging.getLogger(__name__)\n@@ -115,22 +114,18 @@ class DataSourceCloudStack(sources.DataSource):\n         # some distros might use isc-dhclient for network setup via their\n         # network manager. If this happens, the lease is more recent than the\n         # ephemeral lease, so use it first.\n-        lease_file = dhcp.IscDhclient.get_latest_lease(\n-            self.distro.dhclient_lease_directory,\n-            self.distro.dhclient_lease_file_regex,\n+        with suppress(dhcp.NoDHCPLeaseMissingDhclientError):\n+            domain_name = dhcp.IscDhclient().get_key_from_latest_lease(\n+                self.distro, \"domain-name\"\n+            )\n+            if domain_name:\n+                return domain_name\n+\n+        LOG.debug(\n+            \"Could not obtain FQDN from ISC dhclient leases. \"\n+            \"Falling back to %s\",\n+            self.distro.dhcp_client.client_name,\n         )\n-        if lease_file:\n-            with suppress(FileNotFoundError), open(lease_file, \"r\"):\n-                latest_lease = dhcp.IscDhclient.parse_leases(\n-                    util.load_file(lease_file)\n-                )\n-                if not latest_lease:\n-                    raise InvalidDHCPLeaseFileError(\n-                        \"Cannot parse empty dhcp lease file {0}\".format(\n-                            lease_file\n-                        )\n-                    )\n-                return latest_lease[-1].get(\"domain-name\") or None\n \n         # If no distro leases were found, check the ephemeral lease that\n         # cloud-init set up.\n@@ -308,21 +303,25 @@ def get_vr_address(distro):\n         return latest_address\n \n     # Try dhcp lease files next\n-    # get_latest_lease() needs a Distro object to know which directory\n+    # get_key_from_latest_lease() needs a Distro object to know which directory\n     # stores lease files\n-    lease_file = dhcp.IscDhclient.get_latest_lease(\n-        distro.dhclient_lease_directory, distro.dhclient_lease_file_regex\n-    )\n-\n-    if lease_file:\n-        latest_address = dhcp.IscDhclient.parse_dhcp_server_from_lease_file(\n-            lease_file\n+    with suppress(dhcp.NoDHCPLeaseMissingDhclientError):\n+        latest_address = dhcp.IscDhclient().get_key_from_latest_lease(\n+            distro, \"dhcp-server-identifier\"\n         )\n         if latest_address:\n+            LOG.debug(\"Found SERVER_ADDRESS '%s' via dhclient\", latest_address)\n             return latest_address\n-    latest_lease = distro.dhcp_client.get_newest_lease(distro)\n-    if latest_lease:\n-        return latest_address\n+\n+    with suppress(FileNotFoundError):\n+        latest_lease = distro.dhcp_client.get_newest_lease(distro)\n+        if latest_lease:\n+            LOG.debug(\n+                \"Found SERVER_ADDRESS '%s' via ephemeral %s lease \",\n+                latest_lease,\n+                distro.dhcp_client.client_name,\n+            )\n+            return latest_lease\n \n     # No virtual router found, fallback to default gateway\n     LOG.debug(\"No DHCP found, using default gateway\")\n"
        },
        {
            "commit": "4d5898b8a73c93e1ed4434744c2fa7c3f7fbd501",
            "file_path": "cloudinit/util.py",
            "diff": "diff --git a/cloudinit/util.py b/cloudinit/util.py\nindex 6401a196..dda65378 100644\n--- a/cloudinit/util.py\n+++ b/cloudinit/util.py\n@@ -124,14 +124,14 @@ def lsb_release():\n     return data\n \n \n-def decode_binary(blob, encoding=\"utf-8\"):\n+def decode_binary(blob, encoding=\"utf-8\") -> str:\n     # Converts a binary type into a text type using given encoding.\n     if isinstance(blob, str):\n         return blob\n     return blob.decode(encoding)\n \n \n-def encode_text(text, encoding=\"utf-8\"):\n+def encode_text(text, encoding=\"utf-8\") -> bytes:\n     # Converts a text string into a binary type using given encoding.\n     if isinstance(text, bytes):\n         return text\n"
        },
        {
            "commit": "4d5898b8a73c93e1ed4434744c2fa7c3f7fbd501",
            "file_path": "tests/unittests/net/test_dhcp.py",
            "diff": "diff --git a/tests/unittests/net/test_dhcp.py b/tests/unittests/net/test_dhcp.py\nindex 91790a9f..ffa3eab1 100644\n--- a/tests/unittests/net/test_dhcp.py\n+++ b/tests/unittests/net/test_dhcp.py\n@@ -71,20 +71,18 @@ class TestParseDHCPServerFromLeaseFile:\n                     \"dhcp-server-identifier\"\n                 )\n         else:\n-            with pytest.raises(FileNotFoundError):\n-                dhclient.get_newest_lease(\"eth0\").get(\"dhcp-server-identifier\")\n+            assert None is dhclient.get_newest_lease(\"eth0\").get(\n+                \"dhcp-server-identifier\"\n+            )\n \n \n class TestParseDHCPLeasesFile(CiTestCase):\n     def test_parse_empty_lease_file_errors(self):\n         \"\"\"get_newest_lease errors when file content is empty.\"\"\"\n-        with self.assertRaises(InvalidDHCPLeaseFileError) as context_manager:\n-            client = IscDhclient()\n-            client.lease_file = self.tmp_path(\"leases\")\n-            ensure_file(client.lease_file)\n-            client.get_newest_lease(\"eth0\")\n-        error = context_manager.exception\n-        self.assertIn(\"Cannot parse dhcp lease file\", str(error))\n+        client = IscDhclient()\n+        client.lease_file = self.tmp_path(\"leases\")\n+        ensure_file(client.lease_file)\n+        assert not client.get_newest_lease(\"eth0\")\n \n     def test_parse_malformed_lease_file_content_errors(self):\n         \"\"\"IscDhclient.get_newest_lease errors when file content isn't\n@@ -93,10 +91,7 @@ class TestParseDHCPLeasesFile(CiTestCase):\n         client = IscDhclient()\n         client.lease_file = self.tmp_path(\"leases\")\n         write_file(client.lease_file, \"hi mom.\")\n-        with self.assertRaises(InvalidDHCPLeaseFileError) as context_manager:\n-            client.get_newest_lease(\"eth0\")\n-        error = context_manager.exception\n-        self.assertIn(\"Cannot parse dhcp lease file\", str(error))\n+        assert not client.get_newest_lease(\"eth0\")\n \n     def test_parse_multiple_leases(self):\n         \"\"\"IscDhclient().get_newest_lease returns the latest lease\n@@ -416,7 +411,8 @@ class TestDHCPDiscoveryClean(CiTestCase):\n     @mock.patch(\"cloudinit.net.dhcp.subp.subp\")\n     @mock.patch(\"cloudinit.net.dhcp.subp.which\")\n     def test_dhcp_client_failover(self, m_which, m_subp, m_remove, m_fallback):\n-        \"\"\"Log and do nothing when nic is absent and no fallback is found.\"\"\"\n+        \"\"\"Log and do nothing when nic is absent and no fallback client is\n+        found.\"\"\"\n         m_subp.side_effect = [\n             (\"\", \"\"),\n             subp.ProcessExecutionError(exit_code=-5),\n@@ -430,6 +426,14 @@ class TestDHCPDiscoveryClean(CiTestCase):\n             \"DHCP client not found: dhclient\",\n             self.logs.getvalue(),\n         )\n+        self.assertIn(\n+            \"DHCP client not found: dhcpcd\",\n+            self.logs.getvalue(),\n+        )\n+        self.assertIn(\n+            \"DHCP client not found: udhcpc\",\n+            self.logs.getvalue(),\n+        )\n \n     @mock.patch(\"cloudinit.net.dhcp.find_fallback_nic\", return_value=None)\n     def test_provided_nic_does_not_exist(self, m_fallback_nic):\n@@ -528,7 +532,7 @@ class TestDHCPDiscoveryClean(CiTestCase):\n         m_wait.return_value = [PID_F]  # Return the missing pidfile wait for\n         m_getppid.return_value = 1  # Indicate that dhclient has daemonized\n         self.assertEqual(\n-            [], IscDhclient().dhcp_discovery(\"eth9\", distro=MockDistro())\n+            {}, IscDhclient().dhcp_discovery(\"eth9\", distro=MockDistro())\n         )\n         self.assertEqual(\n             mock.call([PID_F, LEASE_F], maxwait=5, naplen=0.01),\n@@ -1106,16 +1110,13 @@ class TestISCDHClient(CiTestCase):\n         ),\n     )\n     @mock.patch(\"os.path.getmtime\", return_value=123.45)\n-    def test_get_latest_lease_rhel(self, *_):\n+    def test_get_newest_lease_file_from_distro_rhel(self, *_):\n         \"\"\"\n         Test that an rhel style lease has been found\n         \"\"\"\n         self.assertEqual(\n             \"/var/lib/NetworkManager/dhclient-0-u-u-i-d-enp2s0f0.lease\",\n-            IscDhclient.get_latest_lease(\n-                rhel.Distro.dhclient_lease_directory,\n-                rhel.Distro.dhclient_lease_file_regex,\n-            ),\n+            IscDhclient.get_newest_lease_file_from_distro(rhel.Distro),\n         )\n \n     @mock.patch(\n@@ -1128,16 +1129,13 @@ class TestISCDHClient(CiTestCase):\n         ),\n     )\n     @mock.patch(\"os.path.getmtime\", return_value=123.45)\n-    def test_get_latest_lease_amazonlinux(self, *_):\n+    def test_get_newest_lease_file_from_distro_amazonlinux(self, *_):\n         \"\"\"\n         Test that an amazon style lease has been found\n         \"\"\"\n         self.assertEqual(\n             \"/var/lib/dhcp/dhclient--eth0.leases\",\n-            IscDhclient.get_latest_lease(\n-                amazon.Distro.dhclient_lease_directory,\n-                amazon.Distro.dhclient_lease_file_regex,\n-            ),\n+            IscDhclient.get_newest_lease_file_from_distro(amazon.Distro),\n         )\n \n     @mock.patch(\n@@ -1150,16 +1148,13 @@ class TestISCDHClient(CiTestCase):\n         ),\n     )\n     @mock.patch(\"os.path.getmtime\", return_value=123.45)\n-    def test_get_latest_lease_freebsd(self, *_):\n+    def test_get_newest_lease_file_from_distro_freebsd(self, *_):\n         \"\"\"\n         Test that an freebsd style lease has been found\n         \"\"\"\n         self.assertEqual(\n             \"/var/db/dhclient.leases.vtynet0\",\n-            IscDhclient.get_latest_lease(\n-                freebsd.Distro.dhclient_lease_directory,\n-                freebsd.Distro.dhclient_lease_file_regex,\n-            ),\n+            IscDhclient.get_newest_lease_file_from_distro(freebsd.Distro),\n         )\n \n     @mock.patch(\n@@ -1172,40 +1167,13 @@ class TestISCDHClient(CiTestCase):\n         ),\n     )\n     @mock.patch(\"os.path.getmtime\", return_value=123.45)\n-    def test_get_latest_lease_debian(self, *_):\n+    def test_get_newest_lease_file_from_distro_debian(self, *_):\n         \"\"\"\n         Test that an debian style lease has been found\n         \"\"\"\n         self.assertEqual(\n             \"/var/lib/dhcp/dhclient.eth0.leases\",\n-            IscDhclient.get_latest_lease(\n-                debian.Distro.dhclient_lease_directory,\n-                debian.Distro.dhclient_lease_file_regex,\n-            ),\n-        )\n-\n-    @mock.patch(\n-        \"os.listdir\",\n-        return_value=(\n-            \"some_file\",\n-            \"!@#$-eth0.lease\",\n-            \"some_other_file\",\n-        ),\n-    )\n-    @mock.patch(\"os.path.getmtime\", return_value=123.45)\n-    def test_no_distro_hints_fallback(self, *_):\n-        \"\"\"\n-        This tests a situation where Distro doesn't provide\n-        hints for dhclient leases.\n-        The code should resort to hardcoded lease location\n-        \"\"\"\n-        # Provide lease_dir and regex as None\n-        self.assertEqual(\n-            os.path.join(DHCLIENT_FALLBACK_LEASE_DIR, \"!@#$-eth0.lease\"),\n-            IscDhclient.get_latest_lease(\n-                None,\n-                None,\n-            ),\n+            IscDhclient.get_newest_lease_file_from_distro(debian.Distro),\n         )\n \n     # If argument to listdir is '/var/lib/NetworkManager'\n@@ -1225,9 +1193,8 @@ class TestISCDHClient(CiTestCase):\n         \"\"\"\n         self.assertEqual(\n             os.path.join(DHCLIENT_FALLBACK_LEASE_DIR, \"!@#$-eth0.lease\"),\n-            IscDhclient.get_latest_lease(\n-                rhel.Distro.dhclient_lease_directory,\n-                rhel.Distro.dhclient_lease_file_regex,\n+            IscDhclient.get_newest_lease_file_from_distro(\n+                rhel.Distro(\"\", {}, {})\n             ),\n         )\n \n@@ -1240,17 +1207,14 @@ class TestISCDHClient(CiTestCase):\n         ),\n     )\n     @mock.patch(\"os.path.getmtime\", return_value=123.45)\n-    def test_get_latest_lease_notfound(self, *_):\n+    def test_get_newest_lease_file_from_distro_notfound(self, *_):\n         \"\"\"\n         Test the case when no leases were found\n         \"\"\"\n         # Any Distro would suffice for the absense test, choose Centos then.\n         self.assertEqual(\n             None,\n-            IscDhclient.get_latest_lease(\n-                centos.Distro.dhclient_lease_directory,\n-                centos.Distro.dhclient_lease_file_regex,\n-            ),\n+            IscDhclient.get_newest_lease_file_from_distro(centos.Distro),\n         )\n \n \n"
        },
        {
            "commit": "4d5898b8a73c93e1ed4434744c2fa7c3f7fbd501",
            "file_path": "tests/unittests/sources/test_cloudstack.py",
            "diff": "diff --git a/tests/unittests/sources/test_cloudstack.py b/tests/unittests/sources/test_cloudstack.py\nindex c98290a7..8ee04b3e 100644\n--- a/tests/unittests/sources/test_cloudstack.py\n+++ b/tests/unittests/sources/test_cloudstack.py\n@@ -1,9 +1,12 @@\n # This file is part of cloud-init. See LICENSE file for license information.\n+from textwrap import dedent\n+\n from cloudinit import helpers\n from cloudinit.distros import rhel, ubuntu\n from cloudinit.sources import DataSourceHostname\n from cloudinit.sources.DataSourceCloudStack import DataSourceCloudStack\n from tests.unittests.helpers import CiTestCase, ExitStack, mock\n+from tests.unittests.util import MockDistro\n \n SOURCES_PATH = \"cloudinit.sources\"\n MOD_PATH = SOURCES_PATH + \".DataSourceCloudStack\"\n@@ -30,6 +33,36 @@ class TestCloudStackHostname(CiTestCase):\n                 SOURCES_PATH + \".DataSource.get_hostname\", get_hostname_parent\n             )\n         )\n+        self.patches.enter_context(\n+            mock.patch(\n+                DHCP_MOD_PATH + \".util.load_file\",\n+                return_value=dedent(\n+                    \"\"\"\n+                    lease {\n+                      interface \"eth0\";\n+                      fixed-address 10.0.0.5;\n+                      server-name \"DSM111070915004\";\n+                      option subnet-mask 255.255.255.0;\n+                      option dhcp-lease-time 4294967295;\n+                      option routers 10.0.0.1;\n+                      option dhcp-message-type 5;\n+                      option dhcp-server-identifier 168.63.129.16;\n+                      option domain-name-servers 168.63.129.16;\n+                      option dhcp-renewal-time 4294967295;\n+                      option rfc3442-classless-static-routes \"\"\"\n+                    \"\"\"0,10,0,0,1,32,168,63,129,16,10,0,0,1,32,169,254,\"\"\"\n+                    \"\"\"169,254,10,0,0,1;\n+                      option unknown-245 a8:3f:81:10;\n+                      option dhcp-rebinding-time 4294967295;\n+                    \"\"\"\n+                    \"\"\"renew 0 2160/02/17 02:22:33;\n+                      rebind 0 2160/02/17 02:22:33;\n+                      expire 0 2160/02/17 02:22:33;\n+                    }\n+                    \"\"\"\n+                ),\n+            )\n+        )\n \n         # Mock cloudinit.net.dhcp.networkd_get_option_from_leases() method \\\n         # result since we don't have a DHCP client running\n@@ -43,31 +76,31 @@ class TestCloudStackHostname(CiTestCase):\n             )\n         )\n \n-        # Mock cloudinit.net.dhcp.get_latest_lease() method \\\n+        # Mock cloudinit.net.dhcp.get_newest_lease_file_from_distro() method \\\n         # result since we don't have a DHCP client running\n-        isc_dhclient_get_latest_lease = mock.MagicMock(\n+        isc_dhclient_get_newest_lease_file_from_distro = mock.MagicMock(\n             return_value=\"/var/lib/NetworkManager/dhclient-u-u-i-d-eth0.lease\"\n         )\n         self.patches.enter_context(\n             mock.patch(\n-                DHCP_MOD_PATH + \".IscDhclient.get_latest_lease\",\n-                isc_dhclient_get_latest_lease,\n+                DHCP_MOD_PATH\n+                + \".IscDhclient.get_newest_lease_file_from_distro\",\n+                isc_dhclient_get_newest_lease_file_from_distro,\n             )\n         )\n \n         # Mock cloudinit.net.dhcp.networkd_get_option_from_leases() method \\\n         # result since we don't have a DHCP client running\n-        get_newest_lease = mock.MagicMock(\n-            return_value={\n-                \"interface\": \"eth0\",\n-                \"fixed-address\": \"192.168.0.1\",\n-                \"subnet-mask\": \"255.255.255.0\",\n-                \"routers\": \"192.168.0.1\",\n-                \"domain-name\": self.isc_dhclient_domainname,\n-                \"renew\": \"4 2017/07/27 18:02:30\",\n-                \"expire\": \"5 2017/07/28 07:08:15\",\n-            }\n-        )\n+        lease = {\n+            \"interface\": \"eth0\",\n+            \"fixed-address\": \"192.168.0.1\",\n+            \"subnet-mask\": \"255.255.255.0\",\n+            \"routers\": \"192.168.0.1\",\n+            \"domain-name\": self.isc_dhclient_domainname,\n+            \"renew\": \"4 2017/07/27 18:02:30\",\n+            \"expire\": \"5 2017/07/28 07:08:15\",\n+        }\n+        get_newest_lease = mock.MagicMock(return_value=lease)\n \n         self.patches.enter_context(\n             mock.patch(\n@@ -76,6 +109,13 @@ class TestCloudStackHostname(CiTestCase):\n             )\n         )\n \n+        self.patches.enter_context(\n+            mock.patch(\n+                DHCP_MOD_PATH + \".IscDhclient.parse_leases\",\n+                mock.MagicMock(return_value=[lease]),\n+            )\n+        )\n+\n         # Mock get_vr_address() method as it relies to\n         # parsing DHCP/networkd files\n         self.patches.enter_context(\n@@ -117,7 +157,36 @@ class TestCloudStackHostname(CiTestCase):\n         ds = DataSourceCloudStack(\n             {}, rhel.Distro, helpers.Paths({\"run_dir\": self.tmp})\n         )\n-        result = ds._get_domainname()\n+        with mock.patch(\n+            MOD_PATH + \".util.load_file\",\n+            return_value=dedent(\n+                \"\"\"\n+                lease {\n+                  interface \"eth0\";\n+                  fixed-address 10.0.0.5;\n+                  server-name \"DSM111070915004\";\n+                  option subnet-mask 255.255.255.0;\n+                  option dhcp-lease-time 4294967295;\n+                  option routers 10.0.0.1;\n+                  option dhcp-message-type 5;\n+                  option dhcp-server-identifier 168.63.129.16;\n+                  option domain-name-servers 168.63.129.16;\n+                  option dhcp-renewal-time 4294967295;\n+                  option rfc3442-classless-static-routes \"\"\"\n+                \"\"\"0,10,0,0,1,32,168,63,129,16,10,0,0,1,32,169,254,\"\"\"\n+                \"\"\"169,254,10,0,0,1;\n+                  option unknown-245 a8:3f:81:10;\n+                  option dhcp-rebinding-time 4294967295;\n+                \"\"\"\n+                f\"option domain-name {self.isc_dhclient_domainname};\"\n+                \"\"\"renew 0 2160/02/17 02:22:33;\n+                  rebind 0 2160/02/17 02:22:33;\n+                  expire 0 2160/02/17 02:22:33;\n+                }\n+                \"\"\"\n+            ),\n+        ):\n+            result = ds._get_domainname()\n         self.assertEqual(self.isc_dhclient_domainname, result)\n \n     def test_get_hostname_non_fqdn(self):\n@@ -175,31 +244,72 @@ class TestCloudStackHostname(CiTestCase):\n             )\n         )\n \n-        # Override IscDhclient.get_newest_lease()\n-        # to return a lease without domain-name option.\n-        get_newest_lease = mock.MagicMock(\n-            return_value={\n-                \"interface\": \"eth0\",\n-                \"fixed-address\": \"192.168.0.1\",\n-                \"subnet-mask\": \"255.255.255.0\",\n-                \"routers\": \"192.168.0.1\",\n-                \"renew\": \"4 2017/07/27 18:02:30\",\n-                \"expire\": \"5 2017/07/28 07:08:15\",\n-            }\n+        self.patches.enter_context(\n+            mock.patch(\n+                MOD_PATH\n+                + \".dhcp.IscDhclient.get_newest_lease_file_from_distro\",\n+                return_value=True,\n+            )\n+        )\n+\n+        self.patches.enter_context(\n+            mock.patch(\n+                MOD_PATH + \".dhcp.IscDhclient.parse_leases\", return_value=[]\n+            )\n         )\n \n         self.patches.enter_context(\n             mock.patch(\n                 DHCP_MOD_PATH + \".IscDhclient.get_newest_lease\",\n-                get_newest_lease,\n+                return_value={\n+                    \"interface\": \"eth0\",\n+                    \"fixed-address\": \"192.168.0.1\",\n+                    \"subnet-mask\": \"255.255.255.0\",\n+                    \"routers\": \"192.168.0.1\",\n+                    \"renew\": \"4 2017/07/27 18:02:30\",\n+                    \"expire\": \"5 2017/07/28 07:08:15\",\n+                },\n+            )\n+        )\n+\n+        self.patches.enter_context(\n+            mock.patch(\n+                DHCP_MOD_PATH + \".util.load_file\",\n+                return_value=dedent(\n+                    \"\"\"\n+                    lease {\n+                      interface \"eth0\";\n+                      fixed-address 10.0.0.5;\n+                      server-name \"DSM111070915004\";\n+                      option subnet-mask 255.255.255.0;\n+                      option dhcp-lease-time 4294967295;\n+                      option routers 10.0.0.1;\n+                      option dhcp-message-type 5;\n+                      option dhcp-server-identifier 168.63.129.16;\n+                      option domain-name-servers 168.63.129.16;\n+                      option dhcp-renewal-time 4294967295;\n+                      option rfc3442-classless-static-routes \"\"\"\n+                    \"\"\"0,10,0,0,1,32,168,63,129,16,10,0,0,1,32,169,254,\"\"\"\n+                    \"\"\"169,254,10,0,0,1;\n+                      option unknown-245 a8:3f:81:10;\n+                      option dhcp-rebinding-time 4294967295;\n+                    \"\"\"\n+                    \"\"\"renew 0 2160/02/17 02:22:33;\n+                      rebind 0 2160/02/17 02:22:33;\n+                      expire 0 2160/02/17 02:22:33;\n+                    }\n+                    \"\"\"\n+                ),\n             )\n         )\n \n         ds = DataSourceCloudStack(\n-            {}, ubuntu.Distro, helpers.Paths({\"run_dir\": self.tmp})\n+            {}, MockDistro(), helpers.Paths({\"run_dir\": self.tmp})\n         )\n-        result = ds.get_hostname(fqdn=True)\n-        self.assertTupleEqual(expected, result)\n+        ds._fallback_interface = \"eth0\"\n+        with mock.patch(MOD_PATH + \".util.load_file\"):\n+            result = ds.get_hostname(fqdn=True)\n+            self.assertTupleEqual(expected, result)\n \n \n class TestCloudStackPasswordFetching(CiTestCase):\n@@ -212,11 +322,25 @@ class TestCloudStackPasswordFetching(CiTestCase):\n         self.patches.enter_context(mock.patch(\"{0}.uhelp\".format(mod_name)))\n         default_gw = \"192.201.20.0\"\n \n-        get_latest_lease = mock.MagicMock(return_value=None)\n+        get_newest_lease_file_from_distro = mock.MagicMock(return_value=None)\n+        self.patches.enter_context(\n+            mock.patch(\n+                DHCP_MOD_PATH + \".IscDhclient.get_newest_lease\",\n+                return_value={\n+                    \"interface\": \"eth0\",\n+                    \"fixed-address\": \"192.168.0.1\",\n+                    \"subnet-mask\": \"255.255.255.0\",\n+                    \"routers\": \"192.168.0.1\",\n+                    \"renew\": \"4 2017/07/27 18:02:30\",\n+                    \"expire\": \"5 2017/07/28 07:08:15\",\n+                },\n+            )\n+        )\n         self.patches.enter_context(\n             mock.patch(\n-                DHCP_MOD_PATH + \".IscDhclient.get_latest_lease\",\n-                get_latest_lease,\n+                DHCP_MOD_PATH\n+                + \".IscDhclient.get_newest_lease_file_from_distro\",\n+                get_newest_lease_file_from_distro,\n             )\n         )\n \n@@ -251,7 +375,7 @@ class TestCloudStackPasswordFetching(CiTestCase):\n     def test_empty_password_doesnt_create_config(self):\n         self._set_password_server_response(\"\")\n         ds = DataSourceCloudStack(\n-            {}, ubuntu.Distro, helpers.Paths({\"run_dir\": self.tmp})\n+            {}, MockDistro(), helpers.Paths({\"run_dir\": self.tmp})\n         )\n         ds.get_data()\n         self.assertEqual({}, ds.get_config_obj())\n@@ -259,7 +383,7 @@ class TestCloudStackPasswordFetching(CiTestCase):\n     def test_saved_password_doesnt_create_config(self):\n         self._set_password_server_response(\"saved_password\")\n         ds = DataSourceCloudStack(\n-            {}, ubuntu.Distro, helpers.Paths({\"run_dir\": self.tmp})\n+            {}, MockDistro(), helpers.Paths({\"run_dir\": self.tmp})\n         )\n         ds.get_data()\n         self.assertEqual({}, ds.get_config_obj())\n@@ -270,7 +394,7 @@ class TestCloudStackPasswordFetching(CiTestCase):\n         password = \"SekritSquirrel\"\n         self._set_password_server_response(password)\n         ds = DataSourceCloudStack(\n-            {}, ubuntu.Distro, helpers.Paths({\"run_dir\": self.tmp})\n+            {}, MockDistro(), helpers.Paths({\"run_dir\": self.tmp})\n         )\n         ds.get_data()\n         self.assertEqual(password, ds.get_config_obj()[\"password\"])\n@@ -279,8 +403,9 @@ class TestCloudStackPasswordFetching(CiTestCase):\n     def test_bad_request_doesnt_stop_ds_from_working(self, m_wait):\n         m_wait.return_value = True\n         self._set_password_server_response(\"bad_request\")\n+        # with mock.patch(DHCP_MOD_PATH + \".util.load_file\"):\n         ds = DataSourceCloudStack(\n-            {}, ubuntu.Distro, helpers.Paths({\"run_dir\": self.tmp})\n+            {}, MockDistro(), helpers.Paths({\"run_dir\": self.tmp})\n         )\n         self.assertTrue(ds.get_data())\n \n@@ -299,7 +424,7 @@ class TestCloudStackPasswordFetching(CiTestCase):\n         password = \"SekritSquirrel\"\n         subp = self._set_password_server_response(password)\n         ds = DataSourceCloudStack(\n-            {}, ubuntu.Distro, helpers.Paths({\"run_dir\": self.tmp})\n+            {}, MockDistro(), helpers.Paths({\"run_dir\": self.tmp})\n         )\n         ds.get_data()\n         self.assertRequestTypesSent(\n@@ -309,7 +434,7 @@ class TestCloudStackPasswordFetching(CiTestCase):\n     def _check_password_not_saved_for(self, response_string):\n         subp = self._set_password_server_response(response_string)\n         ds = DataSourceCloudStack(\n-            {}, ubuntu.Distro, helpers.Paths({\"run_dir\": self.tmp})\n+            {}, MockDistro(), helpers.Paths({\"run_dir\": self.tmp})\n         )\n         with mock.patch(DS_PATH + \".wait_for_metadata_service\") as m_wait:\n             m_wait.return_value = True\n"
        }
    ]
}
{
    "sha_fail": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
    "changed_files": [
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "cookbook/agent_concepts/knowledge/gcs_pdf_kb.py",
            "diff": "diff --git a/cookbook/agent_concepts/knowledge/gcs_pdf_kb.py b/cookbook/agent_concepts/knowledge/gcs_pdf_kb.py\nnew file mode 100644\nindex 000000000..5da38aaa3\n--- /dev/null\n+++ b/cookbook/agent_concepts/knowledge/gcs_pdf_kb.py\n@@ -0,0 +1,29 @@\n+\"\"\"\n+This agent answers questions using knowledge from a PDF stored in a Google Cloud Storage (GCS) bucket.\n+\n+Setup Steps:\n+1. Install required libraries: agno, google-cloud-storage, psycopg2-binary (for PostgreSQL vector DB).\n+2. Set up your GCS bucket and upload your PDF file.\n+3. For public GCS buckets: No authentication needed, just set the bucket and PDF path.\n+4. For private GCS buckets:\n+   - Grant the service account Storage Object Viewer access to the bucket via Google Cloud Console\n+   - Export GOOGLE_APPLICATION_CREDENTIALS with the path to your service account JSON before running the script\n+5. Update 'bucket_name' and 'blob_name' in the script to your PDF's location.\n+6. Run the script to load the knowledge base and ask questions.\n+\"\"\"\n+\n+from agno.agent import Agent\n+from agno.knowledge.gcs.pdf import GCSPDFKnowledgeBase\n+from agno.vectordb.pgvector import PgVector\n+\n+db_url = \"postgresql+psycopg://ai:ai@localhost:5532/ai\"\n+\n+knowledge_base = GCSPDFKnowledgeBase(\n+    bucket_name=\"your-gcs-bucket\",\n+    blob_name=\"path/to/your.pdf\",\n+    vector_db=PgVector(table_name=\"recipes\", db_url=db_url),\n+)\n+knowledge_base.load(recreate=False)  # Comment out after first run\n+\n+agent = Agent(knowledge=knowledge_base, search_knowledge=True)\n+agent.print_response(\"How to make Thai curry?\", markdown=True)\n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "cookbook/agent_concepts/knowledge/gcs_pdf_kb_async.py",
            "diff": "diff --git a/cookbook/agent_concepts/knowledge/gcs_pdf_kb_async.py b/cookbook/agent_concepts/knowledge/gcs_pdf_kb_async.py\nnew file mode 100644\nindex 000000000..b539b28ac\n--- /dev/null\n+++ b/cookbook/agent_concepts/knowledge/gcs_pdf_kb_async.py\n@@ -0,0 +1,33 @@\n+\"\"\"\n+This agent answers questions using knowledge from a PDF stored in a Google Cloud Storage (GCS) bucket.\n+\n+Setup Steps:\n+1. Install required libraries: agno, google-cloud-storage, psycopg2-binary (for PostgreSQL vector DB).\n+2. Set up your GCS bucket and upload your PDF file.\n+3. For public GCS buckets: No authentication needed, just set the bucket and PDF path.\n+4. For private GCS buckets:\n+   - Grant the service account Storage Object Viewer access to the bucket via Google Cloud Console\n+   - Export GOOGLE_APPLICATION_CREDENTIALS with the path to your service account JSON before running the script\n+5. Update 'bucket_name' and 'blob_name' in the script to your PDF's location.\n+6. Run the script to load the knowledge base and ask questions.\n+\"\"\"\n+\n+import asyncio\n+\n+from agno.agent import Agent\n+from agno.knowledge.gcs.pdf import GCSPDFKnowledgeBase\n+from agno.vectordb.pgvector import PgVector\n+\n+db_url = \"postgresql+psycopg://ai:ai@localhost:5532/ai\"\n+\n+knowledge_base = GCSPDFKnowledgeBase(\n+    bucket_name=\"your-gcs-bucket\",\n+    blob_name=\"path/to/your.pdf\",\n+    vector_db=PgVector(table_name=\"recipes\", db_url=db_url),\n+)\n+agent = Agent(knowledge=knowledge_base, search_knowledge=True)\n+\n+if __name__ == \"__main__\":\n+    asyncio.run(knowledge_base.aload(recreate=False))  # Comment out after first run\n+\n+    asyncio.run(agent.aprint_response(\"How to make Thai curry?\", markdown=True))\n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "cookbook/agent_concepts/state/session_state_on_run.py",
            "diff": "diff --git a/cookbook/agent_concepts/state/session_state_on_run.py b/cookbook/agent_concepts/state/session_state_on_run.py\nnew file mode 100644\nindex 000000000..36d8e1dbc\n--- /dev/null\n+++ b/cookbook/agent_concepts/state/session_state_on_run.py\n@@ -0,0 +1,30 @@\n+from agno.agent import Agent\n+from agno.models.openai import OpenAIChat\n+\n+agent = Agent(\n+    model=OpenAIChat(id=\"gpt-4o-mini\"),\n+    add_state_in_messages=True,\n+    instructions=\"Users name is {user_name} and age is {age}\",\n+)\n+\n+# Sets the session state for the session with the id \"user_1_session_1\"\n+agent.print_response(\n+    \"What is my name?\",\n+    session_id=\"user_1_session_1\",\n+    user_id=\"user_1\",\n+    session_state={\"user_name\": \"John\", \"age\": 30},\n+)\n+\n+# Will load the session state from the session with the id \"user_1_session_1\"\n+agent.print_response(\"How old am I?\", session_id=\"user_1_session_1\", user_id=\"user_1\")\n+\n+# Sets the session state for the session with the id \"user_2_session_1\"\n+agent.print_response(\n+    \"What is my name?\",\n+    session_id=\"user_2_session_1\",\n+    user_id=\"user_2\",\n+    session_state={\"user_name\": \"Jane\", \"age\": 25},\n+)\n+\n+# Will load the session state from the session with the id \"user_2_session_1\"\n+agent.print_response(\"How old am I?\", session_id=\"user_2_session_1\", user_id=\"user_2\")\n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "libs/agno/agno/agent/agent.py",
            "diff": "diff --git a/libs/agno/agno/agent/agent.py b/libs/agno/agno/agent/agent.py\nindex 570165c2b..0b9d326f8 100644\n--- a/libs/agno/agno/agent/agent.py\n+++ b/libs/agno/agno/agent/agent.py\n@@ -766,6 +766,7 @@ class Agent:\n         session_id: str,\n         user_id: Optional[str] = None,\n         response_format: Optional[Union[Dict, Type[BaseModel]]] = None,\n+        refresh_session_before_write: Optional[bool] = False,\n     ) -> RunResponse:\n         \"\"\"Run the Agent and return the RunResponse.\n \n@@ -833,7 +834,7 @@ class Agent:\n         self._convert_response_to_structured_format(run_response)\n \n         # 6. Save session to storage\n-        self.write_to_storage(user_id=user_id, session_id=session_id)\n+        self.write_to_storage(user_id=user_id, session_id=session_id, refresh_session=refresh_session_before_write)\n \n         # 7. Save output to file if save_response_to_file is set\n         self.save_run_response_to_file(message=run_messages.user_message, session_id=session_id)\n@@ -853,6 +854,7 @@ class Agent:\n         user_id: Optional[str] = None,\n         response_format: Optional[Union[Dict, Type[BaseModel]]] = None,\n         stream_intermediate_steps: bool = False,\n+        refresh_session_before_write: Optional[bool] = False,\n     ) -> Iterator[RunResponseEvent]:\n         \"\"\"Run the Agent and yield the RunResponse.\n \n@@ -925,7 +927,7 @@ class Agent:\n             yield self._handle_event(create_run_response_completed_event(from_run_response=run_response), run_response)\n \n         # 7. Save session to storage\n-        self.write_to_storage(user_id=user_id, session_id=session_id)\n+        self.write_to_storage(user_id=user_id, session_id=session_id, refresh_session=refresh_session_before_write)\n \n         # Log Agent Run\n         self._log_agent_run(user_id=user_id, session_id=session_id)\n@@ -949,6 +951,7 @@ class Agent:\n         messages: Optional[Sequence[Union[Dict, Message]]] = None,\n         retries: Optional[int] = None,\n         knowledge_filters: Optional[Dict[str, Any]] = None,\n+        refresh_session_before_write: Optional[bool] = False,\n         **kwargs: Any,\n     ) -> RunResponse: ...\n \n@@ -969,6 +972,7 @@ class Agent:\n         messages: Optional[Sequence[Union[Dict, Message]]] = None,\n         retries: Optional[int] = None,\n         knowledge_filters: Optional[Dict[str, Any]] = None,\n+        refresh_session_before_write: Optional[bool] = False,\n         **kwargs: Any,\n     ) -> Iterator[RunResponseEvent]: ...\n \n@@ -988,6 +992,7 @@ class Agent:\n         messages: Optional[Sequence[Union[Dict, Message]]] = None,\n         retries: Optional[int] = None,\n         knowledge_filters: Optional[Dict[str, Any]] = None,\n+        refresh_session_before_write: Optional[bool] = False,\n         **kwargs: Any,\n     ) -> Union[RunResponse, Iterator[RunResponseEvent]]:\n         \"\"\"Run the Agent and return the response.\"\"\"\n@@ -1117,6 +1122,7 @@ class Agent:\n                         session_id=session_id,\n                         response_format=response_format,\n                         stream_intermediate_steps=stream_intermediate_steps,\n+                        refresh_session_before_write=refresh_session_before_write,\n                     )\n                     return response_iterator\n                 else:\n@@ -1126,6 +1132,7 @@ class Agent:\n                         user_id=user_id,\n                         session_id=session_id,\n                         response_format=response_format,\n+                        refresh_session_before_write=refresh_session_before_write,\n                     )\n                     return response\n             except ModelProviderError as e:\n@@ -1175,6 +1182,7 @@ class Agent:\n         session_id: str,\n         user_id: Optional[str] = None,\n         response_format: Optional[Union[Dict, Type[BaseModel]]] = None,\n+        refresh_session_before_write: Optional[bool] = False,\n     ) -> RunResponse:\n         \"\"\"Run the Agent and yield the RunResponse.\n \n@@ -1241,7 +1249,7 @@ class Agent:\n         self._convert_response_to_structured_format(run_response)\n \n         # 6. Save session to storage\n-        self.write_to_storage(user_id=user_id, session_id=session_id)\n+        self.write_to_storage(user_id=user_id, session_id=session_id, refresh_session=refresh_session_before_write)\n \n         # 7. Save output to file if save_response_to_file is set\n         self.save_run_response_to_file(message=run_messages.user_message, session_id=session_id)\n@@ -1261,6 +1269,7 @@ class Agent:\n         user_id: Optional[str] = None,\n         response_format: Optional[Union[Dict, Type[BaseModel]]] = None,\n         stream_intermediate_steps: bool = False,\n+        refresh_session_before_write: Optional[bool] = False,\n     ) -> AsyncIterator[RunResponseEvent]:\n         \"\"\"Run the Agent and yield the RunResponse.\n \n@@ -1336,7 +1345,7 @@ class Agent:\n             yield self._handle_event(create_run_response_completed_event(from_run_response=run_response), run_response)\n \n         # 7. Save session to storage\n-        self.write_to_storage(user_id=user_id, session_id=session_id)\n+        self.write_to_storage(user_id=user_id, session_id=session_id, refresh_session=refresh_session_before_write)\n \n         # Log Agent Run\n         await self._alog_agent_run(user_id=user_id, session_id=session_id)\n@@ -1359,6 +1368,7 @@ class Agent:\n         stream_intermediate_steps: Optional[bool] = None,\n         retries: Optional[int] = None,\n         knowledge_filters: Optional[Dict[str, Any]] = None,\n+        refresh_session_before_write: Optional[bool] = False,\n         **kwargs: Any,\n     ) -> Any:\n         \"\"\"Async Run the Agent and return the response.\"\"\"\n@@ -1369,6 +1379,9 @@ class Agent:\n \n         log_debug(f\"Session ID: {session_id}\", center=True)\n \n+        # Initialize the Agent\n+        self.initialize_agent()\n+\n         effective_filters = knowledge_filters\n         # When filters are passed manually\n         if self.knowledge_filters or knowledge_filters:\n@@ -1484,6 +1497,7 @@ class Agent:\n                         session_id=session_id,\n                         response_format=response_format,\n                         stream_intermediate_steps=stream_intermediate_steps,\n+                        refresh_session_before_write=refresh_session_before_write,\n                     )  # type: ignore[assignment]\n                     return response_iterator\n                 else:\n@@ -1493,6 +1507,7 @@ class Agent:\n                         user_id=user_id,\n                         session_id=session_id,\n                         response_format=response_format,\n+                        refresh_session_before_write=refresh_session_before_write,\n                     )\n                     return response\n             except ModelProviderError as e:\n@@ -4155,13 +4170,56 @@ class Agent:\n                 self.load_agent_session(session=self.agent_session)\n         return self.agent_session\n \n-    def write_to_storage(self, session_id: str, user_id: Optional[str] = None) -> Optional[AgentSession]:\n+    def refresh_from_storage(self, session_id: str) -> None:\n+        \"\"\"Refresh the AgentSession from storage\n+\n+        Args:\n+            session_id: The session_id to refresh from storage.\n+        \"\"\"\n+        if not self.storage:\n+            return\n+\n+        agent_session_from_db = self.storage.read(session_id=session_id)\n+        if (\n+            agent_session_from_db is not None\n+            and agent_session_from_db.memory is not None\n+            and \"runs\" in agent_session_from_db.memory  # type: ignore\n+        ):\n+            if isinstance(self.memory, AgentMemory):\n+                return\n+            try:\n+                if self.memory.runs is None:  # type: ignore\n+                    self.memory.runs = {}  # type: ignore\n+                if session_id not in self.memory.runs:  # type: ignore\n+                    self.memory.runs[session_id] = []  # type: ignore\n+                for run in agent_session_from_db.memory[\"runs\"]:  # type: ignore\n+                    run_session_id = run[\"session_id\"]\n+                    skip = False\n+                    for existing_run in self.memory.runs[run_session_id]:  # type: ignore\n+                        if existing_run.run_id == run[\"run_id\"]:\n+                            skip = True\n+                            break\n+                    if skip:\n+                        continue\n+                    if \"team_id\" in run:\n+                        self.memory.runs[run_session_id].append(TeamRunResponse.from_dict(run))  # type: ignore\n+                    else:\n+                        self.memory.runs[run_session_id].append(RunResponse.from_dict(run))  # type: ignore\n+            except Exception as e:\n+                log_warning(f\"Failed to load runs from memory: {e}\")\n+\n+    def write_to_storage(\n+        self, session_id: str, user_id: Optional[str] = None, refresh_session: Optional[bool] = False\n+    ) -> Optional[AgentSession]:\n         \"\"\"Save the AgentSession to storage\n \n         Returns:\n             Optional[AgentSession]: The saved AgentSession or None if not saved.\n         \"\"\"\n         if self.storage is not None:\n+            if refresh_session:\n+                self.refresh_from_storage(session_id=session_id)\n+\n             self.agent_session = cast(\n                 AgentSession,\n                 self.storage.upsert(session=self.get_agent_session(session_id=session_id, user_id=user_id)),\n@@ -4241,13 +4299,13 @@ class Agent:\n         self.session_id = str(uuid4())\n         self.load_session(force=True)\n \n-    def format_message_with_state_variables(self, msg: Any) -> Any:\n+    def format_message_with_state_variables(self, message: Any) -> Any:\n         \"\"\"Format a message with the session state variables.\"\"\"\n         import re\n         import string\n \n-        if not isinstance(msg, str):\n-            return msg\n+        if not isinstance(message, str):\n+            return message\n \n         format_variables = ChainMap(\n             self.session_state or {},\n@@ -4257,7 +4315,7 @@ class Agent:\n             self.extra_data or {},\n             {\"user_id\": self.user_id} if self.user_id is not None else {},\n         )\n-        converted_msg = msg\n+        converted_msg = message\n         for var_name in format_variables.keys():\n             # Only convert standalone {var_name} patterns, not nested ones\n             pattern = r\"\\{\" + re.escape(var_name) + r\"\\}\"\n@@ -4271,7 +4329,7 @@ class Agent:\n             return result\n         except Exception as e:\n             log_warning(f\"Template substitution failed: {e}\")\n-            return msg\n+            return message\n \n     def get_system_message(self, session_id: str, user_id: Optional[str] = None) -> Optional[Message]:\n         \"\"\"Return the system message for the Agent.\n@@ -4297,6 +4355,7 @@ class Agent:\n             # Format the system message with the session state variables\n             if self.add_state_in_messages:\n                 sys_message_content = self.format_message_with_state_variables(sys_message_content)\n+                print(\"HELLO\", sys_message_content)\n \n             # Add the JSON output prompt if response_model is provided and the model does not support native structured outputs or JSON schema outputs\n             # or if use_json_mode is True\n@@ -4313,7 +4372,6 @@ class Agent:\n \n             # type: ignore\n             return Message(role=self.system_message_role, content=sys_message_content)\n-\n         # 2. If create_default_system_message is False, return None.\n         if not self.create_default_system_message:\n             return None\n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "libs/agno/agno/document/reader/gcs/__init__.py",
            "diff": "diff --git a/libs/agno/agno/document/reader/gcs/__init__.py b/libs/agno/agno/document/reader/gcs/__init__.py\nnew file mode 100644\nindex 000000000..e69de29bb\n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "libs/agno/agno/document/reader/gcs/pdf_reader.py",
            "diff": "diff --git a/libs/agno/agno/document/reader/gcs/pdf_reader.py b/libs/agno/agno/document/reader/gcs/pdf_reader.py\nnew file mode 100644\nindex 000000000..8338e9927\n--- /dev/null\n+++ b/libs/agno/agno/document/reader/gcs/pdf_reader.py\n@@ -0,0 +1,44 @@\n+import asyncio\n+from io import BytesIO\n+from typing import List\n+from uuid import uuid4\n+\n+from agno.document.base import Document\n+from agno.document.reader.base import Reader\n+from agno.utils.log import log_info\n+\n+try:\n+    from google.cloud import storage\n+except ImportError:\n+    raise ImportError(\"`google-cloud-storage` not installed. Please install it via `pip install google-cloud-storage`.\")\n+\n+try:\n+    from pypdf import PdfReader as DocumentReader\n+except ImportError:\n+    raise ImportError(\"`pypdf` not installed. Please install it via `pip install pypdf`.\")\n+\n+\n+class GCSPDFReader(Reader):\n+    def read(self, blob: storage.Blob) -> List[Document]:\n+        log_info(f\"Reading: gs://{blob.bucket.name}/{blob.name}\")\n+        data = blob.download_as_bytes()\n+        doc_name = blob.name.split(\"/\")[-1].split(\".\")[0].replace(\"/\", \"_\").replace(\" \", \"_\")\n+        doc_reader = DocumentReader(BytesIO(data))\n+        documents = [\n+            Document(\n+                name=doc_name,\n+                id=str(uuid4()),\n+                meta_data={\"page\": page_number},\n+                content=page.extract_text(),\n+            )\n+            for page_number, page in enumerate(doc_reader.pages, start=1)\n+        ]\n+        if self.chunk:\n+            chunked_documents = []\n+            for document in documents:\n+                chunked_documents.extend(self.chunk_document(document))\n+            return chunked_documents\n+        return documents\n+\n+    async def async_read(self, blob: storage.Blob) -> List[Document]:\n+        return await asyncio.to_thread(self.read, blob)\n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "libs/agno/agno/knowledge/gcs/__init__.py",
            "diff": "diff --git a/libs/agno/agno/knowledge/gcs/__init__.py b/libs/agno/agno/knowledge/gcs/__init__.py\nnew file mode 100644\nindex 000000000..e69de29bb\n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "libs/agno/agno/knowledge/gcs/base.py",
            "diff": "diff --git a/libs/agno/agno/knowledge/gcs/base.py b/libs/agno/agno/knowledge/gcs/base.py\nnew file mode 100644\nindex 000000000..50b568d3d\n--- /dev/null\n+++ b/libs/agno/agno/knowledge/gcs/base.py\n@@ -0,0 +1,39 @@\n+from typing import AsyncIterator, Iterator, List, Optional\n+\n+from google.cloud import storage\n+\n+from agno.document import Document\n+from agno.knowledge.agent import AgentKnowledge\n+\n+\n+class GCSKnowledgeBase(AgentKnowledge):\n+    bucket: Optional[storage.Bucket] = None\n+    bucket_name: Optional[str] = None\n+    blob_name: Optional[str] = None\n+    prefix: Optional[str] = None\n+\n+    @property\n+    def gcs_blobs(self) -> List[storage.Blob]:\n+        if self.bucket is None and self.bucket_name is None:\n+            raise ValueError(\"No bucket or bucket_name provided\")\n+        if self.bucket is not None and self.bucket_name is not None:\n+            raise ValueError(\"Provide either bucket or bucket_name\")\n+        if self.bucket_name is not None:\n+            client = storage.Client()\n+            self.bucket = client.bucket(self.bucket_name)\n+        blobs_to_read = []\n+        if self.blob_name is not None:\n+            blobs_to_read.append(self.bucket.blob(self.blob_name))  # type: ignore\n+        elif self.prefix is not None:\n+            blobs_to_read.extend(self.bucket.list_blobs(prefix=self.prefix))  # type: ignore\n+        else:\n+            blobs_to_read.extend(self.bucket.list_blobs())  # type: ignore\n+        return list(blobs_to_read)\n+\n+    @property\n+    def document_lists(self) -> Iterator[List[Document]]:\n+        raise NotImplementedError\n+\n+    @property\n+    def async_document_lists(self) -> AsyncIterator[List[Document]]:\n+        raise NotImplementedError\n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "libs/agno/agno/knowledge/gcs/pdf.py",
            "diff": "diff --git a/libs/agno/agno/knowledge/gcs/pdf.py b/libs/agno/agno/knowledge/gcs/pdf.py\nnew file mode 100644\nindex 000000000..ba8631dd1\n--- /dev/null\n+++ b/libs/agno/agno/knowledge/gcs/pdf.py\n@@ -0,0 +1,21 @@\n+from typing import AsyncIterator, Iterator, List\n+\n+from agno.document import Document\n+from agno.document.reader.gcs.pdf_reader import GCSPDFReader\n+from agno.knowledge.gcs.base import GCSKnowledgeBase\n+\n+\n+class GCSPDFKnowledgeBase(GCSKnowledgeBase):\n+    reader: GCSPDFReader = GCSPDFReader()\n+\n+    @property\n+    def document_lists(self) -> Iterator[List[Document]]:\n+        for blob in self.gcs_blobs:\n+            if blob.name.endswith(\".pdf\"):\n+                yield self.reader.read(blob=blob)\n+\n+    @property\n+    async def async_document_lists(self) -> AsyncIterator[List[Document]]:\n+        for blob in self.gcs_blobs:\n+            if blob.name.endswith(\".pdf\"):\n+                yield await self.reader.async_read(blob=blob)\n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "libs/agno/agno/team/team.py",
            "diff": "diff --git a/libs/agno/agno/team/team.py b/libs/agno/agno/team/team.py\nindex 5cb223082..e7d38e71a 100644\n--- a/libs/agno/agno/team/team.py\n+++ b/libs/agno/agno/team/team.py\n@@ -728,6 +728,7 @@ class Team:\n             self.session_state = session_state\n \n         self._initialize_session_state(user_id=user_id, session_id=session_id)\n+\n         # Read existing session from storage\n         self.read_from_storage(session_id=session_id)\n \n@@ -5898,7 +5899,7 @@ class Team:\n             )\n \n             # 3. Create the member agent task\n-            member_agent_task = self._formate_member_agent_task(\n+            member_agent_task = self._format_member_agent_task(\n                 task_description, expected_output, team_context_str, team_member_interactions_str\n             )\n \n@@ -6013,7 +6014,7 @@ class Team:\n             )\n \n             # 3. Create the member agent task\n-            member_agent_task = self._formate_member_agent_task(\n+            member_agent_task = self._format_member_agent_task(\n                 task_description, expected_output, team_context_str, team_member_interactions_str\n             )\n \n@@ -6036,6 +6037,7 @@ class Team:\n                         audio=audio,\n                         files=files,\n                         stream=False,\n+                        refresh_session_before_write=True,\n                     )\n                     check_if_run_cancelled(response)\n \n@@ -6194,7 +6196,7 @@ class Team:\n             )\n \n             # 3. Create the member agent task\n-            member_agent_task = self._formate_member_agent_task(\n+            member_agent_task = self._format_member_agent_task(\n                 task_description, expected_output, team_context_str, team_member_interactions_str\n             )\n \n@@ -6334,7 +6336,7 @@ class Team:\n             )\n \n             # 3. Create the member agent task\n-            member_agent_task = self._formate_member_agent_task(\n+            member_agent_task = self._format_member_agent_task(\n                 task_description, expected_output, team_context_str, team_member_interactions_str\n             )\n \n@@ -6360,6 +6362,7 @@ class Team:\n                     knowledge_filters=knowledge_filters\n                     if not member_agent.knowledge_filters and member_agent.knowledge\n                     else None,\n+                    refresh_session_before_write=True,\n                 )\n                 async for member_agent_run_response_event in member_agent_run_response_stream:\n                     check_if_run_cancelled(member_agent_run_response_event)\n@@ -6378,6 +6381,7 @@ class Team:\n                     knowledge_filters=knowledge_filters\n                     if not member_agent.knowledge_filters and member_agent.knowledge\n                     else None,\n+                    refresh_session_before_write=True,\n                 )\n                 check_if_run_cancelled(member_agent_run_response)\n \n@@ -6444,7 +6448,7 @@ class Team:\n \n         return transfer_func\n \n-    def _formate_member_agent_task(\n+    def _format_member_agent_task(\n         self,\n         task_description: str,\n         expected_output: Optional[str] = None,\n@@ -6730,6 +6734,7 @@ class Team:\n                     knowledge_filters=knowledge_filters\n                     if not member_agent.knowledge_filters and member_agent.knowledge\n                     else None,\n+                    refresh_session_before_write=True,\n                 )\n                 async for member_agent_run_response_event in member_agent_run_response_stream:\n                     check_if_run_cancelled(member_agent_run_response_event)\n@@ -6748,6 +6753,7 @@ class Team:\n                     knowledge_filters=knowledge_filters\n                     if (member_agent.knowledge_filters and member_agent.knowledge)\n                     else None,\n+                    refresh_session_before_write=True,\n                 )\n \n                 try:\n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "libs/agno/tests/integration/agent/test_agent_with_storage_and_memory.py",
            "diff": "diff --git a/libs/agno/tests/integration/agent/test_agent_with_storage_and_memory.py b/libs/agno/tests/integration/agent/test_agent_with_storage_and_memory.py\nindex 7d9ff4373..58a5d3a69 100644\n--- a/libs/agno/tests/integration/agent/test_agent_with_storage_and_memory.py\n+++ b/libs/agno/tests/integration/agent/test_agent_with_storage_and_memory.py\n@@ -126,7 +126,6 @@ async def test_multi_user_multi_session_chat(memory_agent, agent_storage, memory\n     assert len(user_3_sessions) == 1\n     assert user_3_session_1_id in [session.session_id for session in user_3_sessions]\n \n-    print(memory.memories)\n     # Verify memory DB has the right memories\n     user_1_memories = memory.get_user_memories(user_id=user_1_id)\n     assert len(user_1_memories) >= 1  # At least 1 memory for user 1\n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "libs/agno/tests/integration/agent/test_user_input_flows.py",
            "diff": "diff --git a/libs/agno/tests/integration/agent/test_user_input_flows.py b/libs/agno/tests/integration/agent/test_user_input_flows.py\nindex 206459efd..2f98c2d00 100644\n--- a/libs/agno/tests/integration/agent/test_user_input_flows.py\n+++ b/libs/agno/tests/integration/agent/test_user_input_flows.py\n@@ -1,3 +1,5 @@\n+import asyncio\n+\n import pytest\n \n from agno.agent import Agent, RunResponse  # noqa\n@@ -124,6 +126,7 @@ async def test_tool_call_requires_user_input_async():\n             tool_response.user_input_schema[0].value = \"Tokyo\"\n \n     response = await agent.acontinue_run(response)\n+    await asyncio.sleep(1)\n     assert response.is_paused is False\n     assert response.tools[0].result == \"It is currently 70 degrees and cloudy in Tokyo\"\n \n@@ -158,6 +161,7 @@ async def test_tool_call_requires_user_input_stream_async():\n     async for response in await agent.acontinue_run(run_id=response.run_id, updated_tools=response.tools, stream=True):\n         if response.is_paused:\n             found_user_input = True\n+    await asyncio.sleep(1)\n     assert found_user_input is False, \"Some tools still require user input\"\n \n \n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "libs/agno/tests/integration/teams/test_team_session_state.py",
            "diff": "diff --git a/libs/agno/tests/integration/teams/test_team_session_state.py b/libs/agno/tests/integration/teams/test_team_session_state.py\nindex f555cf4d0..00f4f1324 100644\n--- a/libs/agno/tests/integration/teams/test_team_session_state.py\n+++ b/libs/agno/tests/integration/teams/test_team_session_state.py\n@@ -102,14 +102,14 @@ def test_team_session_state_on_run(route_team):\n     response = route_team.run(\"What can you do?\", session_id=session_id_1, session_state={\"test_key\": \"test_value\"})\n     assert response.run_id is not None\n     assert route_team.session_id == session_id_1\n-    assert route_team.session_name is None\n+    assert route_team.session_name == \"my_test_session\"  # Correctly set from the first run\n     assert route_team.session_state == {\"test_key\": \"test_value\"}\n \n     # Second run with different session ID\n     response = route_team.run(\"What can you do?\", session_id=session_id_2)\n     assert response.run_id is not None\n     assert route_team.session_id == session_id_2\n-    assert route_team.session_name is None\n+    assert route_team.session_name is None  # Should be unset, new session ID\n     assert route_team.session_state == {}\n \n     # Third run with the original session ID\n@@ -118,7 +118,7 @@ def test_team_session_state_on_run(route_team):\n     )\n     assert response.run_id is not None\n     assert route_team.session_id == session_id_1\n-    assert route_team.session_name is None\n+    assert route_team.session_name == \"my_test_session\"  # Should load what was set on the first run\n     assert route_team.session_state == {\"test_key\": \"test_value\", \"something_else\": \"other_value\"}, (\n         \"Merging session state should work\"\n     )\n"
        },
        {
            "commit": "073ad2a4332ae2ea545fd18c601fdf2171d150c6",
            "file_path": "libs/agno/tests/integration/teams/test_team_with_storage_and_memory.py",
            "diff": "diff --git a/libs/agno/tests/integration/teams/test_team_with_storage_and_memory.py b/libs/agno/tests/integration/teams/test_team_with_storage_and_memory.py\nindex 39b126e19..895ce0361 100644\n--- a/libs/agno/tests/integration/teams/test_team_with_storage_and_memory.py\n+++ b/libs/agno/tests/integration/teams/test_team_with_storage_and_memory.py\n@@ -195,6 +195,8 @@ async def test_member_run_history_persistence(route_team_with_members, agent_sto\n \n     agent_runs = stored_memory_data[\"runs\"]\n \n+    assert len(agent_runs) == 1\n+\n     assert len(agent_runs[-1][\"messages\"]) == 7, (\n         \"Only system message, user message, two tool calls (and results), and response\"\n     )\n@@ -214,6 +216,8 @@ async def test_member_run_history_persistence(route_team_with_members, agent_sto\n \n     agent_runs = stored_memory_data[\"runs\"]\n \n+    assert len(agent_runs) == 2\n+\n     assert len(agent_runs[-1][\"messages\"]) == 13, \"Full history of messages\"\n \n     # Third request (to the member directly)\n@@ -230,6 +234,8 @@ async def test_member_run_history_persistence(route_team_with_members, agent_sto\n \n     agent_runs = stored_memory_data[\"runs\"]\n \n+    assert len(agent_runs) == 3\n+\n     assert len(agent_runs[-1][\"messages\"]) == 15, \"Full history of messages\"\n \n \n@@ -304,7 +310,7 @@ async def test_correct_sessions_in_db(route_team, team_storage, agent_storage):\n     # Define user and session IDs\n     user_id = \"user_1@example.com\"\n     session_id = \"session_123\"\n-\n+    \n     route_team.mode = \"coordinate\"\n     route_team.members = [\n         Agent(\n@@ -321,7 +327,9 @@ async def test_correct_sessions_in_db(route_team, team_storage, agent_storage):\n \n     # Should create a new team session and agent session\n     await route_team.arun(\n-        \"Ask a big and a small question to your member agents\", user_id=user_id, session_id=session_id\n+        \"Ask both a big and a small question to your member agents. Make sure to call both agents.\",\n+        user_id=user_id,\n+        session_id=session_id,\n     )\n \n     team_sessions = team_storage.get_all_sessions(entity_id=route_team.team_id)\n@@ -331,8 +339,10 @@ async def test_correct_sessions_in_db(route_team, team_storage, agent_storage):\n     assert len(team_sessions[0].memory[\"runs\"][0][\"member_responses\"]) == 2\n \n     agent_sessions = agent_storage.get_all_sessions()\n+\n     # Single shared session for both agents\n     assert len(agent_sessions) == 1\n+    print(agent_sessions[0].memory)\n     assert agent_sessions[0].session_id == session_id\n     assert agent_sessions[0].user_id == user_id\n     assert len(agent_sessions[0].memory[\"runs\"]) == 2\n"
        }
    ]
}
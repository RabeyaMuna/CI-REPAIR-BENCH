{
    "sha_fail": "bd46af653e25571f377664c7b7e9228ae8b28e96",
    "changed_files": [
        {
            "commit": "bd46af653e25571f377664c7b7e9228ae8b28e96",
            "file_path": "libs/agno/agno/vectordb/mongodb/mongodb.py",
            "diff": "diff --git a/libs/agno/agno/vectordb/mongodb/mongodb.py b/libs/agno/agno/vectordb/mongodb/mongodb.py\nindex 5db4e228d..18d407dbd 100644\n--- a/libs/agno/agno/vectordb/mongodb/mongodb.py\n+++ b/libs/agno/agno/vectordb/mongodb/mongodb.py\n@@ -4,9 +4,10 @@ from typing import Any, Dict, List, Optional\n \n from agno.document import Document\n from agno.embedder import Embedder\n-from agno.utils.log import log_debug, log_info, logger\n+from agno.utils.log import log_debug, log_info, log_warning, logger\n from agno.vectordb.base import VectorDb\n from agno.vectordb.distance import Distance\n+from agno.vectordb.search import SearchType\n \n try:\n     from hashlib import md5\n@@ -42,6 +43,10 @@ class MongoDb(VectorDb):\n         client: Optional[MongoClient] = None,\n         search_index_name: Optional[str] = \"vector_index_1\",\n         cosmos_compatibility: Optional[bool] = False,\n+        search_type: SearchType = SearchType.vector,\n+        hybrid_vector_weight: float = 0.5,\n+        hybrid_keyword_weight: float = 0.5,\n+        hybrid_rank_constant: int = 60,\n         **kwargs,\n     ):\n         \"\"\"\n@@ -61,6 +66,10 @@ class MongoDb(VectorDb):\n             client (Optional[MongoClient]): An existing MongoClient instance.\n             search_index_name (str): Name of the search index (default: \"vector_index_1\")\n             cosmos_compatibility (bool): Whether to use Azure Cosmos DB Mongovcore compatibility mode.\n+            search_type: The search type to use when searching for documents.\n+            hybrid_vector_weight (float): Default weight for vector search results in hybrid search.\n+            hybrid_keyword_weight (float): Default weight for keyword search results in hybrid search.\n+            hybrid_rank_constant (int): Default rank constant (k) for Reciprocal Rank Fusion in hybrid search. This constant is added to the rank before taking the reciprocal, helping to smooth scores. A common value is 60.\n             **kwargs: Additional arguments for MongoClient.\n         \"\"\"\n         if not collection_name:\n@@ -71,6 +80,10 @@ class MongoDb(VectorDb):\n         self.database = database\n         self.search_index_name = search_index_name\n         self.cosmos_compatibility = cosmos_compatibility\n+        self.search_type = search_type\n+        self.hybrid_vector_weight = hybrid_vector_weight\n+        self.hybrid_keyword_weight = hybrid_keyword_weight\n+        self.hybrid_rank_constant = hybrid_rank_constant\n \n         if embedder is None:\n             from agno.embedder.openai import OpenAIEmbedder\n@@ -519,6 +532,9 @@ class MongoDb(VectorDb):\n         self, query: str, limit: int = 5, filters: Optional[Dict[str, Any]] = None, min_score: float = 0.0\n     ) -> List[Document]:\n         \"\"\"Search for documents using vector similarity.\"\"\"\n+        if self.search_type == SearchType.hybrid:\n+            return self.hybrid_search(query, limit=limit)\n+\n         query_embedding = self.embedder.get_embedding(query)\n         if query_embedding is None:\n             logger.error(f\"Failed to generate embedding for query: {query}\")\n@@ -653,10 +669,165 @@ class MongoDb(VectorDb):\n             logger.error(f\"Error during keyword search: {e}\")\n             return []\n \n-    def hybrid_search(self, query: str, limit: int = 5) -> List[Document]:\n-        \"\"\"Perform a hybrid search combining vector and keyword-based searches.\"\"\"\n-        log_debug(\"Performing hybrid search is not yet implemented.\")\n-        return []\n+    def hybrid_search(\n+        self,\n+        query: str,\n+        limit: int = 5,\n+    ) -> List[Document]:\n+        \"\"\"\n+        Perform a hybrid search combining vector and keyword-based searches using Reciprocal Rank Fusion.\n+\n+        Weights for vector and keyword search are configured at the instance level (hybrid_vector_weight, hybrid_keyword_weight).\n+        The rank constant k is used in the RRF formula `1 / (rank + k)` to smooth scores.\n+\n+        Reference: https://www.mongodb.com/docs/atlas/atlas-vector-search/tutorials/reciprocal-rank-fusion\n+        \"\"\"\n+\n+        if self.cosmos_compatibility:\n+            log_warning(\"Hybrid search is not implemented for Cosmos DB compatibility mode. Returning empty list.\")\n+            return []\n+\n+        log_debug(f\"Performing hybrid search for query: '{query}' with limit: {limit}\")\n+\n+        query_embedding = self.embedder.get_embedding(query)\n+        if query_embedding is None:\n+            logger.error(f\"Failed to generate embedding for query: {query}\")\n+            return []\n+\n+        collection = self._get_collection()\n+\n+        k = self.hybrid_rank_constant\n+\n+        pipeline = [\n+            # Vector Search Branch\n+            {\n+                \"$vectorSearch\": {\n+                    \"index\": self.search_index_name,\n+                    \"path\": \"embedding\",\n+                    \"queryVector\": query_embedding,\n+                    \"numCandidates\": min(limit * 10, 200),\n+                    \"limit\": limit * 2,\n+                }\n+            },\n+            {\"$group\": {\"_id\": None, \"docs\": {\"$push\": \"$$ROOT\"}}},\n+            {\"$unwind\": {\"path\": \"$docs\", \"includeArrayIndex\": \"rank\"}},\n+            {\n+                \"$addFields\": {\n+                    \"_id\": \"$docs._id\",\n+                    \"name\": \"$docs.name\",\n+                    \"content\": \"$docs.content\",\n+                    \"meta_data\": \"$docs.meta_data\",\n+                    \"vs_score\": {\n+                        \"$divide\": [\n+                            self.hybrid_vector_weight,\n+                            {\"$add\": [\"$rank\", k, 1]},\n+                        ]\n+                    },\n+                    \"fts_score\": 0.0,  # Ensure fts_score exists with a default value\n+                }\n+            },\n+            {\n+                \"$project\": {\n+                    \"_id\": 1,\n+                    \"name\": 1,\n+                    \"content\": 1,\n+                    \"meta_data\": 1,\n+                    \"vs_score\": 1,\n+                    # Now fts_score is included with its value (0.0 here)\n+                    \"fts_score\": 1,\n+                }\n+            },\n+            # Union with Keyword Search Branch\n+            {\n+                \"$unionWith\": {\n+                    \"coll\": self.collection_name,\n+                    \"pipeline\": [\n+                        {\n+                            \"$search\": {\n+                                \"index\": \"default\",\n+                                \"text\": {\"query\": query, \"path\": \"content\"},\n+                            }\n+                        },\n+                        {\"$limit\": limit * 2},\n+                        {\"$group\": {\"_id\": None, \"docs\": {\"$push\": \"$$ROOT\"}}},\n+                        {\"$unwind\": {\"path\": \"$docs\", \"includeArrayIndex\": \"rank\"}},\n+                        {\n+                            \"$addFields\": {\n+                                \"_id\": \"$docs._id\",\n+                                \"name\": \"$docs.name\",\n+                                \"content\": \"$docs.content\",\n+                                \"meta_data\": \"$docs.meta_data\",\n+                                \"vs_score\": 0.0,\n+                                \"fts_score\": {\n+                                    \"$divide\": [\n+                                        self.hybrid_keyword_weight,\n+                                        {\"$add\": [\"$rank\", k, 1]},\n+                                    ]\n+                                },\n+                            }\n+                        },\n+                        {\n+                            \"$project\": {\n+                                \"_id\": 1,\n+                                \"name\": 1,\n+                                \"content\": 1,\n+                                \"meta_data\": 1,\n+                                \"vs_score\": 1,\n+                                \"fts_score\": 1,\n+                            }\n+                        },\n+                    ],\n+                }\n+            },\n+            # Combine and Rank\n+            {\n+                \"$group\": {\n+                    \"_id\": \"$_id\",\n+                    \"name\": {\"$first\": \"$name\"},\n+                    \"content\": {\"$first\": \"$content\"},\n+                    \"meta_data\": {\"$first\": \"$meta_data\"},\n+                    \"vs_score\": {\"$sum\": \"$vs_score\"},\n+                    \"fts_score\": {\"$sum\": \"$fts_score\"},\n+                }\n+            },\n+            {\n+                \"$project\": {\n+                    \"_id\": 1,\n+                    \"name\": 1,\n+                    \"content\": 1,\n+                    \"meta_data\": 1,\n+                    \"score\": {\"$add\": [\"$vs_score\", \"$fts_score\"]},\n+                }\n+            },\n+            {\"$sort\": {\"score\": -1}},\n+            {\"$limit\": limit},\n+        ]\n+\n+        try:\n+            results = list(collection.aggregate(pipeline))\n+            docs = [\n+                Document(\n+                    id=str(doc[\"_id\"]),\n+                    name=doc.get(\"name\"),\n+                    content=doc[\"content\"],\n+                    meta_data={**doc.get(\"meta_data\", {}), \"score\": doc.get(\"score\", 0.0)},\n+                )\n+                for doc in results\n+            ]\n+            log_info(f\"Hybrid search completed. Found {len(docs)} documents.\")\n+            return docs\n+        except errors.OperationFailure as e:\n+            logger.error(\n+                f\"Error during hybrid search, potentially due to missing or misconfigured Atlas Search index for text search: {e}\"\n+            )\n+            logger.error(f\"Details: {e.details}\")\n+            return []\n+        except Exception as e:\n+            logger.error(f\"Error during hybrid search: {e}\")\n+            import traceback\n+\n+            logger.error(f\"Traceback: {traceback.format_exc()}\")\n+            return []\n \n     def drop(self) -> None:\n         \"\"\"Drop the collection and clean up indexes.\"\"\"\n@@ -711,13 +882,15 @@ class MongoDb(VectorDb):\n             try:\n                 collection = self._get_collection()\n                 result = collection.delete_many({})\n-                success = result.deleted_count >= 0  # Consider any deletion (even 0) as success\n+                # Consider any deletion (even 0) as success\n+                success = result.deleted_count >= 0\n                 log_info(f\"Deleted {result.deleted_count} documents from collection.\")\n                 return success\n             except Exception as e:\n                 logger.error(f\"Error deleting documents: {e}\")\n                 return False\n-        return True  # Return True if collection doesn't exist (nothing to delete)\n+        # Return True if collection doesn't exist (nothing to delete)\n+        return True\n \n     def prepare_doc(self, document: Document, filters: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n         \"\"\"Prepare a document for insertion or upsertion into MongoDB.\"\"\"\n"
        }
    ]
}
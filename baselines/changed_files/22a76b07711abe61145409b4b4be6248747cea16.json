{
    "sha_fail": "22a76b07711abe61145409b4b4be6248747cea16",
    "changed_files": [
        {
            "commit": "22a76b07711abe61145409b4b4be6248747cea16",
            "file_path": "redash/query_runner/jql.py",
            "diff": "diff --git a/redash/query_runner/jql.py b/redash/query_runner/jql.py\nindex f7d26aa..b5d20a0 100644\n--- a/redash/query_runner/jql.py\n+++ b/redash/query_runner/jql.py\n@@ -34,9 +34,13 @@ class ResultSet:\n \n def parse_issue(issue, field_mapping):  # noqa: C901\n     result = OrderedDict()\n-    result[\"key\"] = issue[\"key\"]\n-\n-    for k, v in issue[\"fields\"].items():  #\n+    \n+    # Handle API v3 response format: key field may be missing, use id as fallback\n+    result[\"key\"] = issue.get(\"key\", issue.get(\"id\", \"unknown\"))\n+    \n+    # Handle API v3 response format: fields may be missing\n+    fields = issue.get(\"fields\", {})\n+    for k, v in fields.items():  #\n         output_name = field_mapping.get_output_field_name(k)\n         member_names = field_mapping.get_dict_members(k)\n \n@@ -98,7 +102,9 @@ def parse_issues(data, field_mapping):\n \n def parse_count(data):\n     results = ResultSet()\n-    results.add_row({\"count\": data[\"total\"]})\n+    # API v3 may not return 'total' field, fallback to counting issues\n+    count = data.get(\"total\", len(data.get(\"issues\", [])))\n+    results.add_row({\"count\": count})\n     return results\n \n \n@@ -160,12 +166,17 @@ class JiraJQL(BaseHTTPQueryRunner):\n         self.syntax = \"json\"\n \n     def run_query(self, query, user):\n-        jql_url = \"{}/rest/api/2/search\".format(self.configuration[\"url\"])\n+        # Updated to API v3 endpoint, fix double slash issue\n+        jql_url = \"{}/rest/api/3/search/jql\".format(self.configuration[\"url\"].rstrip(\"/\"))\n \n         query = json_loads(query)\n         query_type = query.pop(\"queryType\", \"select\")\n         field_mapping = FieldMapping(query.pop(\"fieldMapping\", {}))\n \n+        # API v3 requires mandatory jql parameter with restrictions\n+        if \"jql\" not in query or not query[\"jql\"]:\n+            query[\"jql\"] = \"created >= -30d order by created DESC\"\n+\n         if query_type == \"count\":\n             query[\"maxResults\"] = 1\n             query[\"fields\"] = \"\"\n@@ -182,17 +193,15 @@ class JiraJQL(BaseHTTPQueryRunner):\n             results = parse_count(data)\n         else:\n             results = parse_issues(data, field_mapping)\n-            index = data[\"startAt\"] + data[\"maxResults\"]\n-\n-            while data[\"total\"] > index:\n-                query[\"startAt\"] = index\n+            \n+            # API v3 uses token-based pagination instead of startAt/total\n+            while not data.get(\"isLast\", True) and \"nextPageToken\" in data:\n+                query[\"nextPageToken\"] = data[\"nextPageToken\"]\n                 response, error = self.get_response(jql_url, params=query)\n                 if error is not None:\n                     return None, error\n \n                 data = response.json()\n-                index = data[\"startAt\"] + data[\"maxResults\"]\n-\n                 addl_results = parse_issues(data, field_mapping)\n                 results.merge(addl_results)\n \n"
        }
    ]
}
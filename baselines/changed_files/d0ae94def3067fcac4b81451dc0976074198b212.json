{
    "sha_fail": "d0ae94def3067fcac4b81451dc0976074198b212",
    "changed_files": [
        {
            "commit": "d0ae94def3067fcac4b81451dc0976074198b212",
            "file_path": "g4f/Provider/Copilot.py",
            "diff": "diff --git a/g4f/Provider/Copilot.py b/g4f/Provider/Copilot.py\nindex ccacb8d..a6d103f 100644\n--- a/g4f/Provider/Copilot.py\n+++ b/g4f/Provider/Copilot.py\n@@ -119,7 +119,7 @@ class Copilot(AsyncAuthedProvider, ProviderModelMixin):\n         model = cls.get_model(model)\n         websocket_url = cls.websocket_url\n         headers = None\n-        if cls._access_token:\n+        if cls._access_token or cls.needs_auth:\n             if api_key is not None:\n                 cls._access_token = api_key\n             if cls._access_token is None:\n@@ -144,17 +144,17 @@ class Copilot(AsyncAuthedProvider, ProviderModelMixin):\n         ) as session:\n             if cls._access_token is not None:\n                 cls._cookies = session.cookies.jar if hasattr(session.cookies, \"jar\") else session.cookies\n-            response = await session.get(\"https://copilot.microsoft.com/c/api/user?api-version=2\", headers={\"x-useridentitytype\": useridentitytype})\n-            if response.status_code == 401:\n-                raise MissingAuthError(\"Status 401: Invalid access token\")\n-            response.raise_for_status()\n-            user = response.json().get('firstName')\n-            if user is None:\n-                if cls.needs_auth:\n-                    raise MissingAuthError(\"No user found, please login first\")\n-                cls._access_token = None\n-            else:\n-                debug.log(f\"Copilot: User: {user}\")\n+                response = await session.get(\"https://copilot.microsoft.com/c/api/user?api-version=2\", headers={\"x-useridentitytype\": useridentitytype})\n+                if response.status_code == 401:\n+                    raise MissingAuthError(\"Status 401: Invalid access token\")\n+                response.raise_for_status()\n+                user = response.json().get('firstName')\n+                if user is None:\n+                    if cls.needs_auth:\n+                        raise MissingAuthError(\"No user found, please login first\")\n+                    cls._access_token = None\n+                else:\n+                    debug.log(f\"Copilot: User: {user}\")\n             if conversation is None:\n                 response = await session.post(cls.conversation_url, headers={\"x-useridentitytype\": useridentitytype})\n                 response.raise_for_status()\n@@ -168,50 +168,50 @@ class Copilot(AsyncAuthedProvider, ProviderModelMixin):\n                 yield conversation\n \n             uploaded_attachments = []\n-            \n-            # Upload regular media (images)\n-            for media, _ in merge_media(media, messages):\n-                if not isinstance(media, str):\n-                    data = to_bytes(media)\n-                    response = await session.post(\n-                        \"https://copilot.microsoft.com/c/api/attachments\",\n-                        headers={\n-                            \"content-type\": is_accepted_format(data),\n-                            \"content-length\": str(len(data)),\n-                            \"x-useridentitytype\": useridentitytype\n-                        },\n-                        data=data\n-                    )\n-                    response.raise_for_status()\n-                    media = response.json().get(\"url\")\n-                uploaded_attachments.append({\"type\":\"image\", \"url\": media})\n+            if cls._access_token is not None:\n+                # Upload regular media (images)\n+                for media, _ in merge_media(media, messages):\n+                    if not isinstance(media, str):\n+                        data = to_bytes(media)\n+                        response = await session.post(\n+                            \"https://copilot.microsoft.com/c/api/attachments\",\n+                            headers={\n+                                \"content-type\": is_accepted_format(data),\n+                                \"content-length\": str(len(data)),\n+                                \"x-useridentitytype\": useridentitytype\n+                            },\n+                            data=data\n+                        )\n+                        response.raise_for_status()\n+                        media = response.json().get(\"url\")\n+                    uploaded_attachments.append({\"type\":\"image\", \"url\": media})\n \n-            # Upload bucket files\n-            bucket_items = extract_bucket_items(messages)\n-            for item in bucket_items:\n-                try:\n-                    # Handle plain text content from bucket\n-                    bucket_path = Path(get_bucket_dir(item[\"bucket_id\"]))\n-                    for text_chunk in read_bucket(bucket_path):\n-                        if text_chunk.strip():\n-                            # Upload plain text as a text file\n-                            text_data = text_chunk.encode('utf-8')\n-                            data = CurlMime()\n-                            data.addpart(\"file\", filename=f\"bucket_{item['bucket_id']}.txt\", content_type=\"text/plain\", data=text_data)\n-                            response = await session.post(\n-                                \"https://copilot.microsoft.com/c/api/attachments\",\n-                                multipart=data,\n-                                headers={\"x-useridentitytype\": useridentitytype}\n-                            )\n-                            response.raise_for_status()\n-                            data = response.json()\n-                            uploaded_attachments.append({\"type\": \"document\", \"attachmentId\": data.get(\"id\")})\n-                            debug.log(f\"Copilot: Uploaded bucket text content: {item['bucket_id']}\")\n-                        else:\n-                            debug.log(f\"Copilot: No text content found in bucket: {item['bucket_id']}\")\n-                except Exception as e:\n-                    debug.log(f\"Copilot: Failed to upload bucket item: {item}\")\n-                    debug.error(e)\n+                # Upload bucket files\n+                bucket_items = extract_bucket_items(messages)\n+                for item in bucket_items:\n+                    try:\n+                        # Handle plain text content from bucket\n+                        bucket_path = Path(get_bucket_dir(item[\"bucket_id\"]))\n+                        for text_chunk in read_bucket(bucket_path):\n+                            if text_chunk.strip():\n+                                # Upload plain text as a text file\n+                                text_data = text_chunk.encode('utf-8')\n+                                data = CurlMime()\n+                                data.addpart(\"file\", filename=f\"bucket_{item['bucket_id']}.txt\", content_type=\"text/plain\", data=text_data)\n+                                response = await session.post(\n+                                    \"https://copilot.microsoft.com/c/api/attachments\",\n+                                    multipart=data,\n+                                    headers={\"x-useridentitytype\": useridentitytype}\n+                                )\n+                                response.raise_for_status()\n+                                data = response.json()\n+                                uploaded_attachments.append({\"type\": \"document\", \"attachmentId\": data.get(\"id\")})\n+                                debug.log(f\"Copilot: Uploaded bucket text content: {item['bucket_id']}\")\n+                            else:\n+                                debug.log(f\"Copilot: No text content found in bucket: {item['bucket_id']}\")\n+                    except Exception as e:\n+                        debug.log(f\"Copilot: Failed to upload bucket item: {item}\")\n+                        debug.error(e)\n \n             if prompt is None:\n                 prompt = get_last_user_message(messages, False)\n"
        },
        {
            "commit": "d0ae94def3067fcac4b81451dc0976074198b212",
            "file_path": "g4f/Provider/qwen/QwenCode.py",
            "diff": "diff --git a/g4f/Provider/qwen/QwenCode.py b/g4f/Provider/qwen/QwenCode.py\nindex 7fccbe6..4df8942 100644\n--- a/g4f/Provider/qwen/QwenCode.py\n+++ b/g4f/Provider/qwen/QwenCode.py\n@@ -20,7 +20,11 @@ class QwenCode(OpenaiTemplate):\n \n     @classmethod\n     def get_models(cls, **kwargs):\n-        if cls.live == 0 and cls.client.shared_manager.isTokenValid(cls.client.shared_manager.getCurrentCredentials()):\n+        if cls.live == 0:\n+            cls.client.shared_manager.checkAndReloadIfNeeded()\n+            creds = cls.client.shared_manager.getCurrentCredentials()\n+            if creds:\n+                cls.client.shared_manager.isTokenValid(creds)\n             cls.live += 1\n         return cls.models\n \n@@ -46,9 +50,7 @@ class QwenCode(OpenaiTemplate):\n                 if chunk != last_chunk:\n                     yield chunk\n                 last_chunk = chunk\n-        except TokenManagerError as e:\n-            raise MissingAuthError(f\"QwenCode: No valid authentication available: {e}\")\n-        except MissingAuthError:\n+        except TokenManagerError:\n             await cls.client.shared_manager.getValidCredentials(cls.client.qwen_client, True)\n             creds = await cls.client.get_valid_token()\n             last_chunk = None\n"
        },
        {
            "commit": "d0ae94def3067fcac4b81451dc0976074198b212",
            "file_path": "g4f/Provider/qwen/sharedTokenManager.py",
            "diff": "diff --git a/g4f/Provider/qwen/sharedTokenManager.py b/g4f/Provider/qwen/sharedTokenManager.py\nindex 90fb29d..07026bd 100644\n--- a/g4f/Provider/qwen/sharedTokenManager.py\n+++ b/g4f/Provider/qwen/sharedTokenManager.py\n@@ -86,7 +86,7 @@ class SharedTokenManager(AuthFileMixin):\n \n     async def getValidCredentials(self, qwen_client: IQwenOAuth2Client, force_refresh: bool = False):\n         try:\n-            await self.checkAndReloadIfNeeded()\n+            self.checkAndReloadIfNeeded()\n \n             if (\n                 self.memory_cache[\"credentials\"]\n@@ -107,7 +107,7 @@ class SharedTokenManager(AuthFileMixin):\n                 raise\n             raise TokenManagerError(TokenError.REFRESH_FAILED, str(e), e)\n \n-    async def checkAndReloadIfNeeded(self):\n+    def checkAndReloadIfNeeded(self):\n         now = int(time.time() * 1000)\n         if now - self.memory_cache[\"last_check\"] < CACHE_CHECK_INTERVAL_MS:\n             return\n@@ -149,12 +149,13 @@ class SharedTokenManager(AuthFileMixin):\n     async def performTokenRefresh(self, qwen_client: IQwenOAuth2Client, force_refresh: bool):\n         lock_path = self.getLockFilePath()\n         try:\n+            qwen_client.setCredentials(self.memory_cache[\"credentials\"])\n             current_credentials = qwen_client.getCredentials()\n             if not current_credentials.get(\"refresh_token\"):\n                 raise TokenManagerError(TokenError.NO_REFRESH_TOKEN, \"No refresh token\")\n             await self.acquireLock(lock_path)\n \n-            await self.checkAndReloadIfNeeded()\n+            self.checkAndReloadIfNeeded()\n \n             if (\n                 not force_refresh\n"
        },
        {
            "commit": "d0ae94def3067fcac4b81451dc0976074198b212",
            "file_path": "g4f/gui/server/backend_api.py",
            "diff": "diff --git a/g4f/gui/server/backend_api.py b/g4f/gui/server/backend_api.py\nindex d29e1bb..bf6559c 100644\n--- a/g4f/gui/server/backend_api.py\n+++ b/g4f/gui/server/backend_api.py\n@@ -31,7 +31,7 @@ try:\n except ImportError as e:\n     has_markitdown = False\n try:\n-    from .crypto import rsa, serialization, create_or_read_keys, decrypt_data, encrypt_data, get_session_key\n+    from .crypto import serialization, create_or_read_keys, decrypt_data, encrypt_data, get_session_key\n     has_crypto = True\n except ImportError:\n     has_crypto = False\n@@ -42,7 +42,7 @@ from ...providers.response import FinishReason, AudioResponse, MediaResponse, Re\n from ...client.helper import filter_markdown\n from ...tools.files import supports_filename, get_streaming, get_bucket_dir, get_tempfile\n from ...tools.run_tools import iter_run_tools\n-from ...errors import ProviderNotFoundError, MissingAuthError\n+from ...errors import ModelNotFoundError, ProviderNotFoundError, MissingAuthError, RateLimitError\n from ...image import is_allowed_extension, process_image, MEDIA_TYPE_MAP\n from ...cookies import get_cookies_dir\n from ...image.copy_images import secure_filename, get_source_url, get_media_dir, copy_media\n@@ -368,6 +368,12 @@ class Backend_Api(Api):\n                     response = response if isinstance(response, str) else \"\".join(response)\n                     return Response(filter_markdown(response, None if is_true_filter else do_filter, response if is_true_filter else \"\"), mimetype='text/plain')\n                 return Response(response, mimetype='text/plain')\n+            except (ModelNotFoundError, ProviderNotFoundError) as e:\n+                return jsonify({\"error\": {\"message\": f\"{type(e).__name__}: {e}\"}}), 404\n+            except MissingAuthError as e:\n+                return jsonify({\"error\": {\"message\": f\"{type(e).__name__}: {e}\"}}), 401\n+            except RateLimitError as e:\n+                return jsonify({\"error\": {\"message\": f\"{type(e).__name__}: {e}\"}}), 429\n             except Exception as e:\n                 logger.exception(e)\n                 return jsonify({\"error\": {\"message\": f\"{type(e).__name__}: {e}\"}}), 500\n"
        },
        {
            "commit": "d0ae94def3067fcac4b81451dc0976074198b212",
            "file_path": "scripts/start-browser.sh",
            "diff": "diff --git a/scripts/start-browser.sh b/scripts/start-browser.sh\nnew file mode 100755\nindex 0000000..9315f00\n--- /dev/null\n+++ b/scripts/start-browser.sh\n@@ -0,0 +1,6 @@\n+#!/bin/bash\n+while true; do\n+    sleep 5\n+    rm ~/.config/g4f/cookies/.nodriver_is_open\n+    google-chrome --remote-allow-origins=* --no-first-run --no-service-autorun --no-default-browser-check --homepage=about:blank --no-pings --password-store=basic --disable-infobars --disable-breakpad --disable-dev-shm-usage --disable-session-crashed-bubble --disable-search-engine-choice-screen --user-data-dir=\"~/.config/g4f-nodriver\" --disable-session-crashed-bubble --disable-features=IsolateOrigins,site-per-process --no-sandbox --remote-debugging-host=127.0.0.1 --remote-debugging-port=57011\n+done\n\\ No newline at end of file\n"
        }
    ]
}
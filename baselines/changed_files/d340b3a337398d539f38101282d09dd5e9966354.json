{
    "sha_fail": "d340b3a337398d539f38101282d09dd5e9966354",
    "changed_files": [
        {
            "commit": "d340b3a337398d539f38101282d09dd5e9966354",
            "file_path": "cookbook/tools/models/morph.py",
            "diff": "diff --git a/cookbook/tools/models/morph.py b/cookbook/tools/models/morph.py\nnew file mode 100644\nindex 000000000..35b44b271\n--- /dev/null\n+++ b/cookbook/tools/models/morph.py\n@@ -0,0 +1,72 @@\n+\"\"\"\n+Simple example showing Morph Fast Apply with file creation and editing.\n+\"\"\"\n+\n+from pathlib import Path\n+\n+from agno.agent import Agent\n+from agno.models.openai import OpenAIChat\n+from agno.tools.models.morph import MorphTools\n+\n+\n+def create_sample_file():\n+    \"\"\"Create a simple Python file in tmp directory for testing\"\"\"\n+    # Create tmp directory if it doesn't exist\n+    tmp_dir = Path(\"tmp\")\n+    tmp_dir.mkdir(exist_ok=True)\n+\n+    # Create a simple Python file\n+    sample_file = tmp_dir / \"calculator.py\"\n+\n+    sample_code = \"\"\"\n+def add(a, b):\n+    return a + b\n+\n+def multiply(x, y):\n+    result = x * y\n+    return result\n+\n+class Calculator:\n+    def __init__(self):\n+        self.history = []\n+    \n+    def calculate(self, operation, a, b):\n+        if operation == \"add\":\n+            result = add(a, b)\n+        elif operation == \"multiply\":\n+            result = multiply(a, b)\n+        else:\n+            result = None\n+        return result\n+\"\"\"\n+\n+    with open(sample_file, \"w\") as f:\n+        f.write(sample_code)\n+\n+    return str(sample_file)\n+\n+\n+def main():\n+    target_file = create_sample_file()\n+\n+    code_editor = Agent(\n+        model=OpenAIChat(id=\"gpt-4o\"),\n+        tools=[MorphTools(model=\"morph-v3-large\")],\n+        debug_mode=True,\n+        markdown=True,\n+    )\n+\n+    # Request to improve the code\n+    improvement_request = f\"\"\"\n+        Please improve the Python code in \"{target_file}\" by adding:\n+\n+        1. Type hints for all functions and methods\n+        2. Docstrings for all functions and the Calculator class\n+        3. Error handling and input validation\n+    \"\"\"  # <-- Or directly provide the code here\n+\n+    code_editor.print_response(improvement_request)\n+\n+\n+if __name__ == \"__main__\":\n+    main()\n"
        },
        {
            "commit": "d340b3a337398d539f38101282d09dd5e9966354",
            "file_path": "libs/agno/agno/tools/models/morph.py",
            "diff": "diff --git a/libs/agno/agno/tools/models/morph.py b/libs/agno/agno/tools/models/morph.py\nnew file mode 100644\nindex 000000000..e3e32fdcd\n--- /dev/null\n+++ b/libs/agno/agno/tools/models/morph.py\n@@ -0,0 +1,186 @@\n+import os\n+from os import getenv\n+from textwrap import dedent\n+from typing import Optional\n+\n+from agno.tools import Toolkit\n+from agno.utils.log import log_debug, log_error\n+\n+try:\n+    from openai import OpenAI\n+except ImportError:\n+    raise ImportError(\"`openai` not installed. Please install using `pip install openai`\")\n+\n+\n+class MorphTools(Toolkit):\n+    \"\"\"Tools for interacting with Morph's Fast Apply API for code editing\"\"\"\n+\n+    def __init__(\n+        self,\n+        api_key: Optional[str] = None,\n+        base_url: str = \"https://api.morphllm.com/v1\",\n+        instructions: Optional[str] = None,\n+        add_instructions: bool = True,\n+        model: str = \"morph-v3-large\",\n+        **kwargs,\n+    ):\n+        \"\"\"Initialize Morph Fast Apply tools.\n+\n+        Args:\n+            api_key: Morph API key. If not provided, will look for MORPH_API_KEY environment variable.\n+            base_url: The base URL for the Morph API.\n+            model: The Morph model to use. Options:\n+                  - \"morph-v3-fast\" (4500+ tok/sec, 96% accuracy)\n+                  - \"morph-v3-large\" (2500+ tok/sec, 98% accuracy)\n+                  - \"auto\" (automatic selection)\n+            **kwargs: Additional arguments to pass to Toolkit.\n+        \"\"\"\n+        # Set up instructions\n+        if instructions is None:\n+            self.instructions = self.DEFAULT_INSTRUCTIONS\n+        else:\n+            self.instructions = instructions\n+\n+        super().__init__(\n+            name=\"morph_tools\",\n+            tools=[self.edit_file],\n+            instructions=self.instructions,\n+            add_instructions=add_instructions,\n+            **kwargs,\n+        )\n+\n+        self.api_key = api_key or getenv(\"MORPH_API_KEY\")\n+        if not self.api_key:\n+            raise ValueError(\"MORPH_API_KEY not set. Please set the MORPH_API_KEY environment variable.\")\n+\n+        self.base_url = base_url\n+        self.model = model\n+        self._morph_client: Optional[OpenAI] = None\n+\n+    def _get_client(self):\n+        \"\"\"Get or create the Morph OpenAI client.\"\"\"\n+        if self._morph_client is None:\n+            self._morph_client = OpenAI(\n+                api_key=self.api_key,\n+                base_url=self.base_url,\n+            )\n+        return self._morph_client\n+\n+    def edit_file(\n+        self,\n+        target_file: str,\n+        instructions: str,\n+        code_edit: str,\n+        original_code: Optional[str] = None,\n+    ) -> str:\n+        \"\"\"\n+        Apply code edits to a target file using Morph's Fast Apply API.\n+    \n+        This function reads the specified file, sends its content along with\n+        editing instructions and code edits to Morph's API, and writes the\n+        resulting code back to the file. A backup of the original file is \n+        created before writing changes.\n+    \n+        Args:\n+            target_file (str): Path to the file to be edited.\n+            instructions (str): High-level instructions describing the intended change.\n+            code_edit (str): Specific code edit or change to apply.\n+            original_code (Optional[str], optional): Original content of the file. \n+                If not provided, the function reads from target_file.\n+    \n+        Returns:\n+            str: Result message indicating success or failure, and details about \n+                the backup and any errors encountered.\n+        \"\"\"\n+        try:\n+            # Always read the actual file content for backup purposes\n+            actual_file_content = None\n+            if os.path.exists(target_file):\n+                try:\n+                    with open(target_file, \"r\", encoding=\"utf-8\") as f:\n+                        actual_file_content = f.read()\n+                except Exception as e:\n+                    return f\"Error reading {target_file} for backup: {e}\"\n+            else:\n+                return f\"Error: File {target_file} does not exist.\"\n+\n+            # Use provided original_code or fall back to file content\n+            code_to_process = original_code if original_code is not None else actual_file_content\n+\n+            # Format the message for Morph's Fast Apply API\n+            content = f\"<instruction>{instructions}</instruction>\\n<code>{code_to_process}</code>\\n<update>{code_edit}</update>\"\n+\n+            log_debug(f\"Input to Morph: {content}\")\n+\n+            client = self._get_client()\n+\n+            response = client.chat.completions.create(\n+                model=self.model,\n+                messages=[\n+                    {\n+                        \"role\": \"user\",\n+                        \"content\": content,\n+                    }\n+                ],\n+            )\n+\n+            if response.choices and response.choices[0].message.content:\n+                final_code = response.choices[0].message.content\n+\n+                try:\n+                    backup_file = f\"{target_file}.backup\"\n+                    with open(backup_file, \"w\", encoding=\"utf-8\") as f:\n+                        f.write(actual_file_content)\n+\n+                    # Write the new code\n+                    with open(target_file, \"w\", encoding=\"utf-8\") as f:\n+                        f.write(final_code)\n+                    return f\"Successfully applied edit to {target_file} using Morph Fast Apply! Original content backed up as {backup_file}\"\n+\n+                except Exception as e:\n+                    return f\"Successfully applied edit but failed to write back to {target_file}: {e}\"\n+\n+            else:\n+                return f\"Failed to apply edit to {target_file}: No response from Morph API\"\n+\n+        except Exception as e:\n+            log_error(f\"Failed to apply edit using Morph Fast Apply: {e}\")\n+            return f\"Failed to apply edit to {target_file}: {e}\"\n+\n+    DEFAULT_INSTRUCTIONS = dedent(\"\"\"\\\n+            You have access to Morph Fast Apply for ultra-fast code editing with 98% accuracy at 2500+ tokens/second.\n+\n+            ## How to use the edit_file tool:\n+\n+            **Critical Requirements:**\n+            1. **Instructions Parameter**: Generate clear first-person instructions describing what you're doing\n+            - Example: \"I am adding type hints to all functions and methods\"\n+            - Example: \"I am refactoring the error handling to use try-catch blocks\"\n+\n+            2. **Code Edit Parameter**: Specify ONLY the lines you want to change\n+            - Use `# ... existing code ...` (or `// ... existing code ...` for JS/Java) to represent unchanged sections\n+            - NEVER write out unchanged code in the code_edit parameter\n+            - Include sufficient context around changes to resolve ambiguity\n+\n+            3. **Single Edit Call**: Make ALL edits to a file in a single edit_file call. The apply model can handle many distinct edits at once.\n+\n+            **Example Format:**\n+            ```\n+            # ... existing code ...\n+            def add(a: int, b: int) -> int:\n+                \\\"\\\"\\\"Add two numbers together.\\\"\\\"\\\"\n+                return a + b\n+            # ... existing code ...\n+            def multiply(x: int, y: int) -> int:\n+                \\\"\\\"\\\"Multiply two numbers.\\\"\\\"\\\"\n+                return x * y\n+            # ... existing code ...\n+            ```\n+\n+            **Important Guidelines:**\n+            - Bias towards repeating as few lines as possible while conveying the change clearly\n+            - Each edit should contain sufficient context of unchanged lines around the code you're editing\n+            - DO NOT omit spans of pre-existing code without using the `# ... existing code ...` comment\n+            - If deleting a section, provide context before and after to clearly indicate the deletion\n+            - The tool automatically creates backup files before applying changes\\\n+        \"\"\")\n"
        },
        {
            "commit": "d340b3a337398d539f38101282d09dd5e9966354",
            "file_path": "libs/agno/tests/unit/tools/models/test_morph.py",
            "diff": "diff --git a/libs/agno/tests/unit/tools/models/test_morph.py b/libs/agno/tests/unit/tools/models/test_morph.py\nnew file mode 100644\nindex 000000000..229c40f98\n--- /dev/null\n+++ b/libs/agno/tests/unit/tools/models/test_morph.py\n@@ -0,0 +1,256 @@\n+from unittest.mock import MagicMock, mock_open, patch\n+\n+import pytest\n+\n+from agno.tools.models.morph import MorphTools\n+\n+\n+# Fixture for mock OpenAI client\n+@pytest.fixture\n+def mock_openai_client():\n+    client = MagicMock()\n+    return client\n+\n+\n+# Fixture for mock MorphTools with mock client\n+@pytest.fixture\n+def mock_morph_tools(mock_openai_client):\n+    with patch(\"agno.tools.models.morph.OpenAI\", return_value=mock_openai_client) as _:\n+        morph_tools = MorphTools(api_key=\"fake_test_key\")\n+        morph_tools._morph_client = mock_openai_client\n+        return morph_tools\n+\n+\n+# Fixture for successful API response\n+@pytest.fixture\n+def mock_successful_response():\n+    mock_response = MagicMock()\n+    mock_choice = MagicMock()\n+    mock_choice.message.content = \"\"\"def add(a: int, b: int) -> int:\n+    \\\"\\\"\\\"Add two numbers together.\\\"\\\"\\\"\n+    return a + b\n+\n+def multiply(x: int, y: int) -> int:\n+    \\\"\\\"\\\"Multiply two numbers.\\\"\\\"\\\"\n+    result = x * y\n+    return result\"\"\"\n+    mock_response.choices = [mock_choice]\n+    return mock_response\n+\n+\n+# Fixture for failed API response (no content)\n+@pytest.fixture\n+def mock_failed_response():\n+    mock_response = MagicMock()\n+    mock_response.choices = []\n+    return mock_response\n+\n+\n+# Test Initialization\n+def test_morph_tools_init_with_api_key_arg():\n+    \"\"\"Test initialization with API key provided as an argument.\"\"\"\n+    api_key = \"test_api_key_arg\"\n+\n+    with patch(\"agno.tools.models.morph.OpenAI\") as mock_openai_cls:\n+        mock_client_instance = MagicMock()\n+        mock_openai_cls.return_value = mock_client_instance\n+\n+        morph_tools = MorphTools(api_key=api_key)\n+\n+        assert morph_tools.api_key == api_key\n+        assert morph_tools.base_url == \"https://api.morphllm.com/v1\"\n+        assert morph_tools.model == \"morph-v3-large\"\n+        assert morph_tools._morph_client is None  # Client created lazily\n+\n+\n+def test_morph_tools_init_with_env_var():\n+    \"\"\"Test initialization with API key from environment variable.\"\"\"\n+    env_api_key = \"test_api_key_env\"\n+\n+    with patch(\"agno.tools.models.morph.getenv\", return_value=env_api_key) as mock_getenv:\n+        morph_tools = MorphTools()\n+\n+        assert morph_tools.api_key == env_api_key\n+        mock_getenv.assert_called_once_with(\"MORPH_API_KEY\")\n+\n+\n+def test_morph_tools_init_no_api_key():\n+    \"\"\"Test initialization raises ValueError when no API key is found.\"\"\"\n+    with patch(\"agno.tools.models.morph.getenv\", return_value=None) as mock_getenv:\n+        with pytest.raises(ValueError, match=\"MORPH_API_KEY not set\"):\n+            MorphTools()\n+\n+        mock_getenv.assert_called_once_with(\"MORPH_API_KEY\")\n+\n+\n+# Test edit_file method - Success cases\n+def test_edit_file_success_with_file_reading(mock_morph_tools, mock_successful_response):\n+    \"\"\"Test successful file editing when reading from existing file.\"\"\"\n+    target_file = \"test_file.py\"\n+    original_content = \"def add(a, b):\\n    return a + b\"\n+    instructions = \"I am adding type hints to the function\"\n+    code_edit = \"def add(a: int, b: int) -> int:\\n    return a + b\"\n+\n+    mock_morph_tools._morph_client.chat.completions.create.return_value = mock_successful_response\n+\n+    with patch(\"os.path.exists\", return_value=True):\n+        with patch(\"builtins.open\", mock_open(read_data=original_content)) as mock_file:\n+            result = mock_morph_tools.edit_file(target_file=target_file, instructions=instructions, code_edit=code_edit)\n+\n+    # Verify file operations\n+    mock_file.assert_any_call(target_file, \"r\", encoding=\"utf-8\")\n+    mock_file.assert_any_call(f\"{target_file}.backup\", \"w\", encoding=\"utf-8\")\n+    mock_file.assert_any_call(target_file, \"w\", encoding=\"utf-8\")\n+\n+    # Verify API call\n+    expected_content = (\n+        f\"<instruction>{instructions}</instruction>\\n<code>{original_content}</code>\\n<update>{code_edit}</update>\"\n+    )\n+    mock_morph_tools._morph_client.chat.completions.create.assert_called_once_with(\n+        model=\"morph-v3-large\", messages=[{\"role\": \"user\", \"content\": expected_content}]\n+    )\n+\n+    assert \"Successfully applied edit\" in result\n+    assert \"File updated!\" in result\n+\n+\n+def test_edit_file_success_with_provided_original_code(mock_morph_tools, mock_successful_response):\n+    \"\"\"Test successful file editing when original code is provided.\"\"\"\n+    target_file = \"test_file.py\"\n+    file_content = \"def old_function():\\n    pass\"\n+    provided_original = \"def add(a, b):\\n    return a + b\"\n+    instructions = \"I am adding type hints to the function\"\n+    code_edit = \"def add(a: int, b: int) -> int:\\n    return a + b\"\n+\n+    mock_morph_tools._morph_client.chat.completions.create.return_value = mock_successful_response\n+\n+    with patch(\"os.path.exists\", return_value=True):\n+        with patch(\"builtins.open\", mock_open(read_data=file_content)) as mock_file:\n+            result = mock_morph_tools.edit_file(\n+                target_file=target_file, instructions=instructions, code_edit=code_edit, original_code=provided_original\n+            )\n+\n+    # Verify API call uses provided original code\n+    expected_content = (\n+        f\"<instruction>{instructions}</instruction>\\n<code>{provided_original}</code>\\n<update>{code_edit}</update>\"\n+    )\n+    mock_morph_tools._morph_client.chat.completions.create.assert_called_once_with(\n+        model=\"morph-v3-large\", messages=[{\"role\": \"user\", \"content\": expected_content}]\n+    )\n+\n+    # Verify backup uses actual file content, not provided original\n+    handle = mock_file()\n+    backup_write_calls = [call for call in handle.write.call_args_list if call[0][0] == file_content]\n+    assert len(backup_write_calls) == 1\n+\n+    assert \"Successfully applied edit\" in result\n+\n+\n+def test_edit_file_no_response_content(mock_morph_tools, mock_failed_response):\n+    \"\"\"Test edit_file when API returns no content.\"\"\"\n+    target_file = \"test_file.py\"\n+    original_content = \"def test(): pass\"\n+\n+    mock_morph_tools._morph_client.chat.completions.create.return_value = mock_failed_response\n+\n+    with patch(\"os.path.exists\", return_value=True):\n+        with patch(\"builtins.open\", mock_open(read_data=original_content)):\n+            result = mock_morph_tools.edit_file(\n+                target_file=target_file, instructions=\"test instruction\", code_edit=\"test edit\"\n+            )\n+\n+    assert f\"Failed to apply edit to {target_file}: No response from Morph API\" in result\n+\n+\n+def test_edit_file_write_error(mock_morph_tools, mock_successful_response):\n+    \"\"\"Test edit_file when writing back to file fails.\"\"\"\n+    target_file = \"test_file.py\"\n+    original_content = \"def test(): pass\"\n+    write_error = \"Disk full\"\n+\n+    mock_morph_tools._morph_client.chat.completions.create.return_value = mock_successful_response\n+\n+    def mock_open_side_effect(file_path, mode, **kwargs):\n+        if mode == \"r\":\n+            return mock_open(read_data=original_content)()\n+        elif file_path.endswith(\".backup\"):\n+            return mock_open()()\n+        else:  # Writing to target file\n+            raise Exception(write_error)\n+\n+    with patch(\"os.path.exists\", return_value=True):\n+        with patch(\"builtins.open\", side_effect=mock_open_side_effect):\n+            result = mock_morph_tools.edit_file(\n+                target_file=target_file, instructions=\"test instruction\", code_edit=\"test edit\"\n+            )\n+\n+    assert f\"Successfully applied edit but failed to write back to {target_file}: {write_error}\" in result\n+    assert \"Final code:\" in result\n+\n+\n+# Test edge cases\n+def test_edit_file_empty_original_code(mock_morph_tools, mock_successful_response):\n+    \"\"\"Test edit_file with empty original code.\"\"\"\n+    target_file = \"empty_file.py\"\n+    original_content = \"\"\n+\n+    mock_morph_tools._morph_client.chat.completions.create.return_value = mock_successful_response\n+\n+    with patch(\"os.path.exists\", return_value=True):\n+        with patch(\"builtins.open\", mock_open(read_data=original_content)):\n+            result = mock_morph_tools.edit_file(\n+                target_file=target_file, instructions=\"I am adding a new function\", code_edit=\"def new_function(): pass\"\n+            )\n+\n+    assert \"Successfully applied edit\" in result\n+\n+\n+# Test toolkit structure\n+def test_morph_tools_toolkit_structure():\n+    \"\"\"Test that MorphTools properly inherits from Toolkit and has correct structure.\"\"\"\n+    morph_tools = MorphTools(api_key=\"test_key\")\n+\n+    assert morph_tools.name == \"morph_tools\"\n+    assert len(morph_tools.tools) == 1\n+    assert morph_tools.tools[0] == morph_tools.edit_file\n+    assert hasattr(morph_tools, \"edit_file\")\n+    assert callable(morph_tools.edit_file)\n+\n+\n+# Test method signature matches current implementation\n+def test_edit_file_method_signature():\n+    \"\"\"Test that edit_file method has the correct signature.\"\"\"\n+    import inspect\n+\n+    morph_tools = MorphTools(api_key=\"test_key\")\n+    sig = inspect.signature(morph_tools.edit_file)\n+\n+    expected_params = [\"target_file\", \"instructions\", \"code_edit\", \"original_code\"]\n+    actual_params = list(sig.parameters.keys())\n+\n+    assert actual_params == expected_params\n+\n+    # Check that original_code has default None\n+    assert sig.parameters[\"original_code\"].default is None\n+\n+\n+def test_edit_file_always_writes_to_file(mock_morph_tools, mock_successful_response):\n+    \"\"\"Test that edit_file always writes to file in current implementation.\"\"\"\n+    target_file = \"test_file.py\"\n+    original_content = \"def test(): pass\"\n+\n+    mock_morph_tools._morph_client.chat.completions.create.return_value = mock_successful_response\n+\n+    with patch(\"os.path.exists\", return_value=True):\n+        with patch(\"builtins.open\", mock_open(read_data=original_content)) as mock_file:\n+            result = mock_morph_tools.edit_file(\n+                target_file=target_file, instructions=\"test instruction\", code_edit=\"test edit\"\n+            )\n+\n+    # Verify that backup file was created (indicates file writing occurred)\n+    mock_file.assert_any_call(f\"{target_file}.backup\", \"w\", encoding=\"utf-8\")\n+    # Verify that original file was written to\n+    mock_file.assert_any_call(target_file, \"w\", encoding=\"utf-8\")\n+\n+    assert \"File updated!\" in result\n+    assert \"backup\" in result\n"
        }
    ]
}
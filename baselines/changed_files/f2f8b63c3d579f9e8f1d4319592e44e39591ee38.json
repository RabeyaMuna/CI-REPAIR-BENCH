{
    "sha_fail": "f2f8b63c3d579f9e8f1d4319592e44e39591ee38",
    "changed_files": [
        {
            "commit": "f2f8b63c3d579f9e8f1d4319592e44e39591ee38",
            "file_path": "pwndbg/commands/heap_tracking.py",
            "diff": "diff --git a/pwndbg/commands/heap_tracking.py b/pwndbg/commands/heap_tracking.py\nindex 5589ce69..6eb993d8 100644\n--- a/pwndbg/commands/heap_tracking.py\n+++ b/pwndbg/commands/heap_tracking.py\n@@ -39,3 +39,15 @@ parser = argparse.ArgumentParser(description=\"Disables the heap tracker.\")\n @pwndbg.commands.ArgparsedCommand(parser, command_name=\"disable-heap-tracker\")\n def disable_tracker() -> None:\n     pwndbg.gdblib.heap_tracking.uninstall()\n+\n+\n+parser = argparse.ArgumentParser(description=\"Toggles whether possible UAF conditions will pause execution.\")\n+\n+\n+@pwndbg.commands.ArgparsedCommand(parser, command_name=\"toggle-heap-tracker-break\")\n+def toggle_tracker_break() -> None:\n+    pwndbg.gdblib.heap_tracking.stop_on_error = not pwndbg.gdblib.heap_tracking.stop_on_error\n+    if pwndbg.gdblib.heap_tracking.stop_on_error:\n+        print(\"The program will stop when the heap tracker detects an error\")\n+    else:\n+        print(\"The heap tracker will only print a message when it detects an error\")\n"
        },
        {
            "commit": "f2f8b63c3d579f9e8f1d4319592e44e39591ee38",
            "file_path": "pwndbg/gdblib/heap_tracking.py",
            "diff": "diff --git a/pwndbg/gdblib/heap_tracking.py b/pwndbg/gdblib/heap_tracking.py\nindex e19b5694..915046dc 100644\n--- a/pwndbg/gdblib/heap_tracking.py\n+++ b/pwndbg/gdblib/heap_tracking.py\n@@ -47,12 +47,14 @@ that were not made explicit.\n \n \"\"\"\n \n+import itertools\n import gdb\n from sortedcontainers import SortedDict\n \n import pwndbg.gdblib\n from pwndbg.color import message\n \n+LIBC_NAME = \"libc.so.6\"\n MALLOC_NAME = \"malloc\"\n CALLOC_NAME = \"calloc\"\n REALLOC_NAME = \"realloc\"\n@@ -60,6 +62,8 @@ FREE_NAME = \"free\"\n \n last_issue = None\n \n+# Useful to track possbile collision errors.\n+PRINT_DEBUG = False\n \n def is_enabled() -> bool:\n     \"\"\"\n@@ -75,13 +79,40 @@ def is_enabled() -> bool:\n \n     return any(installed)\n \n+def _basename(val):\n+    \"\"\"\n+    Returns the last component of a path.\n+    \"\"\"\n+    val.split(\"/\")[-1]\n \n-def is_available(name: str) -> bool:\n+def resolve_address(name: str) -> int | None:\n     \"\"\"\n-    Checks whether a given symbol is available.\n+    Checks whether a given symbol is available and part of libc, and returns its\n+    address.\n     \"\"\"\n-    return pwndbg.gdblib.symbol.address(name) is not None\n+    # If that fails, try to query for it by using the less precise pwndbg API.\n+    address = pwndbg.gdblib.symbol.address(name) \n+    if not address:\n+        # Nothing that we can do here.\n+        return None\n \n+    # Try to see if this belongs to libc.\n+    #\n+    # This check is, frankly, horrifying, but it's one of the few ways we can\n+    # check what objfile the address we got is coming from*, and it's better to\n+    # err on the side of caution here and at least attempt to prevent the wrong\n+    # symbol from being used, than to return a possibly wrong symbol and have\n+    # the user wonder why on Earth the heap tracker would be hooking to ld.so.\n+    #\n+    # *: A better way would be to use gdb.objfile_from_address, but that's only\n+    # available in relatively recent versions of GDB.\n+    info = gdb.execute(f\"info symbol {address:#x}\", to_string=True, from_tty=False)\n+    info = info.split(\" of \")[-1].split(\"/\")[-1]\n+    if not info or LIBC_NAME not in info:\n+        print(message.warn(f\"Instance of symbol {name} that was found does not seem to belong to an instance of libc whose name is in the form {LIBC_NAME}. Refusing to use.\"))\n+        return None\n+    \n+    return address\n \n class FreeChunkWatchpoint(gdb.Breakpoint):\n     def __init__(self, chunk, tracker):\n@@ -109,10 +140,13 @@ class FreeChunkWatchpoint(gdb.Breakpoint):\n             # We explicitly allow this operation.\n             return False\n \n-        global last_issue\n-        last_issue = message.error(\"Use after free\")\n+        print(f\"[!] Possible use-after-free in {self.chunk.size}-byte chunk at address {self.chunk.address:#x}\")\n \n-        return True\n+        global stop_on_error\n+        if stop_on_error:\n+            global last_issue\n+            last_issue = message.error(\"Use after free\")\n+        return stop_on_error\n \n \n class AllocChunkWatchpoint(gdb.Breakpoint):\n@@ -141,13 +175,9 @@ class Tracker:\n \n     def is_performing_memory_management(self):\n         thread = gdb.selected_thread().global_num\n-        print(f\"Is thread {thread} performing memory management? \", end=\"\")\n-\n         if thread not in self.memory_management_calls:\n-            print(\"False\")\n             return False\n         else:\n-            print(self.memory_management_calls[thread])\n             return self.memory_management_calls[thread]\n \n     def enter_memory_management(self, name):\n@@ -159,7 +189,6 @@ class Tracker:\n                 thread\n             ], f\"in {name}(): re-entrant calls are not supported\"\n \n-        print(f\"Thread {thread} entered memory management\")\n         self.memory_management_calls[thread] = True\n \n     def exit_memory_management(self):\n@@ -169,12 +198,9 @@ class Tracker:\n         if thread in self.memory_management_calls:\n             assert self.memory_management_calls[thread]\n \n-        print(f\"Thread {thread} exited memory management\")\n         self.memory_management_calls[thread] = False\n \n     def malloc(self, chunk):\n-        print(f\"Allocated {chunk.size:#x} byte chunk at {chunk.address:#x}\")\n-\n         # malloc()s may arbitrarily change the structure of freed blocks, to the\n         # point our chunk maps may become invalid, so, we update them here if\n         # anything looks wrong.\n@@ -186,12 +212,6 @@ class Tracker:\n                 # Include the element to the left in the update.\n                 lo_i -= 1\n \n-        print(\"    free chunk map:\")\n-        for ch in self.free_chunks:\n-            print(f\"        {self.free_chunks[ch].address:#x} ({self.free_chunks[ch].size} bytes)\")\n-        print(f\"    lo_i: {lo_i}\")\n-        print(f\"    hi_i: {hi_i}\")\n-\n         try:\n             if lo_i != hi_i:\n                 # The newly registered chunk overlaps with chunks we had registered\n@@ -203,9 +223,6 @@ class Tracker:\n                 lo_addr = lo_chunk.address\n                 hi_addr = hi_chunk.address + hi_chunk.size\n \n-                print(f\"    lo_addr: {lo_addr:#x}\")\n-                print(f\"    hi_addr: {hi_addr:#x}\")\n-\n                 lo_heap = pwndbg.heap.ptmalloc.Heap(lo_addr)\n                 hi_heap = pwndbg.heap.ptmalloc.Heap(hi_addr - 1)\n \n@@ -250,7 +267,6 @@ class Tracker:\n                     bins_list.append(allocator.tcachebins(None))\n                 bins_list = [x for x in bins_list if x is not None]\n \n-                print(f\"Chunks in heap {lo_heap.start:#x}-{lo_heap.end:#x}:\")\n                 for ch in lo_heap:\n                     # Check for range overlap.\n                     ch_lo_addr = ch.address\n@@ -261,14 +277,12 @@ class Tracker:\n                     # Check for range overlap.\n                     ch_lo_addr = ch.address\n                     ch_hi_addr = ch.address + ch.size\n-                    print(f\"        {ch.address:#x} ({ch.real_size} bytes)\", end=\"\")\n \n                     lo_in_range = ch_lo_addr < hi_addr\n                     hi_in_range = ch_hi_addr > lo_addr\n \n                     if not lo_in_range or not hi_in_range:\n                         # No range overlap.\n-                        print(\" (out of range)\")\n                         continue\n \n                     # Check if the chunk is free.\n@@ -280,16 +294,12 @@ class Tracker:\n                             nch = Chunk(ch.address, ch.size, ch.real_size, 0)\n                             wp = FreeChunkWatchpoint(nch, self)\n \n-                            print(\" (free)\")\n-\n                             self.free_chunks[ch.address] = nch\n                             self.free_whatchpoints[ch.address] = wp\n \n                             # Move on to the next chunk.\n                             found = True\n                             break\n-                    if not found:\n-                        print(\" (in use)\")\n         except IndexError as e:\n             import traceback\n \n@@ -312,8 +322,8 @@ class Tracker:\n \n \n class MallocEnterBreakpoint(gdb.Breakpoint):\n-    def __init__(self, tracker):\n-        super().__init__(MALLOC_NAME, internal=True)\n+    def __init__(self, address, tracker):\n+        super().__init__(f\"*{address:#x}\", internal=True)\n         self.tracker = tracker\n \n     def stop(self):\n@@ -325,8 +335,8 @@ class MallocEnterBreakpoint(gdb.Breakpoint):\n \n \n class CallocEnterBreakpoint(gdb.Breakpoint):\n-    def __init__(self, tracker):\n-        super().__init__(CALLOC_NAME, internal=True)\n+    def __init__(self, address, tracker):\n+        super().__init__(f\"*{address:#x}\", internal=True)\n         self.tracker = tracker\n \n     def stop(self):\n@@ -380,7 +390,7 @@ class AllocExitBreakpoint(gdb.FinishBreakpoint):\n         chunk = get_chunk(ret_ptr, self.requested_size)\n         self.tracker.malloc(chunk)\n         print(\n-            f\"Allocated {chunk.size} byte chunk ({self.requested_size} bytes requested) starting at {ret_ptr:#x}\"\n+            f\"[*] Allocated {chunk.size} byte chunk ({self.requested_size} bytes requested) starting at {ret_ptr:#x}\"\n         )\n \n         self.tracker.exit_memory_management()\n@@ -396,8 +406,8 @@ class AllocExitBreakpoint(gdb.FinishBreakpoint):\n \n \n class ReallocEnterBreakpoint(gdb.Breakpoint):\n-    def __init__(self, tracker):\n-        super().__init__(REALLOC_NAME, internal=True)\n+    def __init__(self, address, tracker):\n+        super().__init__(f\"*{address:#x}\", internal=True)\n         self.tracker = tracker\n \n     def stop(self):\n@@ -426,7 +436,7 @@ class ReallocExitBreakpoint(gdb.FinishBreakpoint):\n             return False\n \n         print(\n-            f\"Trying to realloc chunk starting at {self.freed_ptr:#x} to have {self.requested_size} bytes\"\n+            f\"[*] Trying to realloc chunk starting at {self.freed_ptr:#x} to have {self.requested_size} bytes\"\n         )\n \n         # Figure out what the reallocated pointer is.\n@@ -440,7 +450,11 @@ class ReallocExitBreakpoint(gdb.FinishBreakpoint):\n             # This is a chunk we'd never seen before.\n             malloc()\n             self.tracker.exit_memory_management()\n-            return True\n+\n+            print(f\"[!] realloc() with previously unknown pointer {self.freed_ptr:#x}\")\n+\n+            global stop_on_error\n+            return stop_on_error\n \n         malloc()\n         self.tracker.exit_memory_management()\n@@ -452,8 +466,8 @@ class ReallocExitBreakpoint(gdb.FinishBreakpoint):\n \n \n class FreeEnterBreakpoint(gdb.Breakpoint):\n-    def __init__(self, tracker):\n-        super().__init__(FREE_NAME, internal=True)\n+    def __init__(self, address, tracker):\n+        super().__init__(f\"*{address:#x}\", internal=True)\n         self.tracker = tracker\n \n     def stop(self):\n@@ -478,11 +492,15 @@ class FreeExitBreakpoint(gdb.FinishBreakpoint):\n             self.tracker.exit_memory_management()\n             return False\n \n-        print(f\"Trying to free chunk starting at {self.ptr:#x}\")\n+        print(f\"[*] Trying to free chunk starting at {self.ptr:#x}\")\n+\n         if not self.tracker.free(self.ptr):\n             # This is a chunk we'd never seen before.\n             self.tracker.exit_memory_management()\n-            return True\n+            \n+            print(f\"[!] free() with previously unknown pointer {self.freed_ptr:#x}\")\n+            global stop_on_error\n+            return stop_on_error\n \n         self.tracker.exit_memory_management()\n         return False\n@@ -514,6 +532,8 @@ calloc_enter = None\n realloc_enter = None\n free_enter = None\n \n+# Whether the inferior should be stopped when an error is detected.\n+stop_on_error = True\n \n def install(disable_hardware_whatchpoints=True):\n     global malloc_enter\n@@ -527,7 +547,7 @@ def install(disable_hardware_whatchpoints=True):\n \n     # Make sure the required functions are available.\n     required_symbols = [MALLOC_NAME, FREE_NAME]\n-    available = [is_available(name) for name in required_symbols]\n+    available = [resolve_address(name) for name in required_symbols]\n \n     if not all(available):\n         print(message.error(\"The following required symbols are not available:\"))\n@@ -562,14 +582,16 @@ def install(disable_hardware_whatchpoints=True):\n     # Install the heap tracker.\n     tracker = Tracker()\n \n-    malloc_enter = MallocEnterBreakpoint(tracker)\n-    free_enter = FreeEnterBreakpoint(tracker)\n+    malloc_enter = MallocEnterBreakpoint(available[0], tracker)\n+    free_enter = FreeEnterBreakpoint(available[1], tracker)\n \n-    if is_available(CALLOC_NAME):\n-        calloc_enter = CallocEnterBreakpoint(tracker)\n+    calloc_address = resolve_address(CALLOC_NAME)\n+    if calloc_address:\n+        calloc_enter = CallocEnterBreakpoint(calloc_address, tracker)\n \n-    if is_available(REALLOC_NAME):\n-        realloc_enter = ReallocEnterBreakpoint(tracker)\n+    realloc_address = resolve_address(REALLOC_NAME)\n+    if realloc_address:\n+        realloc_enter = ReallocEnterBreakpoint(realloc_address, tracker)\n \n     print(\"Heap tracker installed.\")\n \n"
        }
    ]
}
{
    "sha_fail": "c0d46a6bfc97c11b8a770d74b2fdb841622201a1",
    "changed_files": [
        {
            "commit": "c0d46a6bfc97c11b8a770d74b2fdb841622201a1",
            "file_path": "src/telegram/_business.py",
            "diff": "diff --git a/src/telegram/_business.py b/src/telegram/_business.py\nindex 11bc9b4..d758fe8 100644\n--- a/src/telegram/_business.py\n+++ b/src/telegram/_business.py\n@@ -29,8 +29,16 @@ from telegram._files.location import Location\n from telegram._files.sticker import Sticker\n from telegram._telegramobject import TelegramObject\n from telegram._user import User\n-from telegram._utils.argumentparsing import de_json_optional, de_list_optional, parse_sequence_arg\n-from telegram._utils.datetime import extract_tzinfo_from_defaults, from_timestamp, verify_timezone\n+from telegram._utils.argumentparsing import (\n+    de_json_optional,\n+    de_list_optional,\n+    parse_sequence_arg,\n+)\n+from telegram._utils.datetime import (\n+    extract_tzinfo_from_defaults,\n+    from_timestamp,\n+    get_zone_info,\n+)\n from telegram._utils.types import JSONDict\n \n if TYPE_CHECKING:\n@@ -553,7 +561,7 @@ class BusinessOpeningHours(TelegramObject):\n             time intervals describing business opening hours.\n     \"\"\"\n \n-    __slots__ = (\"opening_hours\", \"time_zone_name\")\n+    __slots__ = (\"__zone_info\", \"opening_hours\", \"time_zone_name\")\n \n     def __init__(\n         self,\n@@ -568,12 +576,20 @@ class BusinessOpeningHours(TelegramObject):\n             opening_hours\n         )\n \n+        self.__zone_info: Optional[ZoneInfo] = None\n+\n         self._id_attrs = (self.time_zone_name, self.opening_hours)\n \n         self._freeze()\n \n+    @property\n+    def _zone_info(self) -> ZoneInfo:\n+        if self.__zone_info is None:\n+            self.__zone_info = get_zone_info(self.time_zone_name)\n+        return self.__zone_info\n+\n     def get_opening_hours_for_day(\n-        self, date: dtm.date, time_zone: Optional[Union[dtm.tzinfo, Union[ZoneInfo, str]]] = None\n+        self, date: dtm.date, time_zone: Union[dtm.tzinfo, str, None] = None\n     ) -> tuple[tuple[dtm.datetime, dtm.datetime], ...]:\n         \"\"\"Returns the opening hours intervals for a specific day as datetime objects.\n \n@@ -581,10 +597,8 @@ class BusinessOpeningHours(TelegramObject):\n \n         Args:\n             date (:obj:`datetime.date`): The date to get opening hours for.\n-                Only the weekday component\n-                is used to determine matching opening intervals.\n-            time_zone (:obj:`zoneinfo.ZoneInfo`, optional): Timezone to use for the returned\n-                datetime objects. if not specified, then self.time_zone_name.\n+            time_zone (:obj:`datetime.tzinfo` | :obj:`str`, optional): Timezone to use for the\n+                returned datetime objects. If not specified, then :attr:`time_zone_name` be used.\n \n         Returns:\n             tuple[tuple[:obj:`datetime.datetime`, :obj:`datetime.datetime`], ...]:\n@@ -595,43 +609,42 @@ class BusinessOpeningHours(TelegramObject):\n \n         week_day = date.weekday()\n         res = []\n-        tz_native = verify_timezone(self.time_zone_name)\n-        tz_target = verify_timezone(time_zone) if isinstance(time_zone, str) else time_zone\n+        if isinstance(time_zone, str):\n+            tz_target: dtm.tzinfo = get_zone_info(time_zone)\n+        elif time_zone is None:\n+            tz_target = self._zone_info\n+        else:\n+            tz_target = time_zone\n \n         for interval in self.opening_hours:\n             int_open = interval.opening_time\n             int_close = interval.closing_time\n \n+            if int_open[0] != week_day:\n+                continue\n+\n             result_int_open = dtm.datetime(\n                 year=date.year,\n                 month=date.month,\n                 day=date.day,\n                 hour=int_open[1],\n                 minute=int_open[2],\n-                tzinfo=tz_native,\n-            )\n-\n-            result_int_open_user_tz_aware = (\n-                result_int_open.astimezone(tz_target) if time_zone else result_int_open\n-            )\n-\n-            if result_int_open_user_tz_aware.weekday() == week_day and week_day == int_open[0]:\n-                result_int_close = dtm.datetime(\n-                    year=date.year,\n-                    month=date.month,\n-                    day=date.day,\n-                    hour=int_close[1],\n-                    minute=int_close[2],\n-                    tzinfo=tz_native,\n-                )\n-\n-                result_int_close_user_tz_aware = (\n-                    result_int_close.astimezone(tz_target) if time_zone else result_int_close\n-                )\n-                res.append((result_int_open_user_tz_aware, result_int_close_user_tz_aware))\n-\n-        sort_res = sorted(res, key=lambda x: x[0].hour)\n-        return tuple(sort_res)\n+                tzinfo=self._zone_info,\n+            ).astimezone(tz_target)\n+\n+            result_int_close = dtm.datetime(\n+                year=date.year,\n+                month=date.month,\n+                day=date.day,\n+                hour=int_close[1],\n+                minute=int_close[2],\n+                tzinfo=self._zone_info,\n+            ).astimezone(tz_target)\n+\n+            res.append((result_int_open, result_int_close))\n+\n+        # The sorting is currently an implementation detail\n+        return tuple(sorted(res, key=lambda x: x[0]))\n \n     def is_open(self, datetime: dtm.datetime) -> bool:\n         \"\"\"Check if the business is open at the specified datetime.\n@@ -640,20 +653,21 @@ class BusinessOpeningHours(TelegramObject):\n \n         Args:\n             datetime (:obj:`datetime.datetime`): The datetime to check.\n-                If timezone-aware, the check will be performed in that timezone.\n-                If timezone-naive, the check will be performed in the\n+                If the object is timezone-naive, it is assumed to be in the\n                 timezone specified by :attr:`time_zone_name`.\n+\n         Returns:\n             :obj:`bool`: True if the business is open at the specified time, False otherwise.\n         \"\"\"\n \n-        aware_datetime = (\n-            datetime.replace(tzinfo=verify_timezone(self.time_zone_name))\n-            if datetime.tzinfo is None\n-            else datetime\n+        datetime_in_native_tz = (\n+            datetime.replace(tzinfo=self._zone_info) if datetime.tzinfo is None else datetime\n+        ).astimezone(self._zone_info)\n+        minute_of_week = (\n+            datetime_in_native_tz.weekday() * 1440\n+            + datetime_in_native_tz.hour * 60\n+            + datetime_in_native_tz.minute\n         )\n-        weekday = aware_datetime.weekday()\n-        minute_of_week = weekday * 1440 + aware_datetime.hour * 60 + aware_datetime.minute\n \n         for interval in self.opening_hours:\n             if interval.opening_minute <= minute_of_week < interval.closing_minute:\n"
        },
        {
            "commit": "c0d46a6bfc97c11b8a770d74b2fdb841622201a1",
            "file_path": "src/telegram/_utils/datetime.py",
            "diff": "diff --git a/src/telegram/_utils/datetime.py b/src/telegram/_utils/datetime.py\nindex 68120a8..111c875 100644\n--- a/src/telegram/_utils/datetime.py\n+++ b/src/telegram/_utils/datetime.py\n@@ -232,23 +232,22 @@ def _datetime_to_float_timestamp(dt_obj: dtm.datetime) -> float:\n     return dt_obj.timestamp()\n \n \n-def verify_timezone(tz: Optional[str]) -> Optional[zoneinfo.ZoneInfo]:\n-    \"\"\"Wrapper around the `ZoneInfo` constructor with slightly more helpful error messages\"\"\"\n+def get_zone_info(tz: str) -> zoneinfo.ZoneInfo:\n+    \"\"\"Wrapper around the `ZoneInfo` constructor with slightly more helpful error message\n+    in case tzdata is not installed.\n+    \"\"\"\n \n     if tz is None:\n         return None\n \n     try:\n         return zoneinfo.ZoneInfo(tz)\n-    except (TypeError, ValueError) as e:\n-        raise zoneinfo.ZoneInfoNotFoundError(\n-            f\"ZoneInfo keys may not be absolute paths, got: {tz}.\"\n-        ) from e\n     except zoneinfo.ZoneInfoNotFoundError as err:\n         raise zoneinfo.ZoneInfoNotFoundError(\n             f\"No time zone found with key {tz}. \"\n-            f\"Make sure to use a valid time zone name and \"\n-            f\"correct install tzdata (https://pypi.org/project/tzdata/)\"\n+            \"Make sure to use a valid time zone name and \"\n+            f\"correct install the tzdata (https://pypi.org/project/tzdata/) package if \"\n+            \"your system does not provide the time zone data.\"\n         ) from err\n \n \n@@ -290,7 +289,5 @@ def get_timedelta_value(\n         stacklevel=2,\n     )\n     return (\n-       int(seconds)\n-       if (seconds := value.total_seconds()).is_integer()\n-       else seconds  # type: ignore[return-value]  # pylint: disable=line-too-long\n-   )\n+        int(seconds) if (seconds := value.total_seconds()).is_integer() else seconds  # type: ignore[return-value]  # pylint: disable=line-too-long\n+    )\n"
        },
        {
            "commit": "c0d46a6bfc97c11b8a770d74b2fdb841622201a1",
            "file_path": "tests/_utils/test_datetime.py",
            "diff": "diff --git a/tests/_utils/test_datetime.py b/tests/_utils/test_datetime.py\nindex 4a1ae19..70c4ff4 100644\n--- a/tests/_utils/test_datetime.py\n+++ b/tests/_utils/test_datetime.py\n@@ -23,7 +23,7 @@ import zoneinfo\n import pytest\n \n from telegram._utils import datetime as tg_dtm\n-from telegram._utils.datetime import verify_timezone\n+from telegram._utils.datetime import get_zone_info\n from telegram.ext import Defaults\n \n # sample time specification values categorised into absolute / delta / time-of-day\n@@ -139,7 +139,10 @@ class TestDatetime:\n         # of an xpass when the test is run in a timezone with the same UTC offset\n         ref_datetime = dtm.datetime(1970, 1, 1, 12)\n         utc_offset = timezone.utcoffset(ref_datetime)\n-        ref_t, time_of_day = tg_dtm._datetime_to_float_timestamp(ref_datetime), ref_datetime.time()\n+        ref_t, time_of_day = (\n+            tg_dtm._datetime_to_float_timestamp(ref_datetime),\n+            ref_datetime.time(),\n+        )\n         aware_time_of_day = tg_dtm.localize(ref_datetime, timezone).timetz()\n \n         # first test that naive time is assumed to be utc:\n@@ -194,20 +197,20 @@ class TestDatetime:\n         assert tg_dtm.extract_tzinfo_from_defaults(bot) is None\n         assert tg_dtm.extract_tzinfo_from_defaults(raw_bot) is None\n \n-\n-\n-    def test_with_valid_timezone_string(self):\n+    def test_get_zone_info_with_valid_timezone_string(self):\n         \"\"\"Test with a valid timezone string.\"\"\"\n         tz = \"Asia/Tokyo\"\n-        result = verify_timezone(tz)\n+        result = get_zone_info(tz)\n         assert isinstance(result, zoneinfo.ZoneInfo)\n         assert str(result) == \"Asia/Tokyo\"\n \n-\n-    def test_with_invalid_timezone_string(self):\n+    def test_get_zone_info_with_invalid_timezone_string(self):\n         \"\"\"Test with an invalid timezone string.\"\"\"\n-        with pytest.raises(zoneinfo.ZoneInfoNotFoundError, match=\"No time zone found\"):\n-            verify_timezone(\"Invalid/Timezone\")\n+        with pytest.raises(\n+            zoneinfo.ZoneInfoNotFoundError,\n+            match=\"No time zone found.*Invalid/Timezone.*install the tzdata\",\n+        ):\n+            get_zone_info(\"Invalid/Timezone\")\n \n     @pytest.mark.parametrize(\n         (\"arg\", \"timedelta_result\", \"number_result\"),\n"
        },
        {
            "commit": "c0d46a6bfc97c11b8a770d74b2fdb841622201a1",
            "file_path": "tests/test_business_classes.py",
            "diff": "diff --git a/tests/test_business_classes.py b/tests/test_business_classes.py\nindex dffec6f..75dbd3a 100644\n--- a/tests/test_business_classes.py\n+++ b/tests/test_business_classes.py\n@@ -556,196 +556,226 @@ class TestBusinessOpeningHoursWithoutRequest(BusinessTestBase):\n         assert boh1 != boh3\n         assert hash(boh1) != hash(boh3)\n \n+    class TestBusinessOpeningHoursGetOpeningHoursForDayWithoutRequest:\n+        @pytest.fixture\n+        def sample_opening_hours(self):\n+            # Monday 8am-8:30pm (480-1230)\n+            # Tuesday 24 hours (1440-2879)\n+            # Sunday 12am-11:58pm (8640-10078)\n+            intervals = [\n+                BusinessOpeningHoursInterval(480, 1230),  # Monday 8am-8:30pm\n+                BusinessOpeningHoursInterval(1440, 2879),  # Tuesday 24 hours\n+                BusinessOpeningHoursInterval(8640, 10078),  # Sunday 12am-11:58pm\n+            ]\n+            return BusinessOpeningHours(time_zone_name=\"UTC\", opening_hours=intervals)\n+\n+        def test_monday_opening_hours(self, sample_opening_hours):\n+            # Test for Monday\n+            test_date = dtm.date(2023, 11, 6)  # Monday\n+            time_zone = ZoneInfo(\"UTC\")\n+            result = sample_opening_hours.get_opening_hours_for_day(test_date, time_zone)\n+\n+            expected = (\n+                (\n+                    dtm.datetime(2023, 11, 6, 8, 0, tzinfo=time_zone),\n+                    dtm.datetime(2023, 11, 6, 20, 30, tzinfo=time_zone),\n+                ),\n+            )\n \n-class TestBusinessOpeningHoursGetOpeningHoursForDayWithoutRequest:\n-    @pytest.fixture\n-    def sample_opening_hours(self):\n-        # Monday 8am-8:30pm (480-1230)\n-        # Tuesday 24 hours (1440-2879)\n-        # Sunday 12am-11:58pm (8640-10078)\n-        intervals = [\n-            BusinessOpeningHoursInterval(480, 1230),  # Monday 8am-8:30pm\n-            BusinessOpeningHoursInterval(1440, 2879),  # Tuesday 24 hours\n-            BusinessOpeningHoursInterval(8640, 10078),  # Sunday 12am-11:58pm\n-        ]\n-        return BusinessOpeningHours(time_zone_name=\"UTC\", opening_hours=intervals)\n-\n-    def test_monday_opening_hours(self, sample_opening_hours):\n-        # Test for Monday\n-        test_date = dtm.date(2023, 11, 6)  # Monday\n-        time_zone = ZoneInfo(\"UTC\")\n-        result = sample_opening_hours.get_opening_hours_for_day(test_date, time_zone)\n-\n-        expected = (\n-            (\n-                dtm.datetime(2023, 11, 6, 8, 0, tzinfo=time_zone),\n-                dtm.datetime(2023, 11, 6, 20, 30, tzinfo=time_zone),\n-            ),\n-        )\n-\n-        assert result == expected\n-\n-    def test_tuesday_24_hours(self, sample_opening_hours):\n-        # Test for Tuesday (24 hours)\n-        test_date = dtm.date(2023, 11, 7)  # Tuesday\n-        time_zone = ZoneInfo(\"UTC\")\n-        result = sample_opening_hours.get_opening_hours_for_day(test_date, time_zone)\n-\n-        expected = (\n-            (\n-                dtm.datetime(2023, 11, 7, 0, 0, tzinfo=time_zone),\n-                dtm.datetime(2023, 11, 7, 23, 59, tzinfo=time_zone),\n-            ),\n-        )\n-\n-        assert result == expected\n-\n-    def test_sunday_opening_hours(self, sample_opening_hours):\n-        # Test for Sunday\n-        test_date = dtm.date(2023, 11, 12)  # Sunday\n-        time_zone = ZoneInfo(\"UTC\")\n-        result = sample_opening_hours.get_opening_hours_for_day(test_date, time_zone)\n-\n-        expected = (\n-            (\n-                dtm.datetime(2023, 11, 12, 0, 0, tzinfo=time_zone),\n-                dtm.datetime(2023, 11, 12, 23, 58, tzinfo=time_zone),\n-            ),\n-        )\n-\n-        assert result == expected\n-\n-    def test_day_with_no_opening_hours(self, sample_opening_hours):\n-        # Test for Wednesday (no opening hours defined)\n-        test_date = dtm.date(2023, 11, 8)  # Wednesday\n-        time_zone = ZoneInfo(\"UTC\")\n-        result = sample_opening_hours.get_opening_hours_for_day(test_date, time_zone)\n-\n-        assert result == ()\n-\n-    def test_multiple_intervals_same_day(self):\n-        # Test with multiple intervals on the same day\n-        intervals = [\n-            BusinessOpeningHoursInterval(480, 720),  # Monday 8am-12pm\n-            BusinessOpeningHoursInterval(900, 1230),  # Monday 3pm-8:30pm\n-        ]\n-        opening_hours = BusinessOpeningHours(time_zone_name=\"UTC\", opening_hours=intervals)\n-\n-        test_date = dtm.date(2023, 11, 6)  # Monday\n-        time_zone = ZoneInfo(\"UTC\")\n-        result = opening_hours.get_opening_hours_for_day(test_date, time_zone)\n-\n-        expected = (\n-            (\n-                dtm.datetime(2023, 11, 6, 8, 0, tzinfo=time_zone),\n-                dtm.datetime(2023, 11, 6, 12, 0, tzinfo=time_zone),\n-            ),\n-            (\n-                dtm.datetime(2023, 11, 6, 15, 0, tzinfo=time_zone),\n-                dtm.datetime(2023, 11, 6, 20, 30, tzinfo=time_zone),\n-            ),\n-        )\n-\n-        assert result == expected\n+            assert result == expected\n \n-    def test_timezone_conversion(self, sample_opening_hours):\n-        # Test that timezone is properly applied\n-        test_date = dtm.date(2023, 11, 6)  # Monday\n-        time_zone = ZoneInfo(\"America/New_York\")\n-        result = sample_opening_hours.get_opening_hours_for_day(test_date, time_zone)\n+        def test_tuesday_24_hours(self, sample_opening_hours):\n+            # Test for Tuesday (24 hours)\n+            test_date = dtm.date(2023, 11, 7)  # Tuesday\n+            time_zone = ZoneInfo(\"UTC\")\n+            result = sample_opening_hours.get_opening_hours_for_day(test_date, time_zone)\n \n-        expected = (\n-            (\n-                dtm.datetime(2023, 11, 6, 3, 0, tzinfo=time_zone),\n-                dtm.datetime(2023, 11, 6, 15, 30, tzinfo=time_zone),\n-            ),\n-        )\n+            expected = (\n+                (\n+                    dtm.datetime(2023, 11, 7, 0, 0, tzinfo=time_zone),\n+                    dtm.datetime(2023, 11, 7, 23, 59, tzinfo=time_zone),\n+                ),\n+            )\n \n-        assert result == expected\n-        assert result[0][0].tzinfo == time_zone\n-        assert result[0][1].tzinfo == time_zone\n+            assert result == expected\n \n-    def test_no_timezone_provided(self, sample_opening_hours):\n-        # Test when no timezone is provided\n-        test_date = dtm.date(2023, 11, 6)  # Monday\n-        result = sample_opening_hours.get_opening_hours_for_day(test_date)\n+        def test_sunday_opening_hours(self, sample_opening_hours):\n+            # Test for Sunday\n+            test_date = dtm.date(2023, 11, 12)  # Sunday\n+            time_zone = ZoneInfo(\"UTC\")\n+            result = sample_opening_hours.get_opening_hours_for_day(test_date, time_zone)\n \n-        expected = (\n-            (\n-                dtm.datetime(\n-                    2023, 11, 6, 8, 0, tzinfo=ZoneInfo(sample_opening_hours.time_zone_name)\n+            expected = (\n+                (\n+                    dtm.datetime(2023, 11, 12, 0, 0, tzinfo=time_zone),\n+                    dtm.datetime(2023, 11, 12, 23, 58, tzinfo=time_zone),\n                 ),\n-                dtm.datetime(\n-                    2023, 11, 6, 20, 30, tzinfo=ZoneInfo(sample_opening_hours.time_zone_name)\n+            )\n+\n+            assert result == expected\n+\n+        def test_day_with_no_opening_hours(self, sample_opening_hours):\n+            # Test for Wednesday (no opening hours defined)\n+            test_date = dtm.date(2023, 11, 8)  # Wednesday\n+            time_zone = ZoneInfo(\"UTC\")\n+            result = sample_opening_hours.get_opening_hours_for_day(test_date, time_zone)\n+\n+            assert result == ()\n+\n+        def test_multiple_intervals_same_day(self):\n+            # Test with multiple intervals on the same day\n+            intervals = [\n+                # unsorted on purpose to check that the sorting works (event though this is\n+                # currently undocumented behaviour)\n+                BusinessOpeningHoursInterval(900, 1230),  # Monday 3pm-8:30pm\n+                BusinessOpeningHoursInterval(480, 720),  # Monday 8am-12pm\n+            ]\n+            opening_hours = BusinessOpeningHours(time_zone_name=\"UTC\", opening_hours=intervals)\n+\n+            test_date = dtm.date(2023, 11, 6)  # Monday\n+            time_zone = ZoneInfo(\"UTC\")\n+            result = opening_hours.get_opening_hours_for_day(test_date, time_zone)\n+\n+            expected = (\n+                (\n+                    dtm.datetime(2023, 11, 6, 8, 0, tzinfo=time_zone),\n+                    dtm.datetime(2023, 11, 6, 12, 0, tzinfo=time_zone),\n                 ),\n-            ),\n-        )\n-\n-        assert result == expected\n-\n-\n-class TestBusinessOpeningHoursIsOpenWithoutRequest:\n-    @pytest.fixture\n-    def sample_opening_hours(self):\n-        # Monday 8am-8:30pm (480-1230)\n-        # Tuesday 24 hours (1440-2879)\n-        # Sunday 12am-11:58pm (8640-10078)\n-        intervals = [\n-            BusinessOpeningHoursInterval(480, 1230),  # Monday 8am-8:30pm UTC\n-            BusinessOpeningHoursInterval(1440, 2879),  # Tuesday 24 hours UTC\n-            BusinessOpeningHoursInterval(8640, 10078),  # Sunday 12am-11:58pm UTC\n-        ]\n-        return BusinessOpeningHours(time_zone_name=\"UTC\", opening_hours=intervals)\n-\n-    def test_is_open_during_business_hours(self, sample_opening_hours):\n-        # Monday 10am UTC (within 8am-8:30pm)\n-        dt = dtm.datetime(2023, 11, 6, 10, 0, tzinfo=ZoneInfo(\"UTC\"))\n-        assert sample_opening_hours.is_open(dt) is True\n-\n-    def test_is_open_at_opening_time(self, sample_opening_hours):\n-        # Monday exactly 8am UTC\n-        dt = dtm.datetime(2023, 11, 6, 8, 0, tzinfo=ZoneInfo(\"UTC\"))\n-        assert sample_opening_hours.is_open(dt) is True\n-\n-    def test_is_closed_at_closing_time(self, sample_opening_hours):\n-        # Monday exactly 8:30pm UTC (closing time is exclusive)\n-        dt = dtm.datetime(2023, 11, 6, 20, 30, tzinfo=ZoneInfo(\"UTC\"))\n-        assert sample_opening_hours.is_open(dt) is False\n-\n-    def test_is_closed_outside_business_hours(self, sample_opening_hours):\n-        # Monday 7am UTC (before opening)\n-        dt = dtm.datetime(2023, 11, 6, 7, 0, tzinfo=ZoneInfo(\"UTC\"))\n-        assert sample_opening_hours.is_open(dt) is False\n-\n-    def test_is_open_24h_day(self, sample_opening_hours):\n-        # Tuesday 3am UTC (24h opening)\n-        dt = dtm.datetime(2023, 11, 7, 3, 0, tzinfo=ZoneInfo(\"UTC\"))\n-        assert sample_opening_hours.is_open(dt) is True\n-\n-    def test_is_closed_on_day_with_no_hours(self, sample_opening_hours):\n-        # Wednesday (no opening hours)\n-        dt = dtm.datetime(2023, 11, 8, 12, 0, tzinfo=ZoneInfo(\"UTC\"))\n-        assert sample_opening_hours.is_open(dt) is False\n-\n-    def test_timezone_conversion(self, sample_opening_hours):\n-        # Monday 10am UTC is 6am EDT (should be closed)\n-        dt = dtm.datetime(2023, 11, 6, 2, 30, tzinfo=ZoneInfo(\"America/New_York\"))\n-        assert sample_opening_hours.is_open(dt) is False\n-\n-        # Monday 10am EDT is 2pm UTC (should be open)\n-        dt = dtm.datetime(2023, 11, 6, 10, 0, tzinfo=ZoneInfo(\"America/New_York\"))\n-        assert sample_opening_hours.is_open(dt) is True\n-\n-    def test_naive_datetime_uses_business_timezone(self, sample_opening_hours):\n-        # Naive datetime - should be interpreted as UTC (business timezone)\n-        dt = dtm.datetime(2023, 11, 6, 10, 0)  # 10am naive\n-        assert sample_opening_hours.is_open(dt) is True\n-\n-    def test_boundary_conditions(self, sample_opening_hours):\n-        # Sunday 11:58pm UTC (should be open)\n-        dt = dtm.datetime(2023, 11, 12, 23, 57, tzinfo=ZoneInfo(\"UTC\"))\n-        assert sample_opening_hours.is_open(dt) is True\n-\n-        # Sunday 11:59pm UTC (should be closed)\n-        dt = dtm.datetime(2023, 11, 12, 23, 59, tzinfo=ZoneInfo(\"UTC\"))\n-        assert sample_opening_hours.is_open(dt) is False\n+                (\n+                    dtm.datetime(2023, 11, 6, 15, 0, tzinfo=time_zone),\n+                    dtm.datetime(2023, 11, 6, 20, 30, tzinfo=time_zone),\n+                ),\n+            )\n+\n+            assert result == expected\n+\n+        @pytest.mark.parametrize(\"input_type\", [str, ZoneInfo])\n+        def test_timezone_conversion(self, sample_opening_hours, input_type):\n+            # Test that timezone is properly applied\n+            test_date = dtm.date(2023, 11, 6)  # Monday\n+            time_zone = input_type(\"America/New_York\")\n+            zone_info = ZoneInfo(\"America/New_York\")\n+            result = sample_opening_hours.get_opening_hours_for_day(test_date, time_zone)\n+\n+            expected = (\n+                (\n+                    dtm.datetime(2023, 11, 6, 3, 0, tzinfo=zone_info),\n+                    dtm.datetime(2023, 11, 6, 15, 30, tzinfo=zone_info),\n+                ),\n+            )\n+\n+            assert result == expected\n+            assert result[0][0].tzinfo == zone_info\n+            assert result[0][1].tzinfo == zone_info\n+\n+        def test_timezone_conversation_changing_date(self):\n+            # test for the edge case where the returned time is on a different date in the target\n+            # timezone than in the business timezone\n+            intervals = [\n+                BusinessOpeningHoursInterval(60, 120),  # Monday 1am-2am UTC\n+            ]\n+            opening_hours = BusinessOpeningHours(time_zone_name=\"UTC\", opening_hours=intervals)\n+            test_date = dtm.date(2023, 11, 6)  # Monday\n+            time_zone = ZoneInfo(\"America/New_York\")  # UTC-5, so 1am UTC is 8pm previous day\n+            result = opening_hours.get_opening_hours_for_day(test_date, time_zone)\n+            expected = (\n+                (\n+                    dtm.datetime(2023, 11, 5, 20, 0, tzinfo=time_zone),\n+                    dtm.datetime(2023, 11, 5, 21, 0, tzinfo=time_zone),\n+                ),\n+            )\n+            assert result == expected\n+\n+        def test_no_timezone_provided(self, sample_opening_hours):\n+            # Test when no timezone is provided\n+            test_date = dtm.date(2023, 11, 6)  # Monday\n+            result = sample_opening_hours.get_opening_hours_for_day(test_date)\n+\n+            expected = (\n+                (\n+                    dtm.datetime(\n+                        2023,\n+                        11,\n+                        6,\n+                        8,\n+                        0,\n+                        tzinfo=ZoneInfo(sample_opening_hours.time_zone_name),\n+                    ),\n+                    dtm.datetime(\n+                        2023,\n+                        11,\n+                        6,\n+                        20,\n+                        30,\n+                        tzinfo=ZoneInfo(sample_opening_hours.time_zone_name),\n+                    ),\n+                ),\n+            )\n+\n+            assert result == expected\n+\n+    class TestBusinessOpeningHoursIsOpenWithoutRequest:\n+        @pytest.fixture\n+        def sample_opening_hours(self):\n+            # Monday 8am-8:30pm (480-1230)\n+            # Tuesday 24 hours (1440-2879)\n+            # Sunday 12am-11:59pm (8640-10079)\n+            intervals = [\n+                BusinessOpeningHoursInterval(480, 1230),  # Monday 8am-8:30pm UTC\n+                BusinessOpeningHoursInterval(1440, 2879),  # Tuesday 24 hours UTC\n+                BusinessOpeningHoursInterval(8640, 10079),  # Sunday 12am-11:59pm UTC\n+            ]\n+            return BusinessOpeningHours(time_zone_name=\"UTC\", opening_hours=intervals)\n+\n+        def test_is_open_during_business_hours(self, sample_opening_hours):\n+            # Monday 10am UTC (within 8am-8:30pm)\n+            dt = dtm.datetime(2023, 11, 6, 10, 0, tzinfo=ZoneInfo(\"UTC\"))\n+            assert sample_opening_hours.is_open(dt) is True\n+\n+        def test_is_open_at_opening_time(self, sample_opening_hours):\n+            # Monday exactly 8am UTC\n+            dt = dtm.datetime(2023, 11, 6, 8, 0, tzinfo=ZoneInfo(\"UTC\"))\n+            assert sample_opening_hours.is_open(dt) is True\n+\n+        def test_is_closed_at_closing_time(self, sample_opening_hours):\n+            # Monday exactly 8:30pm UTC (closing time is exclusive)\n+            dt = dtm.datetime(2023, 11, 6, 20, 30, tzinfo=ZoneInfo(\"UTC\"))\n+            assert sample_opening_hours.is_open(dt) is False\n+\n+        def test_is_closed_outside_business_hours(self, sample_opening_hours):\n+            # Monday 7am UTC (before opening)\n+            dt = dtm.datetime(2023, 11, 6, 7, 0, tzinfo=ZoneInfo(\"UTC\"))\n+            assert sample_opening_hours.is_open(dt) is False\n+\n+        def test_is_open_24h_day(self, sample_opening_hours):\n+            # Tuesday 3am UTC (24h opening)\n+            dt = dtm.datetime(2023, 11, 7, 3, 0, tzinfo=ZoneInfo(\"UTC\"))\n+            assert sample_opening_hours.is_open(dt) is True\n+\n+        def test_is_closed_on_day_with_no_hours(self, sample_opening_hours):\n+            # Wednesday (no opening hours)\n+            dt = dtm.datetime(2023, 11, 8, 12, 0, tzinfo=ZoneInfo(\"UTC\"))\n+            assert sample_opening_hours.is_open(dt) is False\n+\n+        def test_timezone_conversion(self, sample_opening_hours):\n+            # Monday 5am EDT is 10am UTC (should be open)\n+            dt = dtm.datetime(2023, 11, 6, 5, 0, tzinfo=ZoneInfo(\"America/New_York\"))\n+            assert sample_opening_hours.is_open(dt) is True\n+\n+            # Monday 2am EDT is 7am UTC (should be closed)\n+            dt = dtm.datetime(2023, 11, 6, 2, 0, tzinfo=ZoneInfo(\"America/New_York\"))\n+            assert sample_opening_hours.is_open(dt) is False\n+\n+        def test_naive_datetime_uses_business_timezone(self, sample_opening_hours):\n+            # Naive datetime - should be interpreted as UTC (business timezone)\n+            dt = dtm.datetime(2023, 11, 6, 10, 0)  # 10am naive\n+            assert sample_opening_hours.is_open(dt) is True\n+\n+        def test_boundary_conditions(self, sample_opening_hours):\n+            # Sunday 11:58pm UTC (should be open)\n+            dt = dtm.datetime(2023, 11, 12, 23, 58, tzinfo=ZoneInfo(\"UTC\"))\n+            assert sample_opening_hours.is_open(dt) is True\n+\n+            # Sunday 11:59pm UTC (should be closed)\n+            dt = dtm.datetime(2023, 11, 12, 23, 59, tzinfo=ZoneInfo(\"UTC\"))\n+            assert sample_opening_hours.is_open(dt) is False\n"
        }
    ]
}
{
    "sha_fail": "f539ef9be2b510a9bef42e224e7c601f5965bcda",
    "changed_files": [
        {
            "commit": "f539ef9be2b510a9bef42e224e7c601f5965bcda",
            "file_path": "framework/py/flwr/supernode/nodestate/in_memory_nodestate.py",
            "diff": "diff --git a/framework/py/flwr/supernode/nodestate/in_memory_nodestate.py b/framework/py/flwr/supernode/nodestate/in_memory_nodestate.py\nindex 139893a56..2e70079f2 100644\n--- a/framework/py/flwr/supernode/nodestate/in_memory_nodestate.py\n+++ b/framework/py/flwr/supernode/nodestate/in_memory_nodestate.py\n@@ -15,17 +15,40 @@\n \"\"\"In-memory NodeState implementation.\"\"\"\n \n \n-from typing import Optional\n+from collections.abc import Sequence\n+from dataclasses import dataclass\n+from threading import Lock\n+from typing import Optional, Union\n+\n+from flwr.common import Context, Message\n+from flwr.common.typing import Run\n \n from .nodestate import NodeState\n \n \n+@dataclass\n+class MessageEntry:\n+    \"\"\"Data class to represent a message entry.\"\"\"\n+\n+    message: Message\n+    is_retrieved: bool = False\n+\n+\n class InMemoryNodeState(NodeState):\n     \"\"\"In-memory NodeState implementation.\"\"\"\n \n     def __init__(self) -> None:\n         # Store node_id\n         self.node_id: Optional[int] = None\n+        # Store Object ID to MessageEntry mapping\n+        self.msg_store: dict[str, MessageEntry] = {}\n+        self.lock_msg_store = Lock()\n+        # Store run ID to Run mapping\n+        self.run_store: dict[int, Run] = {}\n+        self.lock_run_store = Lock()\n+        # Store run ID to Context mapping\n+        self.ctx_store: dict[int, Context] = {}\n+        self.lock_ctx_store = Lock()\n \n     def set_node_id(self, node_id: Optional[int]) -> None:\n         \"\"\"Set the node ID.\"\"\"\n@@ -36,3 +59,92 @@ class InMemoryNodeState(NodeState):\n         if self.node_id is None:\n             raise ValueError(\"Node ID not set\")\n         return self.node_id\n+\n+    def store_message(self, message: Message) -> Optional[str]:\n+        \"\"\"Store a message.\"\"\"\n+        with self.lock_msg_store:\n+            msg_id = message.metadata.message_id\n+            if msg_id == \"\" or msg_id in self.msg_store:\n+                return None\n+            self.msg_store[msg_id] = MessageEntry(message=message)\n+            return msg_id\n+\n+    def get_messages(\n+        self,\n+        *,\n+        run_ids: Optional[Sequence[int]] = None,\n+        is_reply: Optional[bool] = None,\n+        limit: Optional[int] = None,\n+    ) -> Sequence[Message]:\n+        \"\"\"Retrieve messages based on the specified filters.\"\"\"\n+        selected_messages: list[Message] = []\n+\n+        with self.lock_msg_store:\n+            # Iterate through all messages in the store\n+            for object_id in list(self.msg_store.keys()):\n+                entry = self.msg_store[object_id]\n+                message = entry.message\n+\n+                # Skip messages that have already been retrieved\n+                if entry.is_retrieved:\n+                    continue\n+\n+                # Skip messages whose run_id doesn't match the filter\n+                if run_ids is not None:\n+                    if message.metadata.run_id not in run_ids:\n+                        continue\n+\n+                # If is_reply filter is set, filter for reply/non-reply messages\n+                if is_reply is not None:\n+                    is_reply_message = message.metadata.reply_to_message_id != \"\"\n+                    # XOR logic to filter mismatched types (reply vs non-reply)\n+                    if is_reply ^ is_reply_message:\n+                        continue\n+\n+                # Add the message to the result set\n+                selected_messages.append(message)\n+\n+                # Mark the message as retrieved\n+                entry.is_retrieved = True\n+\n+                # Stop if the number of collected messages reaches the limit\n+                if limit is not None and len(selected_messages) >= limit:\n+                    break\n+\n+        return selected_messages\n+\n+    def delete_messages(\n+        self,\n+        *,\n+        message_ids: Optional[Sequence[str]] = None,\n+    ) -> None:\n+        \"\"\"Delete messages based on the specified filters.\"\"\"\n+        with self.lock_msg_store:\n+            if message_ids is None:\n+                # If no message IDs are provided, clear the entire store\n+                self.msg_store.clear()\n+                return\n+\n+            # Remove specified messages from the store\n+            for msg_id in message_ids:\n+                self.msg_store.pop(msg_id, None)\n+\n+    def store_run(self, run: Run) -> None:\n+        \"\"\"Store a run.\"\"\"\n+        with self.lock_run_store:\n+            self.run_store[run.run_id] = run\n+\n+    def get_run(self, run_id: int) -> Optional[Run]:\n+        \"\"\"Retrieve a run by its ID.\"\"\"\n+        with self.lock_run_store:\n+            return self.run_store.get(run_id)\n+\n+    def store_context(self, context: Context) -> None:\n+        \"\"\"Store a context.\"\"\"\n+        with self.lock_ctx_store:\n+            self.ctx_store[context.run_id] = context\n+\n+    def get_context(self, run_id: int) -> Optional[Context]:\n+        \"\"\"Retrieve a context by its run ID.\"\"\"\n+        with self.lock_ctx_store:\n+            return self.ctx_store.get(run_id)\n"
        },
        {
            "commit": "f539ef9be2b510a9bef42e224e7c601f5965bcda",
            "file_path": "framework/py/flwr/supernode/nodestate/nodestate_test.py",
            "diff": "diff --git a/framework/py/flwr/supernode/nodestate/nodestate_test.py b/framework/py/flwr/supernode/nodestate/nodestate_test.py\nindex 9befd6f7f..950e2d5f6 100644\n--- a/framework/py/flwr/supernode/nodestate/nodestate_test.py\n+++ b/framework/py/flwr/supernode/nodestate/nodestate_test.py\n@@ -16,7 +16,13 @@\n \n \n import unittest\n-from abc import abstractmethod\n+from typing import Any\n+\n+from parameterized import parameterized\n+\n+from flwr.common import ConfigRecord, Context, Message, Metadata, RecordDict\n+from flwr.common.message import make_message\n+from flwr.common.typing import Run\n \n from . import InMemoryNodeState, NodeState\n \n@@ -27,7 +33,10 @@ class StateTest(unittest.TestCase):\n     # This is to True in each child class\n     __test__ = False\n \n-    @abstractmethod\n+    def setUp(self) -> None:\n+        \"\"\"Set up the test case.\"\"\"\n+        self.state: NodeState = self.state_factory()\n+\n     def state_factory(self) -> NodeState:\n         \"\"\"Provide state implementation to test.\"\"\"\n         raise NotImplementedError()\n@@ -35,25 +44,140 @@ class StateTest(unittest.TestCase):\n     def test_get_set_node_id(self) -> None:\n         \"\"\"Test set_node_id.\"\"\"\n         # Prepare\n-        state: NodeState = self.state_factory()\n         node_id = 123\n \n         # Execute\n-        state.set_node_id(node_id)\n+        self.state.set_node_id(node_id)\n \n-        retrieved_node_id = state.get_node_id()\n+        retrieved_node_id = self.state.get_node_id()\n \n         # Assert\n         assert node_id == retrieved_node_id\n \n     def test_get_node_id_fails(self) -> None:\n         \"\"\"Test get_node_id fails correctly if node_id is not set.\"\"\"\n-        # Prepare\n-        state: NodeState = self.state_factory()\n-\n         # Execute and assert\n         with self.assertRaises(ValueError):\n-            state.get_node_id()\n+            self.state.get_node_id()\n+\n+    def test_store_and_get_run(self) -> None:\n+        \"\"\"Test storing and retrieving a run.\"\"\"\n+        # Prepare\n+        run = Run.create_empty(61016)\n+        self.state.store_run(run)\n+\n+        # Execute\n+        retrieved = self.state.get_run(61016)\n+\n+        # Assert\n+        self.assertEqual(retrieved, run)\n+\n+    def test_store_and_get_context(self) -> None:\n+        \"\"\"Test storing and retrieving a context.\"\"\"\n+        # Prepare\n+        ctx = Context(\n+            run_id=99,\n+            node_id=1,\n+            node_config={\"key1\": \"value1\"},\n+            state=RecordDict({\"cfg\": ConfigRecord({\"key2\": \"value2\"})}),\n+            run_config={\"key3\": \"value3\"},\n+        )\n+        self.state.store_context(ctx)\n+\n+        # Execute\n+        retrieved = self.state.get_context(99)\n+\n+        # Assert\n+        self.assertEqual(retrieved, ctx)\n+\n+    def test_store_and_get_message_basic(self) -> None:\n+        \"\"\"Test storing and retrieving a message.\"\"\"\n+        # Prepare\n+        msg = make_dummy_message(msg_id=\"test_msg\")\n+\n+        # Execute\n+        self.state.store_message(msg)\n+\n+        # Basic retrieval with no filters\n+        retrieved_msg = self.state.get_messages()[0]\n+\n+        self.assertIn(\"test_msg\", retrieved_msg.metadata.message_id)\n+        self.assertEqual(retrieved_msg, msg)\n+\n+        # Ensure message won't be retrieved again\n+        result = self.state.get_messages()\n+        self.assertEqual(len(result), 0)\n+\n+    @parameterized.expand(  # type: ignore\n+        [\n+            ({\"run_ids\": [1]}, {\"msg1\", \"msg2\"}),\n+            ({\"run_ids\": [1], \"is_reply\": False}, {\"msg2\"}),\n+            ({\"run_ids\": [1], \"limit\": 1}, {\"msg1\", \"msg2\"}),\n+            ({\"run_ids\": [2, 3]}, {\"msg3\", \"msg4\"}),\n+            ({\"is_reply\": True}, {\"msg1\", \"msg4\"}),\n+            ({\"is_reply\": True, \"limit\": 1}, {\"msg1\", \"msg4\"}),\n+        ]\n+    )\n+    def test_get_message_with_filters(\n+        self, filters: dict[str, Any], expected: set[str]\n+    ) -> None:\n+        \"\"\"Test retrieving messages with various filters.\"\"\"\n+        # Prepare\n+        # Run 1: 1 instruction, 1 reply\n+        self.state.store_message(make_dummy_message(1, True, \"msg1\"))\n+        self.state.store_message(make_dummy_message(1, False, \"msg2\"))\n+        # Run 2: 1 instruction\n+        self.state.store_message(make_dummy_message(2, False, \"msg3\"))\n+        # Run 3: 1 reply\n+        self.state.store_message(make_dummy_message(3, True, \"msg4\"))\n+\n+        # Execute\n+        result = self.state.get_messages(**filters)\n+        result_ids = {msg.metadata.message_id for msg in result}\n+\n+        # Assert\n+        if (limit := filters.get(\"limit\")) is not None:\n+            self.assertEqual(len(result), limit)\n+            self.assertTrue(result_ids.issubset(expected))\n+        else:\n+            self.assertEqual(result_ids, expected)\n+\n+    def test_delete_message(self) -> None:\n+        \"\"\"Test deleting messages.\"\"\"\n+        # Prepare\n+        msg1 = make_dummy_message(msg_id=\"msg1\")\n+        msg2 = make_dummy_message(msg_id=\"msg2\")\n+        self.state.store_message(msg1)\n+        self.state.store_message(msg2)\n+\n+        # Execute: delete one message\n+        self.state.delete_messages(message_ids=[\"msg1\"])\n+\n+        # Assert: msg1 should be deleted, msg2 should remain\n+        msgs = self.state.get_messages()\n+        msg_ids = {msg.metadata.message_id for msg in msgs}\n+        self.assertNotIn(\"msg1\", msg_ids)\n+        self.assertIn(\"msg2\", msg_ids)\n+\n+\n+def make_dummy_message(\n+    run_id: int = 110, is_reply: bool = False, msg_id: str = \"\"\n+) -> Message:\n+    \"\"\"Create a dummy message for testing.\"\"\"\n+    metadata = Metadata(\n+        run_id=run_id,\n+        # This is for testing purposes, in a real scenario this would be `.object_id`\n+        message_id=msg_id,\n+        src_node_id=0,\n+        dst_node_id=120,\n+        reply_to_message_id=\"mock id\" if is_reply else \"\",\n+        group_id=\"Mock mock\",\n+        created_at=123456789,\n+        ttl=999,\n+        message_type=\"query\",\n+    )\n+    content = RecordDict({\"cfg\": ConfigRecord({\"key\": \"value\"})})\n+    return make_message(metadata, content)\n \n \n class InMemoryStateTest(StateTest):\n@@ -64,7 +188,3 @@ class InMemoryStateTest(StateTest):\n     def state_factory(self) -> NodeState:\n         \"\"\"Return InMemoryState.\"\"\"\n         return InMemoryNodeState()\n-\n-\n-if __name__ == \"__main__\":\n-    unittest.main(verbosity=2)\n"
        }
    ]
}
{
    "sha_fail": "ce27d795db2ad56eabd9c05bf7a17c9a7bea951f",
    "changed_files": [
        {
            "commit": "ce27d795db2ad56eabd9c05bf7a17c9a7bea951f",
            "file_path": "glances/exports/export.py",
            "diff": "diff --git a/glances/exports/export.py b/glances/exports/export.py\nindex 5d1544a5..bbd37306 100644\n--- a/glances/exports/export.py\n+++ b/glances/exports/export.py\n@@ -152,7 +152,7 @@ class GlancesExport:\n         d_tags = {}\n         if tags:\n             try:\n-                d_tags = dict([x.split(\":\") for x in tags.split(\",\")])\n+                d_tags = dict(x.split(\":\", 1) for x in tags.split(\",\"))\n             except ValueError:\n                 # one of the 'key:value' pairs was missing\n                 logger.info(\"Invalid tags passed: %s\", tags)\n@@ -225,7 +225,7 @@ class GlancesExport:\n \n     def is_excluded(self, field):\n         \"\"\"Return true if the field is excluded.\"\"\"\n-        return hasattr(self, 'exclude_fields') and any(re.fullmatch(i, field, re.I) for i in self.exclude_fields)\n+        return any(re.fullmatch(i, field, re.I) for i in (getattr(self, 'exclude_fields') or ()))\n \n     def plugins_to_export(self, stats):\n         \"\"\"Return the list of plugins to export.\n"
        },
        {
            "commit": "ce27d795db2ad56eabd9c05bf7a17c9a7bea951f",
            "file_path": "glances/exports/glances_prometheus/__init__.py",
            "diff": "diff --git a/glances/exports/glances_prometheus/__init__.py b/glances/exports/glances_prometheus/__init__.py\nindex fd922eb8..85e2e5dd 100644\n--- a/glances/exports/glances_prometheus/__init__.py\n+++ b/glances/exports/glances_prometheus/__init__.py\n@@ -13,11 +13,11 @@ from numbers import Number\n \n from prometheus_client import Gauge, start_http_server\n \n+from glances.api import GlancesStats\n from glances.exports.export import GlancesExport\n from glances.globals import listkeys\n from glances.logger import logger\n \n-\n class Export(GlancesExport):\n     \"\"\"This class manages the Prometheus export module.\"\"\"\n \n@@ -43,6 +43,8 @@ class Export(GlancesExport):\n         # Perhaps a better method is possible...\n         self._metric_dict = {}\n \n+        self._stats = GlancesStats()\n+\n         # Init the Prometheus Exporter\n         self.init()\n \n@@ -61,24 +63,34 @@ class Export(GlancesExport):\n         logger.debug(f\"Export {name} stats to Prometheus exporter\")\n \n         # Remove non number stats and convert all to float (for Boolean)\n-        data = {k: float(v) for k, v in zip(columns, points) if isinstance(v, Number)}\n+        data = {str(k): float(v) for k, v in zip(columns, points) if isinstance(v, Number)}\n+\n+        key_name = self._stats.get_plugin(name).get_key()\n \n         # Write metrics to the Prometheus exporter\n-        for k, v in data.items():\n-            # Prometheus metric name: prefix_<glances stats name>\n-            metric_name = self.prefix + self.METRIC_SEPARATOR + str(name) + self.METRIC_SEPARATOR + str(k)\n+        for metric, value in data.items():\n+            labels = self.labels\n+            metric_name = self.prefix + self.METRIC_SEPARATOR + name + self.METRIC_SEPARATOR\n+            try:\n+                obj, stat = metric.split('.')\n+                metric_name += stat\n+                labels += f\",{key_name}:{obj}\"\n+            except ValueError:\n+                metric_name += metric\n+\n             # Prometheus is very sensible to the metric name\n             # See: https://prometheus.io/docs/practices/naming/\n             for c in ' .-/:[]':\n                 metric_name = metric_name.replace(c, self.METRIC_SEPARATOR)\n+\n             # Get the labels\n-            labels = self.parse_tags(self.labels)\n+            labels = self.parse_tags(labels)\n             # Manage an internal dict between metric name and Gauge\n             if metric_name not in self._metric_dict:\n-                self._metric_dict[metric_name] = Gauge(metric_name, k, labelnames=listkeys(labels))\n+                self._metric_dict[metric_name] = Gauge(metric_name, \"\", labelnames=listkeys(labels))\n             # Write the value\n             if hasattr(self._metric_dict[metric_name], 'labels'):\n                 # Add the labels (see issue #1255)\n-                self._metric_dict[metric_name].labels(**labels).set(v)\n+                self._metric_dict[metric_name].labels(**labels).set(value)\n             else:\n-                self._metric_dict[metric_name].set(v)\n+                self._metric_dict[metric_name].set(value)\n"
        }
    ]
}
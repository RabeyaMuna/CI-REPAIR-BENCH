{
    "sha_fail": "064c3b62f835ae5315b5893b3b4bd98b54e34ffa",
    "changed_files": [
        {
            "commit": "064c3b62f835ae5315b5893b3b4bd98b54e34ffa",
            "file_path": "cli/cli_app.py",
            "diff": "diff --git a/cli/cli_app.py b/cli/cli_app.py\nindex 6504ced..3aab095 100644\n--- a/cli/cli_app.py\n+++ b/cli/cli_app.py\n@@ -37,8 +37,7 @@ class CLIApp:\n         self.app = None  # Will be initialized by workflow adapter\n         self.logger = None\n         self.context = None\n-        # Document segmentation configuration\n-        self.segmentation_config = {\"enabled\": True, \"size_threshold_chars\": 50000}\n+        # Document segmentation will be managed by CLI interface\n \n     async def initialize_mcp_app(self):\n         \"\"\"\u521d\u59cb\u5316MCP\u5e94\u7528 - \u4f7f\u7528\u5de5\u4f5c\u6d41\u9002\u914d\u5668\"\"\"\n@@ -49,50 +48,11 @@ class CLIApp:\n         \"\"\"\u6e05\u7406MCP\u5e94\u7528 - \u4f7f\u7528\u5de5\u4f5c\u6d41\u9002\u914d\u5668\"\"\"\n         await self.workflow_adapter.cleanup_mcp_app()\n \n-    def update_segmentation_config(self):\n-        \"\"\"Update document segmentation configuration in mcp_agent.config.yaml\"\"\"\n-        import yaml\n-        import os\n-\n-        config_path = os.path.join(\n-            os.path.dirname(os.path.dirname(os.path.abspath(__file__))),\n-            \"mcp_agent.config.yaml\",\n-        )\n-\n-        try:\n-            # Read current config\n-            with open(config_path, \"r\", encoding=\"utf-8\") as f:\n-                config = yaml.safe_load(f)\n-\n-            # Update document segmentation settings\n-            if \"document_segmentation\" not in config:\n-                config[\"document_segmentation\"] = {}\n-\n-            config[\"document_segmentation\"][\"enabled\"] = self.segmentation_config[\n-                \"enabled\"\n-            ]\n-            config[\"document_segmentation\"][\"size_threshold_chars\"] = (\n-                self.segmentation_config[\"size_threshold_chars\"]\n-            )\n-\n-            # Write updated config\n-            with open(config_path, \"w\", encoding=\"utf-8\") as f:\n-                yaml.dump(config, f, default_flow_style=False, allow_unicode=True)\n-\n-            self.cli.print_status(\n-                \"\ud83d\udcc4 Document segmentation configuration updated\", \"success\"\n-            )\n-\n-        except Exception as e:\n-            self.cli.print_status(\n-                f\"\u26a0\ufe0f Failed to update segmentation config: {str(e)}\", \"warning\"\n-            )\n \n     async def process_input(self, input_source: str, input_type: str):\n         \"\"\"\u5904\u7406\u8f93\u5165\u6e90\uff08URL\u6216\u6587\u4ef6\uff09- \u4f7f\u7528\u5347\u7ea7\u7248\u667a\u80fd\u4f53\u7f16\u6392\u5f15\u64ce\"\"\"\n         try:\n-            # Update segmentation configuration before processing\n-            self.update_segmentation_config()\n+            # Document segmentation configuration is managed by CLI interface\n \n             self.cli.print_separator()\n             self.cli.print_status(\n@@ -281,20 +241,9 @@ class CLIApp:\n                     self.cli.show_history()\n \n                 elif choice in [\"c\", \"config\", \"configure\"]:\n-                    # Sync current segmentation config from CLI interface\n-                    self.segmentation_config[\"enabled\"] = self.cli.segmentation_enabled\n-                    self.segmentation_config[\"size_threshold_chars\"] = (\n-                        self.cli.segmentation_threshold\n-                    )\n-\n+                    # Show configuration menu - all settings managed by CLI interface\n                     self.cli.show_configuration_menu()\n \n-                    # Sync back from CLI interface after configuration changes\n-                    self.segmentation_config[\"enabled\"] = self.cli.segmentation_enabled\n-                    self.segmentation_config[\"size_threshold_chars\"] = (\n-                        self.cli.segmentation_threshold\n-                    )\n-\n                 else:\n                     self.cli.print_status(\n                         \"Invalid choice. Please select U, F, T, C, H, or Q.\", \"warning\"\n"
        },
        {
            "commit": "064c3b62f835ae5315b5893b3b4bd98b54e34ffa",
            "file_path": "cli/cli_interface.py",
            "diff": "diff --git a/cli/cli_interface.py b/cli/cli_interface.py\nindex 770dc1c..e53773a 100644\n--- a/cli/cli_interface.py\n+++ b/cli/cli_interface.py\n@@ -40,9 +40,60 @@ class CLIInterface:\n         self.is_running = True\n         self.processing_history = []\n         self.enable_indexing = True  # Default configuration\n-        self.segmentation_enabled = True  # Default to smart segmentation\n-        self.segmentation_threshold = 50000  # Default threshold\n+        \n+        # Load segmentation config from the same source as UI\n+        self._load_segmentation_config()\n+        \n+        # Initialize tkinter availability\n+        self._init_tkinter()\n+\n+    def _load_segmentation_config(self):\n+        \"\"\"Load segmentation configuration from mcp_agent.config.yaml\"\"\"\n+        try:\n+            from utils.llm_utils import get_document_segmentation_config\n+            seg_config = get_document_segmentation_config()\n+            self.segmentation_enabled = seg_config.get(\"enabled\", True)\n+            self.segmentation_threshold = seg_config.get(\"size_threshold_chars\", 50000)\n+        except Exception as e:\n+            print(f\"\u26a0\ufe0f Warning: Failed to load segmentation config: {e}\")\n+            # Fall back to defaults\n+            self.segmentation_enabled = True\n+            self.segmentation_threshold = 50000\n+\n+    def _save_segmentation_config(self):\n+        \"\"\"Save segmentation configuration to mcp_agent.config.yaml\"\"\"\n+        import yaml\n+        import os\n+        \n+        # Get the project root directory (where mcp_agent.config.yaml is located)\n+        current_file = os.path.abspath(__file__)\n+        cli_dir = os.path.dirname(current_file)  # cli directory\n+        project_root = os.path.dirname(cli_dir)  # project root\n+        config_path = os.path.join(project_root, \"mcp_agent.config.yaml\")\n+\n+        try:\n+            # Read current config\n+            with open(config_path, \"r\", encoding=\"utf-8\") as f:\n+                config = yaml.safe_load(f)\n+\n+            # Update document segmentation settings\n+            if \"document_segmentation\" not in config:\n+                config[\"document_segmentation\"] = {}\n+\n+            config[\"document_segmentation\"][\"enabled\"] = self.segmentation_enabled\n+            config[\"document_segmentation\"][\"size_threshold_chars\"] = self.segmentation_threshold\n+\n+            # Write updated config\n+            with open(config_path, \"w\", encoding=\"utf-8\") as f:\n+                yaml.dump(config, f, default_flow_style=False, allow_unicode=True)\n+\n+            print(f\"{Colors.OKGREEN}\u2705 Document segmentation configuration updated{Colors.ENDC}\")\n+\n+        except Exception as e:\n+            print(f\"{Colors.WARNING}\u26a0\ufe0f Failed to update segmentation config: {str(e)}{Colors.ENDC}\")\n \n+    def _init_tkinter(self):\n+        \"\"\"Initialize tkinter availability check\"\"\"\n         # Check tkinter availability for file dialogs\n         self.tkinter_available = True\n         try:\n@@ -765,6 +816,8 @@ class CLIInterface:\n             elif choice in [\"s\", \"segmentation\"]:\n                 current_state = getattr(self, \"segmentation_enabled\", True)\n                 self.segmentation_enabled = not current_state\n+                # Save the configuration to file\n+                self._save_segmentation_config()\n                 seg_mode = (\n                     \"\ud83d\udcc4 Smart Segmentation\"\n                     if self.segmentation_enabled\n"
        },
        {
            "commit": "064c3b62f835ae5315b5893b3b4bd98b54e34ffa",
            "file_path": "cli/main_cli.py",
            "diff": "diff --git a/cli/main_cli.py b/cli/main_cli.py\nindex 1e70baa..bee8f74 100644\n--- a/cli/main_cli.py\n+++ b/cli/main_cli.py\n@@ -230,18 +230,16 @@ async def main():\n             print(\n                 f\"\\n{Colors.MAGENTA}\ud83d\udcc4 Document segmentation disabled - using traditional processing{Colors.ENDC}\"\n             )\n-            app.segmentation_config = {\n-                \"enabled\": False,\n-                \"size_threshold_chars\": args.segmentation_threshold,\n-            }\n+            app.cli.segmentation_enabled = False\n+            app.cli.segmentation_threshold = args.segmentation_threshold\n+            app.cli._save_segmentation_config()\n         else:\n             print(\n                 f\"\\n{Colors.BLUE}\ud83d\udcc4 Smart document segmentation enabled (threshold: {args.segmentation_threshold} chars){Colors.ENDC}\"\n             )\n-            app.segmentation_config = {\n-                \"enabled\": True,\n-                \"size_threshold_chars\": args.segmentation_threshold,\n-            }\n+            app.cli.segmentation_enabled = True\n+            app.cli.segmentation_threshold = args.segmentation_threshold\n+            app.cli._save_segmentation_config()\n \n         # \u68c0\u67e5\u662f\u5426\u4e3a\u76f4\u63a5\u5904\u7406\u6a21\u5f0f\n         if args.file or args.url or args.chat:\n"
        },
        {
            "commit": "064c3b62f835ae5315b5893b3b4bd98b54e34ffa",
            "file_path": "workflows/agent_orchestration_engine.py",
            "diff": "diff --git a/workflows/agent_orchestration_engine.py b/workflows/agent_orchestration_engine.py\nindex 3f2d602..b766b64 100644\n--- a/workflows/agent_orchestration_engine.py\n+++ b/workflows/agent_orchestration_engine.py\n@@ -62,6 +62,101 @@ from workflows.agents.document_segmentation_agent import prepare_document_segmen\n os.environ[\"PYTHONDONTWRITEBYTECODE\"] = \"1\"  # Prevent .pyc file generation\n \n \n+def _assess_output_completeness(text: str) -> float:\n+    \"\"\"\n+    \u667a\u80fd\u8bc4\u4f30\u8f93\u51fa\u5b8c\u6574\u6027\u7684\u9ad8\u7ea7\u7b97\u6cd5\n+    \n+    \u4f7f\u7528\u591a\u79cd\u542f\u53d1\u5f0f\u65b9\u6cd5\u6765\u68c0\u6d4b\u8f93\u51fa\u662f\u5426\u88ab\u622a\u65ad\uff1a\n+    1. \u7ed3\u6784\u5316\u6807\u8bb0\u5b8c\u6574\u6027\u68c0\u67e5\n+    2. \u53e5\u5b50\u5b8c\u6574\u6027\u5206\u6790 \n+    3. \u4ee3\u7801\u5757\u5b8c\u6574\u6027\u9a8c\u8bc1\n+    4. \u9884\u671f\u5185\u5bb9\u5143\u7d20\u68c0\u67e5\n+    \n+    Returns:\n+        float: \u5b8c\u6574\u6027\u5206\u6570 (0.0-1.0)\uff0c\u8d8a\u9ad8\u8868\u793a\u8d8a\u5b8c\u6574\n+    \"\"\"\n+    if not text or len(text.strip()) < 100:\n+        return 0.0\n+    \n+    score = 0.0\n+    factors = 0\n+    \n+    # 1. \u57fa\u672c\u957f\u5ea6\u68c0\u67e5 (\u6743\u91cd: 0.2)\n+    if len(text) > 5000:  # \u671f\u671b\u7684\u6700\u5c0f\u8f93\u51fa\u957f\u5ea6\n+        score += 0.2\n+    elif len(text) > 2000:\n+        score += 0.1\n+    factors += 1\n+    \n+    # 2. \u7ed3\u6784\u5b8c\u6574\u6027\u68c0\u67e5 (\u6743\u91cd: 0.3)\n+    structure_indicators = [\n+        \"## 1.\", \"## 2.\", \"## 3.\",  # \u7ae0\u8282\u6807\u9898\n+        \"```\", \"file_structure\", \"implementation\",\n+        \"algorithm\", \"method\", \"function\"\n+    ]\n+    structure_count = sum(1 for indicator in structure_indicators if indicator.lower() in text.lower())\n+    if structure_count >= 6:\n+        score += 0.3\n+    elif structure_count >= 3:\n+        score += 0.15\n+    factors += 1\n+    \n+    # 3. \u53e5\u5b50\u5b8c\u6574\u6027\u68c0\u67e5 (\u6743\u91cd: 0.2)\n+    lines = text.strip().split('\\n')\n+    if lines:\n+        last_line = lines[-1].strip()\n+        # \u68c0\u67e5\u6700\u540e\u4e00\u884c\u662f\u5426\u662f\u5b8c\u6574\u7684\u53e5\u5b50\u6216\u7ed3\u6784\u5316\u5185\u5bb9\n+        if (last_line.endswith(('.', ':', '```', '!', '?')) or \n+            last_line.startswith(('##', '-', '*', '`')) or\n+            len(last_line) < 10):  # \u5f88\u77ed\u7684\u884c\u53ef\u80fd\u662f\u5217\u8868\u9879\n+            score += 0.2\n+        elif len(last_line) > 50 and not last_line.endswith(('.', ':', '```', '!', '?')):\n+            # \u957f\u884c\u4f46\u6ca1\u6709\u9002\u5f53\u7ed3\u5c3e\uff0c\u53ef\u80fd\u88ab\u622a\u65ad\n+            score += 0.05\n+    factors += 1\n+    \n+    # 4. \u4ee3\u7801\u5b9e\u73b0\u8ba1\u5212\u5b8c\u6574\u6027 (\u6743\u91cd: 0.3)\n+    implementation_keywords = [\n+        \"file structure\", \"architecture\", \"implementation\", \n+        \"requirements\", \"dependencies\", \"setup\", \"main\",\n+        \"class\", \"function\", \"method\", \"algorithm\"\n+    ]\n+    impl_count = sum(1 for keyword in implementation_keywords if keyword.lower() in text.lower())\n+    if impl_count >= 8:\n+        score += 0.3\n+    elif impl_count >= 4:\n+        score += 0.15\n+    factors += 1\n+    \n+    return min(score, 1.0)  # \u786e\u4fdd\u4e0d\u8d85\u8fc71.0\n+\n+\n+def _adjust_params_for_retry(params: RequestParams, retry_count: int) -> RequestParams:\n+    \"\"\"\n+    \u52a8\u6001\u8c03\u6574\u8bf7\u6c42\u53c2\u6570\u4ee5\u63d0\u9ad8\u6210\u529f\u7387\n+    \n+    \u57fa\u4e8e\u91cd\u8bd5\u6b21\u6570\u667a\u80fd\u8c03\u6574\u53c2\u6570\uff1a\n+    - \u589e\u52a0token\u9650\u5236\n+    - \u8c03\u6574temperature\n+    - \u4f18\u5316\u5176\u4ed6\u53c2\u6570\n+    \"\"\"\n+    # \u57fa\u7840token\u589e\u91cf\uff1a\u6bcf\u6b21\u91cd\u8bd5\u589e\u52a0\u66f4\u591atokens\n+    token_increment = 4096 * (retry_count + 1)\n+    new_max_tokens = min(params.max_tokens + token_increment, 32768)  # \u4e0d\u8d85\u8fc732K\u7684\u5408\u7406\u9650\u5236\n+    \n+    # \u968f\u7740\u91cd\u8bd5\u6b21\u6570\u589e\u52a0\uff0c\u964d\u4f4etemperature\u4ee5\u83b7\u5f97\u66f4\u4e00\u81f4\u7684\u8f93\u51fa\n+    new_temperature = max(params.temperature - (retry_count * 0.1), 0.1)\n+    \n+    print(f\"\ud83d\udd27 Adjusting parameters for retry {retry_count + 1}:\")\n+    print(f\"   Token limit: {params.max_tokens} \u2192 {new_max_tokens}\")\n+    print(f\"   Temperature: {params.temperature} \u2192 {new_temperature}\")\n+    \n+    return RequestParams(\n+        max_tokens=new_max_tokens,\n+        temperature=new_temperature,\n+    )\n+\n+\n def get_default_search_server(config_path: str = \"mcp_agent.config.yaml\"):\n     \"\"\"\n     Get the default search server from configuration.\n@@ -382,10 +477,22 @@ async def run_code_analyzer(\n         llm_factory=get_preferred_llm_class(),\n     )\n \n-    # Set appropriate token output limit for Claude models (max 8192)\n+    # Advanced token management system with dynamic scaling\n+    # \u68c0\u67e5\u662f\u5426\u4f7f\u7528\u5206\u6bb5\u6a21\u5f0f\u4ee5\u52a8\u6001\u8c03\u6574token\u9650\u5236\n+    if use_segmentation:\n+        # \u5206\u6bb5\u6a21\u5f0f\uff1a\u53ef\u4ee5\u4f7f\u7528\u66f4\u9ad8\u7684token\u9650\u5236\uff0c\u56e0\u4e3a\u8f93\u5165\u5df2\u7ecf\u88ab\u4f18\u5316\n+        max_tokens_limit = 16384  # \u4f7f\u7528\u66f4\u9ad8\u9650\u5236\uff0c\u56e0\u4e3a\u5206\u6bb5\u51cf\u5c11\u4e86\u8f93\u5165\u590d\u6742\u6027\n+        temperature = 0.2  # \u7a0d\u5fae\u964d\u4f4etemperature\u4ee5\u63d0\u9ad8\u4e00\u81f4\u6027\n+        print(\"\ud83e\udde0 Using SEGMENTED mode: Higher token limit (16384) with optimized inputs\")\n+    else:\n+        # \u4f20\u7edf\u6a21\u5f0f\uff1a\u4f7f\u7528\u4fdd\u5b88\u7684token\u9650\u5236\u5e76\u542f\u7528\u589e\u91cf\u751f\u6210\n+        max_tokens_limit = 12288  # \u4e2d\u7b49\u9650\u5236\uff0c\u4e3a\u805a\u5408\u8f93\u51fa\u7559\u51fa\u7a7a\u95f4\n+        temperature = 0.3\n+        print(\"\ud83e\udde0 Using TRADITIONAL mode: Moderate token limit (12288)\")\n+    \n     enhanced_params = RequestParams(\n-        max_tokens=8192,  # Adjusted to Claude 3.5 Sonnet's actual limit\n-        temperature=0.3,\n+        max_tokens=max_tokens_limit,\n+        temperature=temperature,\n     )\n \n     # Concise message for multi-agent paper analysis and code planning\n@@ -399,10 +506,38 @@ Please locate and analyze the markdown (.md) file containing the research paper.\n \n The goal is to create a reproduction plan detailed enough for independent implementation.\"\"\"\n \n-    result = await code_aggregator_agent.generate_str(\n-        message=message, request_params=enhanced_params\n-    )\n-    print(f\"Code analysis result: {result}\")\n+    # \u667a\u80fd\u8f93\u51fa\u5b8c\u6574\u6027\u68c0\u67e5\u548c\u91cd\u8bd5\u673a\u5236\n+    max_retries = 3\n+    retry_count = 0\n+    \n+    while retry_count < max_retries:\n+        try:\n+            print(f\"\ud83d\ude80 Attempting code analysis (attempt {retry_count + 1}/{max_retries})\")\n+            result = await code_aggregator_agent.generate_str(\n+                message=message, request_params=enhanced_params\n+            )\n+            \n+            # \u68c0\u67e5\u8f93\u51fa\u5b8c\u6574\u6027\u7684\u9ad8\u7ea7\u6307\u6807\n+            completeness_score = _assess_output_completeness(result)\n+            print(f\"\ud83d\udcca Output completeness score: {completeness_score:.2f}/1.0\")\n+            \n+            if completeness_score >= 0.8:  # \u8f93\u51fa\u88ab\u8ba4\u4e3a\u662f\u5b8c\u6574\u7684\n+                print(f\"\u2705 Code analysis completed successfully (length: {len(result)} chars)\")\n+                return result\n+            else:\n+                print(f\"\u26a0\ufe0f Output appears truncated (score: {completeness_score:.2f}), retrying with enhanced parameters...\")\n+                # \u52a8\u6001\u8c03\u6574\u53c2\u6570\u8fdb\u884c\u91cd\u8bd5\n+                enhanced_params = _adjust_params_for_retry(enhanced_params, retry_count)\n+                retry_count += 1\n+                \n+        except Exception as e:\n+            print(f\"\u274c Error in code analysis attempt {retry_count + 1}: {e}\")\n+            retry_count += 1\n+            if retry_count >= max_retries:\n+                raise\n+    \n+    # \u5982\u679c\u6240\u6709\u91cd\u8bd5\u90fd\u5931\u8d25\uff0c\u8fd4\u56de\u6700\u540e\u4e00\u6b21\u7684\u7ed3\u679c\n+    print(f\"\u26a0\ufe0f Returning potentially incomplete result after {max_retries} attempts\")\n     return result\n \n \n"
        }
    ]
}
{
    "sha_fail": "cced5b5d68a3fe1a02d8ac1186e9d12b6c75dc8d",
    "changed_files": [
        {
            "commit": "cced5b5d68a3fe1a02d8ac1186e9d12b6c75dc8d",
            "file_path": "sky/resources.py",
            "diff": "diff --git a/sky/resources.py b/sky/resources.py\nindex 875f266e..ef8e888b 100644\n--- a/sky/resources.py\n+++ b/sky/resources.py\n@@ -42,6 +42,7 @@ class Resources:\n     * for provisioning on a cloud\n \n     \"\"\"\n+\n     # If any fields changed, increment the version. For backward compatibility,\n     # modify the __setstate__ method to handle the old version.\n     _VERSION = 13\n@@ -60,7 +61,7 @@ class Resources:\n         zone: Optional[str] = None,\n         image_id: Union[Dict[str, str], str, None] = None,\n         disk_size: Optional[int] = None,\n-        disk_tier: Optional[Literal['high', 'medium', 'low']] = None,\n+        disk_tier: Optional[Literal[\"high\", \"medium\", \"low\"]] = None,\n         ports: Optional[Union[int, str, List[str], Tuple[str]]] = None,\n         # Internal use only.\n         _docker_login_config: Optional[docker_utils.DockerLoginConfig] = None,\n@@ -144,14 +145,15 @@ class Resources:\n         self._use_spot = use_spot if use_spot is not None else False\n         self._spot_recovery = None\n         if spot_recovery is not None:\n-            if spot_recovery.strip().lower() != 'none':\n+            if spot_recovery.strip().lower() != \"none\":\n                 self._spot_recovery = spot_recovery.upper()\n \n         if disk_size is not None:\n             if round(disk_size) != disk_size:\n                 with ux_utils.print_exception_no_traceback():\n                     raise ValueError(\n-                        f'OS disk size must be an integer. Got: {disk_size}.')\n+                        f\"OS disk size must be an integer. Got: {disk_size}.\"\n+                    )\n             self._disk_size = int(disk_size)\n         else:\n             self._disk_size = _DEFAULT_DISK_SIZE_GB\n@@ -165,9 +167,7 @@ class Resources:\n             if None in image_id:\n                 self._image_id = {self._region: image_id[None].strip()}\n             else:\n-                self._image_id = {\n-                    k.strip(): v.strip() for k, v in image_id.items()\n-                }\n+                self._image_id = {k.strip(): v.strip() for k, v in image_id.items()}\n         self._is_image_managed = _is_image_managed\n \n         self._disk_tier = disk_tier\n@@ -177,8 +177,7 @@ class Resources:\n                 ports = list(ports)\n             if not isinstance(ports, list):\n                 ports = [ports]\n-            ports = resources_utils.simplify_ports(\n-                [str(port) for port in ports])\n+            ports = resources_utils.simplify_ports([str(port) for port in ports])\n             if not ports:\n                 # Set to None if empty. This is mainly for resources from\n                 # cli, which will comes in as an empty tuple.\n@@ -229,83 +228,84 @@ class Resources:\n             >>> sky.Resources(disk_size=100)\n             <Cloud>(disk_size=100)\n         \"\"\"\n-        accelerators = ''\n-        accelerator_args = ''\n+        accelerators = \"\"\n+        accelerator_args = \"\"\n         if self.accelerators is not None:\n-            accelerators = f', {self.accelerators}'\n+            accelerators = f\", {self.accelerators}\"\n             if self.accelerator_args is not None:\n-                accelerator_args = f', accelerator_args={self.accelerator_args}'\n+                accelerator_args = f\", accelerator_args={self.accelerator_args}\"\n \n-        cpus = ''\n+        cpus = \"\"\n         if self.cpus is not None:\n-            cpus = f', cpus={self.cpus}'\n+            cpus = f\", cpus={self.cpus}\"\n \n-        memory = ''\n+        memory = \"\"\n         if self.memory is not None:\n-            memory = f', mem={self.memory}'\n+            memory = f\", mem={self.memory}\"\n \n         if isinstance(self.cloud, clouds.Local):\n-            return f'{self.cloud}({self.accelerators})'\n+            return f\"{self.cloud}({self.accelerators})\"\n \n-        use_spot = ''\n+        use_spot = \"\"\n         if self.use_spot:\n-            use_spot = '[Spot]'\n+            use_spot = \"[Spot]\"\n \n-        image_id = ''\n+        image_id = \"\"\n         if self.image_id is not None:\n             if None in self.image_id:\n-                image_id = f', image_id={self.image_id[None]}'\n+                image_id = f\", image_id={self.image_id[None]}\"\n             else:\n-                image_id = f', image_id={self.image_id}'\n+                image_id = f\", image_id={self.image_id}\"\n \n-        disk_tier = ''\n+        disk_tier = \"\"\n         if self.disk_tier is not None:\n-            disk_tier = f', disk_tier={self.disk_tier}'\n+            disk_tier = f\", disk_tier={self.disk_tier}\"\n \n-        disk_size = ''\n+        disk_size = \"\"\n         if self.disk_size != _DEFAULT_DISK_SIZE_GB:\n-            disk_size = f', disk_size={self.disk_size}'\n+            disk_size = f\", disk_size={self.disk_size}\"\n \n-        ports = ''\n+        ports = \"\"\n         if self.ports is not None:\n-            ports = f', ports={self.ports}'\n+            ports = f\", ports={self.ports}\"\n \n         if self._instance_type is not None:\n-            instance_type = f'{self._instance_type}'\n+            instance_type = f\"{self._instance_type}\"\n         else:\n-            instance_type = ''\n+            instance_type = \"\"\n \n         # Do not show region/zone here as `sky status -a` would show them as\n         # separate columns. Also, Resources repr will be printed during\n         # failover, and the region may be dynamically determined.\n         hardware_str = (\n-            f'{instance_type}{use_spot}'\n-            f'{cpus}{memory}{accelerators}{accelerator_args}{image_id}'\n-            f'{disk_tier}{disk_size}{ports}')\n+            f\"{instance_type}{use_spot}\"\n+            f\"{cpus}{memory}{accelerators}{accelerator_args}{image_id}\"\n+            f\"{disk_tier}{disk_size}{ports}\"\n+        )\n         # It may have leading ',' (for example, instance_type not set) or empty\n         # spaces.  Remove them.\n-        while hardware_str and hardware_str[0] in (',', ' '):\n+        while hardware_str and hardware_str[0] in (\",\", \" \"):\n             hardware_str = hardware_str[1:]\n \n-        cloud_str = '<Cloud>'\n+        cloud_str = \"<Cloud>\"\n         if self.cloud is not None:\n-            cloud_str = f'{self.cloud}'\n+            cloud_str = f\"{self.cloud}\"\n \n-        return f'{cloud_str}({hardware_str})'\n+        return f\"{cloud_str}({hardware_str})\"\n \n     @property\n     def repr_with_region_zone(self) -> str:\n-        region_str = ''\n+        region_str = \"\"\n         if self.region is not None:\n-            region_str = f', region={self.region}'\n-        zone_str = ''\n+            region_str = f\", region={self.region}\"\n+        zone_str = \"\"\n         if self.zone is not None:\n-            zone_str = f', zone={self.zone}'\n+            zone_str = f\", zone={self.zone}\"\n         repr_str = str(self)\n-        if repr_str.endswith(')'):\n-            repr_str = repr_str[:-1] + f'{region_str}{zone_str})'\n+        if repr_str.endswith(\")\"):\n+            repr_str = repr_str[:-1] + f\"{region_str}{zone_str})\"\n         else:\n-            repr_str += f'{region_str}{zone_str}'\n+            repr_str += f\"{region_str}{zone_str}\"\n         return repr_str\n \n     @property\n@@ -363,8 +363,7 @@ class Resources:\n         if self._accelerators is not None:\n             return self._accelerators\n         if self.cloud is not None and self._instance_type is not None:\n-            return self.cloud.get_accelerators_from_instance_type(\n-                self._instance_type)\n+            return self.cloud.get_accelerators_from_instance_type(self._instance_type)\n         return None\n \n     @property\n@@ -413,7 +412,7 @@ class Resources:\n \n         self._cpus = str(cpus)\n         if isinstance(cpus, str):\n-            if cpus.endswith('+'):\n+            if cpus.endswith(\"+\"):\n                 num_cpus_str = cpus[:-1]\n             else:\n                 num_cpus_str = cpus\n@@ -424,14 +423,16 @@ class Resources:\n                 with ux_utils.print_exception_no_traceback():\n                     raise ValueError(\n                         f'The \"cpus\" field should be either a number or '\n-                        f'a string \"<number>+\". Found: {cpus!r}') from None\n+                        f'a string \"<number>+\". Found: {cpus!r}'\n+                    ) from None\n         else:\n             num_cpus = float(cpus)\n \n         if num_cpus <= 0:\n             with ux_utils.print_exception_no_traceback():\n                 raise ValueError(\n-                    f'The \"cpus\" field should be positive. Found: {cpus!r}')\n+                    f'The \"cpus\" field should be positive. Found: {cpus!r}'\n+                )\n \n     def _set_memory(\n         self,\n@@ -443,7 +444,7 @@ class Resources:\n \n         self._memory = str(memory)\n         if isinstance(memory, str):\n-            if memory.endswith('+'):\n+            if memory.endswith(\"+\"):\n                 num_memory_gb = memory[:-1]\n             else:\n                 num_memory_gb = memory\n@@ -454,14 +455,16 @@ class Resources:\n                 with ux_utils.print_exception_no_traceback():\n                     raise ValueError(\n                         f'The \"memory\" field should be either a number or '\n-                        f'a string \"<number>+\". Found: {memory!r}') from None\n+                        f'a string \"<number>+\". Found: {memory!r}'\n+                    ) from None\n         else:\n             memory_gb = float(memory)\n \n         if memory_gb <= 0:\n             with ux_utils.print_exception_no_traceback():\n                 raise ValueError(\n-                    f'The \"cpus\" field should be positive. Found: {memory!r}')\n+                    f'The \"cpus\" field should be positive. Found: {memory!r}'\n+                )\n \n     def _set_accelerators(\n         self,\n@@ -476,13 +479,15 @@ class Resources:\n         \"\"\"\n         if accelerators is not None:\n             if isinstance(accelerators, str):  # Convert to Dict[str, int].\n-                if ':' not in accelerators:\n+                if \":\" not in accelerators:\n                     accelerators = {accelerators: 1}\n                 else:\n-                    splits = accelerators.split(':')\n-                    parse_error = ('The \"accelerators\" field as a str '\n-                                   'should be <name> or <name>:<cnt>. '\n-                                   f'Found: {accelerators!r}')\n+                    splits = accelerators.split(\":\")\n+                    parse_error = (\n+                        'The \"accelerators\" field as a str '\n+                        \"should be <name> or <name>:<cnt>. \"\n+                        f\"Found: {accelerators!r}\"\n+                    )\n                     if len(splits) != 2:\n                         with ux_utils.print_exception_no_traceback():\n                             raise ValueError(parse_error)\n@@ -502,35 +507,36 @@ class Resources:\n \n             # Canonicalize the accelerator names.\n             accelerators = {\n-                accelerator_registry.canonicalize_accelerator_name(acc):\n-                acc_count for acc, acc_count in accelerators.items()\n+                accelerator_registry.canonicalize_accelerator_name(acc): acc_count\n+                for acc, acc_count in accelerators.items()\n             }\n \n             acc, _ = list(accelerators.items())[0]\n-            if 'tpu' in acc.lower():\n+            if \"tpu\" in acc.lower():\n                 if self.cloud is None:\n                     self._cloud = clouds.GCP()\n-                assert self.cloud.is_same_cloud(\n-                    clouds.GCP()), 'Cloud must be GCP.'\n+                assert self.cloud.is_same_cloud(clouds.GCP()), \"Cloud must be GCP.\"\n                 if accelerator_args is None:\n                     accelerator_args = {}\n-                use_tpu_vm = accelerator_args.get('tpu_vm', False)\n+                use_tpu_vm = accelerator_args.get(\"tpu_vm\", False)\n                 if use_tpu_vm:\n                     tpu_utils.check_gcp_cli_include_tpu_vm()\n                 if self.instance_type is not None and use_tpu_vm:\n-                    if self.instance_type != 'TPU-VM':\n+                    if self.instance_type != \"TPU-VM\":\n                         with ux_utils.print_exception_no_traceback():\n                             raise ValueError(\n-                                'Cannot specify instance type'\n-                                f' (got \"{self.instance_type}\") for TPU VM.')\n-                if 'runtime_version' not in accelerator_args:\n+                                \"Cannot specify instance type\"\n+                                f' (got \"{self.instance_type}\") for TPU VM.'\n+                            )\n+                if \"runtime_version\" not in accelerator_args:\n                     if use_tpu_vm:\n-                        accelerator_args['runtime_version'] = 'tpu-vm-base'\n+                        accelerator_args[\"runtime_version\"] = \"tpu-vm-base\"\n                     else:\n-                        accelerator_args['runtime_version'] = '2.12.0'\n+                        accelerator_args[\"runtime_version\"] = \"2.12.0\"\n                     logger.info(\n-                        'Missing runtime_version in accelerator_args, using'\n-                        f' default ({accelerator_args[\"runtime_version\"]})')\n+                        \"Missing runtime_version in accelerator_args, using\"\n+                        f' default ({accelerator_args[\"runtime_version\"]})'\n+                    )\n \n         self._accelerators = accelerators\n         self._accelerator_args = accelerator_args\n@@ -543,8 +549,9 @@ class Resources:\n         assert self.is_launchable(), self\n         return self.cloud.need_cleanup_after_preemption(self)\n \n-    def _validate_and_set_region_zone(self, region: Optional[str],\n-                                      zone: Optional[str]) -> None:\n+    def _validate_and_set_region_zone(\n+        self, region: Optional[str], zone: Optional[str]\n+    ) -> None:\n         if region is None and zone is None:\n             return\n \n@@ -564,39 +571,41 @@ class Resources:\n \n             if len(valid_clouds) == 0:\n                 if len(enabled_clouds) == 1:\n-                    cloud_str = f'for cloud {enabled_clouds[0]}'\n+                    cloud_str = f\"for cloud {enabled_clouds[0]}\"\n                 else:\n-                    cloud_str = f'for any cloud among {enabled_clouds}'\n+                    cloud_str = f\"for any cloud among {enabled_clouds}\"\n                 with ux_utils.print_exception_no_traceback():\n                     if len(cloud_to_errors) == 1:\n                         # UX: if 1 cloud, don't print a table.\n                         hint = list(cloud_to_errors.items())[0][-1]\n                     else:\n-                        table = log_utils.create_table(['Cloud', 'Hint'])\n-                        table.add_row(['-----', '----'])\n+                        table = log_utils.create_table([\"Cloud\", \"Hint\"])\n+                        table.add_row([\"-----\", \"----\"])\n                         for cloud, error in cloud_to_errors.items():\n-                            reason_str = '\\n'.join(textwrap.wrap(\n-                                str(error), 80))\n+                            reason_str = \"\\n\".join(textwrap.wrap(str(error), 80))\n                             table.add_row([str(cloud), reason_str])\n                         hint = table.get_string()\n                     raise ValueError(\n-                        f'Invalid (region {region!r}, zone {zone!r}) '\n-                        f'{cloud_str}. Details:\\n{hint}')\n+                        f\"Invalid (region {region!r}, zone {zone!r}) \"\n+                        f\"{cloud_str}. Details:\\n{hint}\"\n+                    )\n             elif len(valid_clouds) > 1:\n                 with ux_utils.print_exception_no_traceback():\n                     raise ValueError(\n-                        f'Cannot infer cloud from (region {region!r}, zone '\n-                        f'{zone!r}). Multiple enabled clouds have region/zone '\n-                        f'of the same names: {valid_clouds}. '\n-                        f'To fix: explicitly specify `cloud`.')\n-            logger.debug(f'Cloud is not specified, using {valid_clouds[0]} '\n-                         f'inferred from region {region!r} and zone {zone!r}')\n+                        f\"Cannot infer cloud from (region {region!r}, zone \"\n+                        f\"{zone!r}). Multiple enabled clouds have region/zone \"\n+                        f\"of the same names: {valid_clouds}. \"\n+                        f\"To fix: explicitly specify `cloud`.\"\n+                    )\n+            logger.debug(\n+                f\"Cloud is not specified, using {valid_clouds[0]} \"\n+                f\"inferred from region {region!r} and zone {zone!r}\"\n+            )\n             self._cloud = valid_clouds[0]\n \n         # Validate if region and zone exist in the catalog, and set the region\n         # if zone is specified.\n-        self._region, self._zone = self._cloud.validate_region_zone(\n-            region, zone)\n+        self._region, self._zone = self._cloud.validate_region_zone(region, zone)\n \n     def get_valid_regions_for_launchable(self) -> List[clouds.Region]:\n         \"\"\"Returns a set of `Region`s that can provision this Resources.\n@@ -609,18 +618,24 @@ class Resources:\n         \"\"\"\n         assert self.is_launchable(), self\n \n-        regions = self._cloud.regions_with_offering(self._instance_type,\n-                                                    self.accelerators,\n-                                                    self._use_spot,\n-                                                    self._region, self._zone)\n+        regions = self._cloud.regions_with_offering(\n+            self._instance_type,\n+            self.accelerators,\n+            self._use_spot,\n+            self._region,\n+            self._zone,\n+        )\n         if self._image_id is not None and None not in self._image_id:\n             regions = [r for r in regions if r.name in self._image_id]\n \n         # Filter the regions by the skypilot_config\n         ssh_proxy_command_config = skypilot_config.get_nested(\n-            (str(self._cloud).lower(), 'ssh_proxy_command'), None)\n-        if (isinstance(ssh_proxy_command_config, str) or\n-                ssh_proxy_command_config is None):\n+            (str(self._cloud).lower(), \"ssh_proxy_command\"), None\n+        )\n+        if (\n+            isinstance(ssh_proxy_command_config, str)\n+            or ssh_proxy_command_config is None\n+        ):\n             # All regions are valid as the regions are not specified for the\n             # ssh_proxy_command config.\n             return regions\n@@ -642,9 +657,10 @@ class Resources:\n             yellow = colorama.Fore.YELLOW\n             reset = colorama.Style.RESET_ALL\n             logger.warning(\n-                f'{yellow}Request {self} cannot be satisfied by any feasible '\n-                'region. To fix, check that ssh_proxy_command\\'s region keys '\n-                f'include the regions to use.{reset}')\n+                f\"{yellow}Request {self} cannot be satisfied by any feasible \"\n+                \"region. To fix, check that ssh_proxy_command's region keys \"\n+                f\"include the regions to use.{reset}\"\n+            )\n \n         return filtered_regions\n \n@@ -658,8 +674,9 @@ class Resources:\n             if not valid:\n                 with ux_utils.print_exception_no_traceback():\n                     raise ValueError(\n-                        f'Invalid instance type {self._instance_type!r} '\n-                        f'for cloud {self.cloud}.')\n+                        f\"Invalid instance type {self._instance_type!r} \"\n+                        f\"for cloud {self.cloud}.\"\n+                    )\n         else:\n             # If cloud not specified\n             valid_clouds = []\n@@ -669,22 +686,24 @@ class Resources:\n                     valid_clouds.append(cloud)\n             if len(valid_clouds) == 0:\n                 if len(enabled_clouds) == 1:\n-                    cloud_str = f'for cloud {enabled_clouds[0]}'\n+                    cloud_str = f\"for cloud {enabled_clouds[0]}\"\n                 else:\n-                    cloud_str = f'for any cloud among {enabled_clouds}'\n+                    cloud_str = f\"for any cloud among {enabled_clouds}\"\n                 with ux_utils.print_exception_no_traceback():\n                     raise ValueError(\n-                        f'Invalid instance type {self._instance_type!r} '\n-                        f'{cloud_str}.')\n+                        f\"Invalid instance type {self._instance_type!r} \"\n+                        f\"{cloud_str}.\"\n+                    )\n             if len(valid_clouds) > 1:\n                 with ux_utils.print_exception_no_traceback():\n                     raise ValueError(\n-                        f'Ambiguous instance type {self._instance_type!r}. '\n-                        f'Please specify cloud explicitly among {valid_clouds}.'\n+                        f\"Ambiguous instance type {self._instance_type!r}. \"\n+                        f\"Please specify cloud explicitly among {valid_clouds}.\"\n                     )\n             logger.debug(\n-                f'Cloud is not specified, using {valid_clouds[0]} '\n-                f'inferred from the instance_type {self.instance_type!r}.')\n+                f\"Cloud is not specified, using {valid_clouds[0]} \"\n+                f\"inferred from the instance_type {self.instance_type!r}.\"\n+            )\n             self._cloud = valid_clouds[0]\n \n     def _try_validate_cpus_mem(self) -> None:\n@@ -696,36 +715,39 @@ class Resources:\n             # The _try_validate_instance_type() method infers and sets\n             # self.cloud if self.instance_type is not None.\n             assert self.cloud is not None\n-            cpus, mem = self.cloud.get_vcpus_mem_from_instance_type(\n-                self.instance_type)\n+            cpus, mem = self.cloud.get_vcpus_mem_from_instance_type(self.instance_type)\n             if self.cpus is not None:\n-                if self.cpus.endswith('+'):\n+                if self.cpus.endswith(\"+\"):\n                     if cpus < float(self.cpus[:-1]):\n                         with ux_utils.print_exception_no_traceback():\n                             raise ValueError(\n-                                f'{self.instance_type} does not have enough '\n-                                f'vCPUs. {self.instance_type} has {cpus} '\n-                                f'vCPUs, but {self.cpus} is requested.')\n+                                f\"{self.instance_type} does not have enough \"\n+                                f\"vCPUs. {self.instance_type} has {cpus} \"\n+                                f\"vCPUs, but {self.cpus} is requested.\"\n+                            )\n                 elif cpus != float(self.cpus):\n                     with ux_utils.print_exception_no_traceback():\n                         raise ValueError(\n-                            f'{self.instance_type} does not have the requested '\n-                            f'number of vCPUs. {self.instance_type} has {cpus} '\n-                            f'vCPUs, but {self.cpus} is requested.')\n+                            f\"{self.instance_type} does not have the requested \"\n+                            f\"number of vCPUs. {self.instance_type} has {cpus} \"\n+                            f\"vCPUs, but {self.cpus} is requested.\"\n+                        )\n             if self.memory is not None:\n-                if self.memory.endswith('+'):\n+                if self.memory.endswith(\"+\"):\n                     if mem < float(self.memory[:-1]):\n                         with ux_utils.print_exception_no_traceback():\n                             raise ValueError(\n-                                f'{self.instance_type} does not have enough '\n-                                f'memory. {self.instance_type} has {mem} GB '\n-                                f'memory, but {self.memory} is requested.')\n+                                f\"{self.instance_type} does not have enough \"\n+                                f\"memory. {self.instance_type} has {mem} GB \"\n+                                f\"memory, but {self.memory} is requested.\"\n+                            )\n                 elif mem != float(self.memory):\n                     with ux_utils.print_exception_no_traceback():\n                         raise ValueError(\n-                            f'{self.instance_type} does not have the requested '\n-                            f'memory. {self.instance_type} has {mem} GB '\n-                            f'memory, but {self.memory} is requested.')\n+                            f\"{self.instance_type} does not have the requested \"\n+                            f\"memory. {self.instance_type} has {mem} GB \"\n+                            f\"memory, but {self.memory} is requested.\"\n+                        )\n \n     def _try_validate_spot(self) -> None:\n         if self._spot_recovery is None:\n@@ -733,41 +755,46 @@ class Resources:\n         if not self._use_spot:\n             with ux_utils.print_exception_no_traceback():\n                 raise ValueError(\n-                    'Cannot specify spot_recovery without use_spot set to True.'\n+                    \"Cannot specify spot_recovery without use_spot set to True.\"\n                 )\n         if self._spot_recovery not in spot.SPOT_STRATEGIES:\n             with ux_utils.print_exception_no_traceback():\n                 raise ValueError(\n-                    f'Spot recovery strategy {self._spot_recovery} '\n-                    'is not supported. The strategy should be among '\n-                    f'{list(spot.SPOT_STRATEGIES.keys())}')\n+                    f\"Spot recovery strategy {self._spot_recovery} \"\n+                    \"is not supported. The strategy should be among \"\n+                    f\"{list(spot.SPOT_STRATEGIES.keys())}\"\n+                )\n \n     def _try_validate_local(self) -> None:\n         if isinstance(self._cloud, clouds.Local):\n             if self._use_spot:\n                 with ux_utils.print_exception_no_traceback():\n-                    raise ValueError('Local/On-prem mode does not support spot '\n-                                     'instances.')\n+                    raise ValueError(\n+                        \"Local/On-prem mode does not support spot \" \"instances.\"\n+                    )\n             local_instance = clouds.Local.get_default_instance_type()\n-            if (self._instance_type is not None and\n-                    self._instance_type != local_instance):\n+            if (\n+                self._instance_type is not None\n+                and self._instance_type != local_instance\n+            ):\n                 with ux_utils.print_exception_no_traceback():\n                     raise ValueError(\n-                        'Local/On-prem mode does not support instance type:'\n-                        f' {self._instance_type}.')\n+                        \"Local/On-prem mode does not support instance type:\"\n+                        f\" {self._instance_type}.\"\n+                    )\n             if self._image_id is not None:\n                 with ux_utils.print_exception_no_traceback():\n                     raise ValueError(\n-                        'Local/On-prem mode does not support custom '\n-                        'images.')\n+                        \"Local/On-prem mode does not support custom \" \"images.\"\n+                    )\n \n     def extract_docker_image(self) -> Optional[str]:\n         if self.image_id is None:\n             return None\n         if len(self.image_id) == 1 and self.region in self.image_id:\n             image_id = self.image_id[self.region]\n-            if image_id.startswith('docker:'):\n-                return image_id[len('docker:'):]\n+            if image_id.startswith(\"docker:\"):\n+                return image_id[len(\"docker:\") :]\n         return None\n \n     def _try_validate_image_id(self) -> None:\n@@ -778,56 +805,66 @@ class Resources:\n             # TODO(tian): validate the docker image exists / of reasonable size\n             if self.accelerators is not None:\n                 for acc in self.accelerators.keys():\n-                    if acc.lower().startswith('tpu'):\n+                    if acc.lower().startswith(\"tpu\"):\n                         with ux_utils.print_exception_no_traceback():\n                             raise ValueError(\n-                                'Docker image is not supported for TPU VM.')\n+                                \"Docker image is not supported for TPU VM.\"\n+                            )\n             if self.cloud is not None:\n                 self.cloud.check_features_are_supported(\n-                    {clouds.CloudImplementationFeatures.DOCKER_IMAGE})\n+                    {clouds.CloudImplementationFeatures.DOCKER_IMAGE}\n+                )\n             return\n \n         if self.cloud is None:\n             with ux_utils.print_exception_no_traceback():\n-                raise ValueError(\n-                    'Cloud must be specified when image_id is provided.')\n+                raise ValueError(\"Cloud must be specified when image_id is provided.\")\n \n         # Apr, 2023 by Hysun(hysun.he@oracle.com): Added support for OCI\n-        if not self._cloud.is_same_cloud(\n-                clouds.AWS()) and not self._cloud.is_same_cloud(\n-                    clouds.GCP()) and not self._cloud.is_same_cloud(\n-                        clouds.IBM()) and not self._cloud.is_same_cloud(\n-                            clouds.OCI()):\n+        if (\n+            not self._cloud.is_same_cloud(clouds.AWS())\n+            and not self._cloud.is_same_cloud(clouds.GCP())\n+            and not self._cloud.is_same_cloud(clouds.IBM())\n+            and not self._cloud.is_same_cloud(clouds.OCI())\n+        ):\n             with ux_utils.print_exception_no_traceback():\n                 raise ValueError(\n-                    'image_id is only supported for AWS/GCP/IBM/OCI, please '\n-                    'explicitly specify the cloud.')\n+                    \"image_id is only supported for AWS/GCP/IBM/OCI, please \"\n+                    \"explicitly specify the cloud.\"\n+                )\n \n         if self._region is not None:\n             if self._region not in self._image_id:\n                 with ux_utils.print_exception_no_traceback():\n                     raise ValueError(\n-                        f'image_id {self._image_id} should contain the image '\n-                        f'for the specified region {self._region}.')\n+                        f\"image_id {self._image_id} should contain the image \"\n+                        f\"for the specified region {self._region}.\"\n+                    )\n             # Narrow down the image_id to the specified region.\n             self._image_id = {self._region: self._image_id[self._region]}\n \n         # Check the image_id's are valid.\n         for region, image_id in self._image_id.items():\n-            if (image_id.startswith('skypilot:') and\n-                    not self._cloud.is_image_tag_valid(image_id, region)):\n-                region_str = f' ({region})' if region else ''\n+            if image_id.startswith(\"skypilot:\") and not self._cloud.is_image_tag_valid(\n+                image_id, region\n+            ):\n+                region_str = f\" ({region})\" if region else \"\"\n                 with ux_utils.print_exception_no_traceback():\n                     raise ValueError(\n-                        f'Image tag {image_id!r} is not valid, please make sure'\n-                        f' the tag exists in {self._cloud}{region_str}.')\n+                        f\"Image tag {image_id!r} is not valid, please make sure\"\n+                        f\" the tag exists in {self._cloud}{region_str}.\"\n+                    )\n \n-            if (self._cloud.is_same_cloud(clouds.AWS()) and\n-                    not image_id.startswith('skypilot:') and region is None):\n+            if (\n+                self._cloud.is_same_cloud(clouds.AWS())\n+                and not image_id.startswith(\"skypilot:\")\n+                and region is None\n+            ):\n                 with ux_utils.print_exception_no_traceback():\n                     raise ValueError(\n-                        'image_id is only supported for AWS in a specific '\n-                        'region, please explicitly specify the region.')\n+                        \"image_id is only supported for AWS in a specific \"\n+                        \"region, please explicitly specify the region.\"\n+                    )\n \n         # Validate the image exists and the size is smaller than the disk size.\n         for region, image_id in self._image_id.items():\n@@ -836,38 +873,41 @@ class Resources:\n             image_size = self.cloud.get_image_size(image_id, region)\n             if image_size >= self.disk_size:\n                 with ux_utils.print_exception_no_traceback():\n-                    size_comparison = \"larger\" if image_size > self.disk_size else \"equal\"\n+                    size_comparison = (\n+                        \"larger\" if image_size > self.disk_size else \"equal\"\n+                    )\n                     raise ValueError(\n-                        f'Image {image_id!r} is {image_size}GB, which is '\n-                        f'{size_comparison} than the specified disk_size: {self.disk_size}'\n-                        ' GB. Please specify a larger disk_size to use this image.')\n+                        f\"Image {image_id!r} is {image_size}GB, which is \"\n+                        f\"{size_comparison} than the specified disk_size: {self.disk_size}\"\n+                        \" GB. Please specify a larger disk_size to use this image.\"\n+                    )\n \n     def _try_validate_disk_tier(self) -> None:\n         if self.disk_tier is None:\n             return\n-        if self.disk_tier not in ['high', 'medium', 'low']:\n+        if self.disk_tier not in [\"high\", \"medium\", \"low\"]:\n             with ux_utils.print_exception_no_traceback():\n                 raise ValueError(\n-                    f'Invalid disk_tier {self.disk_tier}. '\n-                    'Please use one of \"high\", \"medium\", or \"low\".')\n+                    f\"Invalid disk_tier {self.disk_tier}. \"\n+                    'Please use one of \"high\", \"medium\", or \"low\".'\n+                )\n         if self.instance_type is None:\n             return\n         if self.cloud is not None:\n-            self.cloud.check_disk_tier_enabled(self.instance_type,\n-                                               self.disk_tier)\n+            self.cloud.check_disk_tier_enabled(self.instance_type, self.disk_tier)\n \n     def _try_validate_ports(self) -> None:\n         if self.ports is None:\n             return\n-        if skypilot_config.get_nested(('aws', 'security_group_name'),\n-                                      None) is not None:\n+        if skypilot_config.get_nested((\"aws\", \"security_group_name\"), None) is not None:\n             with ux_utils.print_exception_no_traceback():\n                 raise ValueError(\n-                    'Cannot specify ports when AWS security group name is '\n-                    'specified.')\n+                    \"Cannot specify ports when AWS security group name is \" \"specified.\"\n+                )\n         if self.cloud is not None:\n             self.cloud.check_features_are_supported(\n-                {clouds.CloudImplementationFeatures.OPEN_PORTS})\n+                {clouds.CloudImplementationFeatures.OPEN_PORTS}\n+            )\n         # We don't need to check the ports format since we already done it\n         # in resources_utils.simplify_ports\n \n@@ -876,16 +916,21 @@ class Resources:\n         hours = seconds / 3600\n         # Instance.\n         hourly_cost = self.cloud.instance_type_to_hourly_cost(\n-            self._instance_type, self.use_spot, self._region, self._zone)\n+            self._instance_type, self.use_spot, self._region, self._zone\n+        )\n         # Accelerators (if any).\n         if self.accelerators is not None:\n             hourly_cost += self.cloud.accelerators_to_hourly_cost(\n-                self.accelerators, self.use_spot, self._region, self._zone)\n+                self.accelerators, self.use_spot, self._region, self._zone\n+            )\n         return hourly_cost * hours\n \n     def make_deploy_variables(\n-            self, cluster_name_on_cloud: str, region: clouds.Region,\n-            zones: Optional[List[clouds.Zone]]) -> Dict[str, Optional[str]]:\n+        self,\n+        cluster_name_on_cloud: str,\n+        region: clouds.Region,\n+        zones: Optional[List[clouds.Zone]],\n+    ) -> Dict[str, Optional[str]]:\n         \"\"\"Converts planned sky.Resources to resource variables.\n \n         These variables are divided into two categories: cloud-specific and\n@@ -894,7 +939,8 @@ class Resources:\n         variables are generated by this method.\n         \"\"\"\n         cloud_specific_variables = self.cloud.make_deploy_resources_variables(\n-            self, cluster_name_on_cloud, region, zones)\n+            self, cluster_name_on_cloud, region, zones\n+        )\n         docker_image = self.extract_docker_image()\n         return dict(\n             cloud_specific_variables,\n@@ -902,18 +948,19 @@ class Resources:\n                 # Docker config\n                 # Docker image. The image name used to pull the image, e.g.\n                 # ubuntu:latest.\n-                'docker_image': docker_image,\n+                \"docker_image\": docker_image,\n                 # Docker container name. The name of the container. Default to\n                 # `sky_container`.\n-                'docker_container_name':\n-                    constants.DEFAULT_DOCKER_CONTAINER_NAME,\n+                \"docker_container_name\": constants.DEFAULT_DOCKER_CONTAINER_NAME,\n                 # Docker login config (if any). This helps pull the image from\n                 # private registries.\n-                'docker_login_config': self._docker_login_config\n-            })\n+                \"docker_login_config\": self._docker_login_config,\n+            },\n+        )\n \n     def get_reservations_available_resources(\n-            self, specific_reservations: Set[str]) -> Dict[str, int]:\n+        self, specific_reservations: Set[str]\n+    ) -> Dict[str, int]:\n         \"\"\"Returns the number of available reservation resources.\"\"\"\n         if self.use_spot:\n             # GCP's & AWS's reservations do not support spot instances. We\n@@ -921,12 +968,12 @@ class Resources:\n             # to each cloud if any cloud supports reservations for spot.\n             return {}\n         return self.cloud.get_reservations_available_resources(\n-            self._instance_type, self._region, self._zone,\n-            specific_reservations)\n+            self._instance_type, self._region, self._zone, specific_reservations\n+        )\n \n     def less_demanding_than(\n         self,\n-        other: Union[List['Resources'], 'Resources'],\n+        other: Union[List[\"Resources\"], \"Resources\"],\n         requested_num_nodes: int = 1,\n         check_ports: bool = False,\n     ) -> bool:\n@@ -962,15 +1009,17 @@ class Resources:\n                 if not self.image_id.items() <= other.image_id.items():\n                     return False\n             else:\n-                this_image = (self.image_id.get(other.region) or\n-                              self.image_id.get(None))\n-                other_image = (other.image_id.get(other.region) or\n-                               other.image_id.get(None))\n+                this_image = self.image_id.get(other.region) or self.image_id.get(None)\n+                other_image = other.image_id.get(other.region) or other.image_id.get(\n+                    None\n+                )\n                 if this_image != other_image:\n                     return False\n \n-        if (self._instance_type is not None and\n-                self._instance_type != other.instance_type):\n+        if (\n+            self._instance_type is not None\n+            and self._instance_type != other.instance_type\n+        ):\n             return False\n         # self._instance_type <= other.instance_type\n \n@@ -985,8 +1034,10 @@ class Resources:\n                     return False\n         # self.accelerators <= other.accelerators\n \n-        if (self.accelerator_args is not None and\n-                self.accelerator_args != other.accelerator_args):\n+        if (\n+            self.accelerator_args is not None\n+            and self.accelerator_args != other.accelerator_args\n+        ):\n             return False\n         # self.accelerator_args == other.accelerator_args\n \n@@ -997,9 +1048,8 @@ class Resources:\n             if other.disk_tier is None:\n                 return False\n             if self.disk_tier != other.disk_tier:\n-                types = ['low', 'medium', 'high']\n-                return types.index(self.disk_tier) < types.index(\n-                    other.disk_tier)\n+                types = [\"low\", \"medium\", \"high\"]\n+                return types.index(self.disk_tier) < types.index(other.disk_tier)\n \n         if check_ports:\n             if self.ports is not None:\n@@ -1013,68 +1063,72 @@ class Resources:\n         # self <= other\n         return True\n \n-    def should_be_blocked_by(self, blocked: 'Resources') -> bool:\n+    def should_be_blocked_by(self, blocked: \"Resources\") -> bool:\n         \"\"\"Whether this Resources matches the blocked Resources.\n \n         If a field in `blocked` is None, it should be considered as a wildcard\n         for that field.\n         \"\"\"\n         is_matched = True\n-        if (blocked.cloud is not None and\n-                not self.cloud.is_same_cloud(blocked.cloud)):\n+        if blocked.cloud is not None and not self.cloud.is_same_cloud(blocked.cloud):\n             is_matched = False\n-        if (blocked.instance_type is not None and\n-                self.instance_type != blocked.instance_type):\n+        if (\n+            blocked.instance_type is not None\n+            and self.instance_type != blocked.instance_type\n+        ):\n             is_matched = False\n         if blocked.region is not None and self._region != blocked.region:\n             is_matched = False\n         if blocked.zone is not None and self._zone != blocked.zone:\n             is_matched = False\n-        if (blocked.accelerators is not None and\n-                self.accelerators != blocked.accelerators):\n+        if (\n+            blocked.accelerators is not None\n+            and self.accelerators != blocked.accelerators\n+        ):\n             is_matched = False\n         return is_matched\n \n     def is_empty(self) -> bool:\n         \"\"\"Is this Resources an empty request (all fields None)?\"\"\"\n-        return all([\n-            self.cloud is None,\n-            self._instance_type is None,\n-            self.cpus is None,\n-            self.memory is None,\n-            self.accelerators is None,\n-            self.accelerator_args is None,\n-            not self._use_spot_specified,\n-            self.disk_size == _DEFAULT_DISK_SIZE_GB,\n-            self.disk_tier is None,\n-            self._image_id is None,\n-            self.ports is None,\n-            self._docker_login_config is None,\n-        ])\n-\n-    def copy(self, **override) -> 'Resources':\n+        return all(\n+            [\n+                self.cloud is None,\n+                self._instance_type is None,\n+                self.cpus is None,\n+                self.memory is None,\n+                self.accelerators is None,\n+                self.accelerator_args is None,\n+                not self._use_spot_specified,\n+                self.disk_size == _DEFAULT_DISK_SIZE_GB,\n+                self.disk_tier is None,\n+                self._image_id is None,\n+                self.ports is None,\n+                self._docker_login_config is None,\n+            ]\n+        )\n+\n+    def copy(self, **override) -> \"Resources\":\n         \"\"\"Returns a copy of the given Resources.\"\"\"\n         use_spot = self.use_spot if self._use_spot_specified else None\n         resources = Resources(\n-            cloud=override.pop('cloud', self.cloud),\n-            instance_type=override.pop('instance_type', self.instance_type),\n-            cpus=override.pop('cpus', self.cpus),\n-            memory=override.pop('memory', self.memory),\n-            accelerators=override.pop('accelerators', self.accelerators),\n-            accelerator_args=override.pop('accelerator_args',\n-                                          self.accelerator_args),\n-            use_spot=override.pop('use_spot', use_spot),\n-            spot_recovery=override.pop('spot_recovery', self.spot_recovery),\n-            disk_size=override.pop('disk_size', self.disk_size),\n-            region=override.pop('region', self.region),\n-            zone=override.pop('zone', self.zone),\n-            image_id=override.pop('image_id', self.image_id),\n-            disk_tier=override.pop('disk_tier', self.disk_tier),\n-            ports=override.pop('ports', self.ports),\n-            _docker_login_config=override.pop('_docker_login_config',\n-                                              self._docker_login_config),\n-            _is_image_managed=override.pop('_is_image_managed',\n-                                           self._is_image_managed),\n+            cloud=override.pop(\"cloud\", self.cloud),\n+            instance_type=override.pop(\"instance_type\", self.instance_type),\n+            cpus=override.pop(\"cpus\", self.cpus),\n+            memory=override.pop(\"memory\", self.memory),\n+            accelerators=override.pop(\"accelerators\", self.accelerators),\n+            accelerator_args=override.pop(\"accelerator_args\", self.accelerator_args),\n+            use_spot=override.pop(\"use_spot\", use_spot),\n+            spot_recovery=override.pop(\"spot_recovery\", self.spot_recovery),\n+            disk_size=override.pop(\"disk_size\", self.disk_size),\n+            region=override.pop(\"region\", self.region),\n+            zone=override.pop(\"zone\", self.zone),\n+            image_id=override.pop(\"image_id\", self.image_id),\n+            disk_tier=override.pop(\"disk_tier\", self.disk_tier),\n+            ports=override.pop(\"ports\", self.ports),\n+            _docker_login_config=override.pop(\n+                \"_docker_login_config\", self._docker_login_config\n+            ),\n+            _is_image_managed=override.pop(\"_is_image_managed\", self._is_image_managed),\n         )\n         assert len(override) == 0\n         return resources\n@@ -1090,8 +1144,7 @@ class Resources:\n                 return False\n         return True\n \n-    def get_required_cloud_features(\n-            self) -> Set[clouds.CloudImplementationFeatures]:\n+    def get_required_cloud_features(self) -> Set[clouds.CloudImplementationFeatures]:\n         \"\"\"Returns the set of cloud features required by this Resources.\"\"\"\n         features = set()\n         if self.use_spot:\n@@ -1105,46 +1158,48 @@ class Resources:\n         return features\n \n     @classmethod\n-    def from_yaml_config(cls, config: Optional[Dict[str, str]]) -> 'Resources':\n+    def from_yaml_config(cls, config: Optional[Dict[str, str]]) -> \"Resources\":\n         if config is None:\n             return Resources()\n \n-        common_utils.validate_schema(config, schemas.get_resources_schema(),\n-                                     'Invalid resources YAML: ')\n+        common_utils.validate_schema(\n+            config, schemas.get_resources_schema(), \"Invalid resources YAML: \"\n+        )\n \n         resources_fields = {}\n-        resources_fields['cloud'] = clouds.CLOUD_REGISTRY.from_str(\n-            config.pop('cloud', None))\n-        resources_fields['instance_type'] = config.pop('instance_type', None)\n-        resources_fields['cpus'] = config.pop('cpus', None)\n-        resources_fields['memory'] = config.pop('memory', None)\n-        resources_fields['accelerators'] = config.pop('accelerators', None)\n-        resources_fields['accelerator_args'] = config.pop(\n-            'accelerator_args', None)\n-        resources_fields['use_spot'] = config.pop('use_spot', None)\n-        resources_fields['spot_recovery'] = config.pop('spot_recovery', None)\n-        resources_fields['disk_size'] = config.pop('disk_size', None)\n-        resources_fields['region'] = config.pop('region', None)\n-        resources_fields['zone'] = config.pop('zone', None)\n-        resources_fields['image_id'] = config.pop('image_id', None)\n-        resources_fields['disk_tier'] = config.pop('disk_tier', None)\n-        resources_fields['ports'] = config.pop('ports', None)\n-        resources_fields['_docker_login_config'] = config.pop(\n-            '_docker_login_config', None)\n-        resources_fields['_is_image_managed'] = config.pop(\n-            '_is_image_managed', None)\n-\n-        if resources_fields['cpus'] is not None:\n-            resources_fields['cpus'] = str(resources_fields['cpus'])\n-        if resources_fields['memory'] is not None:\n-            resources_fields['memory'] = str(resources_fields['memory'])\n-        if resources_fields['accelerator_args'] is not None:\n-            resources_fields['accelerator_args'] = dict(\n-                resources_fields['accelerator_args'])\n-        if resources_fields['disk_size'] is not None:\n-            resources_fields['disk_size'] = int(resources_fields['disk_size'])\n-\n-        assert not config, f'Invalid resource args: {config.keys()}'\n+        resources_fields[\"cloud\"] = clouds.CLOUD_REGISTRY.from_str(\n+            config.pop(\"cloud\", None)\n+        )\n+        resources_fields[\"instance_type\"] = config.pop(\"instance_type\", None)\n+        resources_fields[\"cpus\"] = config.pop(\"cpus\", None)\n+        resources_fields[\"memory\"] = config.pop(\"memory\", None)\n+        resources_fields[\"accelerators\"] = config.pop(\"accelerators\", None)\n+        resources_fields[\"accelerator_args\"] = config.pop(\"accelerator_args\", None)\n+        resources_fields[\"use_spot\"] = config.pop(\"use_spot\", None)\n+        resources_fields[\"spot_recovery\"] = config.pop(\"spot_recovery\", None)\n+        resources_fields[\"disk_size\"] = config.pop(\"disk_size\", None)\n+        resources_fields[\"region\"] = config.pop(\"region\", None)\n+        resources_fields[\"zone\"] = config.pop(\"zone\", None)\n+        resources_fields[\"image_id\"] = config.pop(\"image_id\", None)\n+        resources_fields[\"disk_tier\"] = config.pop(\"disk_tier\", None)\n+        resources_fields[\"ports\"] = config.pop(\"ports\", None)\n+        resources_fields[\"_docker_login_config\"] = config.pop(\n+            \"_docker_login_config\", None\n+        )\n+        resources_fields[\"_is_image_managed\"] = config.pop(\"_is_image_managed\", None)\n+\n+        if resources_fields[\"cpus\"] is not None:\n+            resources_fields[\"cpus\"] = str(resources_fields[\"cpus\"])\n+        if resources_fields[\"memory\"] is not None:\n+            resources_fields[\"memory\"] = str(resources_fields[\"memory\"])\n+        if resources_fields[\"accelerator_args\"] is not None:\n+            resources_fields[\"accelerator_args\"] = dict(\n+                resources_fields[\"accelerator_args\"]\n+            )\n+        if resources_fields[\"disk_size\"] is not None:\n+            resources_fields[\"disk_size\"] = int(resources_fields[\"disk_size\"])\n+\n+        assert not config, f\"Invalid resource args: {config.keys()}\"\n         return Resources(**resources_fields)\n \n     def to_yaml_config(self) -> Dict[str, Union[str, int]]:\n@@ -1152,28 +1207,28 @@ class Resources:\n         config = {}\n \n         def add_if_not_none(key, value):\n-            if value is not None and value != 'None':\n+            if value is not None and value != \"None\":\n                 config[key] = value\n \n-        add_if_not_none('cloud', str(self.cloud))\n-        add_if_not_none('instance_type', self.instance_type)\n-        add_if_not_none('cpus', self.cpus)\n-        add_if_not_none('memory', self.memory)\n-        add_if_not_none('accelerators', self.accelerators)\n-        add_if_not_none('accelerator_args', self.accelerator_args)\n+        add_if_not_none(\"cloud\", str(self.cloud))\n+        add_if_not_none(\"instance_type\", self.instance_type)\n+        add_if_not_none(\"cpus\", self.cpus)\n+        add_if_not_none(\"memory\", self.memory)\n+        add_if_not_none(\"accelerators\", self.accelerators)\n+        add_if_not_none(\"accelerator_args\", self.accelerator_args)\n \n         if self._use_spot_specified:\n-            add_if_not_none('use_spot', self.use_spot)\n-        config['spot_recovery'] = self.spot_recovery\n-        config['disk_size'] = self.disk_size\n-        add_if_not_none('region', self.region)\n-        add_if_not_none('zone', self.zone)\n-        add_if_not_none('image_id', self.image_id)\n-        add_if_not_none('disk_tier', self.disk_tier)\n-        add_if_not_none('ports', self.ports)\n-        add_if_not_none('_docker_login_config', self._docker_login_config)\n+            add_if_not_none(\"use_spot\", self.use_spot)\n+        config[\"spot_recovery\"] = self.spot_recovery\n+        config[\"disk_size\"] = self.disk_size\n+        add_if_not_none(\"region\", self.region)\n+        add_if_not_none(\"zone\", self.zone)\n+        add_if_not_none(\"image_id\", self.image_id)\n+        add_if_not_none(\"disk_tier\", self.disk_tier)\n+        add_if_not_none(\"ports\", self.ports)\n+        add_if_not_none(\"_docker_login_config\", self._docker_login_config)\n         if self._is_image_managed is not None:\n-            config['_is_image_managed'] = self._is_image_managed\n+            config[\"_is_image_managed\"] = self._is_image_managed\n         return config\n \n     def __setstate__(self, state):\n@@ -1182,25 +1237,25 @@ class Resources:\n \n         # TODO (zhwu): Design our persistent state format with `__getstate__`,\n         # so that to get rid of the version tracking.\n-        version = state.pop('_version', None)\n+        version = state.pop(\"_version\", None)\n         # Handle old version(s) here.\n         if version is None:\n             version = -1\n         if version < 0:\n-            cloud = state.pop('cloud', None)\n-            state['_cloud'] = cloud\n+            cloud = state.pop(\"cloud\", None)\n+            state[\"_cloud\"] = cloud\n \n-            instance_type = state.pop('instance_type', None)\n-            state['_instance_type'] = instance_type\n+            instance_type = state.pop(\"instance_type\", None)\n+            state[\"_instance_type\"] = instance_type\n \n-            use_spot = state.pop('use_spot', False)\n-            state['_use_spot'] = use_spot\n+            use_spot = state.pop(\"use_spot\", False)\n+            state[\"_use_spot\"] = use_spot\n \n-            accelerator_args = state.pop('accelerator_args', None)\n-            state['_accelerator_args'] = accelerator_args\n+            accelerator_args = state.pop(\"accelerator_args\", None)\n+            state[\"_accelerator_args\"] = accelerator_args\n \n-            disk_size = state.pop('disk_size', _DEFAULT_DISK_SIZE_GB)\n-            state['_disk_size'] = disk_size\n+            disk_size = state.pop(\"disk_size\", _DEFAULT_DISK_SIZE_GB)\n+            state[\"_disk_size\"] = disk_size\n \n         if version < 2:\n             self._region = None\n@@ -1215,13 +1270,13 @@ class Resources:\n             self._zone = None\n \n         if version < 6:\n-            accelerators = state.pop('_accelerators', None)\n+            accelerators = state.pop(\"_accelerators\", None)\n             if accelerators is not None:\n                 accelerators = {\n-                    accelerator_registry.canonicalize_accelerator_name(acc):\n-                    acc_count for acc, acc_count in accelerators.items()\n+                    accelerator_registry.canonicalize_accelerator_name(acc): acc_count\n+                    for acc, acc_count in accelerators.items()\n                 }\n-            state['_accelerators'] = accelerators\n+            state[\"_accelerators\"] = accelerators\n \n         if version < 7:\n             self._cpus = None\n@@ -1229,9 +1284,9 @@ class Resources:\n         if version < 8:\n             self._memory = None\n \n-        image_id = state.get('_image_id', None)\n+        image_id = state.get(\"_image_id\", None)\n         if isinstance(image_id, str):\n-            state['_image_id'] = {state.get('_region', None): image_id}\n+            state[\"_image_id\"] = {state.get(\"_region\", None): image_id}\n \n         if version < 9:\n             self._disk_tier = None\n@@ -1246,9 +1301,10 @@ class Resources:\n             self._docker_login_config = None\n \n         if version < 13:\n-            original_ports = state.get('_ports', None)\n+            original_ports = state.get(\"_ports\", None)\n             if original_ports is not None:\n-                state['_ports'] = resources_utils.simplify_ports(\n-                    [str(port) for port in original_ports])\n+                state[\"_ports\"] = resources_utils.simplify_ports(\n+                    [str(port) for port in original_ports]\n+                )\n \n         self.__dict__.update(state)\n"
        }
    ]
}
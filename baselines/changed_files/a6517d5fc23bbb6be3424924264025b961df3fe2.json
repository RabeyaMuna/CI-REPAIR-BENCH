{
    "sha_fail": "a6517d5fc23bbb6be3424924264025b961df3fe2",
    "changed_files": [
        {
            "commit": "a6517d5fc23bbb6be3424924264025b961df3fe2",
            "file_path": "framework/py/flwr/client/__init__.py",
            "diff": "diff --git a/framework/py/flwr/client/__init__.py b/framework/py/flwr/client/__init__.py\nindex 77aa77284..888302056 100644\n--- a/framework/py/flwr/client/__init__.py\n+++ b/framework/py/flwr/client/__init__.py\n@@ -15,8 +15,8 @@\n \"\"\"Flower client.\"\"\"\n \n \n-from .app import start_client as start_client\n-from .app import start_numpy_client as start_numpy_client\n+from ..compat.client.app import start_client as start_client  # Deprecated\n+from ..compat.client.app import start_numpy_client as start_numpy_client  # Deprecated\n from .client import Client as Client\n from .client_app import ClientApp as ClientApp\n from .numpy_client import NumPyClient as NumPyClient\n"
        },
        {
            "commit": "a6517d5fc23bbb6be3424924264025b961df3fe2",
            "file_path": "framework/py/flwr/client/start_client_internal.py",
            "diff": "diff --git a/framework/py/flwr/client/start_client_internal.py b/framework/py/flwr/client/start_client_internal.py\nnew file mode 100644\nindex 000000000..0c2594de8\n--- /dev/null\n+++ b/framework/py/flwr/client/start_client_internal.py\n@@ -0,0 +1,607 @@\n+# Copyright 2025 Flower Labs GmbH. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+\"\"\"Flower client app.\"\"\"\n+\n+\n+import multiprocessing\n+import os\n+import sys\n+import threading\n+import time\n+from contextlib import AbstractContextManager\n+from logging import ERROR, INFO, WARN\n+from os import urandom\n+from pathlib import Path\n+from typing import Callable, Optional, Union, cast\n+\n+import grpc\n+from cryptography.hazmat.primitives.asymmetric import ec\n+from grpc import RpcError\n+\n+from flwr.app.error import Error\n+from flwr.cli.config_utils import get_fab_metadata\n+from flwr.cli.install import install_from_fab\n+from flwr.client.client import Client\n+from flwr.client.client_app import ClientApp, LoadClientAppError\n+from flwr.client.clientapp.app import flwr_clientapp\n+from flwr.client.clientapp.clientappio_servicer import (\n+    ClientAppInputs,\n+    ClientAppIoServicer,\n+)\n+from flwr.client.grpc_adapter_client.connection import grpc_adapter\n+from flwr.client.grpc_client.connection import grpc_connection\n+from flwr.client.grpc_rere_client.connection import grpc_request_response\n+from flwr.client.message_handler.message_handler import handle_control_message\n+from flwr.client.nodestate.nodestate_factory import NodeStateFactory\n+from flwr.client.run_info_store import DeprecatedRunInfoStore\n+from flwr.client.typing import ClientFnExt\n+from flwr.common import GRPC_MAX_MESSAGE_LENGTH, Context, Message\n+from flwr.common.address import parse_address\n+from flwr.common.constant import (\n+    CLIENT_OCTET,\n+    CLIENTAPPIO_API_DEFAULT_SERVER_ADDRESS,\n+    ISOLATION_MODE_PROCESS,\n+    ISOLATION_MODE_SUBPROCESS,\n+    MAX_RETRY_DELAY,\n+    RUN_ID_NUM_BYTES,\n+    SERVER_OCTET,\n+    TRANSPORT_TYPE_GRPC_ADAPTER,\n+    TRANSPORT_TYPE_GRPC_BIDI,\n+    TRANSPORT_TYPE_GRPC_RERE,\n+    TRANSPORT_TYPE_REST,\n+    TRANSPORT_TYPES,\n+    ErrorCode,\n+)\n+from flwr.common.exit import ExitCode, flwr_exit\n+from flwr.common.grpc import generic_create_grpc_server\n+from flwr.common.logger import log\n+from flwr.common.retry_invoker import RetryInvoker, RetryState, exponential\n+from flwr.common.typing import Fab, Run, RunNotRunningException, UserConfig\n+from flwr.proto.clientappio_pb2_grpc import add_ClientAppIoServicer_to_server\n+\n+\n+def _check_actionable_client(\n+    client: Optional[Client], client_fn: Optional[ClientFnExt]\n+) -> None:\n+    if client_fn is None and client is None:\n+        raise ValueError(\n+            \"Both `client_fn` and `client` are `None`, but one is required\"\n+        )\n+\n+    if client_fn is not None and client is not None:\n+        raise ValueError(\n+            \"Both `client_fn` and `client` are provided, but only one is allowed\"\n+        )\n+\n+\n+# pylint: disable=import-outside-toplevel\n+# pylint: disable=too-many-branches\n+# pylint: disable=too-many-locals\n+# pylint: disable=too-many-statements\n+def start_client_internal(\n+    *,\n+    server_address: str,\n+    node_config: UserConfig,\n+    load_client_app_fn: Optional[Callable[[str, str, str], ClientApp]] = None,\n+    client_fn: Optional[ClientFnExt] = None,\n+    client: Optional[Client] = None,\n+    grpc_max_message_length: int = GRPC_MAX_MESSAGE_LENGTH,\n+    root_certificates: Optional[Union[bytes, str]] = None,\n+    insecure: Optional[bool] = None,\n+    transport: Optional[str] = None,\n+    authentication_keys: Optional[\n+        tuple[ec.EllipticCurvePrivateKey, ec.EllipticCurvePublicKey]\n+    ] = None,\n+    max_retries: Optional[int] = None,\n+    max_wait_time: Optional[float] = None,\n+    flwr_path: Optional[Path] = None,\n+    isolation: Optional[str] = None,\n+    clientappio_api_address: Optional[str] = CLIENTAPPIO_API_DEFAULT_SERVER_ADDRESS,\n+) -> None:\n+    \"\"\"Start a Flower client node which connects to a Flower server.\n+\n+    Parameters\n+    ----------\n+    server_address : str\n+        The IPv4 or IPv6 address of the server. If the Flower\n+        server runs on the same machine on port 8080, then `server_address`\n+        would be `\"[::]:8080\"`.\n+    node_config: UserConfig\n+        The configuration of the node.\n+    load_client_app_fn : Optional[Callable[[], ClientApp]] (default: None)\n+        A function that can be used to load a `ClientApp` instance.\n+    client_fn : Optional[ClientFnExt]\n+        A callable that instantiates a Client. (default: None)\n+    client : Optional[flwr.client.Client]\n+        An implementation of the abstract base\n+        class `flwr.client.Client` (default: None)\n+    grpc_max_message_length : int (default: 536_870_912, this equals 512MB)\n+        The maximum length of gRPC messages that can be exchanged with the\n+        Flower server. The default should be sufficient for most models.\n+        Users who train very large models might need to increase this\n+        value. Note that the Flower server needs to be started with the\n+        same value (see `flwr.server.start_server`), otherwise it will not\n+        know about the increased limit and block larger messages.\n+    root_certificates : Optional[Union[bytes, str]] (default: None)\n+        The PEM-encoded root certificates as a byte string or a path string.\n+        If provided, a secure connection using the certificates will be\n+        established to an SSL-enabled Flower server.\n+    insecure : Optional[bool] (default: None)\n+        Starts an insecure gRPC connection when True. Enables HTTPS connection\n+        when False, using system certificates if `root_certificates` is None.\n+    transport : Optional[str] (default: None)\n+        Configure the transport layer. Allowed values:\n+        - 'grpc-bidi': gRPC, bidirectional streaming\n+        - 'grpc-rere': gRPC, request-response (experimental)\n+        - 'rest': HTTP (experimental)\n+    authentication_keys : Optional[Tuple[PrivateKey, PublicKey]] (default: None)\n+        Tuple containing the elliptic curve private key and public key for\n+        authentication from the cryptography library.\n+        Source: https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/\n+        Used to establish an authenticated connection with the server.\n+    max_retries: Optional[int] (default: None)\n+        The maximum number of times the client will try to connect to the\n+        server before giving up in case of a connection error. If set to None,\n+        there is no limit to the number of tries.\n+    max_wait_time: Optional[float] (default: None)\n+        The maximum duration before the client stops trying to\n+        connect to the server in case of connection error.\n+        If set to None, there is no limit to the total time.\n+    flwr_path: Optional[Path] (default: None)\n+        The fully resolved path containing installed Flower Apps.\n+    isolation : Optional[str] (default: None)\n+        Isolation mode for `ClientApp`. Possible values are `subprocess` and\n+        `process`. Defaults to `None`, which runs the `ClientApp` in the same process\n+        as the SuperNode. If `subprocess`, the `ClientApp` runs in a subprocess started\n+        by the SueprNode and communicates using gRPC at the address\n+        `clientappio_api_address`. If `process`, the `ClientApp` runs in a separate\n+        isolated process and communicates using gRPC at the address\n+        `clientappio_api_address`.\n+    clientappio_api_address : Optional[str]\n+        (default: `CLIENTAPPIO_API_DEFAULT_SERVER_ADDRESS`)\n+        The SuperNode gRPC server address.\n+    \"\"\"\n+    if insecure is None:\n+        insecure = root_certificates is None\n+\n+    if load_client_app_fn is None:\n+        _check_actionable_client(client, client_fn)\n+\n+        if client_fn is None:\n+            # Wrap `Client` instance in `client_fn`\n+            def single_client_factory(\n+                context: Context,  # pylint: disable=unused-argument\n+            ) -> Client:\n+                if client is None:  # Added this to keep mypy happy\n+                    raise ValueError(\n+                        \"Both `client_fn` and `client` are `None`, but one is required\"\n+                    )\n+                return client  # Always return the same instance\n+\n+            client_fn = single_client_factory\n+\n+        def _load_client_app(_1: str, _2: str, _3: str) -> ClientApp:\n+            return ClientApp(client_fn=client_fn)\n+\n+        load_client_app_fn = _load_client_app\n+\n+    if isolation:\n+        if clientappio_api_address is None:\n+            raise ValueError(\n+                f\"`clientappio_api_address` required when `isolation` is \"\n+                f\"{ISOLATION_MODE_SUBPROCESS} or {ISOLATION_MODE_PROCESS}\",\n+            )\n+        _clientappio_grpc_server, clientappio_servicer = run_clientappio_api_grpc(\n+            address=clientappio_api_address,\n+            certificates=None,\n+        )\n+    clientappio_api_address = cast(str, clientappio_api_address)\n+\n+    # At this point, only `load_client_app_fn` should be used\n+    # Both `client` and `client_fn` must not be used directly\n+\n+    # Initialize connection context manager\n+    connection, address, connection_error_type = _init_connection(\n+        transport, server_address\n+    )\n+\n+    def _on_sucess(retry_state: RetryState) -> None:\n+        if retry_state.tries > 1:\n+            log(\n+                INFO,\n+                \"Connection successful after %.2f seconds and %s tries.\",\n+                retry_state.elapsed_time,\n+                retry_state.tries,\n+            )\n+\n+    def _on_backoff(retry_state: RetryState) -> None:\n+        if retry_state.tries == 1:\n+            log(WARN, \"Connection attempt failed, retrying...\")\n+        else:\n+            log(\n+                WARN,\n+                \"Connection attempt failed, retrying in %.2f seconds\",\n+                retry_state.actual_wait,\n+            )\n+\n+    retry_invoker = RetryInvoker(\n+        wait_gen_factory=lambda: exponential(max_delay=MAX_RETRY_DELAY),\n+        recoverable_exceptions=connection_error_type,\n+        max_tries=max_retries + 1 if max_retries is not None else None,\n+        max_time=max_wait_time,\n+        on_giveup=lambda retry_state: (\n+            log(\n+                WARN,\n+                \"Giving up reconnection after %.2f seconds and %s tries.\",\n+                retry_state.elapsed_time,\n+                retry_state.tries,\n+            )\n+            if retry_state.tries > 1\n+            else None\n+        ),\n+        on_success=_on_sucess,\n+        on_backoff=_on_backoff,\n+    )\n+\n+    # DeprecatedRunInfoStore gets initialized when the first connection is established\n+    run_info_store: Optional[DeprecatedRunInfoStore] = None\n+    state_factory = NodeStateFactory()\n+    state = state_factory.state()\n+    mp_spawn_context = multiprocessing.get_context(\"spawn\")\n+\n+    runs: dict[int, Run] = {}\n+\n+    while True:\n+        sleep_duration: int = 0\n+        with connection(\n+            address,\n+            insecure,\n+            retry_invoker,\n+            grpc_max_message_length,\n+            root_certificates,\n+            authentication_keys,\n+        ) as conn:\n+            receive, send, create_node, delete_node, get_run, get_fab = conn\n+\n+            # Register node when connecting the first time\n+            if run_info_store is None:\n+                if create_node is None:\n+                    if transport not in [\"grpc-bidi\", None]:\n+                        raise NotImplementedError(\n+                            \"All transports except `grpc-bidi` require \"\n+                            \"an implementation for `create_node()`.'\"\n+                        )\n+                    # gRPC-bidi doesn't have the concept of node_id,\n+                    # so we set it to -1\n+                    run_info_store = DeprecatedRunInfoStore(\n+                        node_id=-1,\n+                        node_config={},\n+                    )\n+                else:\n+                    # Call create_node fn to register node\n+                    # and store node_id in state\n+                    if (node_id := create_node()) is None:\n+                        raise ValueError(\n+                            \"Failed to register SuperNode with the SuperLink\"\n+                        )\n+                    state.set_node_id(node_id)\n+                    run_info_store = DeprecatedRunInfoStore(\n+                        node_id=state.get_node_id(),\n+                        node_config=node_config,\n+                    )\n+\n+            # pylint: disable=too-many-nested-blocks\n+            while True:\n+                try:\n+                    # Receive\n+                    message = receive()\n+                    if message is None:\n+                        time.sleep(3)  # Wait for 3s before asking again\n+                        continue\n+\n+                    log(INFO, \"\")\n+                    if len(message.metadata.group_id) > 0:\n+                        log(\n+                            INFO,\n+                            \"[RUN %s, ROUND %s]\",\n+                            message.metadata.run_id,\n+                            message.metadata.group_id,\n+                        )\n+                    log(\n+                        INFO,\n+                        \"Received: %s message %s\",\n+                        message.metadata.message_type,\n+                        message.metadata.message_id,\n+                    )\n+\n+                    # Handle control message\n+                    out_message, sleep_duration = handle_control_message(message)\n+                    if out_message:\n+                        send(out_message)\n+                        break\n+\n+                    # Get run info\n+                    run_id = message.metadata.run_id\n+                    if run_id not in runs:\n+                        if get_run is not None:\n+                            runs[run_id] = get_run(run_id)\n+                        # If get_run is None, i.e., in grpc-bidi mode\n+                        else:\n+                            runs[run_id] = Run.create_empty(run_id=run_id)\n+\n+                    run: Run = runs[run_id]\n+                    if get_fab is not None and run.fab_hash:\n+                        fab = get_fab(run.fab_hash, run_id)\n+                        if not isolation:\n+                            # If `ClientApp` runs in the same process, install the FAB\n+                            install_from_fab(fab.content, flwr_path, True)\n+                        fab_id, fab_version = get_fab_metadata(fab.content)\n+                    else:\n+                        fab = None\n+                        fab_id, fab_version = run.fab_id, run.fab_version\n+\n+                    run.fab_id, run.fab_version = fab_id, fab_version\n+\n+                    # Register context for this run\n+                    run_info_store.register_context(\n+                        run_id=run_id,\n+                        run=run,\n+                        flwr_path=flwr_path,\n+                        fab=fab,\n+                    )\n+\n+                    # Retrieve context for this run\n+                    context = run_info_store.retrieve_context(run_id=run_id)\n+                    # Create an error reply message that will never be used to prevent\n+                    # the used-before-assignment linting error\n+                    reply_message = Message(\n+                        Error(code=ErrorCode.UNKNOWN, reason=\"Unknown\"),\n+                        reply_to=message,\n+                    )\n+\n+                    # Handle app loading and task message\n+                    try:\n+                        if isolation:\n+                            # Two isolation modes:\n+                            # 1. `subprocess`: SuperNode is starting the ClientApp\n+                            #    process as a subprocess.\n+                            # 2. `process`: ClientApp process gets started separately\n+                            #    (via `flwr-clientapp`), for example, in a separate\n+                            #    Docker container.\n+\n+                            # Generate SuperNode token\n+                            token = int.from_bytes(urandom(RUN_ID_NUM_BYTES), \"little\")\n+\n+                            # Mode 1: SuperNode starts ClientApp as subprocess\n+                            start_subprocess = isolation == ISOLATION_MODE_SUBPROCESS\n+\n+                            # Share Message and Context with servicer\n+                            clientappio_servicer.set_inputs(\n+                                clientapp_input=ClientAppInputs(\n+                                    message=message,\n+                                    context=context,\n+                                    run=run,\n+                                    fab=fab,\n+                                    token=token,\n+                                ),\n+                                token_returned=start_subprocess,\n+                            )\n+\n+                            if start_subprocess:\n+                                _octet, _colon, _port = (\n+                                    clientappio_api_address.rpartition(\":\")\n+                                )\n+                                io_address = (\n+                                    f\"{CLIENT_OCTET}:{_port}\"\n+                                    if _octet == SERVER_OCTET\n+                                    else clientappio_api_address\n+                                )\n+                                # Start ClientApp subprocess\n+                                command = [\n+                                    \"flwr-clientapp\",\n+                                    \"--clientappio-api-address\",\n+                                    io_address,\n+                                    \"--token\",\n+                                    str(token),\n+                                ]\n+                                command.append(\"--insecure\")\n+\n+                                proc = mp_spawn_context.Process(\n+                                    target=_run_flwr_clientapp,\n+                                    args=(command, os.getpid()),\n+                                    daemon=True,\n+                                )\n+                                proc.start()\n+                                proc.join()\n+                            else:\n+                                # Wait for output to become available\n+                                while not clientappio_servicer.has_outputs():\n+                                    time.sleep(0.1)\n+\n+                            outputs = clientappio_servicer.get_outputs()\n+                            reply_message, context = outputs.message, outputs.context\n+                        else:\n+                            # Load ClientApp instance\n+                            client_app: ClientApp = load_client_app_fn(\n+                                fab_id, fab_version, run.fab_hash\n+                            )\n+\n+                            # Execute ClientApp\n+                            reply_message = client_app(message=message, context=context)\n+                    except Exception as ex:  # pylint: disable=broad-exception-caught\n+\n+                        # Legacy grpc-bidi\n+                        if transport in [\"grpc-bidi\", None]:\n+                            log(ERROR, \"Client raised an exception.\", exc_info=ex)\n+                            # Raise exception, crash process\n+                            raise ex\n+\n+                        # Don't update/change DeprecatedRunInfoStore\n+\n+                        e_code = ErrorCode.CLIENT_APP_RAISED_EXCEPTION\n+                        # Ex fmt: \"<class 'ZeroDivisionError'>:<'division by zero'>\"\n+                        reason = str(type(ex)) + \":<'\" + str(ex) + \"'>\"\n+                        exc_entity = \"ClientApp\"\n+                        if isinstance(ex, LoadClientAppError):\n+                            reason = (\n+                                \"An exception was raised when attempting to load \"\n+                                \"`ClientApp`\"\n+                            )\n+                            e_code = ErrorCode.LOAD_CLIENT_APP_EXCEPTION\n+                            exc_entity = \"SuperNode\"\n+\n+                        log(ERROR, \"%s raised an exception\", exc_entity, exc_info=ex)\n+\n+                        # Create error message\n+                        reply_message = Message(\n+                            Error(code=e_code, reason=reason),\n+                            reply_to=message,\n+                        )\n+                    else:\n+                        # No exception, update node state\n+                        run_info_store.update_context(\n+                            run_id=run_id,\n+                            context=context,\n+                        )\n+\n+                    # Send\n+                    send(reply_message)\n+                    log(INFO, \"Sent reply\")\n+\n+                except RunNotRunningException:\n+                    log(INFO, \"\")\n+                    log(\n+                        INFO,\n+                        \"SuperNode aborted sending the reply message. \"\n+                        \"Run ID %s is not in `RUNNING` status.\",\n+                        run_id,\n+                    )\n+                    log(INFO, \"\")\n+            # pylint: enable=too-many-nested-blocks\n+\n+            # Unregister node\n+            if delete_node is not None:\n+                delete_node()  # pylint: disable=not-callable\n+\n+        if sleep_duration == 0:\n+            log(INFO, \"Disconnect and shut down\")\n+            break\n+\n+        # Sleep and reconnect afterwards\n+        log(\n+            INFO,\n+            \"Disconnect, then re-establish connection after %s second(s)\",\n+            sleep_duration,\n+        )\n+        time.sleep(sleep_duration)\n+\n+\n+def _init_connection(transport: Optional[str], server_address: str) -> tuple[\n+    Callable[\n+        [\n+            str,\n+            bool,\n+            RetryInvoker,\n+            int,\n+            Union[bytes, str, None],\n+            Optional[tuple[ec.EllipticCurvePrivateKey, ec.EllipticCurvePublicKey]],\n+        ],\n+        AbstractContextManager[\n+            tuple[\n+                Callable[[], Optional[Message]],\n+                Callable[[Message], None],\n+                Optional[Callable[[], Optional[int]]],\n+                Optional[Callable[[], None]],\n+                Optional[Callable[[int], Run]],\n+                Optional[Callable[[str, int], Fab]],\n+            ]\n+        ],\n+    ],\n+    str,\n+    type[Exception],\n+]:\n+    # Parse IP address\n+    parsed_address = parse_address(server_address)\n+    if not parsed_address:\n+        flwr_exit(\n+            ExitCode.COMMON_ADDRESS_INVALID,\n+            f\"SuperLink address ({server_address}) cannot be parsed.\",\n+        )\n+    host, port, is_v6 = parsed_address\n+    address = f\"[{host}]:{port}\" if is_v6 else f\"{host}:{port}\"\n+\n+    # Set the default transport layer\n+    if transport is None:\n+        transport = TRANSPORT_TYPE_GRPC_BIDI\n+\n+    # Use either gRPC bidirectional streaming or REST request/response\n+    if transport == TRANSPORT_TYPE_REST:\n+        try:\n+            from requests.exceptions import ConnectionError as RequestsConnectionError\n+\n+            from flwr.client.rest_client.connection import http_request_response\n+        except ModuleNotFoundError:\n+            flwr_exit(ExitCode.COMMON_MISSING_EXTRA_REST)\n+        if server_address[:4] != \"http\":\n+            flwr_exit(ExitCode.SUPERNODE_REST_ADDRESS_INVALID)\n+        connection, error_type = http_request_response, RequestsConnectionError\n+    elif transport == TRANSPORT_TYPE_GRPC_RERE:\n+        connection, error_type = grpc_request_response, RpcError\n+    elif transport == TRANSPORT_TYPE_GRPC_ADAPTER:\n+        connection, error_type = grpc_adapter, RpcError\n+    elif transport == TRANSPORT_TYPE_GRPC_BIDI:\n+        connection, error_type = grpc_connection, RpcError\n+    else:\n+        raise ValueError(\n+            f\"Unknown transport type: {transport} (possible: {TRANSPORT_TYPES})\"\n+        )\n+\n+    return connection, address, error_type\n+\n+\n+def _run_flwr_clientapp(args: list[str], main_pid: int) -> None:\n+    # Monitor the main process in case of SIGKILL\n+    def main_process_monitor() -> None:\n+        while True:\n+            time.sleep(1)\n+            if os.getppid() != main_pid:\n+                os.kill(os.getpid(), 9)\n+\n+    threading.Thread(target=main_process_monitor, daemon=True).start()\n+\n+    # Run the command\n+    sys.argv = args\n+    flwr_clientapp()\n+\n+\n+def run_clientappio_api_grpc(\n+    address: str,\n+    certificates: Optional[tuple[bytes, bytes, bytes]],\n+) -> tuple[grpc.Server, ClientAppIoServicer]:\n+    \"\"\"Run ClientAppIo API gRPC server.\"\"\"\n+    clientappio_servicer: grpc.Server = ClientAppIoServicer()\n+    clientappio_add_servicer_to_server_fn = add_ClientAppIoServicer_to_server\n+    clientappio_grpc_server = generic_create_grpc_server(\n+        servicer_and_add_fn=(\n+            clientappio_servicer,\n+            clientappio_add_servicer_to_server_fn,\n+        ),\n+        server_address=address,\n+        max_message_length=GRPC_MAX_MESSAGE_LENGTH,\n+        certificates=certificates,\n+    )\n+    log(INFO, \"Starting Flower ClientAppIo gRPC server on %s\", address)\n+    clientappio_grpc_server.start()\n+    return clientappio_grpc_server, clientappio_servicer\n"
        },
        {
            "commit": "a6517d5fc23bbb6be3424924264025b961df3fe2",
            "file_path": "framework/py/flwr/client/supernode/app.py",
            "diff": "diff --git a/framework/py/flwr/client/supernode/app.py b/framework/py/flwr/client/supernode/app.py\nindex dda395ec4..afbf651b4 100644\n--- a/framework/py/flwr/client/supernode/app.py\n+++ b/framework/py/flwr/client/supernode/app.py\n@@ -43,8 +43,8 @@ from flwr.common.exit import ExitCode, flwr_exit\n from flwr.common.exit_handlers import register_exit_handlers\n from flwr.common.logger import log\n \n-from ..app import start_client_internal\n from ..clientapp.utils import get_load_client_app_fn\n+from ..start_client_internal import start_client_internal\n \n \n def run_supernode() -> None:\n"
        },
        {
            "commit": "a6517d5fc23bbb6be3424924264025b961df3fe2",
            "file_path": "framework/py/flwr/compat/client/app.py",
            "diff": "diff --git a/framework/py/flwr/compat/client/app.py b/framework/py/flwr/compat/client/app.py\nnew file mode 100644\nindex 000000000..4800e66a7\n--- /dev/null\n+++ b/framework/py/flwr/compat/client/app.py\n@@ -0,0 +1,839 @@\n+# Copyright 2025 Flower Labs GmbH. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+\"\"\"Flower client app.\"\"\"\n+\n+\n+import multiprocessing\n+import os\n+import sys\n+import threading\n+import time\n+from contextlib import AbstractContextManager\n+from logging import ERROR, INFO, WARN\n+from os import urandom\n+from pathlib import Path\n+from typing import Callable, Optional, Union, cast\n+\n+import grpc\n+from cryptography.hazmat.primitives.asymmetric import ec\n+from grpc import RpcError\n+\n+from flwr.app.error import Error\n+from flwr.cli.config_utils import get_fab_metadata\n+from flwr.cli.install import install_from_fab\n+from flwr.client.client import Client\n+from flwr.client.client_app import ClientApp, LoadClientAppError\n+from flwr.client.clientapp.app import flwr_clientapp\n+from flwr.client.clientapp.clientappio_servicer import (\n+    ClientAppInputs,\n+    ClientAppIoServicer,\n+)\n+from flwr.client.grpc_adapter_client.connection import grpc_adapter\n+from flwr.client.grpc_client.connection import grpc_connection\n+from flwr.client.grpc_rere_client.connection import grpc_request_response\n+from flwr.client.message_handler.message_handler import handle_control_message\n+from flwr.client.nodestate.nodestate_factory import NodeStateFactory\n+from flwr.client.numpy_client import NumPyClient\n+from flwr.client.run_info_store import DeprecatedRunInfoStore\n+from flwr.client.typing import ClientFnExt\n+from flwr.common import GRPC_MAX_MESSAGE_LENGTH, Context, EventType, Message, event\n+from flwr.common.address import parse_address\n+from flwr.common.constant import (\n+    CLIENT_OCTET,\n+    CLIENTAPPIO_API_DEFAULT_SERVER_ADDRESS,\n+    ISOLATION_MODE_PROCESS,\n+    ISOLATION_MODE_SUBPROCESS,\n+    MAX_RETRY_DELAY,\n+    RUN_ID_NUM_BYTES,\n+    SERVER_OCTET,\n+    TRANSPORT_TYPE_GRPC_ADAPTER,\n+    TRANSPORT_TYPE_GRPC_BIDI,\n+    TRANSPORT_TYPE_GRPC_RERE,\n+    TRANSPORT_TYPE_REST,\n+    TRANSPORT_TYPES,\n+    ErrorCode,\n+)\n+from flwr.common.exit import ExitCode, flwr_exit\n+from flwr.common.grpc import generic_create_grpc_server\n+from flwr.common.logger import log, warn_deprecated_feature\n+from flwr.common.retry_invoker import RetryInvoker, RetryState, exponential\n+from flwr.common.typing import Fab, Run, RunNotRunningException, UserConfig\n+from flwr.proto.clientappio_pb2_grpc import add_ClientAppIoServicer_to_server\n+\n+\n+def _check_actionable_client(\n+    client: Optional[Client], client_fn: Optional[ClientFnExt]\n+) -> None:\n+    if client_fn is None and client is None:\n+        raise ValueError(\n+            \"Both `client_fn` and `client` are `None`, but one is required\"\n+        )\n+\n+    if client_fn is not None and client is not None:\n+        raise ValueError(\n+            \"Both `client_fn` and `client` are provided, but only one is allowed\"\n+        )\n+\n+\n+# pylint: disable=import-outside-toplevel\n+# pylint: disable=too-many-branches\n+# pylint: disable=too-many-locals\n+# pylint: disable=too-many-statements\n+# pylint: disable=too-many-arguments\n+def start_client(\n+    *,\n+    server_address: str,\n+    client_fn: Optional[ClientFnExt] = None,\n+    client: Optional[Client] = None,\n+    grpc_max_message_length: int = GRPC_MAX_MESSAGE_LENGTH,\n+    root_certificates: Optional[Union[bytes, str]] = None,\n+    insecure: Optional[bool] = None,\n+    transport: Optional[str] = None,\n+    authentication_keys: Optional[\n+        tuple[ec.EllipticCurvePrivateKey, ec.EllipticCurvePublicKey]\n+    ] = None,\n+    max_retries: Optional[int] = None,\n+    max_wait_time: Optional[float] = None,\n+) -> None:\n+    \"\"\"Start a Flower client node which connects to a Flower server.\n+\n+    Warning\n+    -------\n+    This function is deprecated since 1.13.0. Use :code:`flower-supernode` command\n+    instead to start a SuperNode.\n+\n+    Parameters\n+    ----------\n+    server_address : str\n+        The IPv4 or IPv6 address of the server. If the Flower\n+        server runs on the same machine on port 8080, then `server_address`\n+        would be `\"[::]:8080\"`.\n+    client_fn : Optional[ClientFnExt]\n+        A callable that instantiates a Client. (default: None)\n+    client : Optional[flwr.client.Client]\n+        An implementation of the abstract base\n+        class `flwr.client.Client` (default: None)\n+    grpc_max_message_length : int (default: 536_870_912, this equals 512MB)\n+        The maximum length of gRPC messages that can be exchanged with the\n+        Flower server. The default should be sufficient for most models.\n+        Users who train very large models might need to increase this\n+        value. Note that the Flower server needs to be started with the\n+        same value (see `flwr.server.start_server`), otherwise it will not\n+        know about the increased limit and block larger messages.\n+    root_certificates : Optional[Union[bytes, str]] (default: None)\n+        The PEM-encoded root certificates as a byte string or a path string.\n+        If provided, a secure connection using the certificates will be\n+        established to an SSL-enabled Flower server.\n+    insecure : bool (default: True)\n+        Starts an insecure gRPC connection when True. Enables HTTPS connection\n+        when False, using system certificates if `root_certificates` is None.\n+    transport : Optional[str] (default: None)\n+        Configure the transport layer. Allowed values:\n+        - 'grpc-bidi': gRPC, bidirectional streaming\n+        - 'grpc-rere': gRPC, request-response (experimental)\n+        - 'rest': HTTP (experimental)\n+    authentication_keys : Optional[Tuple[PrivateKey, PublicKey]] (default: None)\n+        Tuple containing the elliptic curve private key and public key for\n+        authentication from the cryptography library.\n+        Source: https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/\n+        Used to establish an authenticated connection with the server.\n+    max_retries: Optional[int] (default: None)\n+        The maximum number of times the client will try to connect to the\n+        server before giving up in case of a connection error. If set to None,\n+        there is no limit to the number of tries.\n+    max_wait_time: Optional[float] (default: None)\n+        The maximum duration before the client stops trying to\n+        connect to the server in case of connection error.\n+        If set to None, there is no limit to the total time.\n+\n+    Examples\n+    --------\n+    Starting a gRPC client with an insecure server connection::\n+\n+        start_client(\n+            server_address=localhost:8080,\n+            client_fn=client_fn,\n+        )\n+\n+    Starting a TLS-enabled gRPC client using system certificates::\n+\n+        def client_fn(context: Context):\n+            return FlowerClient().to_client()\n+\n+        start_client(\n+            server_address=localhost:8080,\n+            client_fn=client_fn,\n+            insecure=False,\n+        )\n+\n+    Starting a TLS-enabled gRPC client using provided certificates::\n+\n+        from pathlib import Path\n+\n+        start_client(\n+            server_address=localhost:8080,\n+            client_fn=client_fn,\n+            root_certificates=Path(\"/crts/root.pem\").read_bytes(),\n+        )\n+    \"\"\"\n+    msg = (\n+        \"flwr.client.start_client() is deprecated.\"\n+        \"\\n\\tInstead, use the `flower-supernode` CLI command to start a SuperNode \"\n+        \"as shown below:\"\n+        \"\\n\\n\\t\\t$ flower-supernode --insecure --superlink='<IP>:<PORT>'\"\n+        \"\\n\\n\\tTo view all available options, run:\"\n+        \"\\n\\n\\t\\t$ flower-supernode --help\"\n+        \"\\n\\n\\tUsing `start_client()` is deprecated.\"\n+    )\n+    warn_deprecated_feature(name=msg)\n+\n+    event(EventType.START_CLIENT_ENTER)\n+    start_client_internal(\n+        server_address=server_address,\n+        node_config={},\n+        load_client_app_fn=None,\n+        client_fn=client_fn,\n+        client=client,\n+        grpc_max_message_length=grpc_max_message_length,\n+        root_certificates=root_certificates,\n+        insecure=insecure,\n+        transport=transport,\n+        authentication_keys=authentication_keys,\n+        max_retries=max_retries,\n+        max_wait_time=max_wait_time,\n+    )\n+    event(EventType.START_CLIENT_LEAVE)\n+\n+\n+# pylint: disable=import-outside-toplevel\n+# pylint: disable=too-many-branches\n+# pylint: disable=too-many-locals\n+# pylint: disable=too-many-statements\n+def start_client_internal(\n+    *,\n+    server_address: str,\n+    node_config: UserConfig,\n+    load_client_app_fn: Optional[Callable[[str, str, str], ClientApp]] = None,\n+    client_fn: Optional[ClientFnExt] = None,\n+    client: Optional[Client] = None,\n+    grpc_max_message_length: int = GRPC_MAX_MESSAGE_LENGTH,\n+    root_certificates: Optional[Union[bytes, str]] = None,\n+    insecure: Optional[bool] = None,\n+    transport: Optional[str] = None,\n+    authentication_keys: Optional[\n+        tuple[ec.EllipticCurvePrivateKey, ec.EllipticCurvePublicKey]\n+    ] = None,\n+    max_retries: Optional[int] = None,\n+    max_wait_time: Optional[float] = None,\n+    flwr_path: Optional[Path] = None,\n+    isolation: Optional[str] = None,\n+    clientappio_api_address: Optional[str] = CLIENTAPPIO_API_DEFAULT_SERVER_ADDRESS,\n+) -> None:\n+    \"\"\"Start a Flower client node which connects to a Flower server.\n+\n+    Parameters\n+    ----------\n+    server_address : str\n+        The IPv4 or IPv6 address of the server. If the Flower\n+        server runs on the same machine on port 8080, then `server_address`\n+        would be `\"[::]:8080\"`.\n+    node_config: UserConfig\n+        The configuration of the node.\n+    load_client_app_fn : Optional[Callable[[], ClientApp]] (default: None)\n+        A function that can be used to load a `ClientApp` instance.\n+    client_fn : Optional[ClientFnExt]\n+        A callable that instantiates a Client. (default: None)\n+    client : Optional[flwr.client.Client]\n+        An implementation of the abstract base\n+        class `flwr.client.Client` (default: None)\n+    grpc_max_message_length : int (default: 536_870_912, this equals 512MB)\n+        The maximum length of gRPC messages that can be exchanged with the\n+        Flower server. The default should be sufficient for most models.\n+        Users who train very large models might need to increase this\n+        value. Note that the Flower server needs to be started with the\n+        same value (see `flwr.server.start_server`), otherwise it will not\n+        know about the increased limit and block larger messages.\n+    root_certificates : Optional[Union[bytes, str]] (default: None)\n+        The PEM-encoded root certificates as a byte string or a path string.\n+        If provided, a secure connection using the certificates will be\n+        established to an SSL-enabled Flower server.\n+    insecure : Optional[bool] (default: None)\n+        Starts an insecure gRPC connection when True. Enables HTTPS connection\n+        when False, using system certificates if `root_certificates` is None.\n+    transport : Optional[str] (default: None)\n+        Configure the transport layer. Allowed values:\n+        - 'grpc-bidi': gRPC, bidirectional streaming\n+        - 'grpc-rere': gRPC, request-response (experimental)\n+        - 'rest': HTTP (experimental)\n+    authentication_keys : Optional[Tuple[PrivateKey, PublicKey]] (default: None)\n+        Tuple containing the elliptic curve private key and public key for\n+        authentication from the cryptography library.\n+        Source: https://cryptography.io/en/latest/hazmat/primitives/asymmetric/ec/\n+        Used to establish an authenticated connection with the server.\n+    max_retries: Optional[int] (default: None)\n+        The maximum number of times the client will try to connect to the\n+        server before giving up in case of a connection error. If set to None,\n+        there is no limit to the number of tries.\n+    max_wait_time: Optional[float] (default: None)\n+        The maximum duration before the client stops trying to\n+        connect to the server in case of connection error.\n+        If set to None, there is no limit to the total time.\n+    flwr_path: Optional[Path] (default: None)\n+        The fully resolved path containing installed Flower Apps.\n+    isolation : Optional[str] (default: None)\n+        Isolation mode for `ClientApp`. Possible values are `subprocess` and\n+        `process`. Defaults to `None`, which runs the `ClientApp` in the same process\n+        as the SuperNode. If `subprocess`, the `ClientApp` runs in a subprocess started\n+        by the SueprNode and communicates using gRPC at the address\n+        `clientappio_api_address`. If `process`, the `ClientApp` runs in a separate\n+        isolated process and communicates using gRPC at the address\n+        `clientappio_api_address`.\n+    clientappio_api_address : Optional[str]\n+        (default: `CLIENTAPPIO_API_DEFAULT_SERVER_ADDRESS`)\n+        The SuperNode gRPC server address.\n+    \"\"\"\n+    if insecure is None:\n+        insecure = root_certificates is None\n+\n+    if load_client_app_fn is None:\n+        _check_actionable_client(client, client_fn)\n+\n+        if client_fn is None:\n+            # Wrap `Client` instance in `client_fn`\n+            def single_client_factory(\n+                context: Context,  # pylint: disable=unused-argument\n+            ) -> Client:\n+                if client is None:  # Added this to keep mypy happy\n+                    raise ValueError(\n+                        \"Both `client_fn` and `client` are `None`, but one is required\"\n+                    )\n+                return client  # Always return the same instance\n+\n+            client_fn = single_client_factory\n+\n+        def _load_client_app(_1: str, _2: str, _3: str) -> ClientApp:\n+            return ClientApp(client_fn=client_fn)\n+\n+        load_client_app_fn = _load_client_app\n+\n+    if isolation:\n+        if clientappio_api_address is None:\n+            raise ValueError(\n+                f\"`clientappio_api_address` required when `isolation` is \"\n+                f\"{ISOLATION_MODE_SUBPROCESS} or {ISOLATION_MODE_PROCESS}\",\n+            )\n+        _clientappio_grpc_server, clientappio_servicer = run_clientappio_api_grpc(\n+            address=clientappio_api_address,\n+            certificates=None,\n+        )\n+    clientappio_api_address = cast(str, clientappio_api_address)\n+\n+    # At this point, only `load_client_app_fn` should be used\n+    # Both `client` and `client_fn` must not be used directly\n+\n+    # Initialize connection context manager\n+    connection, address, connection_error_type = _init_connection(\n+        transport, server_address\n+    )\n+\n+    def _on_sucess(retry_state: RetryState) -> None:\n+        if retry_state.tries > 1:\n+            log(\n+                INFO,\n+                \"Connection successful after %.2f seconds and %s tries.\",\n+                retry_state.elapsed_time,\n+                retry_state.tries,\n+            )\n+\n+    def _on_backoff(retry_state: RetryState) -> None:\n+        if retry_state.tries == 1:\n+            log(WARN, \"Connection attempt failed, retrying...\")\n+        else:\n+            log(\n+                WARN,\n+                \"Connection attempt failed, retrying in %.2f seconds\",\n+                retry_state.actual_wait,\n+            )\n+\n+    retry_invoker = RetryInvoker(\n+        wait_gen_factory=lambda: exponential(max_delay=MAX_RETRY_DELAY),\n+        recoverable_exceptions=connection_error_type,\n+        max_tries=max_retries + 1 if max_retries is not None else None,\n+        max_time=max_wait_time,\n+        on_giveup=lambda retry_state: (\n+            log(\n+                WARN,\n+                \"Giving up reconnection after %.2f seconds and %s tries.\",\n+                retry_state.elapsed_time,\n+                retry_state.tries,\n+            )\n+            if retry_state.tries > 1\n+            else None\n+        ),\n+        on_success=_on_sucess,\n+        on_backoff=_on_backoff,\n+    )\n+\n+    # DeprecatedRunInfoStore gets initialized when the first connection is established\n+    run_info_store: Optional[DeprecatedRunInfoStore] = None\n+    state_factory = NodeStateFactory()\n+    state = state_factory.state()\n+    mp_spawn_context = multiprocessing.get_context(\"spawn\")\n+\n+    runs: dict[int, Run] = {}\n+\n+    while True:\n+        sleep_duration: int = 0\n+        with connection(\n+            address,\n+            insecure,\n+            retry_invoker,\n+            grpc_max_message_length,\n+            root_certificates,\n+            authentication_keys,\n+        ) as conn:\n+            receive, send, create_node, delete_node, get_run, get_fab = conn\n+\n+            # Register node when connecting the first time\n+            if run_info_store is None:\n+                if create_node is None:\n+                    if transport not in [\"grpc-bidi\", None]:\n+                        raise NotImplementedError(\n+                            \"All transports except `grpc-bidi` require \"\n+                            \"an implementation for `create_node()`.'\"\n+                        )\n+                    # gRPC-bidi doesn't have the concept of node_id,\n+                    # so we set it to -1\n+                    run_info_store = DeprecatedRunInfoStore(\n+                        node_id=-1,\n+                        node_config={},\n+                    )\n+                else:\n+                    # Call create_node fn to register node\n+                    # and store node_id in state\n+                    if (node_id := create_node()) is None:\n+                        raise ValueError(\n+                            \"Failed to register SuperNode with the SuperLink\"\n+                        )\n+                    state.set_node_id(node_id)\n+                    run_info_store = DeprecatedRunInfoStore(\n+                        node_id=state.get_node_id(),\n+                        node_config=node_config,\n+                    )\n+\n+            # pylint: disable=too-many-nested-blocks\n+            while True:\n+                try:\n+                    # Receive\n+                    message = receive()\n+                    if message is None:\n+                        time.sleep(3)  # Wait for 3s before asking again\n+                        continue\n+\n+                    log(INFO, \"\")\n+                    if len(message.metadata.group_id) > 0:\n+                        log(\n+                            INFO,\n+                            \"[RUN %s, ROUND %s]\",\n+                            message.metadata.run_id,\n+                            message.metadata.group_id,\n+                        )\n+                    log(\n+                        INFO,\n+                        \"Received: %s message %s\",\n+                        message.metadata.message_type,\n+                        message.metadata.message_id,\n+                    )\n+\n+                    # Handle control message\n+                    out_message, sleep_duration = handle_control_message(message)\n+                    if out_message:\n+                        send(out_message)\n+                        break\n+\n+                    # Get run info\n+                    run_id = message.metadata.run_id\n+                    if run_id not in runs:\n+                        if get_run is not None:\n+                            runs[run_id] = get_run(run_id)\n+                        # If get_run is None, i.e., in grpc-bidi mode\n+                        else:\n+                            runs[run_id] = Run.create_empty(run_id=run_id)\n+\n+                    run: Run = runs[run_id]\n+                    if get_fab is not None and run.fab_hash:\n+                        fab = get_fab(run.fab_hash, run_id)\n+                        if not isolation:\n+                            # If `ClientApp` runs in the same process, install the FAB\n+                            install_from_fab(fab.content, flwr_path, True)\n+                        fab_id, fab_version = get_fab_metadata(fab.content)\n+                    else:\n+                        fab = None\n+                        fab_id, fab_version = run.fab_id, run.fab_version\n+\n+                    run.fab_id, run.fab_version = fab_id, fab_version\n+\n+                    # Register context for this run\n+                    run_info_store.register_context(\n+                        run_id=run_id,\n+                        run=run,\n+                        flwr_path=flwr_path,\n+                        fab=fab,\n+                    )\n+\n+                    # Retrieve context for this run\n+                    context = run_info_store.retrieve_context(run_id=run_id)\n+                    # Create an error reply message that will never be used to prevent\n+                    # the used-before-assignment linting error\n+                    reply_message = Message(\n+                        Error(code=ErrorCode.UNKNOWN, reason=\"Unknown\"),\n+                        reply_to=message,\n+                    )\n+\n+                    # Handle app loading and task message\n+                    try:\n+                        if isolation:\n+                            # Two isolation modes:\n+                            # 1. `subprocess`: SuperNode is starting the ClientApp\n+                            #    process as a subprocess.\n+                            # 2. `process`: ClientApp process gets started separately\n+                            #    (via `flwr-clientapp`), for example, in a separate\n+                            #    Docker container.\n+\n+                            # Generate SuperNode token\n+                            token = int.from_bytes(urandom(RUN_ID_NUM_BYTES), \"little\")\n+\n+                            # Mode 1: SuperNode starts ClientApp as subprocess\n+                            start_subprocess = isolation == ISOLATION_MODE_SUBPROCESS\n+\n+                            # Share Message and Context with servicer\n+                            clientappio_servicer.set_inputs(\n+                                clientapp_input=ClientAppInputs(\n+                                    message=message,\n+                                    context=context,\n+                                    run=run,\n+                                    fab=fab,\n+                                    token=token,\n+                                ),\n+                                token_returned=start_subprocess,\n+                            )\n+\n+                            if start_subprocess:\n+                                _octet, _colon, _port = (\n+                                    clientappio_api_address.rpartition(\":\")\n+                                )\n+                                io_address = (\n+                                    f\"{CLIENT_OCTET}:{_port}\"\n+                                    if _octet == SERVER_OCTET\n+                                    else clientappio_api_address\n+                                )\n+                                # Start ClientApp subprocess\n+                                command = [\n+                                    \"flwr-clientapp\",\n+                                    \"--clientappio-api-address\",\n+                                    io_address,\n+                                    \"--token\",\n+                                    str(token),\n+                                ]\n+                                command.append(\"--insecure\")\n+\n+                                proc = mp_spawn_context.Process(\n+                                    target=_run_flwr_clientapp,\n+                                    args=(command, os.getpid()),\n+                                    daemon=True,\n+                                )\n+                                proc.start()\n+                                proc.join()\n+                            else:\n+                                # Wait for output to become available\n+                                while not clientappio_servicer.has_outputs():\n+                                    time.sleep(0.1)\n+\n+                            outputs = clientappio_servicer.get_outputs()\n+                            reply_message, context = outputs.message, outputs.context\n+                        else:\n+                            # Load ClientApp instance\n+                            client_app: ClientApp = load_client_app_fn(\n+                                fab_id, fab_version, run.fab_hash\n+                            )\n+\n+                            # Execute ClientApp\n+                            reply_message = client_app(message=message, context=context)\n+                    except Exception as ex:  # pylint: disable=broad-exception-caught\n+\n+                        # Legacy grpc-bidi\n+                        if transport in [\"grpc-bidi\", None]:\n+                            log(ERROR, \"Client raised an exception.\", exc_info=ex)\n+                            # Raise exception, crash process\n+                            raise ex\n+\n+                        # Don't update/change DeprecatedRunInfoStore\n+\n+                        e_code = ErrorCode.CLIENT_APP_RAISED_EXCEPTION\n+                        # Ex fmt: \"<class 'ZeroDivisionError'>:<'division by zero'>\"\n+                        reason = str(type(ex)) + \":<'\" + str(ex) + \"'>\"\n+                        exc_entity = \"ClientApp\"\n+                        if isinstance(ex, LoadClientAppError):\n+                            reason = (\n+                                \"An exception was raised when attempting to load \"\n+                                \"`ClientApp`\"\n+                            )\n+                            e_code = ErrorCode.LOAD_CLIENT_APP_EXCEPTION\n+                            exc_entity = \"SuperNode\"\n+\n+                        log(ERROR, \"%s raised an exception\", exc_entity, exc_info=ex)\n+\n+                        # Create error message\n+                        reply_message = Message(\n+                            Error(code=e_code, reason=reason),\n+                            reply_to=message,\n+                        )\n+                    else:\n+                        # No exception, update node state\n+                        run_info_store.update_context(\n+                            run_id=run_id,\n+                            context=context,\n+                        )\n+\n+                    # Send\n+                    send(reply_message)\n+                    log(INFO, \"Sent reply\")\n+\n+                except RunNotRunningException:\n+                    log(INFO, \"\")\n+                    log(\n+                        INFO,\n+                        \"SuperNode aborted sending the reply message. \"\n+                        \"Run ID %s is not in `RUNNING` status.\",\n+                        run_id,\n+                    )\n+                    log(INFO, \"\")\n+            # pylint: enable=too-many-nested-blocks\n+\n+            # Unregister node\n+            if delete_node is not None:\n+                delete_node()  # pylint: disable=not-callable\n+\n+        if sleep_duration == 0:\n+            log(INFO, \"Disconnect and shut down\")\n+            break\n+\n+        # Sleep and reconnect afterwards\n+        log(\n+            INFO,\n+            \"Disconnect, then re-establish connection after %s second(s)\",\n+            sleep_duration,\n+        )\n+        time.sleep(sleep_duration)\n+\n+\n+def start_numpy_client(\n+    *,\n+    server_address: str,\n+    client: NumPyClient,\n+    grpc_max_message_length: int = GRPC_MAX_MESSAGE_LENGTH,\n+    root_certificates: Optional[bytes] = None,\n+    insecure: Optional[bool] = None,\n+    transport: Optional[str] = None,\n+) -> None:\n+    \"\"\"Start a Flower NumPyClient which connects to a gRPC server.\n+\n+    Warning\n+    -------\n+    This function is deprecated since 1.7.0. Use :code:`flwr.client.start_client`\n+    instead and first convert your :code:`NumPyClient` to type\n+    :code:`flwr.client.Client` by executing its :code:`to_client()` method.\n+\n+    Parameters\n+    ----------\n+    server_address : str\n+        The IPv4 or IPv6 address of the server. If the Flower server runs on\n+        the same machine on port 8080, then `server_address` would be\n+        `\"[::]:8080\"`.\n+    client : flwr.client.NumPyClient\n+        An implementation of the abstract base class `flwr.client.NumPyClient`.\n+    grpc_max_message_length : int (default: 536_870_912, this equals 512MB)\n+        The maximum length of gRPC messages that can be exchanged with the\n+        Flower server. The default should be sufficient for most models.\n+        Users who train very large models might need to increase this\n+        value. Note that the Flower server needs to be started with the\n+        same value (see `flwr.server.start_server`), otherwise it will not\n+        know about the increased limit and block larger messages.\n+    root_certificates : bytes (default: None)\n+        The PEM-encoded root certificates as a byte string or a path string.\n+        If provided, a secure connection using the certificates will be\n+        established to an SSL-enabled Flower server.\n+    insecure : Optional[bool] (default: None)\n+        Starts an insecure gRPC connection when True. Enables HTTPS connection\n+        when False, using system certificates if `root_certificates` is None.\n+    transport : Optional[str] (default: None)\n+        Configure the transport layer. Allowed values:\n+        - 'grpc-bidi': gRPC, bidirectional streaming\n+        - 'grpc-rere': gRPC, request-response (experimental)\n+        - 'rest': HTTP (experimental)\n+\n+    Examples\n+    --------\n+    Starting a gRPC client with an insecure server connection::\n+\n+        start_numpy_client(\n+            server_address=localhost:8080,\n+            client=FlowerClient(),\n+        )\n+\n+    Starting a TLS-enabled gRPC client using system certificates::\n+\n+        start_numpy_client(\n+            server_address=localhost:8080,\n+            client=FlowerClient(),\n+            insecure=False,\n+        )\n+\n+    Starting a TLS-enabled gRPC client using provided certificates::\n+\n+        from pathlib import Path\n+\n+        start_numpy_client(\n+            server_address=localhost:8080,\n+            client=FlowerClient(),\n+            root_certificates=Path(\"/crts/root.pem\").read_bytes(),\n+        )\n+    \"\"\"\n+    mssg = (\n+        \"flwr.client.start_numpy_client() is deprecated. \\n\\tInstead, use \"\n+        \"`flwr.client.start_client()` by ensuring you first call \"\n+        \"the `.to_client()` method as shown below: \\n\"\n+        \"\\tflwr.client.start_client(\\n\"\n+        \"\\t\\tserver_address='<IP>:<PORT>',\\n\"\n+        \"\\t\\tclient=FlowerClient().to_client(),\"\n+        \" # <-- where FlowerClient is of type flwr.client.NumPyClient object\\n\"\n+        \"\\t)\\n\"\n+        \"\\tUsing `start_numpy_client()` is deprecated.\"\n+    )\n+\n+    warn_deprecated_feature(name=mssg)\n+\n+    # Calling this function is deprecated. A warning is thrown.\n+    # We first need to convert the supplied client to `Client.`\n+\n+    wrp_client = client.to_client()\n+\n+    start_client(\n+        server_address=server_address,\n+        client=wrp_client,\n+        grpc_max_message_length=grpc_max_message_length,\n+        root_certificates=root_certificates,\n+        insecure=insecure,\n+        transport=transport,\n+    )\n+\n+\n+def _init_connection(transport: Optional[str], server_address: str) -> tuple[\n+    Callable[\n+        [\n+            str,\n+            bool,\n+            RetryInvoker,\n+            int,\n+            Union[bytes, str, None],\n+            Optional[tuple[ec.EllipticCurvePrivateKey, ec.EllipticCurvePublicKey]],\n+        ],\n+        AbstractContextManager[\n+            tuple[\n+                Callable[[], Optional[Message]],\n+                Callable[[Message], None],\n+                Optional[Callable[[], Optional[int]]],\n+                Optional[Callable[[], None]],\n+                Optional[Callable[[int], Run]],\n+                Optional[Callable[[str, int], Fab]],\n+            ]\n+        ],\n+    ],\n+    str,\n+    type[Exception],\n+]:\n+    # Parse IP address\n+    parsed_address = parse_address(server_address)\n+    if not parsed_address:\n+        flwr_exit(\n+            ExitCode.COMMON_ADDRESS_INVALID,\n+            f\"SuperLink address ({server_address}) cannot be parsed.\",\n+        )\n+    host, port, is_v6 = parsed_address\n+    address = f\"[{host}]:{port}\" if is_v6 else f\"{host}:{port}\"\n+\n+    # Set the default transport layer\n+    if transport is None:\n+        transport = TRANSPORT_TYPE_GRPC_BIDI\n+\n+    # Use either gRPC bidirectional streaming or REST request/response\n+    if transport == TRANSPORT_TYPE_REST:\n+        try:\n+            from requests.exceptions import ConnectionError as RequestsConnectionError\n+\n+            from flwr.client.rest_client.connection import http_request_response\n+        except ModuleNotFoundError:\n+            flwr_exit(ExitCode.COMMON_MISSING_EXTRA_REST)\n+        if server_address[:4] != \"http\":\n+            flwr_exit(ExitCode.SUPERNODE_REST_ADDRESS_INVALID)\n+        connection, error_type = http_request_response, RequestsConnectionError\n+    elif transport == TRANSPORT_TYPE_GRPC_RERE:\n+        connection, error_type = grpc_request_response, RpcError\n+    elif transport == TRANSPORT_TYPE_GRPC_ADAPTER:\n+        connection, error_type = grpc_adapter, RpcError\n+    elif transport == TRANSPORT_TYPE_GRPC_BIDI:\n+        connection, error_type = grpc_connection, RpcError\n+    else:\n+        raise ValueError(\n+            f\"Unknown transport type: {transport} (possible: {TRANSPORT_TYPES})\"\n+        )\n+\n+    return connection, address, error_type\n+\n+\n+def _run_flwr_clientapp(args: list[str], main_pid: int) -> None:\n+    # Monitor the main process in case of SIGKILL\n+    def main_process_monitor() -> None:\n+        while True:\n+            time.sleep(1)\n+            if os.getppid() != main_pid:\n+                os.kill(os.getpid(), 9)\n+\n+    threading.Thread(target=main_process_monitor, daemon=True).start()\n+\n+    # Run the command\n+    sys.argv = args\n+    flwr_clientapp()\n+\n+\n+def run_clientappio_api_grpc(\n+    address: str,\n+    certificates: Optional[tuple[bytes, bytes, bytes]],\n+) -> tuple[grpc.Server, ClientAppIoServicer]:\n+    \"\"\"Run ClientAppIo API gRPC server.\"\"\"\n+    clientappio_servicer: grpc.Server = ClientAppIoServicer()\n+    clientappio_add_servicer_to_server_fn = add_ClientAppIoServicer_to_server\n+    clientappio_grpc_server = generic_create_grpc_server(\n+        servicer_and_add_fn=(\n+            clientappio_servicer,\n+            clientappio_add_servicer_to_server_fn,\n+        ),\n+        server_address=address,\n+        max_message_length=GRPC_MAX_MESSAGE_LENGTH,\n+        certificates=certificates,\n+    )\n+    log(INFO, \"Starting Flower ClientAppIo gRPC server on %s\", address)\n+    clientappio_grpc_server.start()\n+    return clientappio_grpc_server, clientappio_servicer\n"
        },
        {
            "commit": "a6517d5fc23bbb6be3424924264025b961df3fe2",
            "file_path": "framework/py/flwr/compat/client/app_test.py",
            "diff": "diff --git a/framework/py/flwr/compat/client/app_test.py b/framework/py/flwr/compat/client/app_test.py\nnew file mode 100644\nindex 000000000..96352d434\n--- /dev/null\n+++ b/framework/py/flwr/compat/client/app_test.py\n@@ -0,0 +1,126 @@\n+# Copyright 2025 Flower Labs GmbH. All Rights Reserved.\n+#\n+# Licensed under the Apache License, Version 2.0 (the \"License\");\n+# you may not use this file except in compliance with the License.\n+# You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+# ==============================================================================\n+\"\"\"Flower Client app tests.\"\"\"\n+\n+\n+from flwr.client.client import Client\n+from flwr.client.numpy_client import NumPyClient\n+from flwr.common import (\n+    Config,\n+    EvaluateIns,\n+    EvaluateRes,\n+    FitIns,\n+    FitRes,\n+    GetParametersIns,\n+    GetParametersRes,\n+    GetPropertiesIns,\n+    GetPropertiesRes,\n+    NDArrays,\n+    Scalar,\n+)\n+\n+from .app import start_client, start_numpy_client\n+\n+\n+class PlainClient(Client):\n+    \"\"\"Client implementation extending the low-level Client.\"\"\"\n+\n+    def get_properties(self, ins: GetPropertiesIns) -> GetPropertiesRes:\n+        \"\"\"Raise an Exception because this method is not expected to be called.\"\"\"\n+        raise NotImplementedError()\n+\n+    def get_parameters(self, ins: GetParametersIns) -> GetParametersRes:\n+        \"\"\"Raise an Exception because this method is not expected to be called.\"\"\"\n+        raise NotImplementedError()\n+\n+    def fit(self, ins: FitIns) -> FitRes:\n+        \"\"\"Raise an Exception because this method is not expected to be called.\"\"\"\n+        raise NotImplementedError()\n+\n+    def evaluate(self, ins: EvaluateIns) -> EvaluateRes:\n+        \"\"\"Raise an Exception because this method is not expected to be called.\"\"\"\n+        raise NotImplementedError()\n+\n+\n+class NeedsWrappingClient(NumPyClient):\n+    \"\"\"Client implementation extending the high-level NumPyClient.\"\"\"\n+\n+    def get_properties(self, config: Config) -> dict[str, Scalar]:\n+        \"\"\"Raise an Exception because this method is not expected to be called.\"\"\"\n+        raise NotImplementedError()\n+\n+    def get_parameters(self, config: Config) -> NDArrays:\n+        \"\"\"Raise an Exception because this method is not expected to be called.\"\"\"\n+        raise NotImplementedError()\n+\n+    def fit(\n+        self, parameters: NDArrays, config: Config\n+    ) -> tuple[NDArrays, int, dict[str, Scalar]]:\n+        \"\"\"Raise an Exception because this method is not expected to be called.\"\"\"\n+        raise NotImplementedError()\n+\n+    def evaluate(\n+        self, parameters: NDArrays, config: Config\n+    ) -> tuple[float, int, dict[str, Scalar]]:\n+        \"\"\"Raise an Exception because this method is not expected to be called.\"\"\"\n+        raise NotImplementedError()\n+\n+\n+def test_to_client_with_client() -> None:\n+    \"\"\"Test to_client.\"\"\"\n+    client = PlainClient().to_client()\n+\n+    # Assert\n+    assert isinstance(client, Client)\n+\n+\n+def test_to_client_with_numpyclient() -> None:\n+    \"\"\"Test fit_clients.\"\"\"\n+    client = NeedsWrappingClient().to_client()\n+\n+    # Assert\n+    assert isinstance(client, Client)\n+\n+\n+def test_start_client_transport_invalid() -> None:\n+    \"\"\"Test start_client(..., transport=...).\"\"\"\n+    # Prepare\n+    client: Client = PlainClient()\n+    invalid_transport = \"invalid-transport-value\"\n+\n+    # Execute\n+    try:\n+        start_client(\n+            server_address=\"0.0.0.0:8080\", client=client, transport=invalid_transport\n+        )\n+        raise AssertionError()  # Fail the test if no exception was raised\n+    except ValueError:\n+        pass\n+\n+\n+def test_start_numpy_client_transport_invalid() -> None:\n+    \"\"\"Test start_client(..., transport=...).\"\"\"\n+    # Prepare\n+    client: NumPyClient = NeedsWrappingClient()\n+    invalid_transport = \"invalid-transport-value\"\n+\n+    # Execute\n+    try:\n+        start_numpy_client(\n+            server_address=\"0.0.0.0:8080\", client=client, transport=invalid_transport\n+        )\n+        raise AssertionError()  # Fail the test if no exception was raised\n+    except ValueError:\n+        pass\n"
        }
    ]
}
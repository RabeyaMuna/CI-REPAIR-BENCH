{
    "sha_fail": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
    "changed_files": [
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/_exception_handler.py",
            "diff": "diff --git a/starlette/_exception_handler.py b/starlette/_exception_handler.py\nindex 5b4b68e..99cb6b6 100644\n--- a/starlette/_exception_handler.py\n+++ b/starlette/_exception_handler.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import typing\n \n from starlette._utils import is_async_callable\n@@ -22,16 +24,14 @@ StatusHandlers = typing.Dict[int, ExceptionHandler]\n \n def _lookup_exception_handler(\n     exc_handlers: ExceptionHandlers, exc: Exception\n-) -> typing.Optional[ExceptionHandler]:\n+) -> ExceptionHandler | None:\n     for cls in type(exc).__mro__:\n         if cls in exc_handlers:\n             return exc_handlers[cls]\n     return None\n \n \n-def wrap_app_handling_exceptions(\n-    app: ASGIApp, conn: typing.Union[Request, WebSocket]\n-) -> ASGIApp:\n+def wrap_app_handling_exceptions(app: ASGIApp, conn: Request | WebSocket) -> ASGIApp:\n     exception_handlers: ExceptionHandlers\n     status_handlers: StatusHandlers\n     try:\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/_utils.py",
            "diff": "diff --git a/starlette/_utils.py b/starlette/_utils.py\nindex 15ccd92..2e7981f 100644\n--- a/starlette/_utils.py\n+++ b/starlette/_utils.py\n@@ -74,7 +74,7 @@ class AwaitableOrContextManagerWrapper(typing.Generic[SupportsAsyncCloseType]):\n         self.entered = await self.aw\n         return self.entered\n \n-    async def __aexit__(self, *args: typing.Any) -> typing.Union[None, bool]:\n+    async def __aexit__(self, *args: typing.Any) -> None | bool:\n         await self.entered.close()\n         return None\n \n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/applications.py",
            "diff": "diff --git a/starlette/applications.py b/starlette/applications.py\nindex c3afaf7..1a4e3d2 100644\n--- a/starlette/applications.py\n+++ b/starlette/applications.py\n@@ -55,14 +55,14 @@ class Starlette:\n     \"\"\"\n \n     def __init__(\n-        self: \"AppType\",\n+        self: AppType,\n         debug: bool = False,\n         routes: typing.Sequence[BaseRoute] | None = None,\n         middleware: typing.Sequence[Middleware] | None = None,\n         exception_handlers: typing.Mapping[typing.Any, ExceptionHandler] | None = None,\n         on_startup: typing.Sequence[typing.Callable[[], typing.Any]] | None = None,\n         on_shutdown: typing.Sequence[typing.Callable[[], typing.Any]] | None = None,\n-        lifespan: typing.Optional[Lifespan[\"AppType\"]] = None,\n+        lifespan: Lifespan[AppType] | None = None,\n     ) -> None:\n         # The lifespan context function is a newer style that replaces\n         # on_startup / on_shutdown handlers. Use one or the other, not both.\n@@ -84,7 +84,7 @@ class Starlette:\n     def build_middleware_stack(self) -> ASGIApp:\n         debug = self.debug\n         error_handler = None\n-        exception_handlers: typing.Dict[\n+        exception_handlers: dict[\n             typing.Any, typing.Callable[[Request, Exception], Response]\n         ] = {}\n \n@@ -110,7 +110,7 @@ class Starlette:\n         return app\n \n     @property\n-    def routes(self) -> typing.List[BaseRoute]:\n+    def routes(self) -> list[BaseRoute]:\n         return self.router.routes\n \n     def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:\n@@ -193,7 +193,7 @@ class Starlette:\n     def route(\n         self,\n         path: str,\n-        methods: typing.List[str] | None = None,\n+        methods: list[str] | None = None,\n         name: str | None = None,\n         include_in_schema: bool = True,\n     ) -> typing.Callable:  # type: ignore[type-arg]\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/authentication.py",
            "diff": "diff --git a/starlette/authentication.py b/starlette/authentication.py\nindex 07f271c..e26a8a3 100644\n--- a/starlette/authentication.py\n+++ b/starlette/authentication.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import functools\n import inspect\n import sys\n@@ -26,9 +28,9 @@ def has_required_scope(conn: HTTPConnection, scopes: typing.Sequence[str]) -> bo\n \n \n def requires(\n-    scopes: typing.Union[str, typing.Sequence[str]],\n+    scopes: str | typing.Sequence[str],\n     status_code: int = 403,\n-    redirect: typing.Optional[str] = None,\n+    redirect: str | None = None,\n ) -> typing.Callable[\n     [typing.Callable[_P, typing.Any]], typing.Callable[_P, typing.Any]\n ]:\n@@ -113,12 +115,12 @@ class AuthenticationError(Exception):\n class AuthenticationBackend:\n     async def authenticate(\n         self, conn: HTTPConnection\n-    ) -> typing.Optional[typing.Tuple[\"AuthCredentials\", \"BaseUser\"]]:\n+    ) -> tuple[AuthCredentials, BaseUser] | None:\n         raise NotImplementedError()  # pragma: no cover\n \n \n class AuthCredentials:\n-    def __init__(self, scopes: typing.Optional[typing.Sequence[str]] = None):\n+    def __init__(self, scopes: typing.Sequence[str] | None = None):\n         self.scopes = [] if scopes is None else list(scopes)\n \n \n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/background.py",
            "diff": "diff --git a/starlette/background.py b/starlette/background.py\nindex 4aaf7ae..1cbed3b 100644\n--- a/starlette/background.py\n+++ b/starlette/background.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import sys\n import typing\n \n@@ -29,7 +31,7 @@ class BackgroundTask:\n \n \n class BackgroundTasks(BackgroundTask):\n-    def __init__(self, tasks: typing.Optional[typing.Sequence[BackgroundTask]] = None):\n+    def __init__(self, tasks: typing.Sequence[BackgroundTask] | None = None):\n         self.tasks = list(tasks) if tasks else []\n \n     def add_task(\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/concurrency.py",
            "diff": "diff --git a/starlette/concurrency.py b/starlette/concurrency.py\nindex d190201..e9ca46c 100644\n--- a/starlette/concurrency.py\n+++ b/starlette/concurrency.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import functools\n import sys\n import typing\n@@ -14,7 +16,7 @@ P = ParamSpec(\"P\")\n T = typing.TypeVar(\"T\")\n \n \n-async def run_until_first_complete(*args: typing.Tuple[typing.Callable, dict]) -> None:  # type: ignore[type-arg]  # noqa: E501\n+async def run_until_first_complete(*args: tuple[typing.Callable | dict]) -> None:  # type: ignore[type-arg]  # noqa: E501\n     warnings.warn(\n         \"run_until_first_complete is deprecated \"\n         \"and will be removed in a future version.\",\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/config.py",
            "diff": "diff --git a/starlette/config.py b/starlette/config.py\nindex 1ac49ea..75a0977 100644\n--- a/starlette/config.py\n+++ b/starlette/config.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import os\n import typing\n from pathlib import Path\n@@ -51,7 +53,7 @@ T = typing.TypeVar(\"T\")\n class Config:\n     def __init__(\n         self,\n-        env_file: typing.Optional[typing.Union[str, Path]] = None,\n+        env_file: str | Path | None = None,\n         environ: typing.Mapping[str, str] = environ,\n         env_prefix: str = \"\",\n     ) -> None:\n@@ -64,17 +66,15 @@ class Config:\n             self.file_values = self._read_file(env_file)\n \n     @typing.overload\n-    def __call__(self, key: str, *, default: None) -> typing.Optional[str]:\n+    def __call__(self, key: str, *, default: None) -> str | None:\n         ...\n \n     @typing.overload\n-    def __call__(self, key: str, cast: typing.Type[T], default: T = ...) -> T:\n+    def __call__(self, key: str, cast: type[T], default: T = ...) -> T:\n         ...\n \n     @typing.overload\n-    def __call__(\n-        self, key: str, cast: typing.Type[str] = ..., default: str = ...\n-    ) -> str:\n+    def __call__(self, key: str, cast: type[str] = ..., default: str = ...) -> str:\n         ...\n \n     @typing.overload\n@@ -87,15 +87,13 @@ class Config:\n         ...\n \n     @typing.overload\n-    def __call__(\n-        self, key: str, cast: typing.Type[str] = ..., default: T = ...\n-    ) -> typing.Union[T, str]:\n+    def __call__(self, key: str, cast: type[str] = ..., default: T = ...) -> T | str:\n         ...\n \n     def __call__(\n         self,\n         key: str,\n-        cast: typing.Optional[typing.Callable[[typing.Any], typing.Any]] = None,\n+        cast: typing.Callable[[typing.Any], typing.Any] | None = None,\n         default: typing.Any = undefined,\n     ) -> typing.Any:\n         return self.get(key, cast, default)\n@@ -103,7 +101,7 @@ class Config:\n     def get(\n         self,\n         key: str,\n-        cast: typing.Optional[typing.Callable[[typing.Any], typing.Any]] = None,\n+        cast: typing.Callable[[typing.Any], typing.Any] | None = None,\n         default: typing.Any = undefined,\n     ) -> typing.Any:\n         key = self.env_prefix + key\n@@ -117,7 +115,7 @@ class Config:\n             return self._perform_cast(key, default, cast)\n         raise KeyError(f\"Config '{key}' is missing, and has no default.\")\n \n-    def _read_file(self, file_name: typing.Union[str, Path]) -> typing.Dict[str, str]:\n+    def _read_file(self, file_name: str | Path) -> dict[str, str]:\n         file_values: typing.Dict[str, str] = {}\n         with open(file_name) as input_file:\n             for line in input_file.readlines():\n@@ -133,7 +131,7 @@ class Config:\n         self,\n         key: str,\n         value: typing.Any,\n-        cast: typing.Optional[typing.Callable[[typing.Any], typing.Any]] = None,\n+        cast: typing.Callable[[typing.Any], typing.Any] | None = None,\n     ) -> typing.Any:\n         if cast is None or value is None:\n             return value\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/datastructures.py",
            "diff": "diff --git a/starlette/datastructures.py b/starlette/datastructures.py\nindex e12957f..e430d09 100644\n--- a/starlette/datastructures.py\n+++ b/starlette/datastructures.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import typing\n from shlex import shlex\n from urllib.parse import SplitResult, parse_qsl, urlencode, urlsplit\n@@ -22,7 +24,7 @@ class URL:\n     def __init__(\n         self,\n         url: str = \"\",\n-        scope: typing.Optional[Scope] = None,\n+        scope: Scope | None = None,\n         **components: typing.Any,\n     ) -> None:\n         if scope is not None:\n@@ -86,26 +88,26 @@ class URL:\n         return self.components.fragment\n \n     @property\n-    def username(self) -> typing.Union[None, str]:\n+    def username(self) -> None | str:\n         return self.components.username\n \n     @property\n-    def password(self) -> typing.Union[None, str]:\n+    def password(self) -> None | str:\n         return self.components.password\n \n     @property\n-    def hostname(self) -> typing.Union[None, str]:\n+    def hostname(self) -> None | str:\n         return self.components.hostname\n \n     @property\n-    def port(self) -> typing.Optional[int]:\n+    def port(self) -> int | None:\n         return self.components.port\n \n     @property\n     def is_secure(self) -> bool:\n         return self.scheme in (\"https\", \"wss\")\n \n-    def replace(self, **kwargs: typing.Any) -> \"URL\":\n+    def replace(self, **kwargs: typing.Any) -> URL:\n         if (\n             \"username\" in kwargs\n             or \"password\" in kwargs\n@@ -138,19 +140,17 @@ class URL:\n         components = self.components._replace(**kwargs)\n         return self.__class__(components.geturl())\n \n-    def include_query_params(self, **kwargs: typing.Any) -> \"URL\":\n+    def include_query_params(self, **kwargs: typing.Any) -> URL:\n         params = MultiDict(parse_qsl(self.query, keep_blank_values=True))\n         params.update({str(key): str(value) for key, value in kwargs.items()})\n         query = urlencode(params.multi_items())\n         return self.replace(query=query)\n \n-    def replace_query_params(self, **kwargs: typing.Any) -> \"URL\":\n+    def replace_query_params(self, **kwargs: typing.Any) -> URL:\n         query = urlencode([(str(key), str(value)) for key, value in kwargs.items()])\n         return self.replace(query=query)\n \n-    def remove_query_params(\n-        self, keys: typing.Union[str, typing.Sequence[str]]\n-    ) -> \"URL\":\n+    def remove_query_params(self, keys: str | typing.Sequence[str]) -> \"URL\":\n         if isinstance(keys, str):\n             keys = [keys]\n         params = MultiDict(parse_qsl(self.query, keep_blank_values=True))\n@@ -186,7 +186,7 @@ class URLPath(str):\n         self.protocol = protocol\n         self.host = host\n \n-    def make_absolute_url(self, base_url: typing.Union[str, URL]) -> URL:\n+    def make_absolute_url(self, base_url: str | URL) -> URL:\n         if isinstance(base_url, str):\n             base_url = URL(base_url)\n         if self.protocol:\n@@ -223,7 +223,7 @@ class Secret:\n \n \n class CommaSeparatedStrings(typing.Sequence[str]):\n-    def __init__(self, value: typing.Union[str, typing.Sequence[str]]):\n+    def __init__(self, value: str | typing.Sequence[str]):\n         if isinstance(value, str):\n             splitter = shlex(value, posix=True)\n             splitter.whitespace = \",\"\n@@ -235,7 +235,7 @@ class CommaSeparatedStrings(typing.Sequence[str]):\n     def __len__(self) -> int:\n         return len(self._items)\n \n-    def __getitem__(self, index: typing.Union[int, slice]) -> typing.Any:\n+    def __getitem__(self, index: int | slice) -> typing.Any:\n         return self._items[index]\n \n     def __iter__(self) -> typing.Iterator[str]:\n@@ -255,11 +255,9 @@ class ImmutableMultiDict(typing.Mapping[_KeyType, _CovariantValueType]):\n \n     def __init__(\n         self,\n-        *args: typing.Union[\n-            \"ImmutableMultiDict[_KeyType, _CovariantValueType]\",\n-            typing.Mapping[_KeyType, _CovariantValueType],\n-            typing.Iterable[typing.Tuple[_KeyType, _CovariantValueType]],\n-        ],\n+        *args: ImmutableMultiDict[_KeyType, _CovariantValueType]\n+        | typing.Mapping[_KeyType, _CovariantValueType]\n+        | typing.Iterable[typing.Tuple[_KeyType, _CovariantValueType]],\n         **kwargs: typing.Any,\n     ) -> None:\n         assert len(args) < 2, \"Too many arguments.\"\n@@ -272,7 +270,7 @@ class ImmutableMultiDict(typing.Mapping[_KeyType, _CovariantValueType]):\n             )\n \n         if not value:\n-            _items: typing.List[typing.Tuple[typing.Any, typing.Any]] = []\n+            _items: list[tuple[typing.Any, typing.Any]] = []\n         elif hasattr(value, \"multi_items\"):\n             value = typing.cast(\n                 ImmutableMultiDict[_KeyType, _CovariantValueType], value\n@@ -282,15 +280,13 @@ class ImmutableMultiDict(typing.Mapping[_KeyType, _CovariantValueType]):\n             value = typing.cast(typing.Mapping[_KeyType, _CovariantValueType], value)\n             _items = list(value.items())\n         else:\n-            value = typing.cast(\n-                typing.List[typing.Tuple[typing.Any, typing.Any]], value\n-            )\n+            value = typing.cast(\"list[tuple[typing.Any, typing.Any]]\", value)\n             _items = list(value)\n \n         self._dict = {k: v for k, v in _items}\n         self._list = _items\n \n-    def getlist(self, key: typing.Any) -> typing.List[_CovariantValueType]:\n+    def getlist(self, key: typing.Any) -> list[_CovariantValueType]:\n         return [item_value for item_key, item_value in self._list if item_key == key]\n \n     def keys(self) -> typing.KeysView[_KeyType]:\n@@ -302,7 +298,7 @@ class ImmutableMultiDict(typing.Mapping[_KeyType, _CovariantValueType]):\n     def items(self) -> typing.ItemsView[_KeyType, _CovariantValueType]:\n         return self._dict.items()\n \n-    def multi_items(self) -> typing.List[typing.Tuple[_KeyType, _CovariantValueType]]:\n+    def multi_items(self) -> list[tuple[_KeyType, _CovariantValueType]]:\n         return list(self._list)\n \n     def __getitem__(self, key: _KeyType) -> _CovariantValueType:\n@@ -340,12 +336,12 @@ class MultiDict(ImmutableMultiDict[typing.Any, typing.Any]):\n         self._list = [(k, v) for k, v in self._list if k != key]\n         return self._dict.pop(key, default)\n \n-    def popitem(self) -> typing.Tuple[typing.Any, typing.Any]:\n+    def popitem(self) -> tuple[typing.Any, typing.Any]:\n         key, value = self._dict.popitem()\n         self._list = [(k, v) for k, v in self._list if k != key]\n         return key, value\n \n-    def poplist(self, key: typing.Any) -> typing.List[typing.Any]:\n+    def poplist(self, key: typing.Any) -> list[typing.Any]:\n         values = [v for k, v in self._list if k == key]\n         self.pop(key)\n         return values\n@@ -361,7 +357,7 @@ class MultiDict(ImmutableMultiDict[typing.Any, typing.Any]):\n \n         return self[key]\n \n-    def setlist(self, key: typing.Any, values: typing.List[typing.Any]) -> None:\n+    def setlist(self, key: typing.Any, values: list[typing.Any]) -> None:\n         if not values:\n             self.pop(key, None)\n         else:\n@@ -375,11 +371,9 @@ class MultiDict(ImmutableMultiDict[typing.Any, typing.Any]):\n \n     def update(\n         self,\n-        *args: typing.Union[\n-            \"MultiDict\",\n-            typing.Mapping[typing.Any, typing.Any],\n-            typing.List[typing.Tuple[typing.Any, typing.Any]],\n-        ],\n+        *args: MultiDict\n+        | typing.Mapping[typing.Any, typing.Any]\n+        | list[tuple[typing.Any, typing.Any]],\n         **kwargs: typing.Any,\n     ) -> None:\n         value = MultiDict(*args, **kwargs)\n@@ -395,13 +389,11 @@ class QueryParams(ImmutableMultiDict[str, str]):\n \n     def __init__(\n         self,\n-        *args: typing.Union[\n-            \"ImmutableMultiDict[typing.Any, typing.Any]\",\n-            typing.Mapping[typing.Any, typing.Any],\n-            typing.List[typing.Tuple[typing.Any, typing.Any]],\n-            str,\n-            bytes,\n-        ],\n+        *args: ImmutableMultiDict[typing.Any, typing.Any]\n+        | typing.Mapping[typing.Any, typing.Any]\n+        | list[tuple[typing.Any, typing.Any]]\n+        | str\n+        | bytes,\n         **kwargs: typing.Any,\n     ) -> None:\n         assert len(args) < 2, \"Too many arguments.\"\n@@ -437,9 +429,9 @@ class UploadFile:\n         self,\n         file: typing.BinaryIO,\n         *,\n-        size: typing.Optional[int] = None,\n-        filename: typing.Optional[str] = None,\n-        headers: \"typing.Optional[Headers]\" = None,\n+        size: int | None = None,\n+        filename: str | None = None,\n+        headers: Headers | None = None,\n     ) -> None:\n         self.filename = filename\n         self.file = file\n@@ -447,7 +439,7 @@ class UploadFile:\n         self.headers = headers or Headers()\n \n     @property\n-    def content_type(self) -> typing.Optional[str]:\n+    def content_type(self) -> str | None:\n         return self.headers.get(\"content-type\", None)\n \n     @property\n@@ -498,12 +490,10 @@ class FormData(ImmutableMultiDict[str, typing.Union[UploadFile, str]]):\n \n     def __init__(\n         self,\n-        *args: typing.Union[\n-            \"FormData\",\n-            typing.Mapping[str, typing.Union[str, UploadFile]],\n-            typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]],\n-        ],\n-        **kwargs: typing.Union[str, UploadFile],\n+        *args: FormData\n+        | typing.Mapping[str, str | UploadFile]\n+        | list[tuple[str, str | UploadFile]],\n+        **kwargs: str | UploadFile,\n     ) -> None:\n         super().__init__(*args, **kwargs)\n \n@@ -520,11 +510,11 @@ class Headers(typing.Mapping[str, str]):\n \n     def __init__(\n         self,\n-        headers: typing.Optional[typing.Mapping[str, str]] = None,\n-        raw: typing.Optional[typing.List[typing.Tuple[bytes, bytes]]] = None,\n-        scope: typing.Optional[typing.MutableMapping[str, typing.Any]] = None,\n+        headers: typing.Mapping[str, str] | None = None,\n+        raw: list[tuple[bytes, bytes]] | None = None,\n+        scope: typing.MutableMapping[str, typing.Any] | None = None,\n     ) -> None:\n-        self._list: typing.List[typing.Tuple[bytes, bytes]] = []\n+        self._list: list[tuple[bytes, bytes]] = []\n         if headers is not None:\n             assert raw is None, 'Cannot set both \"headers\" and \"raw\".'\n             assert scope is None, 'Cannot set both \"headers\" and \"scope\".'\n@@ -541,22 +531,22 @@ class Headers(typing.Mapping[str, str]):\n             self._list = scope[\"headers\"] = list(scope[\"headers\"])\n \n     @property\n-    def raw(self) -> typing.List[typing.Tuple[bytes, bytes]]:\n+    def raw(self) -> list[tuple[bytes, bytes]]:\n         return list(self._list)\n \n-    def keys(self) -> typing.List[str]:  # type: ignore[override]\n+    def keys(self) -> list[str]:  # type: ignore[override]\n         return [key.decode(\"latin-1\") for key, value in self._list]\n \n-    def values(self) -> typing.List[str]:  # type: ignore[override]\n+    def values(self) -> list[str]:  # type: ignore[override]\n         return [value.decode(\"latin-1\") for key, value in self._list]\n \n-    def items(self) -> typing.List[typing.Tuple[str, str]]:  # type: ignore[override]\n+    def items(self) -> list[tuple[str, str]]:  # type: ignore[override]\n         return [\n             (key.decode(\"latin-1\"), value.decode(\"latin-1\"))\n             for key, value in self._list\n         ]\n \n-    def getlist(self, key: str) -> typing.List[str]:\n+    def getlist(self, key: str) -> list[str]:\n         get_header_key = key.lower().encode(\"latin-1\")\n         return [\n             item_value.decode(\"latin-1\")\n@@ -564,7 +554,7 @@ class Headers(typing.Mapping[str, str]):\n             if item_key == get_header_key\n         ]\n \n-    def mutablecopy(self) -> \"MutableHeaders\":\n+    def mutablecopy(self) -> MutableHeaders:\n         return MutableHeaders(raw=self._list[:])\n \n     def __getitem__(self, key: str) -> str:\n@@ -637,13 +627,13 @@ class MutableHeaders(Headers):\n         for idx in reversed(pop_indexes):\n             del self._list[idx]\n \n-    def __ior__(self, other: typing.Mapping[str, str]) -> \"MutableHeaders\":\n+    def __ior__(self, other: typing.Mapping[str, str]) -> MutableHeaders:\n         if not isinstance(other, typing.Mapping):\n             raise TypeError(f\"Expected a mapping but got {other.__class__.__name__}\")\n         self.update(other)\n         return self\n \n-    def __or__(self, other: typing.Mapping[str, str]) -> \"MutableHeaders\":\n+    def __or__(self, other: typing.Mapping[str, str]) -> MutableHeaders:\n         if not isinstance(other, typing.Mapping):\n             raise TypeError(f\"Expected a mapping but got {other.__class__.__name__}\")\n         new = self.mutablecopy()\n@@ -651,7 +641,7 @@ class MutableHeaders(Headers):\n         return new\n \n     @property\n-    def raw(self) -> typing.List[typing.Tuple[bytes, bytes]]:\n+    def raw(self) -> list[tuple[bytes, bytes]]:\n         return self._list\n \n     def setdefault(self, key: str, value: str) -> str:\n@@ -694,9 +684,9 @@ class State:\n     Used for `request.state` and `app.state`.\n     \"\"\"\n \n-    _state: typing.Dict[str, typing.Any]\n+    _state: dict[str, typing.Any]\n \n-    def __init__(self, state: typing.Optional[typing.Dict[str, typing.Any]] = None):\n+    def __init__(self, state: dict[str, typing.Any] | None = None):\n         if state is None:\n             state = {}\n         super().__setattr__(\"_state\", state)\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/endpoints.py",
            "diff": "diff --git a/starlette/endpoints.py b/starlette/endpoints.py\nindex c25dd9d..57f7188 100644\n--- a/starlette/endpoints.py\n+++ b/starlette/endpoints.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import json\n import typing\n \n@@ -55,7 +57,7 @@ class HTTPEndpoint:\n \n \n class WebSocketEndpoint:\n-    encoding: typing.Optional[str] = None  # May be \"text\", \"bytes\", or \"json\".\n+    encoding: str | None = None  # May be \"text\", \"bytes\", or \"json\".\n \n     def __init__(self, scope: Scope, receive: Receive, send: Send) -> None:\n         assert scope[\"type\"] == \"websocket\"\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/exceptions.py",
            "diff": "diff --git a/starlette/exceptions.py b/starlette/exceptions.py\nindex a583d93..e6d0b8a 100644\n--- a/starlette/exceptions.py\n+++ b/starlette/exceptions.py\n@@ -9,8 +9,8 @@ class HTTPException(Exception):\n     def __init__(\n         self,\n         status_code: int,\n-        detail: typing.Optional[str] = None,\n-        headers: typing.Optional[typing.Dict[str, str]] = None,\n+        detail: str | None = None,\n+        headers: dict[str, str] | None = None,\n     ) -> None:\n         if detail is None:\n             detail = http.HTTPStatus(status_code).phrase\n@@ -27,7 +27,7 @@ class HTTPException(Exception):\n \n \n class WebSocketException(Exception):\n-    def __init__(self, code: int, reason: typing.Optional[str] = None) -> None:\n+    def __init__(self, code: int, reason: str | None = None) -> None:\n         self.code = code\n         self.reason = reason or \"\"\n \n@@ -56,5 +56,5 @@ def __getattr__(name: str) -> typing.Any:  # pragma: no cover\n     raise AttributeError(f\"module '{__name__}' has no attribute '{name}'\")\n \n \n-def __dir__() -> typing.List[str]:\n+def __dir__() -> list[str]:\n     return sorted(list(__all__) + [__deprecated__])  # pragma: no cover\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/formparsers.py",
            "diff": "diff --git a/starlette/formparsers.py b/starlette/formparsers.py\nindex 905260b..e2a95e5 100644\n--- a/starlette/formparsers.py\n+++ b/starlette/formparsers.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import typing\n from dataclasses import dataclass, field\n from enum import Enum\n@@ -24,11 +26,11 @@ class FormMessage(Enum):\n \n @dataclass\n class MultipartPart:\n-    content_disposition: typing.Optional[bytes] = None\n+    content_disposition: bytes | None = None\n     field_name: str = \"\"\n     data: bytes = b\"\"\n-    file: typing.Optional[UploadFile] = None\n-    item_headers: typing.List[typing.Tuple[bytes, bytes]] = field(default_factory=list)\n+    file: UploadFile | None = None\n+    item_headers: list[tuple[bytes, bytes]] = field(default_factory=list)\n \n \n def _user_safe_decode(src: bytes, codec: str) -> str:\n@@ -52,7 +54,7 @@ class FormParser:\n         ), \"The `python-multipart` library must be installed to use form parsing.\"\n         self.headers = headers\n         self.stream = stream\n-        self.messages: typing.List[typing.Tuple[FormMessage, bytes]] = []\n+        self.messages: list[tuple[FormMessage, bytes]] = []\n \n     def on_field_start(self) -> None:\n         message = (FormMessage.FIELD_START, b\"\")\n@@ -89,7 +91,7 @@ class FormParser:\n         field_name = b\"\"\n         field_value = b\"\"\n \n-        items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []\n+        items: list[tuple[str, typing.Union[str, UploadFile]]] = []\n \n         # Feed the parser with data from the request.\n         async for chunk in self.stream:\n@@ -123,8 +125,8 @@ class MultiPartParser:\n         headers: Headers,\n         stream: typing.AsyncGenerator[bytes, None],\n         *,\n-        max_files: typing.Union[int, float] = 1000,\n-        max_fields: typing.Union[int, float] = 1000,\n+        max_files: int | float = 1000,\n+        max_fields: int | float = 1000,\n     ) -> None:\n         assert (\n             multipart is not None\n@@ -133,16 +135,16 @@ class MultiPartParser:\n         self.stream = stream\n         self.max_files = max_files\n         self.max_fields = max_fields\n-        self.items: typing.List[typing.Tuple[str, typing.Union[str, UploadFile]]] = []\n+        self.items: list[tuple[str, str | UploadFile]] = []\n         self._current_files = 0\n         self._current_fields = 0\n         self._current_partial_header_name: bytes = b\"\"\n         self._current_partial_header_value: bytes = b\"\"\n         self._current_part = MultipartPart()\n         self._charset = \"\"\n-        self._file_parts_to_write: typing.List[typing.Tuple[MultipartPart, bytes]] = []\n-        self._file_parts_to_finish: typing.List[MultipartPart] = []\n-        self._files_to_close_on_error: typing.List[SpooledTemporaryFile[bytes]] = []\n+        self._file_parts_to_write: list[tuple[MultipartPart, bytes]] = []\n+        self._file_parts_to_finish: list[MultipartPart] = []\n+        self._files_to_close_on_error: list[SpooledTemporaryFile[bytes]] = []\n \n     def on_part_begin(self) -> None:\n         self._current_part = MultipartPart()\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/middleware/__init__.py",
            "diff": "diff --git a/starlette/middleware/__init__.py b/starlette/middleware/__init__.py\nindex ca9752b..3d0342d 100644\n--- a/starlette/middleware/__init__.py\n+++ b/starlette/middleware/__init__.py\n@@ -1,5 +1,7 @@\n+from __future__ import annotations\n+\n import sys\n-from typing import Any, Iterator, Protocol, Type\n+from typing import Any, Iterator, Protocol\n \n if sys.version_info >= (3, 10):  # pragma: no cover\n     from typing import ParamSpec\n@@ -22,7 +24,7 @@ class _MiddlewareClass(Protocol[P]):\n class Middleware:\n     def __init__(\n         self,\n-        cls: Type[_MiddlewareClass[P]],\n+        cls: type[_MiddlewareClass[P]],\n         *args: P.args,\n         **kwargs: P.kwargs,\n     ) -> None:\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/requests.py",
            "diff": "diff --git a/starlette/requests.py b/starlette/requests.py\nindex e51223b..4af63bf 100644\n--- a/starlette/requests.py\n+++ b/starlette/requests.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import json\n import typing\n from http import cookies as http_cookies\n@@ -29,7 +31,7 @@ SERVER_PUSH_HEADERS_TO_COPY = {\n }\n \n \n-def cookie_parser(cookie_string: str) -> typing.Dict[str, str]:\n+def cookie_parser(cookie_string: str) -> dict[str, str]:\n     \"\"\"\n     This function parses a ``Cookie`` HTTP header into a dict of key/value pairs.\n \n@@ -66,7 +68,7 @@ class HTTPConnection(typing.Mapping[str, typing.Any]):\n     any functionality that is common to both `Request` and `WebSocket`.\n     \"\"\"\n \n-    def __init__(self, scope: Scope, receive: typing.Optional[Receive] = None) -> None:\n+    def __init__(self, scope: Scope, receive: Receive | None = None) -> None:\n         assert scope[\"type\"] in (\"http\", \"websocket\")\n         self.scope = scope\n \n@@ -127,11 +129,11 @@ class HTTPConnection(typing.Mapping[str, typing.Any]):\n         return self._query_params\n \n     @property\n-    def path_params(self) -> typing.Dict[str, typing.Any]:\n+    def path_params(self) -> dict[str, typing.Any]:\n         return self.scope.get(\"path_params\", {})\n \n     @property\n-    def cookies(self) -> typing.Dict[str, str]:\n+    def cookies(self) -> dict[str, str]:\n         if not hasattr(self, \"_cookies\"):\n             cookies: typing.Dict[str, str] = {}\n             cookie_header = self.headers.get(\"cookie\")\n@@ -142,7 +144,7 @@ class HTTPConnection(typing.Mapping[str, typing.Any]):\n         return self._cookies\n \n     @property\n-    def client(self) -> typing.Optional[Address]:\n+    def client(self) -> Address | None:\n         # client is a 2 item tuple of (host, port), None or missing\n         host_port = self.scope.get(\"client\")\n         if host_port is not None:\n@@ -150,7 +152,7 @@ class HTTPConnection(typing.Mapping[str, typing.Any]):\n         return None\n \n     @property\n-    def session(self) -> typing.Dict[str, typing.Any]:\n+    def session(self) -> dict[str, typing.Any]:\n         assert (\n             \"session\" in self.scope\n         ), \"SessionMiddleware must be installed to access request.session\"\n@@ -251,10 +253,7 @@ class Request(HTTPConnection):\n         return self._json\n \n     async def _get_form(\n-        self,\n-        *,\n-        max_files: typing.Union[int, float] = 1000,\n-        max_fields: typing.Union[int, float] = 1000,\n+        self, *, max_files: int | float = 1000, max_fields: int | float = 1000\n     ) -> FormData:\n         if self._form is None:\n             assert (\n@@ -284,10 +283,7 @@ class Request(HTTPConnection):\n         return self._form\n \n     def form(\n-        self,\n-        *,\n-        max_files: typing.Union[int, float] = 1000,\n-        max_fields: typing.Union[int, float] = 1000,\n+        self, *, max_files: int | float = 1000, max_fields: int | float = 1000\n     ) -> AwaitableOrContextManager[FormData]:\n         return AwaitableOrContextManagerWrapper(\n             self._get_form(max_files=max_files, max_fields=max_fields)\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/responses.py",
            "diff": "diff --git a/starlette/responses.py b/starlette/responses.py\nindex c99c64f..419816b 100644\n--- a/starlette/responses.py\n+++ b/starlette/responses.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import http.cookies\n import json\n import os\n@@ -28,9 +30,9 @@ class Response:\n         self,\n         content: typing.Any = None,\n         status_code: int = 200,\n-        headers: typing.Optional[typing.Mapping[str, str]] = None,\n-        media_type: typing.Optional[str] = None,\n-        background: typing.Optional[BackgroundTask] = None,\n+        headers: typing.Mapping[str, str] | None = None,\n+        media_type: str | None = None,\n+        background: BackgroundTask | None = None,\n     ) -> None:\n         self.status_code = status_code\n         if media_type is not None:\n@@ -46,11 +48,9 @@ class Response:\n             return content\n         return content.encode(self.charset)  # type: ignore\n \n-    def init_headers(\n-        self, headers: typing.Optional[typing.Mapping[str, str]] = None\n-    ) -> None:\n+    def init_headers(self, headers: typing.Mapping[str, str] | None = None) -> None:\n         if headers is None:\n-            raw_headers: typing.List[typing.Tuple[bytes, bytes]] = []\n+            raw_headers: list[tuple[bytes, bytes]] = []\n             populate_content_length = True\n             populate_content_type = True\n         else:\n@@ -89,15 +89,15 @@ class Response:\n         self,\n         key: str,\n         value: str = \"\",\n-        max_age: typing.Optional[int] = None,\n-        expires: typing.Optional[typing.Union[datetime, str, int]] = None,\n+        max_age: int | None = None,\n+        expires: datetime | str | int | None = None,\n         path: str = \"/\",\n-        domain: typing.Optional[str] = None,\n+        domain: str | None = None,\n         secure: bool = False,\n         httponly: bool = False,\n-        samesite: typing.Optional[typing.Literal[\"lax\", \"strict\", \"none\"]] = \"lax\",\n+        samesite: typing.Literal[\"lax\", \"strict\", \"none\"] | None = \"lax\",\n     ) -> None:\n-        cookie: \"http.cookies.BaseCookie[str]\" = http.cookies.SimpleCookie()\n+        cookie: http.cookies.BaseCookie[str] = http.cookies.SimpleCookie()\n         cookie[key] = value\n         if max_age is not None:\n             cookie[key][\"max-age\"] = max_age\n@@ -128,10 +128,10 @@ class Response:\n         self,\n         key: str,\n         path: str = \"/\",\n-        domain: typing.Optional[str] = None,\n+        domain: str | None = None,\n         secure: bool = False,\n         httponly: bool = False,\n-        samesite: typing.Optional[typing.Literal[\"lax\", \"strict\", \"none\"]] = \"lax\",\n+        samesite: typing.Literal[\"lax\", \"strict\", \"none\"] | None = \"lax\",\n     ) -> None:\n         self.set_cookie(\n             key,\n@@ -173,9 +173,9 @@ class JSONResponse(Response):\n         self,\n         content: typing.Any,\n         status_code: int = 200,\n-        headers: typing.Optional[typing.Mapping[str, str]] = None,\n-        media_type: typing.Optional[str] = None,\n-        background: typing.Optional[BackgroundTask] = None,\n+        headers: typing.Mapping[str, str] | None = None,\n+        media_type: str | None = None,\n+        background: BackgroundTask | None = None,\n     ) -> None:\n         super().__init__(content, status_code, headers, media_type, background)\n \n@@ -192,10 +192,10 @@ class JSONResponse(Response):\n class RedirectResponse(Response):\n     def __init__(\n         self,\n-        url: typing.Union[str, URL],\n+        url: str | URL,\n         status_code: int = 307,\n-        headers: typing.Optional[typing.Mapping[str, str]] = None,\n-        background: typing.Optional[BackgroundTask] = None,\n+        headers: typing.Mapping[str, str] | None = None,\n+        background: BackgroundTask | None = None,\n     ) -> None:\n         super().__init__(\n             content=b\"\", status_code=status_code, headers=headers, background=background\n@@ -216,9 +216,9 @@ class StreamingResponse(Response):\n         self,\n         content: ContentStream,\n         status_code: int = 200,\n-        headers: typing.Optional[typing.Mapping[str, str]] = None,\n-        media_type: typing.Optional[str] = None,\n-        background: typing.Optional[BackgroundTask] = None,\n+        headers: typing.Mapping[str, str] | None = None,\n+        media_type: str | None = None,\n+        background: BackgroundTask | None = None,\n     ) -> None:\n         if isinstance(content, typing.AsyncIterable):\n             self.body_iterator = content\n@@ -253,7 +253,7 @@ class StreamingResponse(Response):\n     async def __call__(self, scope: Scope, receive: Receive, send: Send) -> None:\n         async with anyio.create_task_group() as task_group:\n \n-            async def wrap(func: \"typing.Callable[[], typing.Awaitable[None]]\") -> None:\n+            async def wrap(func: typing.Callable[[], typing.Awaitable[None]]) -> None:\n                 await func()\n                 task_group.cancel_scope.cancel()\n \n@@ -269,14 +269,14 @@ class FileResponse(Response):\n \n     def __init__(\n         self,\n-        path: typing.Union[str, \"os.PathLike[str]\"],\n+        path: str | os.PathLike[str],\n         status_code: int = 200,\n-        headers: typing.Optional[typing.Mapping[str, str]] = None,\n-        media_type: typing.Optional[str] = None,\n-        background: typing.Optional[BackgroundTask] = None,\n-        filename: typing.Optional[str] = None,\n-        stat_result: typing.Optional[os.stat_result] = None,\n-        method: typing.Optional[str] = None,\n+        headers: typing.Mapping[str, str] | None = None,\n+        media_type: str | None = None,\n+        background: BackgroundTask | None = None,\n+        filename: str | None = None,\n+        stat_result: os.stat_result | None = None,\n+        method: str | None = None,\n         content_disposition_type: str = \"attachment\",\n     ) -> None:\n         self.path = path\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/routing.py",
            "diff": "diff --git a/starlette/routing.py b/starlette/routing.py\nindex d718bb9..b5467bb 100644\n--- a/starlette/routing.py\n+++ b/starlette/routing.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import contextlib\n import functools\n import inspect\n@@ -28,7 +30,7 @@ class NoMatchFound(Exception):\n     if no matching route exists.\n     \"\"\"\n \n-    def __init__(self, name: str, path_params: typing.Dict[str, typing.Any]) -> None:\n+    def __init__(self, name: str, path_params: dict[str, typing.Any]) -> None:\n         params = \", \".join(list(path_params.keys()))\n         super().__init__(f'No route exists for name \"{name}\" and params \"{params}\".')\n \n@@ -106,9 +108,9 @@ def get_name(endpoint: typing.Callable[..., typing.Any]) -> str:\n \n def replace_params(\n     path: str,\n-    param_convertors: typing.Dict[str, Convertor[typing.Any]],\n-    path_params: typing.Dict[str, str],\n-) -> typing.Tuple[str, typing.Dict[str, str]]:\n+    param_convertors: dict[str, Convertor[typing.Any]],\n+    path_params: dict[str, str],\n+) -> tuple[str, dict[str, str]]:\n     for key, value in list(path_params.items()):\n         if \"{\" + key + \"}\" in path:\n             convertor = param_convertors[key]\n@@ -124,7 +126,7 @@ PARAM_REGEX = re.compile(\"{([a-zA-Z_][a-zA-Z0-9_]*)(:[a-zA-Z_][a-zA-Z0-9_]*)?}\")\n \n def compile_path(\n     path: str,\n-) -> typing.Tuple[typing.Pattern[str], str, typing.Dict[str, Convertor[typing.Any]]]:\n+) -> tuple[typing.Pattern[str], str, dict[str, Convertor[typing.Any]]]:\n     \"\"\"\n     Given a path string, like: \"/{username:str}\",\n     or a host string, like: \"{subdomain}.mydomain.org\", return a three-tuple\n@@ -181,7 +183,7 @@ def compile_path(\n \n \n class BaseRoute:\n-    def matches(self, scope: Scope) -> typing.Tuple[Match, Scope]:\n+    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n         raise NotImplementedError()  # pragma: no cover\n \n     def url_path_for(self, name: str, /, **path_params: typing.Any) -> URLPath:\n@@ -216,10 +218,10 @@ class Route(BaseRoute):\n         path: str,\n         endpoint: typing.Callable[..., typing.Any],\n         *,\n-        methods: typing.Optional[typing.List[str]] = None,\n-        name: typing.Optional[str] = None,\n+        methods: list[str] | None = None,\n+        name: str | None = None,\n         include_in_schema: bool = True,\n-        middleware: typing.Optional[typing.Sequence[Middleware]] = None,\n+        middleware: typing.Sequence[Middleware] | None = None,\n     ) -> None:\n         assert path.startswith(\"/\"), \"Routed paths must start with '/'\"\n         self.path = path\n@@ -252,7 +254,7 @@ class Route(BaseRoute):\n \n         self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n \n-    def matches(self, scope: Scope) -> typing.Tuple[Match, Scope]:\n+    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n         path_params: \"typing.Dict[str, typing.Any]\"\n         if scope[\"type\"] == \"http\":\n             route_path = get_route_path(scope)\n@@ -317,8 +319,8 @@ class WebSocketRoute(BaseRoute):\n         path: str,\n         endpoint: typing.Callable[..., typing.Any],\n         *,\n-        name: typing.Optional[str] = None,\n-        middleware: typing.Optional[typing.Sequence[Middleware]] = None,\n+        name: str | None = None,\n+        middleware: typing.Sequence[Middleware] | None = None,\n     ) -> None:\n         assert path.startswith(\"/\"), \"Routed paths must start with '/'\"\n         self.path = path\n@@ -341,7 +343,7 @@ class WebSocketRoute(BaseRoute):\n \n         self.path_regex, self.path_format, self.param_convertors = compile_path(path)\n \n-    def matches(self, scope: Scope) -> typing.Tuple[Match, Scope]:\n+    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n         path_params: \"typing.Dict[str, typing.Any]\"\n         if scope[\"type\"] == \"websocket\":\n             route_path = get_route_path(scope)\n@@ -387,11 +389,11 @@ class Mount(BaseRoute):\n     def __init__(\n         self,\n         path: str,\n-        app: typing.Optional[ASGIApp] = None,\n-        routes: typing.Optional[typing.Sequence[BaseRoute]] = None,\n-        name: typing.Optional[str] = None,\n+        app: ASGIApp | None = None,\n+        routes: typing.Sequence[BaseRoute] | None = None,\n+        name: str | None = None,\n         *,\n-        middleware: typing.Optional[typing.Sequence[Middleware]] = None,\n+        middleware: typing.Sequence[Middleware] | None = None,\n     ) -> None:\n         assert path == \"\" or path.startswith(\"/\"), \"Routed paths must start with '/'\"\n         assert (\n@@ -412,7 +414,7 @@ class Mount(BaseRoute):\n         )\n \n     @property\n-    def routes(self) -> typing.List[BaseRoute]:\n+    def routes(self) -> list[BaseRoute]:\n         return getattr(self._base_app, \"routes\", [])\n \n     def matches(self, scope: Scope) -> typing.Tuple[Match, Scope]:\n@@ -498,9 +500,7 @@ class Mount(BaseRoute):\n \n \n class Host(BaseRoute):\n-    def __init__(\n-        self, host: str, app: ASGIApp, name: typing.Optional[str] = None\n-    ) -> None:\n+    def __init__(self, host: str, app: ASGIApp, name: str | None = None) -> None:\n         assert not host.startswith(\"/\"), \"Host must not start with '/'\"\n         self.host = host\n         self.app = app\n@@ -508,10 +508,10 @@ class Host(BaseRoute):\n         self.host_regex, self.host_format, self.param_convertors = compile_path(host)\n \n     @property\n-    def routes(self) -> typing.List[BaseRoute]:\n+    def routes(self) -> list[BaseRoute]:\n         return getattr(self.app, \"routes\", [])\n \n-    def matches(self, scope: Scope) -> typing.Tuple[Match, Scope]:\n+    def matches(self, scope: Scope) -> tuple[Match, Scope]:\n         if scope[\"type\"] in (\"http\", \"websocket\"):\n             headers = Headers(scope=scope)\n             host = headers.get(\"host\", \"\").split(\":\")[0]\n@@ -581,10 +581,10 @@ class _AsyncLiftContextManager(typing.AsyncContextManager[_T]):\n \n     async def __aexit__(\n         self,\n-        exc_type: typing.Optional[typing.Type[BaseException]],\n-        exc_value: typing.Optional[BaseException],\n-        traceback: typing.Optional[types.TracebackType],\n-    ) -> typing.Optional[bool]:\n+        exc_type: type[BaseException] | None,\n+        exc_value: BaseException | None,\n+        traceback: types.TracebackType | None,\n+    ) -> bool | None:\n         return self._cm.__exit__(exc_type, exc_value, traceback)\n \n \n@@ -603,7 +603,7 @@ def _wrap_gen_lifespan_context(\n \n \n class _DefaultLifespan:\n-    def __init__(self, router: \"Router\"):\n+    def __init__(self, router: Router):\n         self._router = router\n \n     async def __aenter__(self) -> None:\n@@ -619,20 +619,16 @@ class _DefaultLifespan:\n class Router:\n     def __init__(\n         self,\n-        routes: typing.Optional[typing.Sequence[BaseRoute]] = None,\n+        routes: typing.Sequence[BaseRoute] | None = None,\n         redirect_slashes: bool = True,\n-        default: typing.Optional[ASGIApp] = None,\n-        on_startup: typing.Optional[\n-            typing.Sequence[typing.Callable[[], typing.Any]]\n-        ] = None,\n-        on_shutdown: typing.Optional[\n-            typing.Sequence[typing.Callable[[], typing.Any]]\n-        ] = None,\n+        default: ASGIApp | None = None,\n+        on_startup: typing.Sequence[typing.Callable[[], typing.Any]] | None = None,\n+        on_shutdown: typing.Sequence[typing.Callable[[], typing.Any]] | None = None,\n         # the generic to Lifespan[AppType] is the type of the top level application\n         # which the router cannot know statically, so we use typing.Any\n-        lifespan: typing.Optional[Lifespan[typing.Any]] = None,\n+        lifespan: Lifespan[typing.Any] | None = None,\n         *,\n-        middleware: typing.Optional[typing.Sequence[Middleware]] = None,\n+        middleware: typing.Sequence[Middleware] | None = None,\n     ) -> None:\n         self.routes = [] if routes is None else list(routes)\n         self.redirect_slashes = redirect_slashes\n@@ -815,13 +811,13 @@ class Router:\n         return isinstance(other, Router) and self.routes == other.routes\n \n     def mount(\n-        self, path: str, app: ASGIApp, name: typing.Optional[str] = None\n+        self, path: str, app: ASGIApp, name: str | None = None\n     ) -> None:  # pragma: nocover\n         route = Mount(path, app=app, name=name)\n         self.routes.append(route)\n \n     def host(\n-        self, host: str, app: ASGIApp, name: typing.Optional[str] = None\n+        self, host: str, app: ASGIApp, name: str | None = None\n     ) -> None:  # pragma: no cover\n         route = Host(host, app=app, name=name)\n         self.routes.append(route)\n@@ -829,11 +825,9 @@ class Router:\n     def add_route(\n         self,\n         path: str,\n-        endpoint: typing.Callable[\n-            [Request], typing.Union[typing.Awaitable[Response], Response]\n-        ],\n-        methods: typing.Optional[typing.List[str]] = None,\n-        name: typing.Optional[str] = None,\n+        endpoint: typing.Callable[[Request], typing.Awaitable[Response] | Response],\n+        methods: list[str] | None = None,\n+        name: str | None = None,\n         include_in_schema: bool = True,\n     ) -> None:  # pragma: nocover\n         route = Route(\n@@ -849,7 +843,7 @@ class Router:\n         self,\n         path: str,\n         endpoint: typing.Callable[[WebSocket], typing.Awaitable[None]],\n-        name: typing.Optional[str] = None,\n+        name: str | None = None,\n     ) -> None:  # pragma: no cover\n         route = WebSocketRoute(path, endpoint=endpoint, name=name)\n         self.routes.append(route)\n@@ -857,8 +851,8 @@ class Router:\n     def route(\n         self,\n         path: str,\n-        methods: typing.Optional[typing.List[str]] = None,\n-        name: typing.Optional[str] = None,\n+        methods: list[str] | None = None,\n+        name: str | None = None,\n         include_in_schema: bool = True,\n     ) -> typing.Callable:  # type: ignore[type-arg]\n         \"\"\"\n@@ -886,9 +880,7 @@ class Router:\n \n         return decorator\n \n-    def websocket_route(\n-        self, path: str, name: typing.Optional[str] = None\n-    ) -> typing.Callable:  # type: ignore[type-arg]\n+    def websocket_route(self, path: str, name: str | None = None) -> typing.Callable:  # type: ignore[type-arg]\n         \"\"\"\n         We no longer document this decorator style API, and its usage is discouraged.\n         Instead you should use the following approach:\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/schemas.py",
            "diff": "diff --git a/starlette/schemas.py b/starlette/schemas.py\nindex 737f6b0..89fa20b 100644\n--- a/starlette/schemas.py\n+++ b/starlette/schemas.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import inspect\n import re\n import typing\n@@ -30,14 +32,10 @@ class EndpointInfo(typing.NamedTuple):\n \n \n class BaseSchemaGenerator:\n-    def get_schema(\n-        self, routes: typing.List[BaseRoute]\n-    ) -> typing.Dict[str, typing.Any]:\n+    def get_schema(self, routes: list[BaseRoute]) -> dict[str, typing.Any]:\n         raise NotImplementedError()  # pragma: no cover\n \n-    def get_endpoints(\n-        self, routes: typing.List[BaseRoute]\n-    ) -> typing.List[EndpointInfo]:\n+    def get_endpoints(self, routes: list[BaseRoute]) -> list[EndpointInfo]:\n         \"\"\"\n         Given the routes, yields the following information:\n \n@@ -48,7 +46,7 @@ class BaseSchemaGenerator:\n         - func\n             method ready to extract the docstring\n         \"\"\"\n-        endpoints_info: typing.List[EndpointInfo] = []\n+        endpoints_info: list[EndpointInfo] = []\n \n         for route in routes:\n             if isinstance(route, (Mount, Host)):\n@@ -99,7 +97,7 @@ class BaseSchemaGenerator:\n \n     def parse_docstring(\n         self, func_or_method: typing.Callable[..., typing.Any]\n-    ) -> typing.Dict[str, typing.Any]:\n+    ) -> dict[str, typing.Any]:\n         \"\"\"\n         Given a function, parse the docstring as YAML and return a dictionary of info.\n         \"\"\"\n@@ -130,12 +128,10 @@ class BaseSchemaGenerator:\n \n \n class SchemaGenerator(BaseSchemaGenerator):\n-    def __init__(self, base_schema: typing.Dict[str, typing.Any]) -> None:\n+    def __init__(self, base_schema: dict[str, typing.Any]) -> None:\n         self.base_schema = base_schema\n \n-    def get_schema(\n-        self, routes: typing.List[BaseRoute]\n-    ) -> typing.Dict[str, typing.Any]:\n+    def get_schema(self, routes: list[BaseRoute]) -> dict[str, typing.Any]:\n         schema = dict(self.base_schema)\n         schema.setdefault(\"paths\", {})\n         endpoints_info = self.get_endpoints(routes)\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/staticfiles.py",
            "diff": "diff --git a/starlette/staticfiles.py b/starlette/staticfiles.py\nindex 5261440..5d0856c 100644\n--- a/starlette/staticfiles.py\n+++ b/starlette/staticfiles.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import importlib.util\n import os\n import stat\n@@ -41,10 +43,8 @@ class StaticFiles:\n     def __init__(\n         self,\n         *,\n-        directory: typing.Optional[PathLike] = None,\n-        packages: typing.Optional[\n-            typing.List[typing.Union[str, typing.Tuple[str, str]]]\n-        ] = None,\n+        directory: PathLike | None = None,\n+        packages: list[str | tuple[str, str]] | None = None,\n         html: bool = False,\n         check_dir: bool = True,\n         follow_symlink: bool = False,\n@@ -60,11 +60,9 @@ class StaticFiles:\n \n     def get_directories(\n         self,\n-        directory: typing.Optional[PathLike] = None,\n-        packages: typing.Optional[\n-            typing.List[typing.Union[str, typing.Tuple[str, str]]]\n-        ] = None,\n-    ) -> typing.List[PathLike]:\n+        directory: PathLike | None = None,\n+        packages: list[str | tuple[str, str]] | None = None,\n+    ) -> list[PathLike]:\n         \"\"\"\n         Given `directory` and `packages` arguments, return a list of all the\n         directories that should be used for serving static files from.\n@@ -157,9 +155,7 @@ class StaticFiles:\n                 return FileResponse(full_path, stat_result=stat_result, status_code=404)\n         raise HTTPException(status_code=404)\n \n-    def lookup_path(\n-        self, path: str\n-    ) -> typing.Tuple[str, typing.Optional[os.stat_result]]:\n+    def lookup_path(self, path: str) -> tuple[str, os.stat_result | None]:\n         for directory in self.all_directories:\n             joined_path = os.path.join(directory, path)\n             if self.follow_symlink:\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/status.py",
            "diff": "diff --git a/starlette/status.py b/starlette/status.py\nindex 1689328..2cd5db5 100644\n--- a/starlette/status.py\n+++ b/starlette/status.py\n@@ -5,8 +5,9 @@ https://www.iana.org/assignments/http-status-codes/http-status-codes.xhtml\n \n And RFC 2324 - https://tools.ietf.org/html/rfc2324\n \"\"\"\n+from __future__ import annotations\n+\n import warnings\n-from typing import List\n \n __all__ = (\n     \"HTTP_100_CONTINUE\",\n@@ -195,5 +196,5 @@ def __getattr__(name: str) -> int:\n     raise AttributeError(f\"module '{__name__}' has no attribute '{name}'\")\n \n \n-def __dir__() -> List[str]:\n+def __dir__() -> list[str]:\n     return sorted(list(__all__) + list(__deprecated__.keys()))  # pragma: no cover\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/templating.py",
            "diff": "diff --git a/starlette/templating.py b/starlette/templating.py\nindex c2078d2..fe31ab5 100644\n--- a/starlette/templating.py\n+++ b/starlette/templating.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import typing\n import warnings\n from os import PathLike\n@@ -27,11 +29,11 @@ class _TemplateResponse(HTMLResponse):\n     def __init__(\n         self,\n         template: typing.Any,\n-        context: typing.Dict[str, typing.Any],\n+        context: dict[str, typing.Any],\n         status_code: int = 200,\n-        headers: typing.Optional[typing.Mapping[str, str]] = None,\n-        media_type: typing.Optional[str] = None,\n-        background: typing.Optional[BackgroundTask] = None,\n+        headers: typing.Mapping[str, str] | None = None,\n+        media_type: str | None = None,\n+        background: BackgroundTask | None = None,\n     ):\n         self.template = template\n         self.context = context\n@@ -64,11 +66,12 @@ class Jinja2Templates:\n     @typing.overload\n     def __init__(\n         self,\n-        directory: \"typing.Union[str, PathLike[typing.AnyStr], typing.Sequence[typing.Union[str, PathLike[typing.AnyStr]]]]\",  # noqa: E501\n+        directory: str\n+        | PathLike[typing.AnyStr]\n+        | typing.Sequence[str | PathLike[typing.AnyStr]],\n         *,\n-        context_processors: typing.Optional[\n-            typing.List[typing.Callable[[Request], typing.Dict[str, typing.Any]]]\n-        ] = None,\n+        context_processors: list[typing.Callable[[Request], dict[str, typing.Any]]]\n+        | None = None,\n         **env_options: typing.Any,\n     ) -> None:\n         ...\n@@ -77,21 +80,22 @@ class Jinja2Templates:\n     def __init__(\n         self,\n         *,\n-        env: \"jinja2.Environment\",\n-        context_processors: typing.Optional[\n-            typing.List[typing.Callable[[Request], typing.Dict[str, typing.Any]]]\n-        ] = None,\n+        env: jinja2.Environment,\n+        context_processors: list[typing.Callable[[Request], dict[str, typing.Any]]]\n+        | None = None,\n     ) -> None:\n         ...\n \n     def __init__(\n         self,\n-        directory: \"typing.Union[str, PathLike[typing.AnyStr], typing.Sequence[typing.Union[str, PathLike[typing.AnyStr]]], None]\" = None,  # noqa: E501\n+        directory: str\n+        | PathLike[typing.AnyStr]\n+        | typing.Sequence[str | PathLike[typing.AnyStr]]\n+        | None = None,\n         *,\n-        context_processors: typing.Optional[\n-            typing.List[typing.Callable[[Request], typing.Dict[str, typing.Any]]]\n-        ] = None,\n-        env: typing.Optional[\"jinja2.Environment\"] = None,\n+        context_processors: list[typing.Callable[[Request], dict[str, typing.Any]]]\n+        | None = None,\n+        env: jinja2.Environment | None = None,\n         **env_options: typing.Any,\n     ) -> None:\n         if env_options:\n@@ -111,16 +115,18 @@ class Jinja2Templates:\n \n     def _create_env(\n         self,\n-        directory: \"typing.Union[str, PathLike[typing.AnyStr], typing.Sequence[typing.Union[str, PathLike[typing.AnyStr]]]]\",  # noqa: E501\n+        directory: str\n+        | PathLike[typing.AnyStr]\n+        | typing.Sequence[str | PathLike[typing.AnyStr]],\n         **env_options: typing.Any,\n-    ) -> \"jinja2.Environment\":\n+    ) -> jinja2.Environment:\n         loader = jinja2.FileSystemLoader(directory)\n         env_options.setdefault(\"loader\", loader)\n         env_options.setdefault(\"autoescape\", True)\n \n         return jinja2.Environment(**env_options)\n \n-    def _setup_env_defaults(self, env: \"jinja2.Environment\") -> None:\n+    def _setup_env_defaults(self, env: jinja2.Environment) -> None:\n         @pass_context\n         def url_for(\n             context: typing.Dict[str, typing.Any],\n@@ -133,7 +139,7 @@ class Jinja2Templates:\n \n         env.globals.setdefault(\"url_for\", url_for)\n \n-    def get_template(self, name: str) -> \"jinja2.Template\":\n+    def get_template(self, name: str) -> jinja2.Template:\n         return self.env.get_template(name)\n \n     @typing.overload\n@@ -141,11 +147,11 @@ class Jinja2Templates:\n         self,\n         request: Request,\n         name: str,\n-        context: typing.Optional[typing.Dict[str, typing.Any]] = None,\n+        context: dict[str, typing.Any] | None = None,\n         status_code: int = 200,\n-        headers: typing.Optional[typing.Mapping[str, str]] = None,\n-        media_type: typing.Optional[str] = None,\n-        background: typing.Optional[BackgroundTask] = None,\n+        headers: typing.Mapping[str, str] | None = None,\n+        media_type: str | None = None,\n+        background: BackgroundTask | None = None,\n     ) -> _TemplateResponse:\n         ...\n \n@@ -153,11 +159,11 @@ class Jinja2Templates:\n     def TemplateResponse(\n         self,\n         name: str,\n-        context: typing.Optional[typing.Dict[str, typing.Any]] = None,\n+        context: dict[str, typing.Any] | None = None,\n         status_code: int = 200,\n-        headers: typing.Optional[typing.Mapping[str, str]] = None,\n-        media_type: typing.Optional[str] = None,\n-        background: typing.Optional[BackgroundTask] = None,\n+        headers: typing.Mapping[str, str] | None = None,\n+        media_type: str | None = None,\n+        background: BackgroundTask | None = None,\n     ) -> _TemplateResponse:\n         # Deprecated usage\n         ...\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/testclient.py",
            "diff": "diff --git a/starlette/testclient.py b/starlette/testclient.py\nindex 149fbb0..f5cb081 100644\n--- a/starlette/testclient.py\n+++ b/starlette/testclient.py\n@@ -1,9 +1,12 @@\n+from __future__ import annotations\n+\n import contextlib\n import inspect\n import io\n import json\n import math\n import queue\n+import sys\n import typing\n import warnings\n from concurrent.futures import Future\n@@ -11,6 +14,7 @@ from types import GeneratorType\n from urllib.parse import unquote, urljoin\n \n import anyio\n+import anyio.abc\n import anyio.from_thread\n from anyio.abc import ObjectReceiveStream, ObjectSendStream\n from anyio.streams.stapled import StapledObjectStream\n@@ -19,6 +23,11 @@ from starlette._utils import is_async_callable\n from starlette.types import ASGIApp, Message, Receive, Scope, Send\n from starlette.websockets import WebSocketDisconnect\n \n+if sys.version_info >= (3, 10):  # pragma: no cover\n+    from typing import TypeGuard\n+else:  # pragma: no cover\n+    from typing_extensions import TypeGuard\n+\n try:\n     import httpx\n except ModuleNotFoundError:  # pragma: no cover\n@@ -39,7 +48,7 @@ ASGI3App = typing.Callable[[Scope, Receive, Send], typing.Awaitable[None]]\n _RequestData = typing.Mapping[str, typing.Union[str, typing.Iterable[str]]]\n \n \n-def _is_asgi3(app: typing.Union[ASGI2App, ASGI3App]) -> bool:\n+def _is_asgi3(app: ASGI2App | ASGI3App) -> TypeGuard[ASGI3App]:\n     if inspect.isclass(app):\n         return hasattr(app, \"__await__\")\n     return is_async_callable(app)\n@@ -60,11 +69,11 @@ class _WrapASGI2:\n \n class _AsyncBackend(typing.TypedDict):\n     backend: str\n-    backend_options: typing.Dict[str, typing.Any]\n+    backend_options: dict[str, typing.Any]\n \n \n class _Upgrade(Exception):\n-    def __init__(self, session: \"WebSocketTestSession\") -> None:\n+    def __init__(self, session: WebSocketTestSession) -> None:\n         self.session = session\n \n \n@@ -79,11 +88,11 @@ class WebSocketTestSession:\n         self.scope = scope\n         self.accepted_subprotocol = None\n         self.portal_factory = portal_factory\n-        self._receive_queue: \"queue.Queue[Message]\" = queue.Queue()\n-        self._send_queue: \"queue.Queue[Message | BaseException]\" = queue.Queue()\n+        self._receive_queue: queue.Queue[Message] = queue.Queue()\n+        self._send_queue: queue.Queue[Message | BaseException] = queue.Queue()\n         self.extra_headers = None\n \n-    def __enter__(self) -> \"WebSocketTestSession\":\n+    def __enter__(self) -> WebSocketTestSession:\n         self.exit_stack = contextlib.ExitStack()\n         self.portal = self.exit_stack.enter_context(self.portal_factory())\n \n@@ -145,15 +154,16 @@ class WebSocketTestSession:\n     def send_bytes(self, data: bytes) -> None:\n         self.send({\"type\": \"websocket.receive\", \"bytes\": data})\n \n-    def send_json(self, data: typing.Any, mode: str = \"text\") -> None:\n-        assert mode in [\"text\", \"binary\"]\n+    def send_json(\n+        self, data: typing.Any, mode: typing.Literal[\"text\", \"binary\"] = \"text\"\n+    ) -> None:\n         text = json.dumps(data, separators=(\",\", \":\"), ensure_ascii=False)\n         if mode == \"text\":\n             self.send({\"type\": \"websocket.receive\", \"text\": text})\n         else:\n             self.send({\"type\": \"websocket.receive\", \"bytes\": text.encode(\"utf-8\")})\n \n-    def close(self, code: int = 1000, reason: typing.Union[str, None] = None) -> None:\n+    def close(self, code: int = 1000, reason: str | None = None) -> None:\n         self.send({\"type\": \"websocket.disconnect\", \"code\": code, \"reason\": reason})\n \n     def receive(self) -> Message:\n@@ -172,8 +182,9 @@ class WebSocketTestSession:\n         self._raise_on_close(message)\n         return typing.cast(bytes, message[\"bytes\"])\n \n-    def receive_json(self, mode: str = \"text\") -> typing.Any:\n-        assert mode in [\"text\", \"binary\"]\n+    def receive_json(\n+        self, mode: typing.Literal[\"text\", \"binary\"] = \"text\"\n+    ) -> typing.Any:\n         message = self.receive()\n         self._raise_on_close(message)\n         if mode == \"text\":\n@@ -191,7 +202,7 @@ class _TestClientTransport(httpx.BaseTransport):\n         raise_server_exceptions: bool = True,\n         root_path: str = \"\",\n         *,\n-        app_state: typing.Dict[str, typing.Any],\n+        app_state: dict[str, typing.Any],\n     ) -> None:\n         self.app = app\n         self.raise_server_exceptions = raise_server_exceptions\n@@ -217,7 +228,7 @@ class _TestClientTransport(httpx.BaseTransport):\n \n         # Include the 'host' header.\n         if \"host\" in request.headers:\n-            headers: typing.List[typing.Tuple[bytes, bytes]] = []\n+            headers: list[tuple[bytes, bytes]] = []\n         elif port == default_port:  # pragma: no cover\n             headers = [(b\"host\", host.encode())]\n         else:  # pragma: no cover\n@@ -229,7 +240,7 @@ class _TestClientTransport(httpx.BaseTransport):\n             for key, value in request.headers.multi_items()\n         ]\n \n-        scope: typing.Dict[str, typing.Any]\n+        scope: dict[str, typing.Any]\n \n         if scheme in {\"ws\", \"wss\"}:\n             subprotocol = request.headers.get(\"sec-websocket-protocol\", None)\n@@ -272,7 +283,7 @@ class _TestClientTransport(httpx.BaseTransport):\n         request_complete = False\n         response_started = False\n         response_complete: anyio.Event\n-        raw_kwargs: typing.Dict[str, typing.Any] = {\"stream\": io.BytesIO()}\n+        raw_kwargs: dict[str, typing.Any] = {\"stream\": io.BytesIO()}\n         template = None\n         context = None\n \n@@ -363,8 +374,8 @@ class _TestClientTransport(httpx.BaseTransport):\n \n class TestClient(httpx.Client):\n     __test__ = False\n-    task: \"Future[None]\"\n-    portal: typing.Optional[anyio.abc.BlockingPortal] = None\n+    task: Future[None]\n+    portal: anyio.abc.BlockingPortal | None = None\n \n     def __init__(\n         self,\n@@ -372,23 +383,22 @@ class TestClient(httpx.Client):\n         base_url: str = \"http://testserver\",\n         raise_server_exceptions: bool = True,\n         root_path: str = \"\",\n-        backend: str = \"asyncio\",\n-        backend_options: typing.Optional[typing.Dict[str, typing.Any]] = None,\n-        cookies: httpx._types.CookieTypes = None,\n-        headers: typing.Dict[str, str] = None,\n+        backend: typing.Literal[\"asyncio\", \"trio\"] = \"asyncio\",\n+        backend_options: dict[str, typing.Any] | None = None,\n+        cookies: httpx._types.CookieTypes | None = None,\n+        headers: dict[str, str] | None = None,\n         follow_redirects: bool = True,\n     ) -> None:\n         self.async_backend = _AsyncBackend(\n             backend=backend, backend_options=backend_options or {}\n         )\n         if _is_asgi3(app):\n-            app = typing.cast(ASGI3App, app)\n             asgi_app = app\n         else:\n             app = typing.cast(ASGI2App, app)  # type: ignore[assignment]\n             asgi_app = _WrapASGI2(app)  # type: ignore[arg-type]\n         self.app = asgi_app\n-        self.app_state: typing.Dict[str, typing.Any] = {}\n+        self.app_state: dict[str, typing.Any] = {}\n         transport = _TestClientTransport(\n             self.app,\n             portal_factory=self._portal_factory,\n@@ -420,12 +430,12 @@ class TestClient(httpx.Client):\n \n     def _choose_redirect_arg(\n         self,\n-        follow_redirects: typing.Optional[bool],\n-        allow_redirects: typing.Optional[bool],\n-    ) -> typing.Union[bool, httpx._client.UseClientDefault]:\n-        redirect: typing.Union[\n-            bool, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT\n+        follow_redirects: bool | None,\n+        allow_redirects: bool | None,\n+    ) -> bool | httpx._client.UseClientDefault:\n+        redirect: bool | httpx._client.UseClientDefault = (\n+            httpx._client.USE_CLIENT_DEFAULT\n+        )\n         if allow_redirects is not None:\n             message = (\n                 \"The `allow_redirects` argument is deprecated. \"\n@@ -446,22 +456,20 @@ class TestClient(httpx.Client):\n         method: str,\n         url: httpx._types.URLTypes,\n         *,\n-        content: typing.Optional[httpx._types.RequestContent] = None,\n-        data: typing.Optional[_RequestData] = None,\n-        files: typing.Optional[httpx._types.RequestFiles] = None,\n+        content: httpx._types.RequestContent | None = None,\n+        data: _RequestData | None = None,\n+        files: httpx._types.RequestFiles | None = None,\n         json: typing.Any = None,\n-        params: typing.Optional[httpx._types.QueryParamTypes] = None,\n-        headers: typing.Optional[httpx._types.HeaderTypes] = None,\n-        cookies: typing.Optional[httpx._types.CookieTypes] = None,\n-        auth: typing.Union[\n-            httpx._types.AuthTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        follow_redirects: typing.Optional[bool] = None,\n-        allow_redirects: typing.Optional[bool] = None,\n-        timeout: typing.Union[\n-            httpx._types.TimeoutTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        extensions: typing.Optional[typing.Dict[str, typing.Any]] = None,\n+        params: httpx._types.QueryParamTypes | None = None,\n+        headers: httpx._types.HeaderTypes | None = None,\n+        cookies: httpx._types.CookieTypes | None = None,\n+        auth: httpx._types.AuthTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        follow_redirects: bool | None = None,\n+        allow_redirects: bool | None = None,\n+        timeout: httpx._types.TimeoutTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        extensions: dict[str, typing.Any] | None = None,\n     ) -> httpx.Response:\n         url = self._merge_url(url)\n         redirect = self._choose_redirect_arg(follow_redirects, allow_redirects)\n@@ -485,18 +493,16 @@ class TestClient(httpx.Client):\n         self,\n         url: httpx._types.URLTypes,\n         *,\n-        params: typing.Optional[httpx._types.QueryParamTypes] = None,\n-        headers: typing.Optional[httpx._types.HeaderTypes] = None,\n-        cookies: typing.Optional[httpx._types.CookieTypes] = None,\n-        auth: typing.Union[\n-            httpx._types.AuthTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        follow_redirects: typing.Optional[bool] = None,\n-        allow_redirects: typing.Optional[bool] = None,\n-        timeout: typing.Union[\n-            httpx._types.TimeoutTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        extensions: typing.Optional[typing.Dict[str, typing.Any]] = None,\n+        params: httpx._types.QueryParamTypes | None = None,\n+        headers: httpx._types.HeaderTypes | None = None,\n+        cookies: httpx._types.CookieTypes | None = None,\n+        auth: httpx._types.AuthTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        follow_redirects: bool | None = None,\n+        allow_redirects: bool | None = None,\n+        timeout: httpx._types.TimeoutTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        extensions: dict[str, typing.Any] | None = None,\n     ) -> httpx.Response:\n         redirect = self._choose_redirect_arg(follow_redirects, allow_redirects)\n         return super().get(\n@@ -514,18 +520,16 @@ class TestClient(httpx.Client):\n         self,\n         url: httpx._types.URLTypes,\n         *,\n-        params: typing.Optional[httpx._types.QueryParamTypes] = None,\n-        headers: typing.Optional[httpx._types.HeaderTypes] = None,\n-        cookies: typing.Optional[httpx._types.CookieTypes] = None,\n-        auth: typing.Union[\n-            httpx._types.AuthTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        follow_redirects: typing.Optional[bool] = None,\n-        allow_redirects: typing.Optional[bool] = None,\n-        timeout: typing.Union[\n-            httpx._types.TimeoutTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        extensions: typing.Optional[typing.Dict[str, typing.Any]] = None,\n+        params: httpx._types.QueryParamTypes | None = None,\n+        headers: httpx._types.HeaderTypes | None = None,\n+        cookies: httpx._types.CookieTypes | None = None,\n+        auth: httpx._types.AuthTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        follow_redirects: bool | None = None,\n+        allow_redirects: bool | None = None,\n+        timeout: httpx._types.TimeoutTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        extensions: dict[str, typing.Any] | None = None,\n     ) -> httpx.Response:\n         redirect = self._choose_redirect_arg(follow_redirects, allow_redirects)\n         return super().options(\n@@ -543,18 +547,16 @@ class TestClient(httpx.Client):\n         self,\n         url: httpx._types.URLTypes,\n         *,\n-        params: typing.Optional[httpx._types.QueryParamTypes] = None,\n-        headers: typing.Optional[httpx._types.HeaderTypes] = None,\n-        cookies: typing.Optional[httpx._types.CookieTypes] = None,\n-        auth: typing.Union[\n-            httpx._types.AuthTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        follow_redirects: typing.Optional[bool] = None,\n-        allow_redirects: typing.Optional[bool] = None,\n-        timeout: typing.Union[\n-            httpx._types.TimeoutTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        extensions: typing.Optional[typing.Dict[str, typing.Any]] = None,\n+        params: httpx._types.QueryParamTypes | None = None,\n+        headers: httpx._types.HeaderTypes | None = None,\n+        cookies: httpx._types.CookieTypes | None = None,\n+        auth: httpx._types.AuthTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        follow_redirects: bool | None = None,\n+        allow_redirects: bool | None = None,\n+        timeout: httpx._types.TimeoutTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        extensions: dict[str, typing.Any] | None = None,\n     ) -> httpx.Response:\n         redirect = self._choose_redirect_arg(follow_redirects, allow_redirects)\n         return super().head(\n@@ -572,22 +574,20 @@ class TestClient(httpx.Client):\n         self,\n         url: httpx._types.URLTypes,\n         *,\n-        content: typing.Optional[httpx._types.RequestContent] = None,\n-        data: typing.Optional[_RequestData] = None,\n-        files: typing.Optional[httpx._types.RequestFiles] = None,\n+        content: httpx._types.RequestContent | None = None,\n+        data: _RequestData | None = None,\n+        files: httpx._types.RequestFiles | None = None,\n         json: typing.Any = None,\n-        params: typing.Optional[httpx._types.QueryParamTypes] = None,\n-        headers: typing.Optional[httpx._types.HeaderTypes] = None,\n-        cookies: typing.Optional[httpx._types.CookieTypes] = None,\n-        auth: typing.Union[\n-            httpx._types.AuthTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        follow_redirects: typing.Optional[bool] = None,\n-        allow_redirects: typing.Optional[bool] = None,\n-        timeout: typing.Union[\n-            httpx._types.TimeoutTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        extensions: typing.Optional[typing.Dict[str, typing.Any]] = None,\n+        params: httpx._types.QueryParamTypes | None = None,\n+        headers: httpx._types.HeaderTypes | None = None,\n+        cookies: httpx._types.CookieTypes | None = None,\n+        auth: httpx._types.AuthTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        follow_redirects: bool | None = None,\n+        allow_redirects: bool | None = None,\n+        timeout: httpx._types.TimeoutTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        extensions: dict[str, typing.Any] | None = None,\n     ) -> httpx.Response:\n         redirect = self._choose_redirect_arg(follow_redirects, allow_redirects)\n         return super().post(\n@@ -609,22 +609,20 @@ class TestClient(httpx.Client):\n         self,\n         url: httpx._types.URLTypes,\n         *,\n-        content: typing.Optional[httpx._types.RequestContent] = None,\n-        data: typing.Optional[_RequestData] = None,\n-        files: typing.Optional[httpx._types.RequestFiles] = None,\n+        content: httpx._types.RequestContent | None = None,\n+        data: _RequestData | None = None,\n+        files: httpx._types.RequestFiles | None = None,\n         json: typing.Any = None,\n-        params: typing.Optional[httpx._types.QueryParamTypes] = None,\n-        headers: typing.Optional[httpx._types.HeaderTypes] = None,\n-        cookies: typing.Optional[httpx._types.CookieTypes] = None,\n-        auth: typing.Union[\n-            httpx._types.AuthTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        follow_redirects: typing.Optional[bool] = None,\n-        allow_redirects: typing.Optional[bool] = None,\n-        timeout: typing.Union[\n-            httpx._types.TimeoutTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        extensions: typing.Optional[typing.Dict[str, typing.Any]] = None,\n+        params: httpx._types.QueryParamTypes | None = None,\n+        headers: httpx._types.HeaderTypes | None = None,\n+        cookies: httpx._types.CookieTypes | None = None,\n+        auth: httpx._types.AuthTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        follow_redirects: bool | None = None,\n+        allow_redirects: bool | None = None,\n+        timeout: httpx._types.TimeoutTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        extensions: dict[str, typing.Any] | None = None,\n     ) -> httpx.Response:\n         redirect = self._choose_redirect_arg(follow_redirects, allow_redirects)\n         return super().put(\n@@ -646,22 +644,20 @@ class TestClient(httpx.Client):\n         self,\n         url: httpx._types.URLTypes,\n         *,\n-        content: typing.Optional[httpx._types.RequestContent] = None,\n-        data: typing.Optional[_RequestData] = None,\n-        files: typing.Optional[httpx._types.RequestFiles] = None,\n+        content: httpx._types.RequestContent | None = None,\n+        data: _RequestData | None = None,\n+        files: httpx._types.RequestFiles | None = None,\n         json: typing.Any = None,\n-        params: typing.Optional[httpx._types.QueryParamTypes] = None,\n-        headers: typing.Optional[httpx._types.HeaderTypes] = None,\n-        cookies: typing.Optional[httpx._types.CookieTypes] = None,\n-        auth: typing.Union[\n-            httpx._types.AuthTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        follow_redirects: typing.Optional[bool] = None,\n-        allow_redirects: typing.Optional[bool] = None,\n-        timeout: typing.Union[\n-            httpx._types.TimeoutTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        extensions: typing.Optional[typing.Dict[str, typing.Any]] = None,\n+        params: httpx._types.QueryParamTypes | None = None,\n+        headers: httpx._types.HeaderTypes | None = None,\n+        cookies: httpx._types.CookieTypes | None = None,\n+        auth: httpx._types.AuthTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        follow_redirects: bool | None = None,\n+        allow_redirects: bool | None = None,\n+        timeout: httpx._types.TimeoutTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        extensions: dict[str, typing.Any] | None = None,\n     ) -> httpx.Response:\n         redirect = self._choose_redirect_arg(follow_redirects, allow_redirects)\n         return super().patch(\n@@ -683,18 +679,16 @@ class TestClient(httpx.Client):\n         self,\n         url: httpx._types.URLTypes,\n         *,\n-        params: typing.Optional[httpx._types.QueryParamTypes] = None,\n-        headers: typing.Optional[httpx._types.HeaderTypes] = None,\n-        cookies: typing.Optional[httpx._types.CookieTypes] = None,\n-        auth: typing.Union[\n-            httpx._types.AuthTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        follow_redirects: typing.Optional[bool] = None,\n-        allow_redirects: typing.Optional[bool] = None,\n-        timeout: typing.Union[\n-            httpx._types.TimeoutTypes, httpx._client.UseClientDefault\n-        ] = httpx._client.USE_CLIENT_DEFAULT,\n-        extensions: typing.Optional[typing.Dict[str, typing.Any]] = None,\n+        params: httpx._types.QueryParamTypes | None = None,\n+        headers: httpx._types.HeaderTypes | None = None,\n+        cookies: httpx._types.CookieTypes | None = None,\n+        auth: httpx._types.AuthTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        follow_redirects: bool | None = None,\n+        allow_redirects: bool | None = None,\n+        timeout: httpx._types.TimeoutTypes\n+        | httpx._client.UseClientDefault = httpx._client.USE_CLIENT_DEFAULT,\n+        extensions: dict[str, typing.Any] | None = None,\n     ) -> httpx.Response:\n         redirect = self._choose_redirect_arg(follow_redirects, allow_redirects)\n         return super().delete(\n@@ -709,8 +703,11 @@ class TestClient(httpx.Client):\n         )\n \n     def websocket_connect(\n-        self, url: str, subprotocols: typing.Sequence[str] = None, **kwargs: typing.Any\n-    ) -> \"WebSocketTestSession\":\n+        self,\n+        url: str,\n+        subprotocols: typing.Sequence[str] | None = None,\n+        **kwargs: typing.Any,\n+    ) -> WebSocketTestSession:\n         url = urljoin(\"ws://testserver\", url)\n         headers = kwargs.get(\"headers\", {})\n         headers.setdefault(\"connection\", \"upgrade\")\n@@ -728,7 +725,7 @@ class TestClient(httpx.Client):\n \n         return session\n \n-    def __enter__(self) -> \"TestClient\":\n+    def __enter__(self) -> TestClient:\n         with contextlib.ExitStack() as stack:\n             self.portal = portal = stack.enter_context(\n                 anyio.from_thread.start_blocking_portal(**self.async_backend)\n@@ -738,12 +735,8 @@ class TestClient(httpx.Client):\n             def reset_portal() -> None:\n                 self.portal = None\n \n-            send1: ObjectSendStream[\n-                typing.Optional[typing.MutableMapping[str, typing.Any]]\n-            ]\n-            receive1: ObjectReceiveStream[\n-                typing.Optional[typing.MutableMapping[str, typing.Any]]\n-            ]\n+            send1: ObjectSendStream[typing.MutableMapping[str, typing.Any] | None]\n+            receive1: ObjectReceiveStream[typing.MutableMapping[str, typing.Any] | None]\n             send2: ObjectSendStream[typing.MutableMapping[str, typing.Any]]\n             receive2: ObjectReceiveStream[typing.MutableMapping[str, typing.Any]]\n             send1, receive1 = anyio.create_memory_object_stream(math.inf)\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/types.py",
            "diff": "diff --git a/starlette/types.py b/starlette/types.py\nindex 1948430..f78dd63 100644\n--- a/starlette/types.py\n+++ b/starlette/types.py\n@@ -22,7 +22,7 @@ StatefulLifespan = typing.Callable[\n Lifespan = typing.Union[StatelessLifespan[AppType], StatefulLifespan[AppType]]\n \n HTTPExceptionHandler = typing.Callable[\n-    [\"Request\", Exception], typing.Union[\"Response\", typing.Awaitable[\"Response\"]]\n+    [\"Request\", Exception], \"Response | typing.Awaitable[Response]\"\n ]\n WebSocketExceptionHandler = typing.Callable[\n     [\"WebSocket\", Exception], typing.Awaitable[None]\n"
        },
        {
            "commit": "e21f666b44b5c2ddf22f9a9d057787811dc92a30",
            "file_path": "starlette/websockets.py",
            "diff": "diff --git a/starlette/websockets.py b/starlette/websockets.py\nindex a34bc13..14aaa9c 100644\n--- a/starlette/websockets.py\n+++ b/starlette/websockets.py\n@@ -1,3 +1,5 @@\n+from __future__ import annotations\n+\n import enum\n import json\n import typing\n@@ -88,8 +90,8 @@ class WebSocket(HTTPConnection):\n \n     async def accept(\n         self,\n-        subprotocol: typing.Optional[str] = None,\n-        headers: typing.Optional[typing.Iterable[typing.Tuple[bytes, bytes]]] = None,\n+        subprotocol: str | None = None,\n+        headers: typing.Iterable[tuple[bytes, bytes]] | None = None,\n     ) -> None:\n         headers = headers or []\n \n@@ -174,16 +176,14 @@ class WebSocket(HTTPConnection):\n         else:\n             await self.send({\"type\": \"websocket.send\", \"bytes\": text.encode(\"utf-8\")})\n \n-    async def close(\n-        self, code: int = 1000, reason: typing.Optional[str] = None\n-    ) -> None:\n+    async def close(self, code: int = 1000, reason: str | None = None) -> None:\n         await self.send(\n             {\"type\": \"websocket.close\", \"code\": code, \"reason\": reason or \"\"}\n         )\n \n \n class WebSocketClose:\n-    def __init__(self, code: int = 1000, reason: typing.Optional[str] = None) -> None:\n+    def __init__(self, code: int = 1000, reason: str | None = None) -> None:\n         self.code = code\n         self.reason = reason or \"\"\n \n"
        }
    ]
}
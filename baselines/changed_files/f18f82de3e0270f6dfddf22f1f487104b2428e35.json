{
    "sha_fail": "f18f82de3e0270f6dfddf22f1f487104b2428e35",
    "changed_files": [
        {
            "commit": "f18f82de3e0270f6dfddf22f1f487104b2428e35",
            "file_path": "cloudinit/sources/DataSourceWSL.py",
            "diff": "diff --git a/cloudinit/sources/DataSourceWSL.py b/cloudinit/sources/DataSourceWSL.py\nindex 5ece0bc0..c32de6b1 100644\n--- a/cloudinit/sources/DataSourceWSL.py\n+++ b/cloudinit/sources/DataSourceWSL.py\n@@ -121,3 +121,107 @@ def win_user_profile_dir() -> Optional[PurePath]:\n         return None\n \n     return win_path_2_wsl(home.rstrip())\n+\n+\n+def machine_id():\n+    \"\"\"\n+    Returns the local machine ID value from /etc/machine-id.\n+    \"\"\"\n+    MACHINE_ID_FILE = \"/etc/machine-id\"\n+\n+    if util.wait_for_files([MACHINE_ID_FILE], 2.0):\n+        LOG.debug(\"%s file not found\", MACHINE_ID_FILE)\n+        return None\n+\n+    return util.load_file(MACHINE_ID_FILE, decode=True)\n+\n+\n+def candidate_user_data_file_names(instance_name) -> List[str]:\n+    \"\"\"\n+    Return a list of candidate file names that may contain user-data\n+    in some supported format, ordered by precedence.\n+    \"\"\"\n+    lsb_rel = util.lsb_release()\n+    distribution_id = lsb_rel[\"id\"]\n+    release_codename = lsb_rel[\"codename\"]\n+\n+    return [\n+        # WSL instance specific:\n+        \"%s.user-data\" % instance_name,\n+        # release codename specific\n+        \"%s-%s.user-data\" % (distribution_id, release_codename),\n+        # distribution specific (Alpine, Arch, Fedora, openSUSE, Ubuntu...)\n+        \"%s-all.user-data\" % distribution_id,\n+        # generic, valid for all WSL distros and instances.\n+        \"config.user-data\",\n+    ]\n+\n+\n+class DataSourceWSL(sources.DataSource):\n+    dsname = \"WSL\"\n+\n+    def __init__(self, sys_cfg, distro, paths):\n+        sources.DataSource.__init__(self, sys_cfg, distro, paths)\n+        self._network_config = sources.UNSET\n+        self.dsmode = sources.DSMODE_LOCAL\n+        self.distro = distro\n+        self.instance_name = instance_name()\n+\n+    def find_user_data_file(self) -> Optional[PurePath]:\n+        \"\"\"\n+        Finds the most precendent of the candidate files that may contain\n+        user-data, if any, or None otherwise.\n+        \"\"\"\n+        profile_dir = win_user_profile_dir()\n+        if profile_dir is None:\n+            LOG.warning(\n+                \"Cannot proceed without finding the Windows %USERPROFILE% dir.\"\n+            )\n+            return None\n+\n+        seed_dir = os.path.join(profile_dir, \".cloud-init\")\n+        if not os.path.isdir(seed_dir):\n+            LOG.warning(\"%s directory doesn't exist.\", seed_dir)\n+            return None\n+\n+        for filename in candidate_user_data_file_names(self.instance_name):\n+            file = os.path.join(seed_dir, filename)\n+            if os.path.isfile(file):\n+                return PurePath(file)\n+\n+        LOG.warning(\n+            \"%s doesn't contain any of the expected user-data files\", seed_dir\n+        )\n+        return None\n+\n+    def _get_data(self) -> bool:\n+        self.vendordata_raw = None\n+\n+        self.metadata = dict()\n+        m_id = machine_id()\n+        if m_id is None:\n+            LOG.debug(\"Instance ID will be the WSL instance name only\")\n+            self.metadata[\"instance-id\"] = self.instance_name\n+        else:\n+            self.metadata[\"instance-id\"] = \"{}-{}\".format(\n+                self.instance_name, m_id\n+            )\n+\n+        file = self.find_user_data_file()\n+        if file is None:\n+            self.userdata_raw = None\n+        else:\n+            self.userdata_raw = cast(str, util.load_file(file, decode=True))\n+\n+        return True\n+\n+\n+# Used to match classes to dependencies\n+datasources = [\n+    (DataSourceWSL, (sources.DEP_FILESYSTEM,)),\n+]\n+\n+\n+# Return a list of data sources that match this set of dependencies\n+def get_datasource_list(depends):\n+    return sources.list_from_depends(depends, datasources)\n"
        },
        {
            "commit": "f18f82de3e0270f6dfddf22f1f487104b2428e35",
            "file_path": "tests/unittests/sources/test_wsl.py",
            "diff": "diff --git a/tests/unittests/sources/test_wsl.py b/tests/unittests/sources/test_wsl.py\nindex 030b2cbc..9653cfa4 100644\n--- a/tests/unittests/sources/test_wsl.py\n+++ b/tests/unittests/sources/test_wsl.py\n@@ -4,9 +4,12 @@\n #\n # This file is part of cloud-init. See LICENSE file for license information.\n \n+import os\n from copy import deepcopy\n+from email.mime.multipart import MIMEMultipart\n+from typing import Optional, cast\n \n-from cloudinit import util\n+from cloudinit import helpers, util\n from cloudinit.sources import DataSourceWSL as wsl\n from tests.unittests.helpers import CiTestCase, mock\n \n@@ -43,6 +46,12 @@ GOOD_MOUNTS = {\n         \"opts\": \"rw,relatime...\",\n     },\n }\n+SAMPLE_LSB = {\n+    \"id\": \"Ubuntu\",\n+    \"description\": \"Ubuntu 24.04\",\n+    \"release\": \"24.04\",\n+    \"codename\": \"noble\",\n+}\n \n \n class TestWSLHelperFunctions(CiTestCase):\n@@ -139,7 +148,188 @@ class TestWSLHelperFunctions(CiTestCase):\n         m_mounts.return_value = deepcopy(GOOD_MOUNTS)\n         m_mounts.return_value.pop(\"C:\\\\\")\n         m_mounts.return_value.pop(\"D:\\\\\")\n-        with self.assertRaises(RuntimeError) as ctx:\n-            _ = wsl.cmd_executable()\n+        self.assertIsNone(wsl.cmd_executable())\n+\n+    @mock.patch(\"cloudinit.util.lsb_release\")\n+    def test_candidate_files(self, m_lsb):\n+        \"\"\"\n+        Validate the file names candidate for holding user-data and their\n+        order of precedence.\n+        \"\"\"\n+        m_lsb.return_value = SAMPLE_LSB\n+        self.assertListEqual(\n+            [\n+                \"%s.user-data\" % INSTANCE_NAME,\n+                \"Ubuntu-noble.user-data\",\n+                \"Ubuntu-all.user-data\",\n+                \"config.user-data\",\n+            ],\n+            wsl.candidate_user_data_file_names(INSTANCE_NAME),\n+        )\n+\n+\n+SAMPLE_CFG = {\"datasource_list\": [\"NoCloud\", \"WSL\"]}\n+\n+\n+def join_payloads_from_content_type(\n+    part: MIMEMultipart, content_type: str\n+) -> str:\n+    \"\"\"\n+    Helper function to decode and join all parts of a multipart MIME\n+    message matched by the content type.\n+    \"\"\"\n+    content = \"\"\n+    for p in part.walk():\n+        if p.get_content_type() == content_type:\n+            content = content + str(p.get_payload(decode=True))\n+\n+    return content\n+\n+\n+class TestWSLDataSource(CiTestCase):\n+    def setUp(self):\n+        super(TestWSLDataSource, self).setUp()\n+        self.tmp = self.tmp_dir()\n+        self.paths = helpers.Paths(\n+            {\"cloud_dir\": self.tmp, \"run_dir\": self.tmp}\n+        )\n+\n+    @mock.patch(\"cloudinit.util.wait_for_files\")\n+    @mock.patch(\"cloudinit.util.load_file\")\n+    @mock.patch(\"cloudinit.sources.DataSourceWSL.instance_name\")\n+    @mock.patch(\"cloudinit.sources.DataSourceWSL.win_user_profile_dir\")\n+    def test_metadata_id(self, m_prof_dir, m_iname, m_load_file, m_wait_file):\n+        \"\"\"\n+        Validates that instance-id is properly set, indepedent of the existence\n+        of user-data.\n+        \"\"\"\n+        m_wait_file.return_value = set()\n+        NICE_MACHINE_ID = \"A-Nice-Machine-ID_by_systemd\"\n+        m_load_file.return_value = NICE_MACHINE_ID\n+        m_iname.return_value = INSTANCE_NAME\n+        m_prof_dir.return_value = None\n+\n+        ds = wsl.DataSourceWSL(\n+            sys_cfg=SAMPLE_CFG,\n+            distro=None,\n+            paths=self.paths,\n+        )\n+        ds.get_data()\n+\n+        self.assertEqual(\n+            ds.get_instance_id(),\n+            \"%s-%s\" % (INSTANCE_NAME, NICE_MACHINE_ID),\n+        )\n+\n+    @mock.patch(\"cloudinit.util.lsb_release\")\n+    @mock.patch(\"cloudinit.sources.DataSourceWSL.instance_name\")\n+    @mock.patch(\"cloudinit.sources.DataSourceWSL.win_user_profile_dir\")\n+    def test_get_data_cc(self, m_prof_dir, m_iname, m_lsb):\n+        m_lsb.return_value = SAMPLE_LSB\n+        m_iname.return_value = INSTANCE_NAME\n+        m_prof_dir.return_value = self.tmp\n+        userdata_file = os.path.join(\n+            self.tmp, \".cloud-init\", \"%s.user-data\" % INSTANCE_NAME\n+        )\n+        util.write_file(\n+            userdata_file, \"#cloud-config\\nwrite_files:\\n- path: /etc/wsl.conf\"\n+        )\n+\n+        ds = wsl.DataSourceWSL(\n+            sys_cfg=SAMPLE_CFG,\n+            distro=None,\n+            paths=self.paths,\n+        )\n+\n+        self.assertTrue(ds.get_data())\n+        ud = ds.get_userdata()\n+\n+        self.assertIsNotNone(ud)\n+        userdata = join_payloads_from_content_type(\n+            cast(MIMEMultipart, ud), \"text/cloud-config\"\n+        )\n+        self.assertIsNotNone(userdata)\n+        self.assertIn(\"wsl.conf\", cast(str, userdata))\n+\n+    @mock.patch(\"cloudinit.util.lsb_release\")\n+    @mock.patch(\"cloudinit.sources.DataSourceWSL.instance_name\")\n+    @mock.patch(\"cloudinit.sources.DataSourceWSL.win_user_profile_dir\")\n+    def test_get_data_sh(self, m_prof_dir, m_iname, m_lsb):\n+        m_lsb.return_value = SAMPLE_LSB\n+        m_iname.return_value = INSTANCE_NAME\n+        m_prof_dir.return_value = self.tmp\n+        userdata_file = os.path.join(\n+            self.tmp, \".cloud-init\", \"%s.user-data\" % INSTANCE_NAME\n+        )\n+        COMMAND = \"echo Hello cloud-init on WSL!\"\n+        util.write_file(userdata_file, \"#!/bin/sh\\n%s\\n\" % COMMAND)\n+\n+        ds = wsl.DataSourceWSL(\n+            sys_cfg=SAMPLE_CFG,\n+            distro=None,\n+            paths=self.paths,\n+        )\n+\n+        self.assertTrue(ds.get_data())\n+        ud = ds.get_userdata()\n+\n+        self.assertIsNotNone(ud)\n+        userdata = cast(\n+            str,\n+            join_payloads_from_content_type(\n+                cast(MIMEMultipart, ud), \"text/x-shellscript\"\n+            ),\n+        )\n+        self.assertIn(COMMAND, userdata)\n+\n+    @mock.patch(\"cloudinit.util.lsb_release\")\n+    @mock.patch(\"cloudinit.sources.DataSourceWSL.instance_name\")\n+    @mock.patch(\"cloudinit.sources.DataSourceWSL.win_user_profile_dir\")\n+    def test_data_precendence(self, m_prof_dir, m_iname, m_lsb):\n+        m_lsb.return_value = SAMPLE_LSB\n+        m_iname.return_value = INSTANCE_NAME\n+        m_prof_dir.return_value = self.tmp\n+        # This is the most specific: should win over the other user-data files.\n+        userdata_file = os.path.join(\n+            self.tmp, \".cloud-init\", \"Ubuntu-noble.user-data\"\n+        )\n+        util.write_file(\n+            userdata_file, \"#cloud-config\\nwrite_files:\\n- path: /etc/wsl.conf\"\n+        )\n+\n+        distro_file = os.path.join(\n+            self.tmp, \".cloud-init\", \"Ubuntu-all.user-data\"\n+        )\n+        util.write_file(distro_file, \"#!/bin/sh\\n\\necho Hello World\\n\")\n+\n+        generic_file = os.path.join(\n+            self.tmp, \".cloud-init\", \"config.user-data\"\n+        )\n+        util.write_file(generic_file, \"#cloud-config\\npackages:\\n- g++-13\\n\")\n+\n+        ds = wsl.DataSourceWSL(\n+            sys_cfg=SAMPLE_CFG,\n+            distro=None,\n+            paths=self.paths,\n+        )\n+\n+        self.assertTrue(ds.get_data())\n+        ud = ds.get_userdata()\n+\n+        self.assertIsNotNone(ud)\n+        userdata = cast(\n+            str,\n+            join_payloads_from_content_type(\n+                cast(MIMEMultipart, ud), \"text/cloud-config\"\n+            ),\n+        )\n+        self.assertIn(\"wsl.conf\", userdata)\n+        self.assertNotIn(\"packages\", userdata)\n+        shell_script = cast(\n+            str,\n+            join_payloads_from_content_type(\n+                cast(MIMEMultipart, ud), \"text/x-shellscript\"\n+            ),\n+        )\n \n-        self.assertIn(\"drives\", str(ctx.exception))\n+        self.assertEqual(\"\", shell_script)\n"
        }
    ]
}
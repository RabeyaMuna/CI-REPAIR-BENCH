{
    "sha_fail": "98c0877ed94c574c7a6eae2f2eb662bfcef1ba87",
    "changed_files": [
        {
            "commit": "98c0877ed94c574c7a6eae2f2eb662bfcef1ba87",
            "file_path": "libs/agno/agno/agent/agent.py",
            "diff": "diff --git a/libs/agno/agno/agent/agent.py b/libs/agno/agno/agent/agent.py\nindex bd0262b72..d2d2c1401 100644\n--- a/libs/agno/agno/agent/agent.py\n+++ b/libs/agno/agno/agent/agent.py\n@@ -1091,12 +1091,21 @@ class Agent:\n \n         # When filters are passed manually\n         if self.knowledge_filters or knowledge_filters:\n-            # initialize metadata (specially required in case when load is commented out)\n-            if not self.knowledge.filters_ready:  # type: ignore\n+            \"\"\"\n+                initialize metadata (specially required in case when load is commented out)\n+                when load is not called the reader's document_lists won't be called and metadata filters won't be initialized\n+                so we need to call initialize_valid_filters to make sure the filters are initialized\n+            \"\"\"\n+            if not self.knowledge.valid_metadata_filters:  # type: ignore\n                 self.knowledge.initialize_valid_filters()  # type: ignore\n \n             effective_filters = self._get_effective_filters(knowledge_filters)\n \n+        # Agentic filters are enabled\n+        if self.enable_agentic_filters and not self.knowledge.valid_metadata_filters:\n+            # initialize metadata (specially required in case when load is commented out)\n+            self.knowledge.initialize_valid_filters()  # type: ignore\n+\n         # If no retries are set, use the agent's default retries\n         if retries is None:\n             retries = self.retries\n@@ -1716,12 +1725,21 @@ class Agent:\n \n         # When filters are passed manually\n         if self.knowledge_filters or knowledge_filters:\n-            # initialize metadata (specially required in case when aload is commented out)\n-            if not self.knowledge.filters_ready:  # type: ignore\n+            \"\"\"\n+                initialize metadata (specially required in case when load is commented out)\n+                when load is not called the reader's document_lists won't be called and metadata filters won't be initialized\n+                so we need to call initialize_valid_filters to make sure the filters are initialized\n+            \"\"\"\n+            if not self.knowledge.valid_metadata_filters:  # type: ignore\n                 self.knowledge.initialize_valid_filters()  # type: ignore\n \n             effective_filters = self._get_effective_filters(knowledge_filters)\n \n+        # Agentic filters are enabled\n+        if self.enable_agentic_filters and not self.knowledge.valid_metadata_filters:\n+            # initialize metadata (specially required in case when load is commented out)\n+            self.knowledge.initialize_valid_filters()  # type: ignore\n+\n         # If no retries are set, use the agent's default retries\n         if retries is None:\n             retries = self.retries\n@@ -2021,9 +2039,16 @@ class Agent:\n \n             if self.search_knowledge:\n                 # Use async or sync search based on async_mode\n-                agent_tools.append(\n-                    self.search_knowledge_base_function(async_mode=async_mode, knowledge_filters=knowledge_filters)\n-                )\n+                if self.enable_agentic_filters:\n+                    agent_tools.append(\n+                        self.search_knowledge_base_with_agentic_filters_function(\n+                            async_mode=async_mode, knowledge_filters=knowledge_filters\n+                        )\n+                    )\n+                else:\n+                    agent_tools.append(\n+                        self.search_knowledge_base_function(async_mode=async_mode, knowledge_filters=knowledge_filters)\n+                    )\n             if self.update_knowledge:\n                 agent_tools.append(self.add_to_knowledge)\n \n@@ -2734,8 +2759,24 @@ class Agent:\n             if valid_filters:\n                 valid_filters_str = \", \".join(valid_filters)\n                 additional_information.append(\n-                    f\"The knowledge base contains documents with these metadata filters: {valid_filters_str}. \"\n-                    f\"When searching the knowledge base, you can use these filters to narrow down results.\"\n+                    dedent(f\"\"\"\n+                    The knowledge base contains documents with these metadata filters: {valid_filters_str}.\n+                    When searching the knowledge base, you MUST use these filters to narrow down results.\n+                    Always use filters when the user query indicates specific metadata.\n+\n+                    Examples:\n+                    1. If the user asks about a specific person like \"Jordan Mitchell\", you MUST use the search_knowledge_base tool with the filters parameter set to {{'<valid key like user id or something>': '<valid value based on the user query>'}}.\n+                    2. If the user asks about a specific document type like \"contracts\", you MUST use the search_knowledge_base tool with the filters parameter set to {{'document_type': 'contract'}}.\n+                    4. If the user asks about a specific location like \"documents from New York\", you MUST use the search_knowledge_base tool with the filters parameter set to {{'<valid key like location if present in {valid_filters_str}>': 'New York'}}.\n+\n+                    General Guidelines:\n+                    - Always analyze the user query to identify relevant metadata.\n+                    - Use the most specific filter(s) possible to narrow down results.\n+                    - If multiple filters are relevant, combine them in the filters parameter (e.g., {{'name': 'Jordan Mitchell', 'document_type': 'contract'}}).\n+                    - Ensure the filter keys match the valid metadata filters: {valid_filters_str}.\n+\n+                    You can use the search_knowledge_base tool to search the knowledge base and get the most relevant documents. Make sure to pass the filters as [Dict[str: Any]] to the tool. FOLLOW THIS STRUCTURE STRICTLY.\n+                \"\"\")\n                 )\n \n         # 3.3 Build the default system message for the Agent.\n@@ -4478,6 +4519,109 @@ class Agent:\n         else:\n             return search_knowledge_base\n \n+    def search_knowledge_base_with_agentic_filters_function(\n+        self, knowledge_filters: Optional[Dict[str, Any]] = None, async_mode: bool = False\n+    ) -> Callable:\n+        \"\"\"Factory function to create a search_knowledge_base function with filters.\"\"\"\n+        # Determine which filters to use\n+        effective_filters = knowledge_filters if knowledge_filters is not None else self.knowledge_filters\n+\n+        def search_knowledge_base(query: str, filters: Optional[Dict[str, Any]] = None) -> str:\n+            \"\"\"Use this function to search the knowledge base for information about a query.\n+\n+            Args:\n+                query: The query to search for.\n+\n+            Returns:\n+                str: A string containing the response from the knowledge base.\n+            \"\"\"\n+            search_filters = self._get_agentic_or_user_search_filters(filters, effective_filters)\n+\n+            # Get the relevant documents from the knowledge base, passing filters\n+            self.run_response = cast(RunResponse, self.run_response)\n+            retrieval_timer = Timer()\n+            retrieval_timer.start()\n+            docs_from_knowledge = self.get_relevant_docs_from_knowledge(query=query, filters=search_filters)\n+            if docs_from_knowledge is not None:\n+                references = MessageReferences(\n+                    query=query, references=docs_from_knowledge, time=round(retrieval_timer.elapsed, 4)\n+                )\n+                # Add the references to the run_response\n+                if self.run_response.extra_data is None:\n+                    self.run_response.extra_data = RunResponseExtraData()\n+                if self.run_response.extra_data.references is None:\n+                    self.run_response.extra_data.references = []\n+                self.run_response.extra_data.references.append(references)\n+            retrieval_timer.stop()\n+            from agno.utils.log import log_debug\n+\n+            log_debug(f\"Time to get references: {retrieval_timer.elapsed:.4f}s\")\n+\n+            if docs_from_knowledge is None:\n+                return \"No documents found\"\n+            return self.convert_documents_to_string(docs_from_knowledge)\n+\n+        async def asearch_knowledge_base(query: str, filters: Optional[Dict[str, Any]] = None) -> str:\n+            \"\"\"Use this function to search the knowledge base for information about a query asynchronously.\n+\n+            Args:\n+                query: The query to search for.\n+\n+            Returns:\n+                str: A string containing the response from the knowledge base.\n+            \"\"\"\n+            search_filters = self._get_agentic_or_user_search_filters(filters, effective_filters)\n+\n+            self.run_response = cast(RunResponse, self.run_response)\n+            retrieval_timer = Timer()\n+            retrieval_timer.start()\n+            docs_from_knowledge = await self.aget_relevant_docs_from_knowledge(query=query, filters=search_filters)\n+            if docs_from_knowledge is not None:\n+                references = MessageReferences(\n+                    query=query, references=docs_from_knowledge, time=round(retrieval_timer.elapsed, 4)\n+                )\n+                if self.run_response.extra_data is None:\n+                    self.run_response.extra_data = RunResponseExtraData()\n+                if self.run_response.extra_data.references is None:\n+                    self.run_response.extra_data.references = []\n+                self.run_response.extra_data.references.append(references)\n+            retrieval_timer.stop()\n+            log_debug(f\"Time to get references: {retrieval_timer.elapsed:.4f}s\")\n+\n+            if docs_from_knowledge is None:\n+                return \"No documents found\"\n+            return self.convert_documents_to_string(docs_from_knowledge)\n+\n+        if async_mode:\n+            return asearch_knowledge_base\n+        else:\n+            return search_knowledge_base\n+\n+    def _get_agentic_or_user_search_filters(\n+        self, filters: Optional[Dict[str, Any]], effective_filters: Optional[Dict[str, Any]]\n+    ) -> Dict[str, Any]:\n+        \"\"\"Helper function to determine the final filters to use for the search.\n+\n+        Args:\n+            filters: Filters passed by the agent.\n+            effective_filters: Filters passed by user.\n+\n+        Returns:\n+            Dict[str, Any]: The final filters to use for the search.\n+        \"\"\"\n+        search_filters = {}\n+\n+        # If agentic filters exist and manual filters (passed by user) do not, use agentic filters\n+        if filters and not effective_filters:\n+            search_filters = filters\n+\n+        # If both agentic filters exist and manual filters (passed by user) exist, use manual filters (give priority to user and override)\n+        if filters and effective_filters:\n+            search_filters = effective_filters\n+\n+        log_info(f\"Filters used by Agent: {search_filters}\")\n+        return search_filters\n+\n     def add_to_knowledge(self, query: str, result: str) -> str:\n         \"\"\"Use this function to add information to the knowledge base for future use.\n \n"
        },
        {
            "commit": "98c0877ed94c574c7a6eae2f2eb662bfcef1ba87",
            "file_path": "libs/agno/agno/knowledge/agent.py",
            "diff": "diff --git a/libs/agno/agno/knowledge/agent.py b/libs/agno/agno/knowledge/agent.py\nindex 3894d380f..0b2b5a854 100644\n--- a/libs/agno/agno/knowledge/agent.py\n+++ b/libs/agno/agno/knowledge/agent.py\n@@ -29,8 +29,6 @@ class AgentKnowledge(BaseModel):\n \n     valid_metadata_filters: Set[str] = None  # type: ignore\n \n-    filters_ready: bool = False\n-\n     @model_validator(mode=\"after\")\n     def update_reader(self) -> \"AgentKnowledge\":\n         if self.reader is not None and self.reader.chunking_strategy is None:\n@@ -448,8 +446,6 @@ class AgentKnowledge(BaseModel):\n             for key in metadata.keys():\n                 self.valid_metadata_filters.add(key)\n \n-            self.filters_ready = True\n-\n     def validate_filters(self, filters: Optional[Dict[str, Any]]) -> Tuple[Dict[str, Any], List[str]]:\n         if not filters:\n             return {}, []\n"
        }
    ]
}
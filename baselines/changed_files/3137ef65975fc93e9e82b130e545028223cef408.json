{
    "sha_fail": "3137ef65975fc93e9e82b130e545028223cef408",
    "changed_files": [
        {
            "commit": "3137ef65975fc93e9e82b130e545028223cef408",
            "file_path": "optuna/samplers/nsgaii/_constraints_evaluation.py",
            "diff": "diff --git a/optuna/samplers/nsgaii/_constraints_evaluation.py b/optuna/samplers/nsgaii/_constraints_evaluation.py\nindex 1c10c47a2..6ab4c60cb 100644\n--- a/optuna/samplers/nsgaii/_constraints_evaluation.py\n+++ b/optuna/samplers/nsgaii/_constraints_evaluation.py\n@@ -96,7 +96,7 @@ def _evaluate_penalty(population: Sequence[FrozenTrial]) -> np.ndarray:\n     for trial in population:\n         constraints = trial.system_attrs.get(_CONSTRAINTS_KEY)\n         if constraints is None:\n-            penalty.append(float(\"inf\"))\n+            penalty.append(np.nan)\n         else:\n             assert isinstance(constraints, (list, tuple))\n             penalty.append(sum(v for v in constraints if v > 0))\n"
        },
        {
            "commit": "3137ef65975fc93e9e82b130e545028223cef408",
            "file_path": "optuna/study/_multi_objective.py",
            "diff": "diff --git a/optuna/study/_multi_objective.py b/optuna/study/_multi_objective.py\nindex afd814bf3..4e4a36557 100644\n--- a/optuna/study/_multi_objective.py\n+++ b/optuna/study/_multi_objective.py\n@@ -1,16 +1,13 @@\n from __future__ import annotations\n \n from collections import defaultdict\n-from typing import List\n-from typing import Optional\n-from typing import Sequence\n+from typing import List, Optional, Sequence\n \n import numpy as np\n \n import optuna\n from optuna.study._study_direction import StudyDirection\n-from optuna.trial import FrozenTrial\n-from optuna.trial import TrialState\n+from optuna.trial import FrozenTrial, TrialState\n \n \n def _get_pareto_front_trials_2d(\n@@ -80,20 +77,32 @@ def _fast_non_dominated_sort(\n     penalty: np.ndarray | None = None,\n     n_below: int | None = None,\n ) -> np.ndarray:\n-    if penalty is None:\n-        penalty = np.zeros_like(objective_values[:, 0])\n-\n     # Calculate the domination matrix.\n     # The resulting matrix `domination_matrix` is a boolean matrix where\n     # `domination_matrix[i, j] == True` means that the j-th trial dominates the i-th trial in the\n     # given multi objective minimization problem.\n+\n+    # First, we calculate the domination matrix for the objective values.\n     domination_mat = np.all(\n         objective_values[:, np.newaxis, :] >= objective_values[np.newaxis, :, :], axis=2\n     ) & np.any(objective_values[:, np.newaxis, :] > objective_values[np.newaxis, :, :], axis=2)\n-\n-    # Filter the domination relations by the penalty on the constraints.\n-    domination_mat |= penalty[:, np.newaxis] > penalty\n-    domination_mat &= penalty[:, np.newaxis] >= penalty\n+    if penalty is not None:\n+        # Filter the domination relations by the penalty on the constraints.\n+        # When a penalty score does not exist, the trial is considered to be dominated by the\n+        # other trials with a penalty score.\n+        is_nan = np.isnan(penalty)\n+        domination_mat |= is_nan[:, np.newaxis] & ~is_nan\n+        domination_mat &= is_nan[:, np.newaxis] | ~is_nan\n+        # When the penalty score is equal and the both trials are explicitly infeasible, i.e., the\n+        # scores are bounded, the domination relationship is discarded.\n+        is_infeasible = penalty > 0\n+        domination_mat &= ~(\n+            (penalty[:, np.newaxis] == penalty) & (is_infeasible[:, np.newaxis] | is_infeasible)\n+        )\n+        # If the penalty score is dominated, the value domination relationship is overwritten.\n+        penalty = np.where(is_nan, np.inf, penalty)\n+        domination_mat |= penalty[:, np.newaxis] > penalty\n+        domination_mat &= penalty[:, np.newaxis] >= penalty\n \n     domination_list = np.nonzero(domination_mat)\n     domination_map = defaultdict(list)\n"
        }
    ]
}
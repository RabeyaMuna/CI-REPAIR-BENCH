{
    "sha_fail": "785242b646b54a33547ff1298cb945a05c24aa4c",
    "changed_files": [
        {
            "commit": "785242b646b54a33547ff1298cb945a05c24aa4c",
            "file_path": "seaborn/relational.py",
            "diff": "diff --git a/seaborn/relational.py b/seaborn/relational.py\nindex bb87288..8d0d856 100644\n--- a/seaborn/relational.py\n+++ b/seaborn/relational.py\n@@ -792,17 +792,18 @@ def relplot(\n \n     # Add the grid semantics onto the plotter\n     grid_variables = dict(\n-        x=x, y=y, row=row, col=col,\n-        hue=hue, size=size, style=style,\n+        x=x, y=y, row=row, col=col, hue=hue, size=size, style=style,\n     )\n     if kind == \"line\":\n-        grid_variables[\"units\"] = units\n+        grid_variables.update(units=units, weights=weights)\n     p.assign_variables(data, grid_variables)\n \n     # Define the named variables for plotting on each facet\n     # Rename the variables with a leading underscore to avoid\n     # collisions with faceting variable names\n     plot_variables = {v: f\"_{v}\" for v in variables}\n+    if \"weight\" in plot_variables:\n+        plot_variables[\"weights\"] = plot_variables.pop(\"weight\")\n     plot_kws.update(plot_variables)\n \n     # Pass the row/col variables to FacetGrid with their original\n@@ -930,6 +931,10 @@ style : vector or key in `data`\n     Grouping variable that will produce elements with different styles.\n     Can have a numeric dtype but will always be treated as categorical.\n {params.rel.units}\n+weights : vector or key in `data`\n+    Data values or column used to compute weighted estimation.\n+    Note that use of weights currently limits the choice of statistics\n+    to a 'mean' estimator and 'ci' errorbar.\n {params.facets.rowcol}\n {params.facets.col_wrap}\n row_order, col_order : lists of strings\n"
        },
        {
            "commit": "785242b646b54a33547ff1298cb945a05c24aa4c",
            "file_path": "tests/test_relational.py",
            "diff": "diff --git a/tests/test_relational.py b/tests/test_relational.py\nindex 2f5eda1..06d0860 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -578,6 +578,15 @@ class TestRelationalPlotter(Helpers):\n             expected_paths = [paths[val] for val in grp_df[\"a\"]]\n             assert self.paths_equal(points.get_paths(), expected_paths)\n \n+    def test_relplot_weighted_estimator(self, long_df):\n+\n+        g = relplot(data=long_df, x=\"a\", y=\"y\", weights=\"x\", kind=\"line\")\n+        ydata = g.ax.lines[0].get_ydata()\n+        for i, label in enumerate(g.ax.get_xticklabels()):\n+            pos_df = long_df[long_df[\"a\"] == label.get_text()]\n+            expected = np.average(pos_df[\"y\"], weights=pos_df[\"x\"])\n+            assert ydata[i] == pytest.approx(expected)\n+\n     def test_relplot_stringy_numerics(self, long_df):\n \n         long_df[\"x_str\"] = long_df[\"x\"].astype(str)\n@@ -1063,8 +1072,8 @@ class TestLinePlotter(SharedAxesLevelTests, Helpers):\n \n         ax = lineplot(long_df, x=\"a\", y=\"y\", weights=\"x\")\n         vals = ax.lines[0].get_ydata()\n-        for i, a in enumerate(ax.get_xticklabels()):\n-            pos_df = long_df.loc[long_df[\"a\"] == a.get_text()]\n+        for i, label in enumerate(ax.get_xticklabels()):\n+            pos_df = long_df.loc[long_df[\"a\"] == label.get_text()]\n             expected = np.average(pos_df[\"y\"], weights=pos_df[\"x\"])\n             assert vals[i] == pytest.approx(expected)\n \n"
        }
    ]
}
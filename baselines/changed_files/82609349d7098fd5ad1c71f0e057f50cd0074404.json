{
    "sha_fail": "82609349d7098fd5ad1c71f0e057f50cd0074404",
    "changed_files": [
        {
            "commit": "82609349d7098fd5ad1c71f0e057f50cd0074404",
            "file_path": "cookbook/workflows/async_hackernews_reporter.py",
            "diff": "diff --git a/cookbook/workflows/async_hackernews_reporter.py b/cookbook/workflows/async_hackernews_reporter.py\nindex 84acf54e1..0a8a4c09a 100644\n--- a/cookbook/workflows/async_hackernews_reporter.py\n+++ b/cookbook/workflows/async_hackernews_reporter.py\n@@ -109,8 +109,7 @@ if __name__ == \"__main__\":\n         # Run the workflow and collect the final response\n         final_content = []\n         try:\n-            response = await workflow.arun(num_stories=5)\n-            async for response in response:\n+            async for response in workflow.arun(num_stories=5):\n                 if response.content:\n                     final_content.append(response.content)\n         except Exception as e:\n"
        },
        {
            "commit": "82609349d7098fd5ad1c71f0e057f50cd0074404",
            "file_path": "libs/agno/agno/workflow/workflow.py",
            "diff": "diff --git a/libs/agno/agno/workflow/workflow.py b/libs/agno/agno/workflow/workflow.py\nindex d52a0d336..3d7109aca 100644\n--- a/libs/agno/agno/workflow/workflow.py\n+++ b/libs/agno/agno/workflow/workflow.py\n@@ -242,7 +242,6 @@ class Workflow:\n             return None\n \n     # Add to workflow.py after the run_workflow method\n-\n     async def arun_workflow(self, **kwargs: Any):\n         \"\"\"Run the Workflow asynchronously\"\"\"\n \n@@ -269,60 +268,14 @@ class Workflow:\n \n         log_debug(f\"Workflow Run Start: {self.run_id}\", center=True)\n         try:\n-            from inspect import isasyncgen, isasyncgenfunction\n-\n             self._subclass_run = cast(Callable, self._subclass_run)\n-            if isasyncgenfunction(self._subclass_run) or isasyncgen(self._subclass_run):\n-                result = self._subclass_run(**kwargs)\n-            else:\n-                result = await self._subclass_run(**kwargs)\n+            result = await self._subclass_run(**kwargs)\n         except Exception as e:\n             logger.error(f\"Workflow.arun() failed: {e}\")\n             raise e\n \n-        # Handle async iterator results\n-        if isinstance(result, (AsyncIterator, AsyncGenerator)):\n-            # Initialize the run_response content\n-            self.run_response.content = \"\"\n-\n-            async def result_generator():\n-                self.run_response = cast(RunResponse, self.run_response)\n-                if isinstance(self.memory, WorkflowMemory):\n-                    self.memory = cast(WorkflowMemory, self.memory)\n-                elif isinstance(self.memory, Memory):\n-                    self.memory = cast(Memory, self.memory)\n-\n-                async for item in result:\n-                    if (\n-                        isinstance(item, tuple(get_args(RunResponseEvent)))\n-                        or isinstance(item, tuple(get_args(TeamRunResponseEvent)))\n-                        or isinstance(item, tuple(get_args(WorkflowRunResponseEvent)))\n-                        or isinstance(item, RunResponse)\n-                    ):\n-                        # Update the run_id, session_id and workflow_id of the RunResponseEvent\n-                        item.run_id = self.run_id\n-                        item.session_id = self.session_id\n-                        item.workflow_id = self.workflow_id\n-\n-                        # Update the run_response with the content from the result\n-                        if hasattr(item, \"content\") and item.content is not None and isinstance(item.content, str):\n-                            self.run_response.content += item.content\n-                    else:\n-                        logger.warning(f\"Workflow.arun() should only yield RunResponseEvent objects, got: {type(item)}\")\n-                    yield item\n-\n-                # Add the run to the memory\n-                if isinstance(self.memory, WorkflowMemory):\n-                    self.memory.add_run(WorkflowRun(input=self.run_input, response=self.run_response))\n-                elif isinstance(self.memory, Memory):\n-                    self.memory.add_run(session_id=self.session_id, run=self.run_response)  # type: ignore\n-                # Write this run to the database\n-                self.write_to_storage()\n-                log_debug(f\"Workflow Run End: {self.run_id}\", center=True)\n-\n-            return result_generator()\n         # Handle single RunResponse result\n-        elif isinstance(result, RunResponse):\n+        if isinstance(result, RunResponse):\n             # Update the result with the run_id, session_id and workflow_id of the workflow run\n             result.run_id = self.run_id\n             result.session_id = self.session_id\n@@ -345,6 +298,67 @@ class Workflow:\n             logger.warning(f\"Workflow.arun() should only return RunResponse objects, got: {type(result)}\")\n             return None\n \n+    async def arun_workflow_generator(self, **kwargs: Any) -> AsyncIterator[RunResponse]:\n+        \"\"\"Run the Workflow asynchronously for async generators\"\"\"\n+\n+        # Set mode, debug, workflow_id, session_id, initialize memory\n+        self.set_storage_mode()\n+        self.set_debug()\n+        self.set_monitoring()\n+        self.set_workflow_id()  # Ensure workflow_id is set\n+        self.set_session_id()\n+        self.initialize_memory()\n+\n+        # Create a run_id\n+        self.run_id = str(uuid4())\n+\n+        # Set run_input, run_response\n+        self.run_input = kwargs\n+        self.run_response = RunResponse(run_id=self.run_id, session_id=self.session_id, workflow_id=self.workflow_id)\n+\n+        # Read existing session from storage\n+        self.read_from_storage()\n+\n+        # Update the session_id for all Agent instances\n+        self.update_agent_session_ids()\n+\n+        log_debug(f\"Workflow Run Start: {self.run_id}\", center=True)\n+        # Initialize the run_response content\n+        self.run_response.content = \"\"\n+        try:\n+            self._subclass_run = cast(Callable, self._subclass_run)\n+            async for item in self._subclass_run(**kwargs):\n+                if (\n+                    isinstance(item, tuple(get_args(RunResponseEvent)))\n+                    or isinstance(item, tuple(get_args(TeamRunResponseEvent)))\n+                    or isinstance(item, tuple(get_args(WorkflowRunResponseEvent)))\n+                    or isinstance(item, RunResponse)\n+                ):\n+                    # Update the run_id, session_id and workflow_id of the RunResponseEvent\n+                    item.run_id = self.run_id\n+                    item.session_id = self.session_id\n+                    item.workflow_id = self.workflow_id\n+\n+                    # Update the run_response with the content from the result\n+                    if hasattr(item, \"content\") and item.content is not None and isinstance(item.content, str):\n+                        self.run_response.content += item.content\n+                else:\n+                    logger.warning(f\"Workflow.run() should only yield RunResponseEvent objects, got: {type(item)}\")\n+                yield item\n+            \n+            # Add the run to the memory\n+            if isinstance(self.memory, WorkflowMemory):\n+                self.memory.add_run(WorkflowRun(input=self.run_input, response=self.run_response))\n+            elif isinstance(self.memory, Memory):\n+                self.memory.add_run(session_id=self.session_id, run=self.run_response)  # type: ignore\n+            # Write this run to the database\n+            self.write_to_storage()\n+            log_debug(f\"Workflow Run End: {self.run_id}\", center=True)\n+        except Exception as e:\n+            logger.error(f\"Workflow.arun() failed: {e}\")\n+            raise e\n+\n+\n     async def arun(self, **kwargs: Any):\n         \"\"\"Async version of run() that calls arun_workflow()\"\"\"\n         logger.error(f\"{self.__class__.__name__}.arun() method not implemented.\")\n@@ -408,6 +422,11 @@ class Workflow:\n                 # Get the parameters of the async run method\n                 sig = inspect.signature(self.__class__.arun)\n                 run_type = \"async\"\n+                \n+                # Check if the async method is a coroutine or async generator\n+                from inspect import isasyncgenfunction\n+                if isasyncgenfunction(self.__class__.arun):\n+                    run_type = \"async_generator\"\n \n             # Convert parameters to a serializable format\n             self._run_parameters = {\n@@ -447,6 +466,8 @@ class Workflow:\n                 object.__setattr__(self, \"run\", self.run_workflow.__get__(self))\n             elif run_type == \"async\":\n                 object.__setattr__(self, \"arun\", self.arun_workflow.__get__(self))\n+            elif run_type == \"async_generator\":\n+                object.__setattr__(self, \"arun\", self.arun_workflow_generator.__get__(self))\n         else:\n             # If the subclass does not override the run method,\n             # the Workflow.run() method will be called and will log an error\n"
        }
    ]
}
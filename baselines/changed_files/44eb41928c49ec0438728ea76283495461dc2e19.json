{
    "sha_fail": "44eb41928c49ec0438728ea76283495461dc2e19",
    "changed_files": [
        {
            "commit": "44eb41928c49ec0438728ea76283495461dc2e19",
            "file_path": "framework/py/flwr/supernode/nodestate/in_memory_nodestate.py",
            "diff": "diff --git a/framework/py/flwr/supernode/nodestate/in_memory_nodestate.py b/framework/py/flwr/supernode/nodestate/in_memory_nodestate.py\nindex d125a7793..500ebd5ae 100644\n--- a/framework/py/flwr/supernode/nodestate/in_memory_nodestate.py\n+++ b/framework/py/flwr/supernode/nodestate/in_memory_nodestate.py\n@@ -59,3 +59,92 @@ class InMemoryNodeState(NodeState):\n         if self.node_id is None:\n             raise ValueError(\"Node ID not set\")\n         return self.node_id\n+\n+    def store_message(self, message: Message) -> Optional[str]:\n+        \"\"\"Store a message.\"\"\"\n+        with self.lock_msg_store:\n+            msg_id = message.metadata.message_id\n+            if msg_id == \"\" or msg_id in self.msg_store:\n+                return None\n+            self.msg_store[msg_id] = MessageEntry(message=message)\n+            return msg_id\n+\n+    def get_messages(\n+        self,\n+        *,\n+        run_ids: Optional[Sequence[int]] = None,\n+        is_reply: Optional[bool] = None,\n+        limit: Optional[int] = None,\n+    ) -> Sequence[Message]:\n+        \"\"\"Retrieve messages based on the specified filters.\"\"\"\n+        selected_messages: list[Message] = []\n+\n+        with self.lock_msg_store:\n+            # Iterate through all messages in the store\n+            for object_id in list(self.msg_store.keys()):\n+                entry = self.msg_store[object_id]\n+                message = entry.message\n+\n+                # Skip messages that have already been retrieved\n+                if entry.is_retrieved:\n+                    continue\n+\n+                # Skip messages whose run_id doesn't match the filter\n+                if run_ids is not None:\n+                    if message.metadata.run_id not in run_ids:\n+                        continue\n+\n+                # If is_reply filter is set, filter for reply/non-reply messages\n+                if is_reply is not None:\n+                    is_reply_message = message.metadata.reply_to_message_id != \"\"\n+                    # XOR logic to filter mismatched types (reply vs non-reply)\n+                    if is_reply ^ is_reply_message:\n+                        continue\n+\n+                # Add the message to the result set\n+                selected_messages.append(message)\n+\n+                # Mark the message as retrieved\n+                entry.is_retrieved = True\n+\n+                # Stop if the number of collected messages reaches the limit\n+                if limit is not None and len(selected_messages) >= limit:\n+                    break\n+\n+        return selected_messages\n+\n+    def delete_messages(\n+        self,\n+        *,\n+        message_ids: Optional[Sequence[str]] = None,\n+    ) -> None:\n+        \"\"\"Delete messages based on the specified filters.\"\"\"\n+        with self.lock_msg_store:\n+            if message_ids is None:\n+                # If no message IDs are provided, clear the entire store\n+                self.msg_store.clear()\n+                return\n+\n+            # Remove specified messages from the store\n+            for msg_id in message_ids:\n+                self.msg_store.pop(msg_id, None)\n+\n+    def store_run(self, run: Run) -> None:\n+        \"\"\"Store a run.\"\"\"\n+        with self.lock_run_store:\n+            self.run_store[run.run_id] = run\n+\n+    def get_run(self, run_id: int) -> Optional[Run]:\n+        \"\"\"Retrieve a run by its ID.\"\"\"\n+        with self.lock_run_store:\n+            return self.run_store.get(run_id)\n+\n+    def store_context(self, context: Context) -> None:\n+        \"\"\"Store a context.\"\"\"\n+        with self.lock_ctx_store:\n+            self.ctx_store[context.run_id] = context\n+\n+    def get_context(self, run_id: int) -> Optional[Context]:\n+        \"\"\"Retrieve a context by its run ID.\"\"\"\n+        with self.lock_ctx_store:\n+            return self.ctx_store.get(run_id)\n"
        }
    ]
}
{
    "sha_fail": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
    "changed_files": [
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "doc/_docstrings/barplot.ipynb",
            "diff": "diff --git a/doc/_docstrings/barplot.ipynb b/doc/_docstrings/barplot.ipynb\nindex e130ec4..bb1e6d1 100644\n--- a/doc/_docstrings/barplot.ipynb\n+++ b/doc/_docstrings/barplot.ipynb\n@@ -22,7 +22,7 @@\n    \"id\": \"b53b65b8-5670-4905-aa39-36db04f4b813\",\n    \"metadata\": {},\n    \"source\": [\n-    \"With long data, assign `x` and `y` to group by a categorical varaible and plot aggregated values, with confidence intervals:\"\n+    \"With long data, assign `x` and `y` to group by a categorical variable and plot aggregated values, with confidence intervals:\"\n    ]\n   },\n   {\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "doc/_docstrings/histplot.ipynb",
            "diff": "diff --git a/doc/_docstrings/histplot.ipynb b/doc/_docstrings/histplot.ipynb\nindex 79b6636..b448f7a 100644\n--- a/doc/_docstrings/histplot.ipynb\n+++ b/doc/_docstrings/histplot.ipynb\n@@ -312,7 +312,7 @@\n    \"cell_type\": \"markdown\",\n    \"metadata\": {},\n    \"source\": [\n-    \"Step functions, esepcially when unfilled, make it easy to compare cumulative histograms:\"\n+    \"Step functions, especially when unfilled, make it easy to compare cumulative histograms:\"\n    ]\n   },\n   {\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "doc/_docstrings/objects.Est.ipynb",
            "diff": "diff --git a/doc/_docstrings/objects.Est.ipynb b/doc/_docstrings/objects.Est.ipynb\nindex 3dcac46..94aacfa 100644\n--- a/doc/_docstrings/objects.Est.ipynb\n+++ b/doc/_docstrings/objects.Est.ipynb\n@@ -109,12 +109,30 @@\n     \"p.add(so.Range(), so.Est(seed=0))\"\n    ]\n   },\n+  {\n+   \"cell_type\": \"markdown\",\n+   \"id\": \"df807ef8-b5fb-4eac-b539-1bd4e797ddc2\",\n+   \"metadata\": {},\n+   \"source\": [\n+    \"To compute a weighted estimate (and confidence interval), assign a `weight` variable in the layer where you use the stat:\"\n+   ]\n+  },\n   {\n    \"cell_type\": \"code\",\n    \"execution_count\": null,\n    \"id\": \"5e4a0594-e1ee-4f72-971e-3763dd626e8b\",\n    \"metadata\": {},\n    \"outputs\": [],\n+   \"source\": [\n+    \"p.add(so.Range(), so.Est(), weight=\\\"price\\\")\"\n+   ]\n+  },\n+  {\n+   \"cell_type\": \"code\",\n+   \"execution_count\": null,\n+   \"id\": \"0d0c34d7-fb76-44cf-9079-3ec7f45741d0\",\n+   \"metadata\": {},\n+   \"outputs\": [],\n    \"source\": []\n   }\n  ],\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "doc/_docstrings/pointplot.ipynb",
            "diff": "diff --git a/doc/_docstrings/pointplot.ipynb b/doc/_docstrings/pointplot.ipynb\nindex ace676b..efa7922 100644\n--- a/doc/_docstrings/pointplot.ipynb\n+++ b/doc/_docstrings/pointplot.ipynb\n@@ -22,7 +22,7 @@\n    \"id\": \"f25d3647-9fad-47b2-b49d-db6f5b5c3795\",\n    \"metadata\": {},\n    \"source\": [\n-    \"Group by a categorical varaible and plot aggregated values, with confidence intervals:\"\n+    \"Group by a categorical variable and plot aggregated values, with confidence intervals:\"\n    ]\n   },\n   {\n@@ -138,7 +138,7 @@\n    \"id\": \"00273ada-cd12-410a-a268-38243d6514ae\",\n    \"metadata\": {},\n    \"source\": [\n-    \"Dodge by a specific amount, relative to the width alloted for each level:\"\n+    \"Dodge by a specific amount, relative to the width allotted for each level:\"\n    ]\n   },\n   {\n@@ -164,7 +164,7 @@\n    \"id\": \"e205e7c8-6b11-44e6-b43f-7416c427215d\",\n    \"metadata\": {},\n    \"source\": [\n-    \"When variables are not explicity assigned and the dataset is two-dimensional, the plot will aggregate over each column:\"\n+    \"When variables are not explicitly assigned and the dataset is two-dimensional, the plot will aggregate over each column:\"\n    ]\n   },\n   {\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "doc/_docstrings/scatterplot.ipynb",
            "diff": "diff --git a/doc/_docstrings/scatterplot.ipynb b/doc/_docstrings/scatterplot.ipynb\nindex 973a67d..4b78f8e 100644\n--- a/doc/_docstrings/scatterplot.ipynb\n+++ b/doc/_docstrings/scatterplot.ipynb\n@@ -167,7 +167,7 @@\n    \"cell_type\": \"raw\",\n    \"metadata\": {},\n    \"source\": [\n-    \"Control the range of marker areas with ``sizes``, and set ``lengend=\\\"full\\\"`` to force every unique value to appear in the legend:\"\n+    \"Control the range of marker areas with ``sizes``, and set ``legend=\\\"full\\\"`` to force every unique value to appear in the legend:\"\n    ]\n   },\n   {\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "doc/_tutorial/data_structure.ipynb",
            "diff": "diff --git a/doc/_tutorial/data_structure.ipynb b/doc/_tutorial/data_structure.ipynb\nindex 2d66370..a474477 100644\n--- a/doc/_tutorial/data_structure.ipynb\n+++ b/doc/_tutorial/data_structure.ipynb\n@@ -19,7 +19,7 @@\n     \"As a data visualization library, seaborn requires that you provide it with data. This chapter explains the various ways to accomplish that task. Seaborn supports several different dataset formats, and most functions accept data represented with objects from the `pandas <https://pandas.pydata.org/>`_ or `numpy <https://numpy.org/>`_ libraries as well as built-in Python types like lists and dictionaries. Understanding the usage patterns associated with these different options will help you quickly create useful visualizations for nearly any dataset.\\n\",\n     \"\\n\",\n     \".. note::\\n\",\n-    \"   As of current writing (v0.13.0), the full breadth of options covered here are supported by most, but not all, of the functions in seaborn. Namely, a few older functinos (e.g., :func:`lmplot` and :func:`regplot`) anre more limited in what they accept.\"\n+    \"   As of current writing (v0.13.0), the full breadth of options covered here are supported by most, but not all, of the functions in seaborn. Namely, a few older functions (e.g., :func:`lmplot` and :func:`regplot`) are more limited in what they accept.\"\n    ]\n   },\n   {\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "seaborn/_base.py",
            "diff": "diff --git a/seaborn/_base.py b/seaborn/_base.py\nindex b659300..9aa83d4 100644\n--- a/seaborn/_base.py\n+++ b/seaborn/_base.py\n@@ -933,7 +933,8 @@ class VectorPlotter:\n \n             grouping_keys = []\n             for var in grouping_vars:\n-                grouping_keys.append(levels.get(var, []))\n+                key = levels.get(var)\n+                grouping_keys.append([] if key is None else key)\n \n             iter_keys = itertools.product(*grouping_keys)\n             if reverse:\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "seaborn/_compat.py",
            "diff": "diff --git a/seaborn/_compat.py b/seaborn/_compat.py\nindex 6b2c619..190ec6b 100644\n--- a/seaborn/_compat.py\n+++ b/seaborn/_compat.py\n@@ -71,66 +71,6 @@ def norm_from_scale(scale, norm):\n     return new_norm\n \n \n-def scale_factory(scale, axis, **kwargs):\n-    \"\"\"\n-    Backwards compatability for creation of independent scales.\n-\n-    Matplotlib scales require an Axis object for instantiation on < 3.4.\n-    But the axis is not used, aside from extraction of the axis_name in LogScale.\n-\n-    \"\"\"\n-    modify_transform = False\n-    if _version_predates(mpl, \"3.4\"):\n-        if axis[0] in \"xy\":\n-            modify_transform = True\n-            axis = axis[0]\n-            base = kwargs.pop(\"base\", None)\n-            if base is not None:\n-                kwargs[f\"base{axis}\"] = base\n-            nonpos = kwargs.pop(\"nonpositive\", None)\n-            if nonpos is not None:\n-                kwargs[f\"nonpos{axis}\"] = nonpos\n-\n-    if isinstance(scale, str):\n-        class Axis:\n-            axis_name = axis\n-        axis = Axis()\n-\n-    scale = mpl.scale.scale_factory(scale, axis, **kwargs)\n-\n-    if modify_transform:\n-        transform = scale.get_transform()\n-        transform.base = kwargs.get(\"base\", 10)\n-        if kwargs.get(\"nonpositive\") == \"mask\":\n-            # Setting a private attribute, but we only get here\n-            # on an old matplotlib, so this won't break going forwards\n-            transform._clip = False\n-\n-    return scale\n-\n-\n-def set_scale_obj(ax, axis, scale):\n-    \"\"\"Handle backwards compatability with setting matplotlib scale.\"\"\"\n-    if _version_predates(mpl, \"3.4\"):\n-        # The ability to pass a BaseScale instance to Axes.set_{}scale was added\n-        # to matplotlib in version 3.4.0: GH: matplotlib/matplotlib/pull/19089\n-        # Workaround: use the scale name, which is restrictive only if the user\n-        # wants to define a custom scale; they'll need to update the registry too.\n-        if scale.name is None:\n-            # Hack to support our custom Formatter-less CatScale\n-            return\n-        method = getattr(ax, f\"set_{axis}scale\")\n-        kws = {}\n-        if scale.name == \"function\":\n-            trans = scale.get_transform()\n-            kws[\"functions\"] = (trans._forward, trans._inverse)\n-        method(scale.name, **kws)\n-        axis_obj = getattr(ax, f\"{axis}axis\")\n-        scale.set_default_locators_and_formatters(axis_obj)\n-    else:\n-        ax.set(**{f\"{axis}scale\": scale})\n-\n-\n def get_colormap(name):\n     \"\"\"Handle changes to matplotlib colormap interface in 3.6.\"\"\"\n     try:\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "seaborn/_core/plot.py",
            "diff": "diff --git a/seaborn/_core/plot.py b/seaborn/_core/plot.py\nindex 804fd1e..af4669c 100644\n--- a/seaborn/_core/plot.py\n+++ b/seaborn/_core/plot.py\n@@ -27,7 +27,7 @@ from seaborn._marks.base import Mark\n from seaborn._stats.base import Stat\n from seaborn._core.data import PlotData\n from seaborn._core.moves import Move\n-from seaborn._core.scales import Scale, Nominal\n+from seaborn._core.scales import Scale\n from seaborn._core.subplots import Subplots\n from seaborn._core.groupby import GroupBy\n from seaborn._core.properties import PROPERTIES, Property\n@@ -40,10 +40,9 @@ from seaborn._core.typing import (\n )\n from seaborn._core.exceptions import PlotSpecError\n from seaborn._core.rules import categorical_order\n-from seaborn._compat import get_layout_engine, set_layout_engine, set_scale_obj\n+from seaborn._compat import set_layout_engine\n from seaborn.rcmod import axes_style, plotting_context\n from seaborn.palettes import color_palette\n-from seaborn.utils import _version_predates\n \n from typing import TYPE_CHECKING, TypedDict\n if TYPE_CHECKING:\n@@ -462,16 +461,12 @@ class Plot:\n \n         \"\"\"\n         accepted_types: tuple  # Allow tuple of various length\n-        if hasattr(mpl.figure, \"SubFigure\"):  # Added in mpl 3.4\n-            accepted_types = (\n-                mpl.axes.Axes, mpl.figure.SubFigure, mpl.figure.Figure\n-            )\n-            accepted_types_str = (\n-                f\"{mpl.axes.Axes}, {mpl.figure.SubFigure}, or {mpl.figure.Figure}\"\n-            )\n-        else:\n-            accepted_types = mpl.axes.Axes, mpl.figure.Figure\n-            accepted_types_str = f\"{mpl.axes.Axes} or {mpl.figure.Figure}\"\n+        accepted_types = (\n+            mpl.axes.Axes, mpl.figure.SubFigure, mpl.figure.Figure\n+        )\n+        accepted_types_str = (\n+            f\"{mpl.axes.Axes}, {mpl.figure.SubFigure}, or {mpl.figure.Figure}\"\n+        )\n \n         if not isinstance(target, accepted_types):\n             err = (\n@@ -1377,19 +1372,6 @@ class Plotter:\n                 share_state = self._subplots.subplot_spec[f\"share{axis}\"]\n                 subplots = [view for view in self._subplots if view[axis] == coord]\n \n-            # Shared categorical axes are broken on matplotlib<3.4.0.\n-            # https://github.com/matplotlib/matplotlib/pull/18308\n-            # This only affects us when sharing *paired* axes. This is a novel/niche\n-            # behavior, so we will raise rather than hack together a workaround.\n-            if axis is not None and _version_predates(mpl, \"3.4\"):\n-                paired_axis = axis in p._pair_spec.get(\"structure\", {})\n-                cat_scale = isinstance(scale, Nominal)\n-                ok_dim = {\"x\": \"col\", \"y\": \"row\"}[axis]\n-                shared_axes = share_state not in [False, \"none\", ok_dim]\n-                if paired_axis and cat_scale and shared_axes:\n-                    err = \"Sharing paired categorical axes requires matplotlib>=3.4.0\"\n-                    raise RuntimeError(err)\n-\n             if scale is None:\n                 self._scales[var] = Scale._identity()\n             else:\n@@ -1415,7 +1397,7 @@ class Plotter:\n                 axis_obj = getattr(view[\"ax\"], f\"{axis}axis\")\n                 seed_values = self._get_subplot_data(var_df, var, view, share_state)\n                 view_scale = scale._setup(seed_values, prop, axis=axis_obj)\n-                set_scale_obj(view[\"ax\"], axis, view_scale._matplotlib_scale)\n+                view[\"ax\"].set(**{f\"{axis}scale\": view_scale._matplotlib_scale})\n \n                 for layer, new_series in zip(layers, transformed_data):\n                     layer_df = layer[\"data\"].frame\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "seaborn/_core/scales.py",
            "diff": "diff --git a/seaborn/_core/scales.py b/seaborn/_core/scales.py\nindex 8c597e1..1e7bef8 100644\n--- a/seaborn/_core/scales.py\n+++ b/seaborn/_core/scales.py\n@@ -278,8 +278,6 @@ class Nominal(Scale):\n         # major_formatter = new._get_formatter(major_locator, **new._label_params)\n \n         class CatScale(mpl.scale.LinearScale):\n-            name = None  # To work around mpl<3.4 compat issues\n-\n             def set_default_locators_and_formatters(self, axis):\n                 ...\n                 # axis.set_major_locator(major_locator)\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "seaborn/_core/subplots.py",
            "diff": "diff --git a/seaborn/_core/subplots.py b/seaborn/_core/subplots.py\nindex f98025c..287f441 100644\n--- a/seaborn/_core/subplots.py\n+++ b/seaborn/_core/subplots.py\n@@ -158,11 +158,8 @@ class Subplots:\n                 err = \" \".join([\n                     \"Cannot create multiple subplots after calling `Plot.on` with\",\n                     f\"a {mpl.axes.Axes} object.\",\n+                    f\" You may want to use a {mpl.figure.SubFigure} instead.\",\n                 ])\n-                try:\n-                    err += f\" You may want to use a {mpl.figure.SubFigure} instead.\"\n-                except AttributeError:  # SubFigure added in mpl 3.4\n-                    pass\n                 raise RuntimeError(err)\n \n             self._subplot_list = [{\n@@ -179,10 +176,7 @@ class Subplots:\n             self._figure = target.figure\n             return self._figure\n \n-        elif (\n-            hasattr(mpl.figure, \"SubFigure\")  # Added in mpl 3.4\n-            and isinstance(target, mpl.figure.SubFigure)\n-        ):\n+        elif isinstance(target, mpl.figure.SubFigure):\n             figure = target.figure\n         elif isinstance(target, mpl.figure.Figure):\n             figure = target\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "seaborn/_marks/bar.py",
            "diff": "diff --git a/seaborn/_marks/bar.py b/seaborn/_marks/bar.py\nindex 4b1c072..2aed683 100644\n--- a/seaborn/_marks/bar.py\n+++ b/seaborn/_marks/bar.py\n@@ -16,7 +16,6 @@ from seaborn._marks.base import (\n     resolve_color,\n     document_properties\n )\n-from seaborn.utils import _version_predates\n \n from typing import TYPE_CHECKING\n if TYPE_CHECKING:\n@@ -170,11 +169,8 @@ class Bar(BarBase):\n                 ax.add_patch(bar)\n \n             # Add a container which is useful for, e.g. Axes.bar_label\n-            if _version_predates(mpl, \"3.4\"):\n-                container_kws = {}\n-            else:\n-                orientation = {\"x\": \"vertical\", \"y\": \"horizontal\"}[orient]\n-                container_kws = dict(datavalues=vals, orientation=orientation)\n+            orientation = {\"x\": \"vertical\", \"y\": \"horizontal\"}[orient]\n+            container_kws = dict(datavalues=vals, orientation=orientation)\n             container = mpl.container.BarContainer(bars, **container_kws)\n             ax.add_container(container)\n \n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "seaborn/_statistics.py",
            "diff": "diff --git a/seaborn/_statistics.py b/seaborn/_statistics.py\nindex c2f01ce..98fa515 100644\n--- a/seaborn/_statistics.py\n+++ b/seaborn/_statistics.py\n@@ -518,6 +518,62 @@ class EstimateAggregator:\n         return pd.Series({var: estimate, f\"{var}min\": err_min, f\"{var}max\": err_max})\n \n \n+class WeightedAggregator:\n+\n+    def __init__(self, estimator, errorbar=None, **boot_kws):\n+        \"\"\"\n+        Data aggregator that produces a weighted estimate and error bar interval.\n+\n+        Parameters\n+        ----------\n+        estimator : string\n+            Function (or method name) that maps a vector to a scalar. Currently\n+            supports only \"mean\".\n+        errorbar : string or (string, number) tuple\n+            Name of errorbar method or a tuple with a method name and a level parameter.\n+            Currently the only supported method is \"ci\".\n+        boot_kws\n+            Additional keywords are passed to bootstrap when error_method is \"ci\".\n+\n+        \"\"\"\n+        if estimator != \"mean\":\n+            # Note that, while other weighted estimators may make sense (e.g. median),\n+            # I'm not aware of an implementation in our dependencies. We can add one\n+            # in seaborn later, if there is sufficient interest. For now, limit to mean.\n+            raise ValueError(f\"Weighted estimator must be 'mean', not {estimator!r}.\")\n+        self.estimator = estimator\n+\n+        method, level = _validate_errorbar_arg(errorbar)\n+        if method is not None and method != \"ci\":\n+            # As with the estimator, weighted 'sd' or 'pi' error bars may make sense.\n+            # But we'll keep things simple for now and limit to (bootstrap) CI.\n+            raise ValueError(f\"Error bar method must be 'ci', not {method!r}.\")\n+        self.error_method = method\n+        self.error_level = level\n+\n+        self.boot_kws = boot_kws\n+\n+    def __call__(self, data, var):\n+        \"\"\"Aggregate over `var` column of `data` with estimate and error interval.\"\"\"\n+        vals = data[var]\n+        weights = data[\"weight\"]\n+\n+        estimate = np.average(vals, weights=weights)\n+\n+        if self.error_method == \"ci\" and len(data) > 1:\n+\n+            def error_func(x, w):\n+                return np.average(x, weights=w)\n+\n+            boots = bootstrap(vals, weights, func=error_func, **self.boot_kws)\n+            err_min, err_max = _percentile_interval(boots, self.error_level)\n+\n+        else:\n+            err_min = err_max = np.nan\n+\n+        return pd.Series({var: estimate, f\"{var}min\": err_min, f\"{var}max\": err_max})\n+\n+\n class LetterValues:\n \n     def __init__(self, k_depth, outlier_prop, trust_alpha):\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "seaborn/_stats/aggregation.py",
            "diff": "diff --git a/seaborn/_stats/aggregation.py b/seaborn/_stats/aggregation.py\nindex d175273..7e7d602 100644\n--- a/seaborn/_stats/aggregation.py\n+++ b/seaborn/_stats/aggregation.py\n@@ -8,7 +8,10 @@ from pandas import DataFrame\n from seaborn._core.scales import Scale\n from seaborn._core.groupby import GroupBy\n from seaborn._stats.base import Stat\n-from seaborn._statistics import EstimateAggregator\n+from seaborn._statistics import (\n+    EstimateAggregator,\n+    WeightedAggregator,\n+)\n from seaborn._core.typing import Vector\n \n \n@@ -54,8 +57,14 @@ class Est(Stat):\n     \"\"\"\n     Calculate a point estimate and error bar interval.\n \n-    For additional information about the various `errorbar` choices, see\n-    the :doc:`errorbar tutorial </tutorial/error_bars>`.\n+    For more information about the various `errorbar` choices, see the\n+    :doc:`errorbar tutorial </tutorial/error_bars>`.\n+\n+    Additional variables:\n+\n+    - **weight**: When passed to a layer that uses this stat, a weighted estimate\n+      will be computed. Note that use of weights currently limits the choice of\n+      function and error bar method  to `\"mean\"` and `\"ci\"`, respectively.\n \n     Parameters\n     ----------\n@@ -95,7 +104,10 @@ class Est(Stat):\n     ) -> DataFrame:\n \n         boot_kws = {\"n_boot\": self.n_boot, \"seed\": self.seed}\n-        engine = EstimateAggregator(self.func, self.errorbar, **boot_kws)\n+        if \"weight\" in data:\n+            engine = WeightedAggregator(self.func, self.errorbar, **boot_kws)\n+        else:\n+            engine = EstimateAggregator(self.func, self.errorbar, **boot_kws)\n \n         var = {\"x\": \"y\", \"y\": \"x\"}[orient]\n         res = (\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "seaborn/categorical.py",
            "diff": "diff --git a/seaborn/categorical.py b/seaborn/categorical.py\nindex 6b4d85d..03b2268 100644\n--- a/seaborn/categorical.py\n+++ b/seaborn/categorical.py\n@@ -28,7 +28,11 @@ from seaborn.utils import (\n     _version_predates,\n )\n from seaborn._compat import MarkerStyle\n-from seaborn._statistics import EstimateAggregator, LetterValues\n+from seaborn._statistics import (\n+    EstimateAggregator,\n+    LetterValues,\n+    WeightedAggregator,\n+)\n from seaborn.palettes import light_palette\n from seaborn.axisgrid import FacetGrid, _facet_docs\n \n@@ -600,7 +604,7 @@ class _CategoricalPlotter(VectorPlotter):\n \n         if not fill and linewidth is None:\n             linewidth = mpl.rcParams[\"lines.linewidth\"]\n-\n+        bootstrap = plot_kws.pop(\"bootstrap\", mpl.rcParams[\"boxplot.bootstrap\"])\n         plot_kws.setdefault(\"shownotches\", plot_kws.pop(\"notch\", False))\n \n         box_artist = mpl.patches.Rectangle if fill else mpl.lines.Line2D\n@@ -626,7 +630,8 @@ class _CategoricalPlotter(VectorPlotter):\n \n             grouped = sub_data.groupby(self.orient)[value_var]\n             value_data = [x.to_numpy() for _, x in grouped]\n-            stats = pd.DataFrame(mpl.cbook.boxplot_stats(value_data, whis=whis))\n+            stats = pd.DataFrame(mpl.cbook.boxplot_stats(value_data, whis=whis,\n+                                                         bootstrap=bootstrap))\n             positions = grouped.grouper.result_index.to_numpy(dtype=float)\n \n             orig_width = width * self._native_width\n@@ -1384,11 +1389,16 @@ _categorical_docs = dict(\n         .. versionadded:: v0.12.0\n     n_boot : int\n         Number of bootstrap samples used to compute confidence intervals.\n+    seed : int, `numpy.random.Generator`, or `numpy.random.RandomState`\n+        Seed or random number generator for reproducible bootstrapping.\n     units : name of variable in `data` or vector data\n         Identifier of sampling units; used by the errorbar function to\n         perform a multilevel bootstrap and account for repeated measures\n-    seed : int, `numpy.random.Generator`, or `numpy.random.RandomState`\n-        Seed or random number generator for reproducible bootstrapping.\\\n+    weights : name of variable in `data` or vector data\n+        Data values or column used to compute weighted statistics.\n+        Note that the use of weights may limit other statistical options.\n+\n+        .. versionadded:: v0.13.1\\\n     \"\"\"),\n     ci=dedent(\"\"\"\\\n     ci : float\n@@ -2307,10 +2317,10 @@ swarmplot.__doc__ = dedent(\"\"\"\\\n \n def barplot(\n     data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n-    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,\n-    orient=None, color=None, palette=None, saturation=.75, fill=True, hue_norm=None,\n-    width=.8, dodge=\"auto\", gap=0, log_scale=None, native_scale=False, formatter=None,\n-    legend=\"auto\", capsize=0, err_kws=None,\n+    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, seed=None, units=None,\n+    weights=None, orient=None, color=None, palette=None, saturation=.75,\n+    fill=True, hue_norm=None, width=.8, dodge=\"auto\", gap=0, log_scale=None,\n+    native_scale=False, formatter=None, legend=\"auto\", capsize=0, err_kws=None,\n     ci=deprecated, errcolor=deprecated, errwidth=deprecated, ax=None, **kwargs,\n ):\n \n@@ -2323,7 +2333,7 @@ def barplot(\n \n     p = _CategoricalAggPlotter(\n         data=data,\n-        variables=dict(x=x, y=y, hue=hue, units=units),\n+        variables=dict(x=x, y=y, hue=hue, units=units, weight=weights),\n         order=order,\n         orient=orient,\n         color=color,\n@@ -2353,7 +2363,8 @@ def barplot(\n     p.map_hue(palette=palette, order=hue_order, norm=hue_norm, saturation=saturation)\n     color = _default_color(ax.bar, hue, color, kwargs, saturation=saturation)\n \n-    aggregator = EstimateAggregator(estimator, errorbar, n_boot=n_boot, seed=seed)\n+    agg_cls = WeightedAggregator if \"weight\" in p.plot_data else EstimateAggregator\n+    aggregator = agg_cls(estimator, errorbar, n_boot=n_boot, seed=seed)\n     err_kws = {} if err_kws is None else _normalize_kwargs(err_kws, mpl.lines.Line2D)\n \n     # Deprecations to remove in v0.15.0.\n@@ -2448,20 +2459,19 @@ barplot.__doc__ = dedent(\"\"\"\\\n \n def pointplot(\n     data=None, *, x=None, y=None, hue=None, order=None, hue_order=None,\n-    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,\n-    color=None, palette=None, hue_norm=None, markers=default, linestyles=default,\n-    dodge=False, log_scale=None, native_scale=False, orient=None, capsize=0,\n-    formatter=None, legend=\"auto\", err_kws=None,\n+    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, seed=None, units=None,\n+    weights=None, color=None, palette=None, hue_norm=None, markers=default,\n+    linestyles=default, dodge=False, log_scale=None, native_scale=False,\n+    orient=None, capsize=0, formatter=None, legend=\"auto\", err_kws=None,\n     ci=deprecated, errwidth=deprecated, join=deprecated, scale=deprecated,\n-    ax=None,\n-    **kwargs,\n+    ax=None, **kwargs,\n ):\n \n     errorbar = utils._deprecate_ci(errorbar, ci)\n \n     p = _CategoricalAggPlotter(\n         data=data,\n-        variables=dict(x=x, y=y, hue=hue, units=units),\n+        variables=dict(x=x, y=y, hue=hue, units=units, weight=weights),\n         order=order,\n         orient=orient,\n         # Handle special backwards compatibility where pointplot originally\n@@ -2488,7 +2498,8 @@ def pointplot(\n     p.map_hue(palette=palette, order=hue_order, norm=hue_norm)\n     color = _default_color(ax.plot, hue, color, kwargs)\n \n-    aggregator = EstimateAggregator(estimator, errorbar, n_boot=n_boot, seed=seed)\n+    agg_cls = WeightedAggregator if \"weight\" in p.plot_data else EstimateAggregator\n+    aggregator = agg_cls(estimator, errorbar, n_boot=n_boot, seed=seed)\n     err_kws = {} if err_kws is None else _normalize_kwargs(err_kws, mpl.lines.Line2D)\n \n     # Deprecations to remove in v0.15.0.\n@@ -2728,12 +2739,12 @@ countplot.__doc__ = dedent(\"\"\"\\\n \n def catplot(\n     data=None, *, x=None, y=None, hue=None, row=None, col=None, kind=\"strip\",\n-    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, units=None, seed=None,\n-    order=None, hue_order=None, row_order=None, col_order=None, col_wrap=None,\n-    height=5, aspect=1, log_scale=None, native_scale=False, formatter=None,\n-    orient=None, color=None, palette=None, hue_norm=None, legend=\"auto\",\n-    legend_out=True, sharex=True, sharey=True, margin_titles=False, facet_kws=None,\n-    ci=deprecated, **kwargs\n+    estimator=\"mean\", errorbar=(\"ci\", 95), n_boot=1000, seed=None, units=None,\n+    weights=None, order=None, hue_order=None, row_order=None, col_order=None,\n+    col_wrap=None, height=5, aspect=1, log_scale=None, native_scale=False,\n+    formatter=None, orient=None, color=None, palette=None, hue_norm=None,\n+    legend=\"auto\", legend_out=True, sharex=True, sharey=True,\n+    margin_titles=False, facet_kws=None, ci=deprecated, **kwargs\n ):\n \n     # Check for attempt to plot onto specific axes and warn\n@@ -2763,7 +2774,9 @@ def catplot(\n \n     p = Plotter(\n         data=data,\n-        variables=dict(x=x, y=y, hue=hue, row=row, col=col, units=units),\n+        variables=dict(\n+            x=x, y=y, hue=hue, row=row, col=col, units=units, weight=weights\n+        ),\n         order=order,\n         orient=orient,\n         # Handle special backwards compatibility where pointplot originally\n@@ -2839,6 +2852,14 @@ def catplot(\n     if dodge == \"auto\":\n         dodge = p._dodge_needed()\n \n+    if \"weight\" in p.plot_data:\n+        if kind not in [\"bar\", \"point\"]:\n+            msg = f\"The `weights` parameter has no effect with kind={kind!r}.\"\n+            warnings.warn(msg, stacklevel=2)\n+        agg_cls = WeightedAggregator\n+    else:\n+        agg_cls = EstimateAggregator\n+\n     if kind == \"strip\":\n \n         jitter = kwargs.pop(\"jitter\", True)\n@@ -2988,9 +3009,7 @@ def catplot(\n \n     elif kind == \"point\":\n \n-        aggregator = EstimateAggregator(\n-            estimator, errorbar, n_boot=n_boot, seed=seed\n-        )\n+        aggregator = agg_cls(estimator, errorbar, n_boot=n_boot, seed=seed)\n \n         markers = kwargs.pop(\"markers\", default)\n         linestyles = kwargs.pop(\"linestyles\", default)\n@@ -3024,9 +3043,8 @@ def catplot(\n \n     elif kind == \"bar\":\n \n-        aggregator = EstimateAggregator(\n-            estimator, errorbar, n_boot=n_boot, seed=seed\n-        )\n+        aggregator = agg_cls(estimator, errorbar, n_boot=n_boot, seed=seed)\n+\n         err_kws, capsize = p._err_kws_backcompat(\n             _normalize_kwargs(kwargs.pop(\"err_kws\", {}), mpl.lines.Line2D),\n             errcolor=kwargs.pop(\"errcolor\", deprecated),\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "seaborn/relational.py",
            "diff": "diff --git a/seaborn/relational.py b/seaborn/relational.py\nindex d4ade9d..8d0d856 100644\n--- a/seaborn/relational.py\n+++ b/seaborn/relational.py\n@@ -17,7 +17,7 @@ from .utils import (\n     _normalize_kwargs,\n     _scatter_legend_artist,\n )\n-from ._statistics import EstimateAggregator\n+from ._statistics import EstimateAggregator, WeightedAggregator\n from .axisgrid import FacetGrid, _facet_docs\n from ._docstrings import DocstringComponents, _core_docs\n \n@@ -252,7 +252,8 @@ class _LinePlotter(_RelationalPlotter):\n             raise ValueError(err.format(self.err_style))\n \n         # Initialize the aggregation object\n-        agg = EstimateAggregator(\n+        weighted = \"weight\" in self.plot_data\n+        agg = (WeightedAggregator if weighted else EstimateAggregator)(\n             self.estimator, self.errorbar, n_boot=self.n_boot, seed=self.seed,\n         )\n \n@@ -464,7 +465,7 @@ class _ScatterPlotter(_RelationalPlotter):\n \n def lineplot(\n     data=None, *,\n-    x=None, y=None, hue=None, size=None, style=None, units=None,\n+    x=None, y=None, hue=None, size=None, style=None, units=None, weights=None,\n     palette=None, hue_order=None, hue_norm=None,\n     sizes=None, size_order=None, size_norm=None,\n     dashes=True, markers=None, style_order=None,\n@@ -478,7 +479,9 @@ def lineplot(\n \n     p = _LinePlotter(\n         data=data,\n-        variables=dict(x=x, y=y, hue=hue, size=size, style=style, units=units),\n+        variables=dict(\n+            x=x, y=y, hue=hue, size=size, style=style, units=units, weight=weights\n+        ),\n         estimator=estimator, n_boot=n_boot, seed=seed, errorbar=errorbar,\n         sort=sort, orient=orient, err_style=err_style, err_kws=err_kws,\n         legend=legend,\n@@ -536,6 +539,10 @@ style : vector or key in `data`\n     and/or markers. Can have a numeric dtype but will always be treated\n     as categorical.\n {params.rel.units}\n+weights : vector or key in `data`\n+    Data values or column used to compute weighted estimation.\n+    Note that use of weights currently limits the choice of statistics\n+    to a 'mean' estimator and 'ci' errorbar.\n {params.core.palette}\n {params.core.hue_order}\n {params.core.hue_norm}\n@@ -687,7 +694,7 @@ Examples\n \n def relplot(\n     data=None, *,\n-    x=None, y=None, hue=None, size=None, style=None, units=None,\n+    x=None, y=None, hue=None, size=None, style=None, units=None, weights=None,\n     row=None, col=None, col_wrap=None, row_order=None, col_order=None,\n     palette=None, hue_order=None, hue_norm=None,\n     sizes=None, size_order=None, size_norm=None,\n@@ -725,9 +732,14 @@ def relplot(\n     variables = dict(x=x, y=y, hue=hue, size=size, style=style)\n     if kind == \"line\":\n         variables[\"units\"] = units\n-    elif units is not None:\n-        msg = \"The `units` parameter of `relplot` has no effect with kind='scatter'\"\n-        warnings.warn(msg, stacklevel=2)\n+        variables[\"weight\"] = weights\n+    else:\n+        if units is not None:\n+            msg = \"The `units` parameter has no effect with kind='scatter'.\"\n+            warnings.warn(msg, stacklevel=2)\n+        if weights is not None:\n+            msg = \"The `weights` parameter has no effect with kind='scatter'.\"\n+            warnings.warn(msg, stacklevel=2)\n     p = Plotter(\n         data=data,\n         variables=variables,\n@@ -780,17 +792,18 @@ def relplot(\n \n     # Add the grid semantics onto the plotter\n     grid_variables = dict(\n-        x=x, y=y, row=row, col=col,\n-        hue=hue, size=size, style=style,\n+        x=x, y=y, row=row, col=col, hue=hue, size=size, style=style,\n     )\n     if kind == \"line\":\n-        grid_variables[\"units\"] = units\n+        grid_variables.update(units=units, weights=weights)\n     p.assign_variables(data, grid_variables)\n \n     # Define the named variables for plotting on each facet\n     # Rename the variables with a leading underscore to avoid\n     # collisions with faceting variable names\n     plot_variables = {v: f\"_{v}\" for v in variables}\n+    if \"weight\" in plot_variables:\n+        plot_variables[\"weights\"] = plot_variables.pop(\"weight\")\n     plot_kws.update(plot_variables)\n \n     # Pass the row/col variables to FacetGrid with their original\n@@ -918,6 +931,10 @@ style : vector or key in `data`\n     Grouping variable that will produce elements with different styles.\n     Can have a numeric dtype but will always be treated as categorical.\n {params.rel.units}\n+weights : vector or key in `data`\n+    Data values or column used to compute weighted estimation.\n+    Note that use of weights currently limits the choice of statistics\n+    to a 'mean' estimator and 'ci' errorbar.\n {params.facets.rowcol}\n {params.facets.col_wrap}\n row_order, col_order : lists of strings\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "tests/_core/test_plot.py",
            "diff": "diff --git a/tests/_core/test_plot.py b/tests/_core/test_plot.py\nindex f5f8349..97e55e5 100644\n--- a/tests/_core/test_plot.py\n+++ b/tests/_core/test_plot.py\n@@ -579,10 +579,6 @@ class TestScaling:\n         assert_vector_equal(m.passed_data[0][\"x\"], pd.Series([0., 1.], [0, 1]))\n         assert_vector_equal(m.passed_data[1][\"x\"], pd.Series([0., 1.], [0, 1]))\n \n-    @pytest.mark.xfail(\n-        _version_predates(mpl, \"3.4.0\"),\n-        reason=\"Sharing paired categorical axes requires matplotlib>3.4.0\"\n-    )\n     def test_pair_categories_shared(self):\n \n         data = [(\"a\", \"a\"), (\"b\", \"c\")]\n@@ -1141,10 +1137,6 @@ class TestPlotting:\n         assert m.passed_axes == f.axes\n         assert p._figure is f\n \n-    @pytest.mark.skipif(\n-        _version_predates(mpl, \"3.4\"),\n-        reason=\"mpl<3.4 does not have SubFigure\",\n-    )\n     @pytest.mark.parametrize(\"facet\", [True, False])\n     def test_on_subfigure(self, facet):\n \n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "tests/_core/test_properties.py",
            "diff": "diff --git a/tests/_core/test_properties.py b/tests/_core/test_properties.py\nindex b476476..9356748 100644\n--- a/tests/_core/test_properties.py\n+++ b/tests/_core/test_properties.py\n@@ -7,7 +7,6 @@ from matplotlib.colors import same_color, to_rgb, to_rgba\n import pytest\n from numpy.testing import assert_array_equal\n \n-from seaborn.utils import _version_predates\n from seaborn._core.rules import categorical_order\n from seaborn._core.scales import Nominal, Continuous, Boolean\n from seaborn._core.properties import (\n@@ -250,9 +249,8 @@ class TestColor(DataFixtures):\n         assert f(\"#123456\") == to_rgb(\"#123456\")\n         assert f(\"#12345678\") == to_rgba(\"#12345678\")\n \n-        if not _version_predates(mpl, \"3.4.0\"):\n-            assert f(\"#123\") == to_rgb(\"#123\")\n-            assert f(\"#1234\") == to_rgba(\"#1234\")\n+        assert f(\"#123\") == to_rgb(\"#123\")\n+        assert f(\"#1234\") == to_rgba(\"#1234\")\n \n \n class ObjectPropertyBase(DataFixtures):\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "tests/_core/test_scales.py",
            "diff": "diff --git a/tests/_core/test_scales.py b/tests/_core/test_scales.py\nindex 8be674f..3218a8a 100644\n--- a/tests/_core/test_scales.py\n+++ b/tests/_core/test_scales.py\n@@ -571,10 +571,6 @@ class TestNominal:\n         s = Nominal()._setup(x, Coordinate())\n         assert_array_equal(s(x), [])\n \n-    @pytest.mark.skipif(\n-        _version_predates(mpl, \"3.4.0\"),\n-        reason=\"Test failing on older matplotlib for unclear reasons\",\n-    )\n     def test_finalize(self, x):\n \n         ax = mpl.figure.Figure().subplots()\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "tests/_stats/test_aggregation.py",
            "diff": "diff --git a/tests/_stats/test_aggregation.py b/tests/_stats/test_aggregation.py\nindex 08291d4..b3a5d58 100644\n--- a/tests/_stats/test_aggregation.py\n+++ b/tests/_stats/test_aggregation.py\n@@ -115,6 +115,17 @@ class TestEst(AggregationFixtures):\n         expected = est.assign(ymin=grouped.min()[\"y\"], ymax=grouped.max()[\"y\"])\n         assert_frame_equal(res, expected)\n \n+    def test_weighted_mean(self, df, rng):\n+\n+        weights = rng.uniform(0, 5, len(df))\n+        gb = self.get_groupby(df[[\"x\", \"y\"]], \"x\")\n+        df = df.assign(weight=weights)\n+        res = Est(\"mean\")(df, gb, \"x\", {})\n+        for _, res_row in res.iterrows():\n+            rows = df[df[\"x\"] == res_row[\"x\"]]\n+            expected = np.average(rows[\"y\"], weights=rows[\"weight\"])\n+            assert res_row[\"y\"] == expected\n+\n     def test_seed(self, df):\n \n         ori = \"x\"\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "tests/test_categorical.py",
            "diff": "diff --git a/tests/test_categorical.py b/tests/test_categorical.py\nindex cc3fa5b..9876452 100644\n--- a/tests/test_categorical.py\n+++ b/tests/test_categorical.py\n@@ -2131,6 +2131,13 @@ class TestBarPlot(SharedAggTests):\n         for i, bar in enumerate(ax.patches):\n             assert bar.get_height() == approx(agg_df[order[i]])\n \n+    def test_weighted_estimate(self, long_df):\n+\n+        ax = barplot(long_df, y=\"y\", weights=\"x\")\n+        height = ax.patches[0].get_height()\n+        expected = np.average(long_df[\"y\"], weights=long_df[\"x\"])\n+        assert height == expected\n+\n     def test_estimate_log_transform(self, long_df):\n \n         ax = mpl.figure.Figure().subplots()\n@@ -2490,6 +2497,13 @@ class TestPointPlot(SharedAggTests):\n         for i, xy in enumerate(ax.lines[0].get_xydata()):\n             assert tuple(xy) == approx((i, agg_df[order[i]]))\n \n+    def test_weighted_estimate(self, long_df):\n+\n+        ax = pointplot(long_df, y=\"y\", weights=\"x\")\n+        val = ax.lines[0].get_ydata().item()\n+        expected = np.average(long_df[\"y\"], weights=long_df[\"x\"])\n+        assert val == expected\n+\n     def test_estimate_log_transform(self, long_df):\n \n         ax = mpl.figure.Figure().subplots()\n@@ -3133,6 +3147,12 @@ class TestCatPlot(CategoricalFixture):\n         g2 = catplot(self.df, x=\"g\", y=\"y\", hue=\"g\", legend=True)\n         assert g2._legend is not None\n \n+    def test_weights_warning(self, long_df):\n+\n+        with pytest.warns(UserWarning, match=\"The `weights` parameter\"):\n+            g = catplot(long_df, x=\"a\", y=\"y\", weights=\"z\")\n+        assert g.ax is not None\n+\n \n class TestBeeswarm:\n \n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "tests/test_regression.py",
            "diff": "diff --git a/tests/test_regression.py b/tests/test_regression.py\nindex 4367597..368f6c5 100644\n--- a/tests/test_regression.py\n+++ b/tests/test_regression.py\n@@ -16,7 +16,6 @@ except ImportError:\n     _no_statsmodels = True\n \n from seaborn import regression as lm\n-from seaborn.utils import _version_predates\n from seaborn.palettes import color_palette\n \n rs = np.random.RandomState(0)\n@@ -611,8 +610,6 @@ class TestRegressionPlots:\n         npt.assert_array_equal(red, red_scatter.get_facecolors()[0, :3])\n         npt.assert_array_equal(blue, blue_scatter.get_facecolors()[0, :3])\n \n-    @pytest.mark.skipif(_version_predates(mpl, \"3.4\"),\n-                        reason=\"MPL bug #15967\")\n     @pytest.mark.parametrize(\"sharex\", [True, False])\n     def test_lmplot_facet_truncate(self, sharex):\n \n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "tests/test_relational.py",
            "diff": "diff --git a/tests/test_relational.py b/tests/test_relational.py\nindex 4c7ff43..f4f9706 100644\n--- a/tests/test_relational.py\n+++ b/tests/test_relational.py\n@@ -578,6 +578,15 @@ class TestRelationalPlotter(Helpers):\n             expected_paths = [paths[val] for val in grp_df[\"a\"]]\n             assert self.paths_equal(points.get_paths(), expected_paths)\n \n+    def test_relplot_weighted_estimator(self, long_df):\n+\n+        g = relplot(data=long_df, x=\"a\", y=\"y\", weights=\"x\", kind=\"line\")\n+        ydata = g.ax.lines[0].get_ydata()\n+        for i, level in enumerate(categorical_order(long_df[\"a\"])):\n+            pos_df = long_df[long_df[\"a\"] == level]\n+            expected = np.average(pos_df[\"y\"], weights=pos_df[\"x\"])\n+            assert ydata[i] == pytest.approx(expected)\n+\n     def test_relplot_stringy_numerics(self, long_df):\n \n         long_df[\"x_str\"] = long_df[\"x\"].astype(str)\n@@ -668,12 +677,16 @@ class TestRelationalPlotter(Helpers):\n         )\n         assert g.axes.shape == (1, len(col_data.unique()))\n \n-    def test_relplot_scatter_units(self, long_df):\n+    def test_relplot_scatter_unused_variables(self, long_df):\n \n         with pytest.warns(UserWarning, match=\"The `units` parameter\"):\n             g = relplot(long_df, x=\"x\", y=\"y\", units=\"a\")\n         assert g.ax is not None\n \n+        with pytest.warns(UserWarning, match=\"The `weights` parameter\"):\n+            g = relplot(long_df, x=\"x\", y=\"y\", weights=\"x\")\n+        assert g.ax is not None\n+\n     def test_ax_kwarg_removal(self, long_df):\n \n         f, ax = plt.subplots()\n@@ -1055,6 +1068,15 @@ class TestLinePlotter(SharedAxesLevelTests, Helpers):\n         ax.clear()\n         p.plot(ax, {})\n \n+    def test_weights(self, long_df):\n+\n+        ax = lineplot(long_df, x=\"a\", y=\"y\", weights=\"x\")\n+        vals = ax.lines[0].get_ydata()\n+        for i, level in enumerate(categorical_order(long_df[\"a\"])):\n+            pos_df = long_df[long_df[\"a\"] == level]\n+            expected = np.average(pos_df[\"y\"], weights=pos_df[\"x\"])\n+            assert vals[i] == pytest.approx(expected)\n+\n     def test_non_aggregated_data(self):\n \n         x = [1, 2, 3, 4]\n@@ -1302,6 +1324,9 @@ class TestLinePlotter(SharedAxesLevelTests, Helpers):\n         lineplot(x=\"x\", y=\"y\", hue=\"f\", size=\"s\", data=object_df)\n         ax.clear()\n \n+        lineplot(x=\"x\", y=\"y\", hue=\"a\", data=long_df.iloc[:0])\n+        ax.clear()\n+\n     def test_ci_deprecation(self, long_df):\n \n         axs = plt.figure().subplots(2)\n"
        },
        {
            "commit": "2201be21886bb82201f3c3487f5f1468f6e6ac81",
            "file_path": "tests/test_statistics.py",
            "diff": "diff --git a/tests/test_statistics.py b/tests/test_statistics.py\nindex c0d4e83..ab6cc02 100644\n--- a/tests/test_statistics.py\n+++ b/tests/test_statistics.py\n@@ -15,6 +15,7 @@ from seaborn._statistics import (\n     ECDF,\n     EstimateAggregator,\n     LetterValues,\n+    WeightedAggregator,\n     _validate_errorbar_arg,\n     _no_scipy,\n )\n@@ -632,6 +633,39 @@ class TestEstimateAggregator:\n                 _validate_errorbar_arg(arg)\n \n \n+class TestWeightedAggregator:\n+\n+    def test_weighted_mean(self, long_df):\n+\n+        long_df[\"weight\"] = long_df[\"x\"]\n+        est = WeightedAggregator(\"mean\")\n+        out = est(long_df, \"y\")\n+        expected = np.average(long_df[\"y\"], weights=long_df[\"weight\"])\n+        assert_array_equal(out[\"y\"], expected)\n+        assert_array_equal(out[\"ymin\"], np.nan)\n+        assert_array_equal(out[\"ymax\"], np.nan)\n+\n+    def test_weighted_ci(self, long_df):\n+\n+        long_df[\"weight\"] = long_df[\"x\"]\n+        est = WeightedAggregator(\"mean\", \"ci\")\n+        out = est(long_df, \"y\")\n+        expected = np.average(long_df[\"y\"], weights=long_df[\"weight\"])\n+        assert_array_equal(out[\"y\"], expected)\n+        assert (out[\"ymin\"] <= out[\"y\"]).all()\n+        assert (out[\"ymax\"] >= out[\"y\"]).all()\n+\n+    def test_limited_estimator(self):\n+\n+        with pytest.raises(ValueError, match=\"Weighted estimator must be 'mean'\"):\n+            WeightedAggregator(\"median\")\n+\n+    def test_limited_ci(self):\n+\n+        with pytest.raises(ValueError, match=\"Error bar method must be 'ci'\"):\n+            WeightedAggregator(\"mean\", \"sd\")\n+\n+\n class TestLetterValues:\n \n     @pytest.fixture\n"
        }
    ]
}
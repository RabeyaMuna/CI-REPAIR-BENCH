{
    "sha_fail": "33ed019c7f623b9fb89b1430b38c7e7a7aefa57c",
    "changed_files": [
        {
            "commit": "33ed019c7f623b9fb89b1430b38c7e7a7aefa57c",
            "file_path": "libs/agno/agno/agent/agent.py",
            "diff": "diff --git a/libs/agno/agno/agent/agent.py b/libs/agno/agno/agent/agent.py\nindex c4585653d..6ac9e0752 100644\n--- a/libs/agno/agno/agent/agent.py\n+++ b/libs/agno/agno/agent/agent.py\n@@ -82,6 +82,7 @@ class Agent:\n     # Session state (stored in the database to persist across runs)\n     session_state: Optional[Dict[str, Any]] = None\n     search_previous_sessions_history: bool = False\n+    number_of_sessions: Optional[int] = None\n \n     # --- Agent Context ---\n     # Context available for tools and prompt functions\n@@ -290,7 +291,8 @@ class Agent:\n         session_id: Optional[str] = None,\n         session_name: Optional[str] = None,\n         session_state: Optional[Dict[str, Any]] = None,\n-        search_previous_sessions_history: bool = False,\n+        search_previous_sessions_history: Optional[bool] = False,\n+        number_of_sessions: Optional[int] = None,\n         context: Optional[Dict[str, Any]] = None,\n         add_context: bool = False,\n         resolve_context: bool = True,\n@@ -374,6 +376,7 @@ class Agent:\n         self.session_name = session_name\n         self.session_state = session_state\n         self.search_previous_sessions_history = search_previous_sessions_history\n+        self.number_of_sessions = number_of_sessions\n \n         self.context = context\n         self.add_context = add_context\n@@ -2075,7 +2078,11 @@ class Agent:\n         if self.read_tool_call_history:\n             agent_tools.append(self.get_tool_call_history_function(session_id=session_id))\n         if self.search_previous_sessions_history:\n-            agent_tools.append(self.get_messages_from_previous_sessions(number_of_sessions=3))\n+            agent_tools.append(\n+                self.get_previous_sessions_messages_function(\n+                    number_of_sessions=self.number_of_sessions,\n+                )\n+            )\n \n         if isinstance(self.memory, AgentMemory) and self.memory.create_user_memories:\n             agent_tools.append(self.update_memory)\n@@ -2918,18 +2925,6 @@ class Agent:\n                         \"</updating_user_memories>\\n\\n\"\n                     )\n \n-            if self.search_previous_sessions_history:\n-                additional_information.append(\n-                    dedent(\"\"\"\n-                You have access to messages from previous chat sessions through the `get_messages_from_previous_sessions` tool.\n-                - Use this tool to retrieve and analyze messages whenever asked a question similar to- \"What was my last conversation?\"\n-                - The tool returns messages in chronological order from previous sessions\n-                - You can specify how many previous sessions to look at (default is 3)\n-                - Use this information to maintain context and provide more personalized responses\n-                - Always prefer information from the current conversation over past sessions\n-                \"\"\").strip()\n-                )\n-\n             # 3.3.11 Then add a summary of the interaction to the system prompt\n             if isinstance(self.memory, AgentMemory) and self.memory.create_session_summary:\n                 if self.memory.summary is not None:\n@@ -3184,13 +3179,6 @@ class Agent:\n                     session_id=session_id, last_n=self.num_history_runs, skip_role=self.system_message_role\n                 )\n \n-            # # Add messages from previous sessions if enabled\n-            # if self.search_previous_sessions_history:\n-            #     previous_sessions_history = self.get_messages_from_previous_sessions(\n-            #         number_of_sessions=3,\n-            #     )\n-            #     history.extend(previous_sessions_history)\n-\n             if len(history) > 0:\n                 # Create a deep copy of the history messages to avoid modifying the original messages\n                 history_copy = [deepcopy(msg) for msg in history]\n@@ -5817,36 +5805,68 @@ class Agent:\n \n         return effective_filters\n \n-    def get_messages_from_previous_sessions(self, number_of_sessions: int) -> List[Message]:\n-        \"\"\"Internal helper method to get messages from previous sessions.\"\"\"\n-        if self.storage is None:\n-            return []\n+    def get_previous_sessions_messages_function(self, number_of_sessions: int = 3) -> Callable:\n+        \"\"\"Factory function to create a get_previous_session_messages function.\n+\n+        Args:\n+            user_id: The user ID to get sessions for\n+            number_of_sessions: The last n sessions to be taken from db\n+\n+        Returns:\n+            Callable: A function that retrieves messages from previous sessions\n+        \"\"\"\n+\n+        def get_previous_session_messages(max_messages_per_session: int = 10) -> str:\n+            \"\"\"Use this function to retrieve messages from previous chat sessions.\n+            USE THIS TOOL ONLY WHEN THE QUESTION IS EITHER \"What was my last conversation?\" or \"What was my last question?\" and similar to it.\n+\n+            Args:\n+            max_messages_per_session: The number of messages to retrieve from each session (To avoid context length issues)\n+\n+            Returns:\n+                str: JSON formatted list of message pairs from previous sessions\n+            \"\"\"\n+            import json\n \n-        sessions = self.storage.get_all_sessions(user_id=self.user_id)\n-        sorted_sessions = sorted(sessions, key=lambda x: x.created_at if x.created_at else 0, reverse=True)\n-        selected_sessions = sorted_sessions[:number_of_sessions]\n-\n-        all_messages = []\n-        seen_message_pairs = set()\n-\n-        for session in selected_sessions:\n-            if isinstance(session, AgentSession) and session.memory:\n-                for run in session.memory.get(\"runs\", []):\n-                    messages = run.get(\"messages\", [])\n-                    for i in range(0, len(messages) - 1, 2):\n-                        if i + 1 < len(messages):\n-                            try:\n-                                user_msg = messages[i]\n-                                assistant_msg = messages[i + 1]\n-                                msg_pair_id = f\"{user_msg.get('content', '')}:{assistant_msg.get('content', '')}\"\n-                                if msg_pair_id not in seen_message_pairs:\n-                                    seen_message_pairs.add(msg_pair_id)\n-                                    all_messages.append(Message.model_validate(user_msg))\n-                                    all_messages.append(Message.model_validate(assistant_msg))\n-                            except Exception as e:\n-                                log_warning(f\"Error processing message pair: {e}\")\n-                                continue\n-        return all_messages\n+            if self.storage is None:\n+                return \"Storage not available\"\n+\n+            sessions = self.storage.get_all_sessions(user_id=self.user_id)\n+            sorted_sessions = sorted(sessions, key=lambda x: x.created_at if x.created_at else 0, reverse=True)\n+            selected_sessions = sorted_sessions[:number_of_sessions]\n+\n+            all_messages = []\n+            seen_message_pairs = set()\n+\n+            for session in selected_sessions:\n+                if isinstance(session, AgentSession) and session.memory:\n+                    message_count = 0\n+                    for run in session.memory.get(\"runs\", []):\n+                        if message_count >= max_messages_per_session:\n+                            break\n+\n+                        messages = run.get(\"messages\", [])\n+                        for i in range(0, len(messages) - 1, 2):\n+                            if message_count >= max_messages_per_session:\n+                                break\n+\n+                            if i + 1 < len(messages):\n+                                try:\n+                                    user_msg = messages[i]\n+                                    assistant_msg = messages[i + 1]\n+                                    msg_pair_id = f\"{user_msg.get('content', '')}:{assistant_msg.get('content', '')}\"\n+                                    if msg_pair_id not in seen_message_pairs:\n+                                        seen_message_pairs.add(msg_pair_id)\n+                                        all_messages.append(Message.model_validate(user_msg))\n+                                        all_messages.append(Message.model_validate(assistant_msg))\n+                                        message_count += 1\n+                                except Exception as e:\n+                                    log_warning(f\"Error processing message pair: {e}\")\n+                                    continue\n+\n+            return json.dumps([msg.to_dict() for msg in all_messages]) if all_messages else \"No history found\"\n+\n+        return get_previous_session_messages\n \n     def cli_app(\n         self,\n"
        }
    ]
}
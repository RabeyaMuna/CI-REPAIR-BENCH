{
    "sha_fail": "fa597eab63defb9e7e146e73c6ee23fb00f16284",
    "changed_files": [
        {
            "commit": "fa597eab63defb9e7e146e73c6ee23fb00f16284",
            "file_path": "cookbook/tools/bitbucket_tools.py",
            "diff": "diff --git a/cookbook/tools/bitbucket_tools.py b/cookbook/tools/bitbucket_tools.py\nindex bc279ec33..42716532d 100644\n--- a/cookbook/tools/bitbucket_tools.py\n+++ b/cookbook/tools/bitbucket_tools.py\n@@ -1,62 +1,35 @@\n \"\"\"\n-This example demonstrates how to use the BitbucketTools to interact with Bitbucket Cloud.\n-\n-Setup Instructions:\n-1. Create a Bitbucket Cloud account if you don't have one\n-2. Generate an App Password:\n+Setup:\n+1. Generate an App Password:\n    - Go to \"Personal Bitbucket settings\" -> \"App passwords\"\n-   - Create a new App password with the required permissions:\n-     - Account: Email, Read\n-     - Workspace membership: Read\n-     - Projects: Read\n-     - Repositories: Read, Write, Admin\n-     - Pull requests: Read, Write\n-     - Issues: Read, Write\n-3. Set environment variables:\n+   - Create a new App password with the appropriate permissions\n+\n+2. Set environment variables:\n    - BITBUCKET_USERNAME: Your Bitbucket username\n    - BITBUCKET_PASSWORD: Your generated App password\n-\n-The BitbucketTools will automatically use these credentials from environment variables.\n-For local development, you can add them to your .envrc file:\n-\n-export BITBUCKET_USERNAME=\"xxx\"\n-export BITBUCKET_PASSWORD=\"xxx\"\n-\n \"\"\"\n+\n from agno.agent import Agent\n from agno.tools.bitbucket import BitbucketTools\n \n-repo_slug = \"Your Repository Slug\"\n-workspace = \"Your Workspace\"\n+repo_slug = \"ai\"\n+workspace = \"MaximMFP\"\n \n agent = Agent(\n-    instructions=[\n-        f\"Use your tools to answer questions about the repo {repo_slug} in the {workspace} workspace\",\n-        \"Do not create any issues or pull requests unless explicitly asked to do so\",\n-    ],\n-    tools=[BitbucketTools()],\n+    tools=[BitbucketTools(workspace=workspace, repo_slug=repo_slug)],\n     show_tool_calls=True,\n )\n \n-# Example usage: List all the open pull requests\n-# agent.print_response(\"List open pull requests\", markdown=True)\n-\n-# Example usage: Get pull request details\n-# agent.print_response(\"Get details of #230\", markdown=True)\n-\n-# Example usage: Get pull request changes\n-# agent.print_response(\"Show changes for #230\", markdown=True)\n+agent.print_response(\"List open pull requests\", markdown=True)\n \n-# Example usage: List open issues. Only works if the repository has issues enabled\n-# agent.print_response(\"What is the latest opened issue?\", markdown=True)\n+# Example 1: Get specific pull request details\n+# agent.print_response(\"Get details of pull request #23\", markdown=True)\n \n-# Example usage: Get the repo details\n+# Example 2: Get the repo details\n # agent.print_response(\"Get details of the repository\", markdown=True)\n \n-# Example usage: List all the repositories\n+# Example 3: List repositories\n # agent.print_response(\"List 5 repositories for this workspace\", markdown=True)\n \n-# Example usage: Create a Repo. Needs Admin Repository access when using App Password\n-# agent.print_response(\n-#     \"Create a repo called agent-testing and add description hello\", markdown=True\n-# )\n+# Example 4: List commits\n+# agent.print_response(\"List the last 20 commits\", markdown=True)\n"
        },
        {
            "commit": "fa597eab63defb9e7e146e73c6ee23fb00f16284",
            "file_path": "libs/agno/agno/tools/bitbucket.py",
            "diff": "diff --git a/libs/agno/agno/tools/bitbucket.py b/libs/agno/agno/tools/bitbucket.py\nindex 7e04948a5..8b2f30d13 100644\n--- a/libs/agno/agno/tools/bitbucket.py\n+++ b/libs/agno/agno/tools/bitbucket.py\n@@ -10,58 +10,17 @@ from agno.utils.log import logger\n \n \n class BitbucketTools(Toolkit):\n-    \"\"\"A class that provides tools for interacting with the Bitbucket API.\"\"\"\n-\n     def __init__(\n         self,\n         server_url: str = \"api.bitbucket.org\",\n         username: Optional[str] = None,\n         password: Optional[str] = None,\n         token: Optional[str] = None,\n+        workspace: Optional[str] = None,\n+        repo_slug: Optional[str] = None,\n         api_version: str = \"2.0\",\n-        list_repositories: bool = True,\n-        get_repository: bool = True,\n-        create_repository: bool = True,\n-        list_repository_commits: bool = True,\n-        list_pull_requests: bool = True,\n-        get_pull_request: bool = True,\n-        get_pull_request_changes: bool = True,\n-        list_issues: bool = True,\n-        list_repository_pipelines: bool = True,\n+        **kwargs,\n     ):\n-        \"\"\"Initializes Bitbucket Tools.\n-\n-        Args:\n-            server_url (str, optional): The Bitbucket server URL. Defaults to \"api.bitbucket.org\".\n-            username (str, optional): The username to authenticate with. If not provided, it will take the value of `BITBUCKET_USERNAME` env variable.\n-            password (str, optional): The password to authenticate with. If not provided, it will take the value of `BITBUCKET_PASSWORD` env variable.\n-            token (str, optional): The token to authenticate with. If not provided, it will take the value of `BITBUCKET_TOKEN` env variable.\n-            api_version (str, optional): The version of the Bitbucket API to use. Defaults to \"2.0\".\n-            list_repositories (bool, optional): Whether to register the `list_repositories` method. Defaults to True.\n-            get_repository (bool, optional): Whether to register the `get_repository` method. Defaults to True.\n-            create_repository (bool, optional): Whether to register the `create_repository` method. Defaults to True.\n-            list_repository_commits (bool, optional): Whether to register the `list_repository_commits` method. Defaults to True.\n-            list_pull_requests (bool, optional): Whether to register the `list_pull_requests` method. Defaults to True.\n-            get_pull_request (bool, optional): Whether to register the `get_pull_request` method. Defaults to True.\n-            get_pull_request_changes (bool, optional): Whether to register the `get_pull_request_changes` method. Defaults to True.\n-            list_issues (bool, optional): Whether to register the `list_issues` method. Defaults to True.\n-            list_repository_pipelines (bool, optional): Whether to register the `list_repository_pipelines` method. Defaults to True.\n-\n-        Raises:\n-            ValueError: If username and password or token are not provided.\n-\n-        Example:\n-            ```python\n-            bitbucket = BitbucketTools(\n-                username=\"your-username\",\n-                password=\"your-password\",\n-                server_url=\"your-server-url\",\n-                api_version=\"2.0\"\n-            )\n-            ```\n-        \"\"\"\n-        super().__init__(name=\"bitbucket\")\n-\n         self.username = username or os.getenv(\"BITBUCKET_USERNAME\")\n         self.password = password or os.getenv(\"BITBUCKET_PASSWORD\")\n         self.token = token or os.getenv(\"BITBUCKET_TOKEN\")\n@@ -73,39 +32,35 @@ class BitbucketTools(Toolkit):\n             if not self.server_url.startswith((\"http://\", \"https://\"))\n             else f\"{self.server_url}/{api_version}\"\n         )\n+        self.workspace = workspace\n+        self.repo_slug = repo_slug\n \n         if not (self.username and self.auth_password):\n-            logger.error(\"Username and password or token are required\")\n             raise ValueError(\"Username and password or token are required\")\n \n+        if not self.workspace:\n+            raise ValueError(\"Workspace is required\")\n+        if not self.repo_slug:\n+            raise ValueError(\"Repo slug is required\")\n+\n         self.headers = {\"Accept\": \"application/json\", \"Authorization\": f\"Basic {self._generate_access_token()}\"}\n \n-        # Register methods\n-        if list_repositories:\n-            self.register(self.list_repositories)\n-        if get_repository:\n-            self.register(self.get_repository)\n-        if create_repository:\n-            self.register(self.create_repository)\n-        if list_repository_commits:\n-            self.register(self.list_repository_commits)\n-        if list_pull_requests:\n-            self.register(self.list_pull_requests)\n-        if get_pull_request:\n-            self.register(self.get_pull_request)\n-        if get_pull_request_changes:\n-            self.register(self.get_pull_request_changes)\n-        if list_issues:\n-            self.register(self.list_issues)\n-        if list_repository_pipelines:\n-            self.register(self.list_repository_pipelines)\n+        super().__init__(\n+            name=\"bitbucket\",\n+            tools=[\n+                self.list_repositories,\n+                self.get_repository_details,\n+                self.create_repository,\n+                self.list_repository_commits,\n+                self.list_all_pull_requests,\n+                self.get_pull_request_details,\n+                self.get_pull_request_changes,\n+                self.list_issues,\n+            ],\n+            **kwargs,\n+        )\n \n     def _generate_access_token(self) -> str:\n-        \"\"\"Generate an access token for Bitbucket API using Basic Auth.\n-\n-        Returns:\n-            str: The access token.\n-        \"\"\"\n         auth_str = f\"{self.username}:{self.auth_password}\"\n         auth_bytes = auth_str.encode(\"ascii\")\n         auth_base64 = base64.b64encode(auth_bytes).decode(\"ascii\")\n@@ -118,17 +73,6 @@ class BitbucketTools(Toolkit):\n         params: Optional[Dict[str, Any]] = None,\n         data: Optional[Dict[str, Any]] = None,\n     ) -> Union[str, Dict[str, Any]]:\n-        \"\"\"Make a request to Bitbucket API.\n-\n-        Args:\n-            method (str): The HTTP method to use for the request.\n-            endpoint (str): The API endpoint to make the request to.\n-            params (Dict[str, Any], optional): Query parameters to include in the request. Defaults to None.\n-            data (Dict[str, Any], optional): The payload to send with the request. Defaults to None.\n-\n-        Returns:\n-            Union[str, Dict[str, Any]]: The response from the API as a string or a dictionary.\n-        \"\"\"\n         url = f\"{self.base_url}{endpoint}\"\n         response = requests.request(method, url, headers=self.headers, json=data, params=params)\n         response.raise_for_status()\n@@ -141,50 +85,47 @@ class BitbucketTools(Toolkit):\n         logger.warning(f\"Unsupported content type: {encoding_type}\")\n         return {}\n \n-    def list_repositories(self, workspace: str, page: int = 1, pagelen: int = 10) -> str:\n+    def list_repositories(self, count: int = 10) -> str:\n         \"\"\"\n-        List repository info for a given workspace.\n-        API Docs: https://developer.atlassian.com/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-get\n-\n+        Get all repositories in the workspace.\n         Args:\n-            workspace (str): The slug of the workspace where the repository exists.\n-            page (int, optional): The page number to retrieve. Defaults to 1.\n-            pagelen (int, optional): The number of repositories to retrieve per page. Defaults to 10.\n+            count (int, optional): The number of repositories to retrieve\n \n         Returns:\n             str: A JSON string containing repository list.\n         \"\"\"\n         try:\n-            params = {\"page\": page, \"pagelen\": pagelen}\n-            repo = self._make_request(\"GET\", f\"/repositories/{workspace}\", params=params)\n+            # Limit count to maximum of 50\n+            count = min(count, 50)\n+\n+            # Use count directly as pagelen for simplicity, max out at 50 per our limit\n+            pagelen = min(count, 50)\n+            params = {\"page\": 1, \"pagelen\": pagelen}\n+\n+            repo = self._make_request(\"GET\", f\"/repositories/{self.workspace}\", params=params)\n+\n             return json.dumps(repo, indent=2)\n         except Exception as e:\n-            logger.error(f\"Error retrieving repository list for workspace {workspace}: {str(e)}\")\n+            logger.error(f\"Error retrieving repository list for workspace {self.workspace}: {str(e)}\")\n             return json.dumps({\"error\": str(e)})\n \n-    def get_repository(self, workspace: str, repo_slug: str) -> str:\n+    def get_repository_details(self) -> str:\n         \"\"\"\n         Retrieves repository information.\n         API Docs: https://developer.atlassian.com/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-repo-slug-get\n \n-        Args:\n-            workspace (str): The slug of the workspace where the repository exists.\n-            repo_slug (str): The slug of the repository to retrieve information for.\n-\n         Returns:\n             str: A JSON string containing repository information.\n         \"\"\"\n         try:\n-            repo = self._make_request(\"GET\", f\"/repositories/{workspace}/{repo_slug}\")\n+            repo = self._make_request(\"GET\", f\"/repositories/{self.workspace}/{self.repo_slug}\")\n             return json.dumps(repo, indent=2)\n         except Exception as e:\n-            logger.error(f\"Error retrieving repository information for {repo_slug}: {str(e)}\")\n+            logger.error(f\"Error retrieving repository information for {self.repo_slug}: {str(e)}\")\n             return json.dumps({\"error\": str(e)})\n \n     def create_repository(\n         self,\n-        workspace: str,\n-        repo_slug: str,\n         name: str,\n         project: Optional[str] = None,\n         is_private: bool = False,\n@@ -195,18 +136,15 @@ class BitbucketTools(Toolkit):\n     ) -> str:\n         \"\"\"\n         Creates a new repository in Bitbucket for the given workspace.\n-        API Docs: https://developer.atlassian.com/cloud/bitbucket/rest/api-group-repositories/#api-repositories-workspace-repo-slug-post\n \n         Args:\n-            workspace (str): The slug of the workspace where the repository exists.\n-            repo_slug (str): The slug of the new repository.\n             name (str): The name of the new repository.\n-            project (str, optional): The key of the project to create the repository in. Defaults to None. If not provided, the repository will be created in the oldest project in the workspace.\n-            is_private (bool, optional): Whether the repository is private. Defaults to False.\n-            description (str, optional): A short description of the repository. Defaults to None.\n-            language (str, optional): The primary language of the repository. Defaults to None.\n-            has_issues (bool, optional): Whether the repository has issues enabled. Defaults to False.\n-            has_wiki (bool, optional): Whether the repository has a wiki enabled. Defaults to False.\n+            project (str, optional): The key of the project to create the repository in.\n+            is_private (bool, optional): Whether the repository is private.\n+            description (str, optional): A short description of the repository.\n+            language (str, optional): The primary language of the repository\n+            has_issues (bool, optional): Whether the repository has issues enabled.\n+            has_wiki (bool, optional): Whether the repository has a wiki enabled.\n \n         Returns:\n             str: A JSON string containing repository information.\n@@ -223,108 +161,99 @@ class BitbucketTools(Toolkit):\n             }\n             if project:\n                 payload[\"project\"] = {\"key\": project}\n-            repo = self._make_request(\"POST\", f\"/repositories/{workspace}/{repo_slug}\", data=payload)\n+            repo = self._make_request(\"POST\", f\"/repositories/{self.workspace}/{self.repo_slug}\", data=payload)\n             return json.dumps(repo, indent=2)\n         except Exception as e:\n-            logger.error(f\"Error creating repository {repo_slug} for {workspace}: {str(e)}\")\n+            logger.error(f\"Error creating repository {self.repo_slug} for {self.workspace}: {str(e)}\")\n             return json.dumps({\"error\": str(e)})\n \n-    def list_repository_commits(\n-        self, workspace: str, repo_slug: str, ctx: Optional[str] = None, page: int = 1, pagelen: int = 10\n-    ) -> str:\n+    def list_repository_commits(self, count: int = 10) -> str:\n         \"\"\"\n         Retrieves all commits in a repository.\n-        API Docs: https://developer.atlassian.com/cloud/bitbucket/rest/api-group-commits/#api-repositories-workspace-repo-slug-commits-get\n-\n-        Note: The underlying API uses cursor based pagination, so refrain from using the page parameter. Multiple API calls need to be made to retrieve commits of next pages.\n \n         Args:\n-            workspace (str): The slug of the workspace where the repository exists.\n-            repo_slug (str): The slug of the repository to retrieve commits for.\n-            ctx (str, optional): The cursor to navigate between pages. Provided by Bitbucket API. Defaults to None.\n-            page (int, optional): The page number to retrieve. Defaults to 1.\n-            pagelen (int, optional): The number of commits to retrieve per page. Defaults to 10.\n+            count (int, optional): The number of commits to retrieve. Defaults to 10. Maximum 50.\n \n         Returns:\n             str: A JSON string containing all commits.\n         \"\"\"\n         try:\n-            if ctx:\n-                commits = self._make_request(\n-                    \"GET\", f\"/repositories/{workspace}/{repo_slug}/commits?ctx={ctx}&page={page}&pagelen={pagelen}\"\n-                )\n-            else:\n-                commits = self._make_request(\"GET\", f\"/repositories/{workspace}/{repo_slug}/commits?pagelen={pagelen}\")\n-                for i in range(2, page + 1):\n+            count = min(count, 50)\n+            params = {\"pagelen\": count}\n+\n+            commits = self._make_request(\n+                \"GET\", f\"/repositories/{self.workspace}/{self.repo_slug}/commits\", params=params\n+            )\n+\n+            if isinstance(commits, dict) and commits.get(\"next\"):\n+                collected_commits = commits.get(\"values\", [])\n+\n+                while len(collected_commits) < count and isinstance(commits, dict) and commits.get(\"next\"):\n                     next_url = commits[\"next\"]  # type: ignore\n-                    query_param = next_url.split(\"?\")[1]\n-                    commits = self._make_request(\"GET\", f\"/repositories/{workspace}/{repo_slug}/commits?{query_param}\")\n+                    query_param = next_url.split(\"?\")[1] if \"?\" in next_url else \"\"\n+                    commits = self._make_request(\n+                        \"GET\", f\"/repositories/{self.workspace}/{self.repo_slug}/commits?{query_param}\"\n+                    )\n+                    if isinstance(commits, dict):\n+                        collected_commits.extend(commits.get(\"values\", []))\n+\n+                if isinstance(commits, dict):\n+                    commits[\"values\"] = collected_commits[:count]\n+\n             return json.dumps(commits, indent=2)\n         except Exception as e:\n-            logger.error(f\"Error retrieving commits for {repo_slug}: {str(e)}\")\n+            logger.error(f\"Error retrieving commits for {self.repo_slug}: {str(e)}\")\n             return json.dumps({\"error\": str(e)})\n \n-    def list_pull_requests(\n-        self, workspace: str, repo_slug: str, state: str = \"OPEN\", page: int = 1, pagelen: int = 10\n-    ) -> str:\n+    def list_all_pull_requests(self, state: str = \"OPEN\") -> str:\n         \"\"\"\n         Retrieves all pull requests for a repository.\n-        API Docs: https://developer.atlassian.com/cloud/bitbucket/rest/api-group-pullrequests/#api-repositories-workspace-repo-slug-pullrequests-get\n \n         Args:\n-            workspace (str): The slug of the workspace where the repository exists.\n-            repo_slug (str): The slug of the repository to retrieve pull requests for.\n-            state (str, optional): The state of the pull requests to retrieve. Defaults to \"OPEN\". Possible values: \"OPEN\", \"MERGED\", \"DECLINED\", \"SUPERSEDED\".\n-            page (int, optional): The page number to retrieve. Defaults to 1.\n-            pagelen (int, optional): The number of pull requests to retrieve per page. Defaults to 10.\n+            state (str, optional): The state of the pull requests to retrieve.\n \n         Returns:\n             str: A JSON string containing all pull requests.\n         \"\"\"\n         try:\n-            VALID_STATES = [\"OPEN\", \"MERGED\", \"DECLINED\", \"SUPERSEDED\"]\n-            if state not in VALID_STATES:\n-                raise ValueError(f\"Invalid state: {state}. Valid states are: {', '.join(VALID_STATES)}\")\n+            if state not in [\"OPEN\", \"MERGED\", \"DECLINED\", \"SUPERSEDED\"]:\n+                logger.debug(f\"Invalid pull request state: {state}. Defaulting to OPEN\")\n+                state = \"OPEN\"\n+\n+            params = {\"state\": state}\n \n-            params = {\"state\": state, \"page\": page, \"pagelen\": pagelen}\n             pull_requests = self._make_request(\n-                \"GET\", f\"/repositories/{workspace}/{repo_slug}/pullrequests\", params=params\n+                \"GET\", f\"/repositories/{self.workspace}/{self.repo_slug}/pullrequests\", params=params\n             )\n+\n             return json.dumps(pull_requests, indent=2)\n         except Exception as e:\n-            logger.error(f\"Error retrieving pull requests for {repo_slug}: {str(e)}\")\n+            logger.error(f\"Error retrieving pull requests for {self.repo_slug}: {str(e)}\")\n             return json.dumps({\"error\": str(e)})\n \n-    def get_pull_request(self, workspace: str, repo_slug: str, pull_request_id: int) -> str:\n+    def get_pull_request_details(self, pull_request_id: int) -> str:\n         \"\"\"\n         Retrieves a pull request for a repository.\n-        API Docs: https://developer.atlassian.com/cloud/bitbucket/rest/api-group-pullrequests/#api-repositories-workspace-repo-slug-pullrequests-pull-request-id-get\n-\n         Args:\n-            workspace (str): The slug of the workspace where the repository exists.\n-            repo_slug (str): The slug of the repository to retrieve pull requests for.\n             pull_request_id (int): The ID of the pull request to retrieve.\n \n         Returns:\n             str: A JSON string containing the pull request.\n         \"\"\"\n         try:\n-            pull_requests = self._make_request(\n-                \"GET\", f\"/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}\"\n+            pull_request = self._make_request(\n+                \"GET\", f\"/repositories/{self.workspace}/{self.repo_slug}/pullrequests/{pull_request_id}\"\n             )\n-            return json.dumps(pull_requests, indent=2)\n+            return json.dumps(pull_request, indent=2)\n         except Exception as e:\n-            logger.error(f\"Error retrieving pull requests for {repo_slug}: {str(e)}\")\n+            logger.error(f\"Error retrieving pull requests for {self.repo_slug}: {str(e)}\")\n             return json.dumps({\"error\": str(e)})\n \n-    def get_pull_request_changes(self, workspace: str, repo_slug: str, pull_request_id: int) -> str:\n+    def get_pull_request_changes(self, pull_request_id: int) -> str:\n         \"\"\"\n         Retrieves changes for a pull request in a repository.\n-        API Docs: https://developer.atlassian.com/cloud/bitbucket/rest/api-group-pullrequests/#api-repositories-workspace-repo-slug-pullrequests-pull-request-id-diff-get\n \n         Args:\n-            workspace (str): The slug of the workspace where the repository exists.\n-            repo_slug (str): The slug of the repository to retrieve pull requests for.\n             pull_request_id (int): The ID of the pull request to retrieve.\n \n         Returns:\n@@ -332,54 +261,30 @@ class BitbucketTools(Toolkit):\n         \"\"\"\n         try:\n             diff = self._make_request(\n-                \"GET\", f\"/repositories/{workspace}/{repo_slug}/pullrequests/{pull_request_id}/diff\"\n+                \"GET\", f\"/repositories/{self.workspace}/{self.repo_slug}/pullrequests/{pull_request_id}/diff\"\n             )\n-            return f\"```\\n{diff}\\n```\"\n+            return diff\n         except Exception as e:\n-            logger.error(f\"Error retrieving changes for pull request {pull_request_id} in {repo_slug}: {str(e)}\")\n+            logger.error(f\"Error retrieving changes for pull request {pull_request_id} in {self.repo_slug}: {str(e)}\")\n             return json.dumps({\"error\": str(e)})\n \n-    def list_issues(self, workspace: str, repo_slug: str, page: int = 1, pagelen: int = 10) -> str:\n+    def list_issues(self, count: int = 10) -> str:\n         \"\"\"\n         Retrieves all issues for a repository.\n-        API Docs: https://developer.atlassian.com/cloud/bitbucket/rest/api-group-issue-tracker/#api-repositories-workspace-repo-slug-issues-get\n \n         Args:\n-            workspace (str): The slug of the workspace where the repository exists.\n-            repo_slug (str): The slug of the repository to retrieve issues for.\n-            page (int, optional): The page number to retrieve. Defaults to 1.\n-            pagelen (int, optional): The number of issues to retrieve per page. Defaults to 10.\n+            count (int, optional): The number of issues to retrieve. Defaults to 10. Maximum 50.\n \n         Returns:\n             str: A JSON string containing all issues.\n         \"\"\"\n         try:\n-            params = {\"page\": page, \"pagelen\": pagelen}\n-            issues = self._make_request(\"GET\", f\"/repositories/{workspace}/{repo_slug}/issues\", params=params)\n-            return json.dumps(issues, indent=2)\n-        except Exception as e:\n-            logger.error(f\"Error retrieving issues for {repo_slug}: {str(e)}\")\n-            return json.dumps({\"error\": str(e)})\n+            count = min(count, 50)\n+            params = {\"pagelen\": count}\n \n-    def list_repository_pipelines(self, workspace: str, repo_slug: str, page: int = 1, pagelen: int = 10) -> str:\n-        \"\"\"\n-        Retrieves all pipelines for a repository.\n-        API Docs: https://developer.atlassian.com/cloud/bitbucket/rest/api-group-pipelines/#api-repositories-workspace-repo-slug-pipelines-get\n-\n-        Args:\n-            workspace (str): The slug of the workspace where the repository exists.\n-            repo_slug (str): The slug of the repository to retrieve pipelines for.\n-            page (int, optional): The page number to retrieve. Defaults to 1.\n-            pagelen (int, optional): The number of pipelines to retrieve per page. Defaults to 10.\n+            issues = self._make_request(\"GET\", f\"/repositories/{self.workspace}/{self.repo_slug}/issues\", params=params)\n \n-        Returns:\n-            str: A JSON string containing all pipelines.\n-        \"\"\"\n-        try:\n-            pipelines = self._make_request(\n-                \"GET\", f\"/repositories/{workspace}/{repo_slug}/pipelines?page={page}&pagelen={pagelen}\"\n-            )\n-            return json.dumps(pipelines, indent=2)\n+            return json.dumps(issues, indent=2)\n         except Exception as e:\n-            logger.error(f\"Error retrieving pipelines for {repo_slug}: {str(e)}\")\n+            logger.error(f\"Error retrieving issues for {self.repo_slug}: {str(e)}\")\n             return json.dumps({\"error\": str(e)})\n"
        },
        {
            "commit": "fa597eab63defb9e7e146e73c6ee23fb00f16284",
            "file_path": "libs/agno/tests/unit/tools/test_bitbucket.py",
            "diff": "diff --git a/libs/agno/tests/unit/tools/test_bitbucket.py b/libs/agno/tests/unit/tools/test_bitbucket.py\nnew file mode 100644\nindex 000000000..5f1fcdf61\n--- /dev/null\n+++ b/libs/agno/tests/unit/tools/test_bitbucket.py\n@@ -0,0 +1,409 @@\n+import json\n+import os\n+from unittest.mock import MagicMock, patch\n+\n+import pytest\n+import requests\n+\n+from agno.tools.bitbucket import BitbucketTools\n+\n+\n+class TestBitbucketTools:\n+    \"\"\"Test suite for BitbucketTools class.\"\"\"\n+\n+    @pytest.fixture\n+    def mock_env_vars(self):\n+        \"\"\"Mock environment variables for testing.\"\"\"\n+        with patch.dict(\n+            os.environ,\n+            {\n+                \"BITBUCKET_USERNAME\": \"test_user\",\n+                \"BITBUCKET_PASSWORD\": \"test_password\",\n+            },\n+        ):\n+            yield\n+\n+    @pytest.fixture\n+    def bitbucket_tools(self, mock_env_vars):\n+        \"\"\"Create BitbucketTools instance for testing.\"\"\"\n+        return BitbucketTools(workspace=\"test_workspace\", repo_slug=\"test_repo\")\n+\n+    @pytest.fixture\n+    def bitbucket_tools_with_token(self, mock_env_vars):\n+        \"\"\"Create BitbucketTools instance with token for testing.\"\"\"\n+        with patch.dict(os.environ, {\"BITBUCKET_TOKEN\": \"test_token\"}):\n+            return BitbucketTools(workspace=\"test_workspace\", repo_slug=\"test_repo\")\n+\n+    def test_init_with_required_params(self, mock_env_vars):\n+        \"\"\"Test successful initialization with required parameters.\"\"\"\n+        tools = BitbucketTools(workspace=\"test_workspace\", repo_slug=\"test_repo\")\n+\n+        assert tools.workspace == \"test_workspace\"\n+        assert tools.repo_slug == \"test_repo\"\n+        assert tools.username == \"test_user\"\n+        assert tools.auth_password == \"test_password\"\n+        assert tools.server_url == \"api.bitbucket.org\"\n+        assert tools.api_version == \"2.0\"\n+        assert \"Basic\" in tools.headers[\"Authorization\"]\n+\n+    def test_init_with_custom_params(self, mock_env_vars):\n+        \"\"\"Test initialization with custom parameters.\"\"\"\n+        tools = BitbucketTools(\n+            workspace=\"custom_workspace\",\n+            repo_slug=\"custom_repo\",\n+            server_url=\"custom.bitbucket.com\",\n+            username=\"custom_user\",\n+            password=\"custom_password\",\n+            api_version=\"2.1\",\n+        )\n+\n+        assert tools.workspace == \"custom_workspace\"\n+        assert tools.repo_slug == \"custom_repo\"\n+        assert tools.username == \"custom_user\"\n+        assert tools.auth_password == \"custom_password\"\n+        assert tools.server_url == \"custom.bitbucket.com\"\n+        assert tools.api_version == \"2.1\"\n+\n+    def test_init_with_token_priority(self, mock_env_vars):\n+        \"\"\"Test that token takes priority over password.\"\"\"\n+        tools = BitbucketTools(\n+            workspace=\"test_workspace\", repo_slug=\"test_repo\", token=\"test_token\", password=\"test_password\"\n+        )\n+\n+        assert tools.auth_password == \"test_token\"\n+        assert tools.token == \"test_token\"\n+        assert tools.password == \"test_password\"\n+\n+    def test_init_missing_credentials(self):\n+        \"\"\"Test initialization fails without credentials.\"\"\"\n+        with patch.dict(os.environ, {}, clear=True):  # Clear all environment variables\n+            with pytest.raises(ValueError, match=\"Username and password or token are required\"):\n+                BitbucketTools(workspace=\"test_workspace\", repo_slug=\"test_repo\")\n+\n+    def test_init_missing_workspace(self, mock_env_vars):\n+        \"\"\"Test initialization fails without workspace.\"\"\"\n+        with pytest.raises(ValueError, match=\"Workspace is required\"):\n+            BitbucketTools(repo_slug=\"test_repo\")\n+\n+    def test_init_missing_repo_slug(self, mock_env_vars):\n+        \"\"\"Test initialization fails without repo_slug.\"\"\"\n+        with pytest.raises(ValueError, match=\"Repo slug is required\"):\n+            BitbucketTools(workspace=\"test_workspace\")\n+\n+    def test_generate_access_token(self, bitbucket_tools):\n+        \"\"\"Test access token generation.\"\"\"\n+        token = bitbucket_tools._generate_access_token()\n+        assert isinstance(token, str)\n+        assert len(token) > 0\n+\n+    @patch(\"requests.request\")\n+    def test_make_request_json_response(self, mock_request, bitbucket_tools):\n+        \"\"\"Test _make_request with JSON response.\"\"\"\n+        mock_response = MagicMock()\n+        mock_response.headers = {\"Content-Type\": \"application/json\"}\n+        mock_response.json.return_value = {\"test\": \"data\"}\n+        mock_response.text = '{\"test\": \"data\"}'\n+        mock_request.return_value = mock_response\n+\n+        result = bitbucket_tools._make_request(\"GET\", \"/test\")\n+\n+        assert result == {\"test\": \"data\"}\n+        mock_request.assert_called_once()\n+\n+    @patch(\"requests.request\")\n+    def test_make_request_text_response(self, mock_request, bitbucket_tools):\n+        \"\"\"Test _make_request with text response.\"\"\"\n+        mock_response = MagicMock()\n+        mock_response.headers = {\"Content-Type\": \"text/plain\"}\n+        mock_response.text = \"test data\"\n+        mock_request.return_value = mock_response\n+\n+        result = bitbucket_tools._make_request(\"GET\", \"/test\")\n+\n+        assert result == \"test data\"\n+\n+    @patch(\"requests.request\")\n+    def test_make_request_empty_json_response(self, mock_request, bitbucket_tools):\n+        \"\"\"Test _make_request with empty JSON response.\"\"\"\n+        mock_response = MagicMock()\n+        mock_response.headers = {\"Content-Type\": \"application/json\"}\n+        mock_response.text = \"\"\n+        mock_request.return_value = mock_response\n+\n+        result = bitbucket_tools._make_request(\"GET\", \"/test\")\n+\n+        assert result == {}\n+\n+    @patch(\"requests.request\")\n+    def test_make_request_unsupported_content_type(self, mock_request, bitbucket_tools):\n+        \"\"\"Test _make_request with unsupported content type.\"\"\"\n+        mock_response = MagicMock()\n+        mock_response.headers = {\"Content-Type\": \"application/xml\"}\n+        mock_request.return_value = mock_response\n+\n+        with patch(\"agno.utils.log.logger.warning\") as mock_logger:\n+            result = bitbucket_tools._make_request(\"GET\", \"/test\")\n+\n+            assert result == {}\n+            mock_logger.assert_called_once()\n+\n+    @patch(\"requests.request\")\n+    def test_make_request_http_error(self, mock_request, bitbucket_tools):\n+        \"\"\"Test _make_request with HTTP error.\"\"\"\n+        mock_request.side_effect = requests.exceptions.HTTPError(\"HTTP Error\")\n+\n+        with pytest.raises(requests.exceptions.HTTPError):\n+            bitbucket_tools._make_request(\"GET\", \"/test\")\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_list_repositories_success(self, mock_request, bitbucket_tools):\n+        \"\"\"Test list_repositories method success.\"\"\"\n+        mock_response = {\"values\": [{\"name\": \"repo1\"}, {\"name\": \"repo2\"}], \"page\": 1, \"size\": 2}\n+        mock_request.return_value = mock_response\n+\n+        result = bitbucket_tools.list_repositories(count=5)\n+\n+        assert isinstance(result, str)\n+        result_data = json.loads(result)\n+        assert result_data == mock_response\n+        mock_request.assert_called_once_with(\"GET\", \"/repositories/test_workspace\", params={\"page\": 1, \"pagelen\": 5})\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_list_repositories_max_count(self, mock_request, bitbucket_tools):\n+        \"\"\"Test list_repositories respects maximum count of 50.\"\"\"\n+        mock_response = {\"values\": []}\n+        mock_request.return_value = mock_response\n+\n+        bitbucket_tools.list_repositories(count=100)\n+\n+        # Should be limited to 50\n+        mock_request.assert_called_once_with(\"GET\", \"/repositories/test_workspace\", params={\"page\": 1, \"pagelen\": 50})\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_list_repositories_error(self, mock_request, bitbucket_tools):\n+        \"\"\"Test list_repositories error handling.\"\"\"\n+        mock_request.side_effect = Exception(\"API Error\")\n+\n+        with patch(\"agno.utils.log.logger.error\") as mock_logger:\n+            result = bitbucket_tools.list_repositories()\n+\n+            result_data = json.loads(result)\n+            assert \"error\" in result_data\n+            mock_logger.assert_called_once()\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_get_repository_details_success(self, mock_request, bitbucket_tools):\n+        \"\"\"Test get_repository_details method success.\"\"\"\n+        mock_response = {\"name\": \"test_repo\", \"full_name\": \"test_workspace/test_repo\"}\n+        mock_request.return_value = mock_response\n+\n+        result = bitbucket_tools.get_repository_details()\n+\n+        assert isinstance(result, str)\n+        result_data = json.loads(result)\n+        assert result_data == mock_response\n+        mock_request.assert_called_once_with(\"GET\", \"/repositories/test_workspace/test_repo\")\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_create_repository_success(self, mock_request, bitbucket_tools):\n+        \"\"\"Test create_repository method success.\"\"\"\n+        mock_response = {\"name\": \"new_repo\", \"is_private\": False}\n+        mock_request.return_value = mock_response\n+\n+        result = bitbucket_tools.create_repository(name=\"new_repo\", description=\"Test repository\", is_private=False)\n+\n+        assert isinstance(result, str)\n+        result_data = json.loads(result)\n+        assert result_data == mock_response\n+\n+        expected_payload = {\n+            \"name\": \"new_repo\",\n+            \"scm\": \"git\",\n+            \"is_private\": False,\n+            \"description\": \"Test repository\",\n+            \"language\": None,\n+            \"has_issues\": False,\n+            \"has_wiki\": False,\n+        }\n+        mock_request.assert_called_once_with(\"POST\", \"/repositories/test_workspace/test_repo\", data=expected_payload)\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_create_repository_with_project(self, mock_request, bitbucket_tools):\n+        \"\"\"Test create_repository with project parameter.\"\"\"\n+        mock_response = {\"name\": \"new_repo\"}\n+        mock_request.return_value = mock_response\n+\n+        bitbucket_tools.create_repository(name=\"new_repo\", project=\"TEST\")\n+\n+        call_args = mock_request.call_args\n+        payload = call_args[1][\"data\"]\n+        assert payload[\"project\"] == {\"key\": \"TEST\"}\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_list_repository_commits_success(self, mock_request, bitbucket_tools):\n+        \"\"\"Test list_repository_commits method success.\"\"\"\n+        mock_response = {\"values\": [{\"hash\": \"abc123\"}, {\"hash\": \"def456\"}], \"next\": None}\n+        mock_request.return_value = mock_response\n+\n+        result = bitbucket_tools.list_repository_commits(count=10)\n+\n+        assert isinstance(result, str)\n+        result_data = json.loads(result)\n+        assert result_data == mock_response\n+        mock_request.assert_called_once_with(\n+            \"GET\", \"/repositories/test_workspace/test_repo/commits\", params={\"pagelen\": 10}\n+        )\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_list_repository_commits_with_pagination(self, mock_request, bitbucket_tools):\n+        \"\"\"Test list_repository_commits with pagination.\"\"\"\n+        # First response with next page\n+        first_response = {\n+            \"values\": [{\"hash\": \"abc123\"}],\n+            \"next\": \"https://api.bitbucket.org/repositories/test_workspace/test_repo/commits?page=2\",\n+        }\n+        # Second response\n+        second_response = {\"values\": [{\"hash\": \"def456\"}], \"next\": None}\n+\n+        mock_request.side_effect = [first_response, second_response]\n+\n+        result = bitbucket_tools.list_repository_commits(count=10)\n+\n+        result_data = json.loads(result)\n+        assert len(result_data[\"values\"]) == 2\n+        assert result_data[\"values\"][0][\"hash\"] == \"abc123\"\n+        assert result_data[\"values\"][1][\"hash\"] == \"def456\"\n+        assert mock_request.call_count == 2\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_list_all_pull_requests_success(self, mock_request, bitbucket_tools):\n+        \"\"\"Test list_all_pull_requests method success.\"\"\"\n+        mock_response = {\"values\": [{\"id\": 1, \"title\": \"PR 1\"}, {\"id\": 2, \"title\": \"PR 2\"}]}\n+        mock_request.return_value = mock_response\n+\n+        result = bitbucket_tools.list_all_pull_requests(state=\"OPEN\")\n+\n+        assert isinstance(result, str)\n+        result_data = json.loads(result)\n+        assert result_data == mock_response\n+        mock_request.assert_called_once_with(\n+            \"GET\", \"/repositories/test_workspace/test_repo/pullrequests\", params={\"state\": \"OPEN\"}\n+        )\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_list_all_pull_requests_invalid_state(self, mock_request, bitbucket_tools):\n+        \"\"\"Test list_all_pull_requests with invalid state defaults to OPEN.\"\"\"\n+        mock_response = {\"values\": []}\n+        mock_request.return_value = mock_response\n+\n+        with patch(\"agno.utils.log.logger.debug\") as mock_logger:\n+            bitbucket_tools.list_all_pull_requests(state=\"INVALID\")\n+\n+            mock_logger.assert_called_once()\n+            # Should default to OPEN state\n+            mock_request.assert_called_once_with(\n+                \"GET\", \"/repositories/test_workspace/test_repo/pullrequests\", params={\"state\": \"OPEN\"}\n+            )\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_get_pull_request_details_success(self, mock_request, bitbucket_tools):\n+        \"\"\"Test get_pull_request_details method success.\"\"\"\n+        mock_response = {\"id\": 123, \"title\": \"Test PR\"}\n+        mock_request.return_value = mock_response\n+\n+        result = bitbucket_tools.get_pull_request_details(pull_request_id=123)\n+\n+        assert isinstance(result, str)\n+        result_data = json.loads(result)\n+        assert result_data == mock_response\n+        mock_request.assert_called_once_with(\"GET\", \"/repositories/test_workspace/test_repo/pullrequests/123\")\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_get_pull_request_changes_success(self, mock_request, bitbucket_tools):\n+        \"\"\"Test get_pull_request_changes method success.\"\"\"\n+        mock_diff = \"diff --git a/file.txt b/file.txt\\n+added line\"\n+        mock_request.return_value = mock_diff\n+\n+        result = bitbucket_tools.get_pull_request_changes(pull_request_id=123)\n+\n+        assert result == mock_diff\n+        mock_request.assert_called_once_with(\"GET\", \"/repositories/test_workspace/test_repo/pullrequests/123/diff\")\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_list_issues_success(self, mock_request, bitbucket_tools):\n+        \"\"\"Test list_issues method success.\"\"\"\n+        mock_response = {\"values\": [{\"id\": 1, \"title\": \"Issue 1\"}, {\"id\": 2, \"title\": \"Issue 2\"}]}\n+        mock_request.return_value = mock_response\n+\n+        result = bitbucket_tools.list_issues(count=10)\n+\n+        assert isinstance(result, str)\n+        result_data = json.loads(result)\n+        assert result_data == mock_response\n+        mock_request.assert_called_once_with(\n+            \"GET\", \"/repositories/test_workspace/test_repo/issues\", params={\"pagelen\": 10}\n+        )\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_list_issues_max_count(self, mock_request, bitbucket_tools):\n+        \"\"\"Test list_issues respects maximum count of 50.\"\"\"\n+        mock_response = {\"values\": []}\n+        mock_request.return_value = mock_response\n+\n+        bitbucket_tools.list_issues(count=100)\n+\n+        # Should be limited to 50\n+        mock_request.assert_called_once_with(\n+            \"GET\", \"/repositories/test_workspace/test_repo/issues\", params={\"pagelen\": 50}\n+        )\n+\n+    def test_base_url_construction_with_protocol(self, mock_env_vars):\n+        \"\"\"Test base URL construction when server_url already has protocol.\"\"\"\n+        tools = BitbucketTools(\n+            workspace=\"test_workspace\", repo_slug=\"test_repo\", server_url=\"https://custom.bitbucket.com\"\n+        )\n+\n+        assert tools.base_url == \"https://custom.bitbucket.com/2.0\"\n+\n+    def test_base_url_construction_without_protocol(self, mock_env_vars):\n+        \"\"\"Test base URL construction when server_url doesn't have protocol.\"\"\"\n+        tools = BitbucketTools(workspace=\"test_workspace\", repo_slug=\"test_repo\", server_url=\"custom.bitbucket.com\")\n+\n+        assert tools.base_url == \"https://custom.bitbucket.com/2.0\"\n+\n+    def test_tools_registration(self, bitbucket_tools):\n+        \"\"\"Test that all expected tools are registered.\"\"\"\n+        # Check that the tools list contains the expected methods\n+        assert hasattr(bitbucket_tools, \"list_repositories\")\n+        assert hasattr(bitbucket_tools, \"get_repository_details\")\n+        assert hasattr(bitbucket_tools, \"create_repository\")\n+        assert hasattr(bitbucket_tools, \"list_repository_commits\")\n+        assert hasattr(bitbucket_tools, \"list_all_pull_requests\")\n+        assert hasattr(bitbucket_tools, \"get_pull_request_details\")\n+        assert hasattr(bitbucket_tools, \"get_pull_request_changes\")\n+        assert hasattr(bitbucket_tools, \"list_issues\")\n+\n+    @patch.object(BitbucketTools, \"_make_request\")\n+    def test_error_handling_returns_json_error(self, mock_request, bitbucket_tools):\n+        \"\"\"Test that errors are properly formatted as JSON.\"\"\"\n+        mock_request.side_effect = Exception(\"Test error\")\n+\n+        with patch(\"agno.utils.log.logger.error\"):\n+            result = bitbucket_tools.list_repositories()\n+\n+            result_data = json.loads(result)\n+            assert \"error\" in result_data\n+            assert \"Test error\" in result_data[\"error\"]\n+\n+    def test_env_var_fallbacks(self):\n+        \"\"\"Test environment variable fallbacks work correctly.\"\"\"\n+        with patch.dict(\n+            os.environ,\n+            {\"BITBUCKET_USERNAME\": \"env_user\", \"BITBUCKET_PASSWORD\": \"env_password\", \"BITBUCKET_TOKEN\": \"env_token\"},\n+        ):\n+            tools = BitbucketTools(workspace=\"test_workspace\", repo_slug=\"test_repo\")\n+\n+            assert tools.username == \"env_user\"\n+            assert tools.password == \"env_password\"\n+            assert tools.token == \"env_token\"\n+            assert tools.auth_password == \"env_token\"  # Token takes priority\n"
        }
    ]
}